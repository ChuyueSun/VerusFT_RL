{"id": "task_b_4a0a6071762c", "task": "task_b", "input_text": "fn F () -> (r : i32)\nensures r == F_spec () && r <= 0", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_tmp_tmp0wu8wmfr_tests_F1a/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "4a0a6071762c", "function_name": "F", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_4b4010ca0b85", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool) requires seq . len () > 0 ,  { let first_len = seq [0] . len () ; for k in 1 .. seq . len () invariant forall | i : int | (0 <= i < k) ==> seq [i] . len () == first_len , { if seq [k] . len () != first_len { assert (seq [0] . len () == first_len) ; assert (seq [k as int] . len () != first_len) ; assert (0 <= 0 < seq . len () && 0 <= k < seq . len ()) ; assert (seq [0] . len () != seq [k as int] . len ()) ; assert (! (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> seq [i] . len () == seq [j] . len ())) ; return false ; } } assert (forall | i : int | (0 <= i < seq . len ()) ==> seq [i] . len () == first_len) ; assert (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> seq [i] . len () == first_len && seq [j] . len () == first_len) ; true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool) requires seq . len () > 0 , ensures result == (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> (# [trigger] seq [i] . len () == # [trigger] seq [j] . len ())) , { let first_len = seq [0] . len () ; for k in 1 .. seq . len () invariant forall | i : int | (0 <= i < k) ==> seq [i] . len () == first_len , { if seq [k] . len () != first_len { assert (seq [0] . len () == first_len) ; assert (seq [k as int] . len () != first_len) ; assert (0 <= 0 < seq . len () && 0 <= k < seq . len ()) ; assert (seq [0] . len () != seq [k as int] . len ()) ; assert (! (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> seq [i] . len () == seq [j] . len ())) ; return false ; } } assert (forall | i : int | (0 <= i < seq . len ()) ==> seq [i] . len () == first_len) ; assert (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> seq [i] . len () == first_len && seq [j] . len () == first_len) ; true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool) requires seq . len () > 0 , ensures result == (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> (# [trigger] seq [i] . len () == # [trigger] seq [j] . len ())) , { let first_len = seq [0] . len () ; for k in 1 .. seq . len () invariant forall | i : int | (0 <= i < k) ==> seq [i] . len () == first_len , { if seq [k] . len () != first_len { assert (seq [0] . len () == first_len) ; assert (seq [k as int] . len () != first_len) ; assert (0 <= 0 < seq . len () && 0 <= k < seq . len ()) ; assert (seq [0] . len () != seq [k as int] . len ()) ; assert (! (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> seq [i] . len () == seq [j] . len ())) ; return false ; } } assert (forall | i : int | (0 <= i < seq . len ()) ==> seq [i] . len () == first_len) ; assert (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> seq [i] . len () == first_len && seq [j] . len () == first_len) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_70_impl.rs", "verified": true, "metadata": {"original_id": "4b4010ca0b85", "function_name": "all_sequence_equal_length", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_0343db65884e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s2lif_impl.rs", "verified": true, "metadata": {"original_id": "0343db65884e", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_a_befeb2ba707c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn count_digits_helper (n : u32 , acc : u32) -> u32 { return 0 ; }\n\n} // verus!", "target_text": "decreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn count_digits_helper (n : u32 , acc : u32) -> u32 decreases n , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_18/verina_advanced_18_iter_0_original.rs", "verified": true, "metadata": {"original_id": "befeb2ba707c", "function_name": "count_digits_helper", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_c_missing_invariant_63261adfa282", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> (result : bool) { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len ()  { if arr [i] % 2 == 0 { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> (result : bool) { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (# [trigger] arr [k]) { if arr [i] % 2 == 0 { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> (result : bool) { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (# [trigger] arr [k]) { if arr [i] % 2 == 0 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "63261adfa282", "function_name": "is_product_even", "bug_type": "missing_invariant"}}
{"id": "task_b_575b6114c039", "task": "task_b", "input_text": "fn bubbleSorta (a : & mut Vec < int > , c : usize , f : usize)\nrequires 0 <= c <= f <= old (a) . len () \nensures a . len () == old (a) . len () ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSorta (a : & mut Vec < int > , c : usize , f : usize) requires 0 <= c <= f <= old (a) . len () , ensures a . len () == old (a) . len () , { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSorta (a : & mut Vec < int > , c : usize , f : usize) requires 0 <= c <= f <= old (a) . len () , ensures a . len () == old (a) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "575b6114c039", "function_name": "bubbleSorta", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_ae7e0a5425d1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32)  { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0  { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0 ensures result == is_sum_divisible_by (x as nat , d as nat) { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0 ensures result == is_sum_divisible_by (x as nat , d as nat) { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_9/verina_advanced_9_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ae7e0a5425d1", "function_name": "is_sum_divisible_by_exec", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_4230f034f4f9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut i = a . len () - 1 ; loop  { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; } proof { assert (forall | j : int | 0 <= j < a . len () ==> a [j] != elem) ; assert (exists | k : int | 0 <= k < a . len () && a [k] == elem) ; assert (false) ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut i = a . len () - 1 ; loop invariant 0 <= i < a . len () , forall | j : int | i < j < a . len () ==> a [j] != elem , decreases i { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; } proof { assert (forall | j : int | 0 <= j < a . len () ==> a [j] != elem) ; assert (exists | k : int | 0 <= k < a . len () && a [k] == elem) ; assert (false) ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut i = a . len () - 1 ; loop invariant 0 <= i < a . len () , forall | j : int | i < j < a . len () ==> a [j] != elem , decreases i { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; } proof { assert (forall | j : int | 0 <= j < a . len () ==> a [j] != elem) ; assert (exists | k : int | 0 <= k < a . len () && a [k] == elem) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/preconditions_removed/last_position_impl.rs", "verified": true, "metadata": {"original_id": "4230f034f4f9", "function_name": "last_position", "bug_type": "missing_invariant"}}
{"id": "task_b_46af5580e5a0", "task": "task_b", "input_text": "fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >)\nrequires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN \nensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | # ! [auto] 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { row . push (a [i] [j] + b [i] [j]) ; } c . push (row) ; } c }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | # ! [auto] 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { row . push (a [i] [j] + b [i] [j]) ; } c . push (row) ; } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/invariants_removed/index_wise_addition_iter_2_current.rs", "verified": true, "metadata": {"original_id": "46af5580e5a0", "function_name": "index_wise_addition", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_requires_0f6e1bbdfe8c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >)  ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () >= 1 , result [result . len () - 1] == a [i - 1] , forall | k : int , l : int | # ! [trigger result [k] , result [l]] 0 <= k && k < l && l < result . len () ==> result [k] < result [l] , forall | k : int | # ! [trigger result [k]] 0 <= k < result . len () ==> exists | j : int | 0 <= j < i && result [k] == a [j] , decreases a . len () - i { if a [i] != result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () >= 1 , result [result . len () - 1] == a [i - 1] , forall | k : int , l : int | # ! [trigger result [k] , result [l]] 0 <= k && k < l && l < result . len () ==> result [k] < result [l] , forall | k : int | # ! [trigger result [k]] 0 <= k < result . len () ==> exists | j : int | 0 <= j < i && result [k] == a [j] , decreases a . len () - i { if a [i] != result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () >= 1 , result [result . len () - 1] == a [i - 1] , forall | k : int , l : int | # ! [trigger result [k] , result [l]] 0 <= k && k < l && l < result . len () ==> result [k] < result [l] , forall | k : int | # ! [trigger result [k]] 0 <= k < result . len () ==> exists | j : int | 0 <= j < i && result [k] == a [j] , decreases a . len () - i { if a [i] != result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/unique_impl.rs", "verified": true, "metadata": {"original_id": "0f6e1bbdfe8c", "function_name": "unique", "bug_type": "missing_requires"}}
{"id": "task_b_1eb541c80733", "task": "task_b", "input_text": "fn is_digit (c : u8) -> (res : bool)\nensures res == is_digit_sepc (c) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "1eb541c80733", "function_name": "is_digit", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_4b532462b50b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool)  { n % 2 == 0 }\n\n} // verus!", "target_text": "ensures result == is_even (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_60/verina_basic_60_impl.rs", "verified": true, "metadata": {"original_id": "4b532462b50b", "function_name": "is_even_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_decreases_728fed2aa103", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) , { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) , decreases str1 . len () - i { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant i <= str1 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == to_toggle_case_spec (str1 [j]) , decreases str1 . len () - i { let c = str1 [i] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_557_iter_2_current.rs", "verified": true, "metadata": {"original_id": "728fed2aa103", "function_name": "to_toggle_case", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_ec0669710e30", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_linear_search2/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "ec0669710e30", "function_name": "linear_search", "bug_type": "missing_invariant"}}
{"id": "task_a_vostd_function_properties_ac5ffca188ef", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd::relations::*;\n\nverus! {\n\n/// A function is bijective from `domain` to `codomain`\n/// if it is injective on `domain` and its image equals `codomain`.\npub open spec fn bijective_on<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>) -> bool {\n    injective_on(f, domain) && domain.map(f) =~= codomain\n}\n\n/// `g` is a left inverse of `f` on `domain` if `g(f(x)) == x` for all `x` in `domain`,\n/// and `f(x)` lies in `codomain`.\npub open spec fn left_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    domain.all(|x: A| codomain.contains(f(x)) && g(f(x)) == x)\n}\n\n/// `g` is a right inverse of `f` on `codomain` if `f(g(y)) == y` for all `y` in `codomain`,\n/// and `g(y)` lies in `domain`.\npub open spec fn right_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    codomain.all(|y: B| domain.contains(g(y)) && f(g(y)) == y)\n}\n\n/// `g` is a two-sided inverse of `f` if it is both a left and right inverse.\npub open spec fn inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    left_inverse_on(f, g, domain, codomain) && right_inverse_on(f, g, domain, codomain)\n}\n\n/// Constructs a left inverse function `g` of `f` when `f` is injective on `domain`.\n/// For each `b` in the image, returns the unique `a` such that `f(a) = b`.\npub open spec fn construct_left_inverse<A, B>(f: spec_fn(A) -> B, domain: Set<A>) -> spec_fn(B) -> A\n    recommends\n        injective_on(f, domain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// Constructs the inverse of a bijective function `f` from `domain` to `codomain`.\n/// For each `b` in `codomain`, returns the unique `a` in `domain` such that `f(a) == b`.\npub open spec fn construct_inverse<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> spec_fn(B) -> A\n    recommends\n        bijective_on(f, domain, codomain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// If `f` is injective on `domain`, then `construct_left_inverse(f, domain)`\n/// is a left inverse of `f` on that domain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x`.\npub proof fn lemma_construct_left_inverse_sound<A, B>(f: spec_fn(A) -> B, domain: Set<A>)\n\n{\n}\n\n/// If `f` is bijective from `domain` to `codomain`, then `construct_inverse(f, domain, codomain)`\n/// is a two-sided inverse of `f` on that domain and codomain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x` and for all `y \u2208 codomain`, we have `f(g(y)) == y`.\npub proof fn lemma_construct_inverse_sound<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n\n{\n}\n\n/// A function is injective on the whole type implies that it is injective on any sub-domain.\npub proof fn lemma_injective_implies_injective_on<T, U>(f: spec_fn(T) -> U, dom: Set<T>)\n\n{\n}\n\n/// If `f` has a two-sided inverse `g` on `domain` and `codomain`, then `f` is bijective on that domain and codomain.\npub proof fn lemma_two_sided_inverse_implies_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its left inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_left_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_right_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n\n{\n    // Prove that g is injective on codomain\n    }\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is either its left or right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n\n{\n    if left_inverse_on(f, g, domain, codomain) {\n        lemma_left_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    } else {\n        lemma_right_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    }\n}\n\n/// Mapping a finite set with an injective function results in a set of the same cardinality.\npub proof fn lemma_injective_map_cardinality<T, U>(f: spec_fn(T) -> U, dom: Set<T>, s: Set<T>)\n\n    {\n    if s.is_empty() {\n\n    } else {\n        let x = s.choose();\n        lemma_injective_map_cardinality(f, dom, s.remove(x));\n\n    }\n}\n\npub proof fn lemma_bijective_cardinality<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>)\n\n{\n    lemma_injective_map_cardinality(f, domain, domain);\n}\n\npub proof fn lemma_bijective_subset_still_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n    s: Set<A>,\n)\n\n{\n}\n\n} // verus!\n", "target_text": "requires injective_on(f, domain), bijective_on(f, domain, codomain), injective(f), inverse_on(f, g, domain, codomain), bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain), bijective_on(f, domain, codomain),\n        right_inverse_on(f, g, domain, codomain), bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain) || right_inverse_on(f, g, domain, codomain), injective_on(f, dom),\n        s.finite(),\n        s <= dom, bijective_on(f, domain, codomain),\n        domain.finite(), bijective_on(f, domain, codomain),\n        s <= domain\nensures left_inverse_on(f, construct_left_inverse(f, domain), domain, domain.map(f)), inverse_on(f, construct_inverse(f, domain, codomain), domain, codomain), injective_on(f, dom), bijective_on(f, domain, codomain), bijective_on(g, codomain, domain), bijective_on(g, codomain, domain), bijective_on(g, codomain, domain), s.len() == s.map(f).len(),\n        s.map(f).finite(), codomain.finite(),\n        domain.len() == codomain.len(), bijective_on(f, s, s.map(f)), s.len() == s.map(f).len(),\n        s.map(f).finite(),\n    decreases s.len()\ndecreases s.len()", "full_verified_code": "use vstd::prelude::*;\nuse vstd::relations::*;\n\nverus! {\n\n/// A function is bijective from `domain` to `codomain`\n/// if it is injective on `domain` and its image equals `codomain`.\npub open spec fn bijective_on<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>) -> bool {\n    injective_on(f, domain) && domain.map(f) =~= codomain\n}\n\n/// `g` is a left inverse of `f` on `domain` if `g(f(x)) == x` for all `x` in `domain`,\n/// and `f(x)` lies in `codomain`.\npub open spec fn left_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    domain.all(|x: A| codomain.contains(f(x)) && g(f(x)) == x)\n}\n\n/// `g` is a right inverse of `f` on `codomain` if `f(g(y)) == y` for all `y` in `codomain`,\n/// and `g(y)` lies in `domain`.\npub open spec fn right_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    codomain.all(|y: B| domain.contains(g(y)) && f(g(y)) == y)\n}\n\n/// `g` is a two-sided inverse of `f` if it is both a left and right inverse.\npub open spec fn inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    left_inverse_on(f, g, domain, codomain) && right_inverse_on(f, g, domain, codomain)\n}\n\n/// Constructs a left inverse function `g` of `f` when `f` is injective on `domain`.\n/// For each `b` in the image, returns the unique `a` such that `f(a) = b`.\npub open spec fn construct_left_inverse<A, B>(f: spec_fn(A) -> B, domain: Set<A>) -> spec_fn(B) -> A\n    recommends\n        injective_on(f, domain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// Constructs the inverse of a bijective function `f` from `domain` to `codomain`.\n/// For each `b` in `codomain`, returns the unique `a` in `domain` such that `f(a) == b`.\npub open spec fn construct_inverse<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> spec_fn(B) -> A\n    recommends\n        bijective_on(f, domain, codomain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// If `f` is injective on `domain`, then `construct_left_inverse(f, domain)`\n/// is a left inverse of `f` on that domain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x`.\npub proof fn lemma_construct_left_inverse_sound<A, B>(f: spec_fn(A) -> B, domain: Set<A>)\n    requires\n        injective_on(f, domain),\n    ensures\n        left_inverse_on(f, construct_left_inverse(f, domain), domain, domain.map(f)),\n{\n}\n\n/// If `f` is bijective from `domain` to `codomain`, then `construct_inverse(f, domain, codomain)`\n/// is a two-sided inverse of `f` on that domain and codomain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x` and for all `y \u2208 codomain`, we have `f(g(y)) == y`.\npub proof fn lemma_construct_inverse_sound<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n    ensures\n        inverse_on(f, construct_inverse(f, domain, codomain), domain, codomain),\n{\n}\n\n/// A function is injective on the whole type implies that it is injective on any sub-domain.\npub proof fn lemma_injective_implies_injective_on<T, U>(f: spec_fn(T) -> U, dom: Set<T>)\n    requires\n        injective(f),\n    ensures\n        injective_on(f, dom),\n{\n}\n\n/// If `f` has a two-sided inverse `g` on `domain` and `codomain`, then `f` is bijective on that domain and codomain.\npub proof fn lemma_two_sided_inverse_implies_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(f, domain, codomain),\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its left inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_left_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_right_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        right_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n    // Prove that g is injective on codomain\n    assert forall|x| #[trigger] codomain.map(g).contains(x) == domain.contains(x) by {\n        if domain.contains(x) {\n            assert(codomain.contains(f(x)));\n        }\n    }\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is either its left or right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain) || right_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n    if left_inverse_on(f, g, domain, codomain) {\n        lemma_left_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    } else {\n        lemma_right_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    }\n}\n\n/// Mapping a finite set with an injective function results in a set of the same cardinality.\npub proof fn lemma_injective_map_cardinality<T, U>(f: spec_fn(T) -> U, dom: Set<T>, s: Set<T>)\n    requires\n        injective_on(f, dom),\n        s.finite(),\n        s <= dom,\n    ensures\n        s.len() == s.map(f).len(),\n        s.map(f).finite(),\n    decreases s.len(),\n{\n    if s.is_empty() {\n        assert(s.map(f) =~= Set::empty());\n    } else {\n        let x = s.choose();\n        lemma_injective_map_cardinality(f, dom, s.remove(x));\n        assert(s.map(f) =~= s.remove(x).map(f).insert(f(x)));\n    }\n}\n\npub proof fn lemma_bijective_cardinality<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>)\n    requires\n        bijective_on(f, domain, codomain),\n        domain.finite(),\n    ensures\n        codomain.finite(),\n        domain.len() == codomain.len(),\n{\n    lemma_injective_map_cardinality(f, domain, domain);\n}\n\npub proof fn lemma_bijective_subset_still_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n    s: Set<A>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        s <= domain,\n    ensures\n        bijective_on(f, s, s.map(f)),\n{\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/vstd_extra/src/function_properties.rs", "verified": true, "metadata": {"original_id": "vostd_function_properties_ac5ffca188ef", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_7b6b6e7b4184", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize)   { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i\ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "7b6b6e7b4184", "function_name": "max", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_assert_3a261bf6d204", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; }  result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } assert (i == a . len ()) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } assert (i == a . len ()) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/array_copy_impl.rs", "verified": true, "metadata": {"original_id": "3a261bf6d204", "function_name": "array_copy", "bug_type": "missing_assert"}}
{"id": "task_c_missing_requires_f0354149d7eb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool)  ensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] , { let mut i = 0 ; while i < lst . len () - 1 invariant 0 <= i <= lst . len () - 1 , forall | k : int , l : int | 0 <= k && k < l && l < i + 1 ==> lst [k] <= lst [l] , decreases lst . len () - 1 - i { if lst [i] > lst [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool) requires lst . len () >= 1 , ensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] , { let mut i = 0 ; while i < lst . len () - 1 invariant 0 <= i <= lst . len () - 1 , forall | k : int , l : int | 0 <= k && k < l && l < i + 1 ==> lst [k] <= lst [l] , decreases lst . len () - 1 - i { if lst [i] > lst [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool) requires lst . len () >= 1 , ensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] , { let mut i = 0 ; while i < lst . len () - 1 invariant 0 <= i <= lst . len () - 1 , forall | k : int , l : int | 0 <= k && k < l && l < i + 1 ==> lst [k] <= lst [l] , decreases lst . len () - 1 - i { if lst [i] > lst [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/is_sorted_impl.rs", "verified": true, "metadata": {"original_id": "f0354149d7eb", "function_name": "is_sorted", "bug_type": "missing_requires"}}
{"id": "task_b_b7f4c8c3eb78", "task": "task_b", "input_text": "fn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >)\nensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len () invariant j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , decreases str1 . len () - j { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len () invariant j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , decreases str1 . len () - j { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_474_iter_3_current.rs", "verified": true, "metadata": {"original_id": "b7f4c8c3eb78", "function_name": "replace_chars", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_requires_5f1e80c20f7b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)  ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)  ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_iter_2_current.rs", "verified": true, "metadata": {"original_id": "5f1e80c20f7b", "function_name": "bubble_inner", "bug_type": "missing_requires"}}
{"id": "task_b_0901af1693d5", "task": "task_b", "input_text": "pub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)\nrequires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/havoc_inline_post_iter_0_original.rs", "verified": true, "metadata": {"original_id": "0901af1693d5", "function_name": "havoc_inline_post", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_a64d84288315", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool)   { let mut i : u64 = 2 ; while i < n  { if n % i == 0 {     return false ; } i = i + 1 ; }   return true ; }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) \ndecreases n - i \ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn prime_num (n : u64) -> (result : bool) requires n >= 2 , ensures result == (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i , { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; assert (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) ; assert (! (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k))) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_605_impl.rs", "verified": true, "metadata": {"original_id": "a64d84288315", "function_name": "prime_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_b_680933740be3", "task": "task_b", "input_text": "pub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)\nrequires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 3 * N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , (3 * N) as i32) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , (3 * N) as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s22if_impl.rs", "verified": true, "metadata": {"original_id": "680933740be3", "function_name": "myfun", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_a5e65eff668f", "task": "task_b", "input_text": "fn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >)\nensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (# [trigger] str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (# [trigger] str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_557_impl.rs", "verified": true, "metadata": {"original_id": "a5e65eff668f", "function_name": "to_toggle_case", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_ensures_0ccc6a238222", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/arithmetic_weird_impl.rs", "verified": true, "metadata": {"original_id": "0ccc6a238222", "function_name": "arithmetic", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_dec266c13e53", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i ,  { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) ,  { if s [0] <= s [1] { secondSmallestAux (s , 2 , 0 , 1) } else { secondSmallestAux (s , 2 , 1 , 0) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { if s [0] <= s [1] { secondSmallestAux (s , 2 , 0 , 1) } else { secondSmallestAux (s , 2 , 1 , 0) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { if s [0] <= s [1] { secondSmallestAux (s , 2 , 0 , 1) } else { secondSmallestAux (s , 2 , 1 , 0) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_40/verina_basic_40_iter_3_current.rs", "verified": true, "metadata": {"original_id": "dec266c13e53", "function_name": "secondSmallest", "bug_type": "missing_ensures"}}
{"id": "task_a_050586e58c13", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize)   { 0 }\n\n} // verus!", "target_text": "requires true \nensures 0 <= n <= a . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "050586e58c13", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_0b6837913b8e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool)  { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; for i in 0 .. l . len () - 1  { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } } is_non_decreasing || is_non_increasing }\n\n} // verus!", "target_text": "ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) \ninvariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; for i in 0 .. l . len () - 1 invariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) , { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } } is_non_decreasing || is_non_increasing }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/HumanEval-RustBench/057-monotonic_iter_1_current.rs", "verified": true, "metadata": {"original_id": "0b6837913b8e", "function_name": "monotonic", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_b_abc483f4c846", "task": "task_b", "input_text": "fn is_integer (text : & [u8]) -> (result : bool)\nensures res == is_digit_sepc (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "abc483f4c846", "function_name": "is_integer", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_requires_69c92090d0b3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32)  ensures z == 0 { 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "69c92090d0b3", "function_name": "main_method", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_c8b0aaf19948", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 ,  { avgs . clear () ; let mut i : usize = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i : usize = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i : usize = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/conditional_average_iter_3_current.rs", "verified": true, "metadata": {"original_id": "c8b0aaf19948", "function_name": "conditional_average", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_b843b3e80d44", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >)  { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index , { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } index += 1 ; } upper_case }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index , { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } index += 1 ; } upper_case }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index , { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } index += 1 ; } upper_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_624_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b843b3e80d44", "function_name": "to_uppercase", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_4f29741cb0fd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 3 ,  { let result = 3 * N ; sum . set (0 , result) ; assert (sum [0] == result) ; assert (result == 3 * N) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 3 , ensures sum [0] == 3 * N , { let result = 3 * N ; sum . set (0 , result) ; assert (sum [0] == result) ; assert (result == 3 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 3 , ensures sum [0] == 3 * N , { let result = 3 * N ; sum . set (0 , result) ; assert (sum [0] == result) ; assert (result == 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/s3if_impl.rs", "verified": true, "metadata": {"original_id": "4f29741cb0fd", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_13e059beed7d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "13e059beed7d", "function_name": "contains", "bug_type": "missing_invariant"}}
{"id": "task_a_4a328d542dff", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i = 0 ; while i < N  { a [i as usize] = 0 ; i = i + 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures forall | k : int | 0 <= k < N ==> a [k] == 0 \ndecreases N - i \ninvariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i , { a [i as usize] = 0 ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/modn_impl.rs", "verified": true, "metadata": {"original_id": "4a328d542dff", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1f74c30eea6b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/choose_odd.rs", "verified": true, "metadata": {"original_id": "1f74c30eea6b", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_requires_6e704e06adc5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool)  ensures is_peak_valley_postcond (lst @ , result) { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , started_decreasing) } else if current > next { aux (l , start + 1 , false , true) } else { false } } else { if current > next { aux (l , start + 1 , false , started_decreasing) } else { false } } }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { if lst . len () <= 2 { return false ; } aux (& lst , 0 , true , false) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_22/verina_advanced_22_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "6e704e06adc5", "function_name": "is_peak_valley", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_8b33e6965087", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "8b33e6965087", "function_name": "contains", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_0e172342657b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_414_iter_3_current.rs", "verified": true, "metadata": {"original_id": "0e172342657b", "function_name": "contains", "bug_type": "missing_invariant"}}
{"id": "task_b_fa3fc34cebcd", "task": "task_b", "input_text": "fn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)\nensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] , decreases arr . len () - index , { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] , decreases arr . len () - index , { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_433_iter_2_current.rs", "verified": true, "metadata": {"original_id": "fa3fc34cebcd", "function_name": "is_greater", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_decreases_c86d2afd7c0f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | k : int | (0 <= k < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [k] - arr2 [k]) <= MAX) , { result . push (arr1 [i] - arr2 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | k : int | (0 <= k < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [k] - arr2 [k]) <= MAX) , decreases arr1 . len () - i , { result . push (arr1 [i] - arr2 [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | k : int | (0 <= k < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [k] - arr2 [k]) <= MAX) , decreases arr1 . len () - i , { result . push (arr1 [i] - arr2 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_273_impl.rs", "verified": true, "metadata": {"original_id": "c86d2afd7c0f", "function_name": "element_wise_subtract", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_5be2fd92c629", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n  { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/largest_prime_factor_impl.rs", "verified": true, "metadata": {"original_id": "5be2fd92c629", "function_name": "is_prime", "bug_type": "missing_invariant"}}
{"id": "task_a_9527f2d135b3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >)   { let mut result = Vec :: new () ; for i in 0 .. arr . len ()  { if arr [i] % 2 == 0 { result . push (arr [i]) ; } } result }\n\n} // verus!", "target_text": "requires arr . len () <= MAX \nensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int))\ninvariant forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> exists | j : int | 0 <= j < i && arr @ [j] == # [trigger] result @ [k] , forall | x : i32 | result @ . contains (x) ==> (exists | j : int | 0 <= j < i && arr @ [j] == x) && is_even_spec (x as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> exists | j : int | 0 <= j < i && arr @ [j] == # [trigger] result @ [k] , forall | x : i32 | result @ . contains (x) ==> (exists | j : int | 0 <= j < i && arr @ [j] == x) && is_even_spec (x as int) { if arr [i] % 2 == 0 { result . push (arr [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_even_list/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9527f2d135b3", "function_name": "find_even_numbers", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_56ade0e9e02d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_coverage_after_removing_one (intervals : Vec < (usize , usize) >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires intervals @ . len () > 0 , forall | i : int | 0 <= i < intervals @ . len () ==> # [trigger] intervals @ [i] . 0 <= intervals @ [i] . 1\nensures result >= 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_coverage_after_removing_one (intervals : Vec < (usize , usize) >) -> (result : usize) requires intervals @ . len () > 0 , forall | i : int | 0 <= i < intervals @ . len () ==> # [trigger] intervals @ [i] . 0 <= intervals @ [i] . 1 ensures result >= 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_38/verina_advanced_38_iter_0_original.rs", "verified": true, "metadata": {"original_id": "56ade0e9e02d", "function_name": "max_coverage_after_removing_one", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_62a8cc71df06", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int))  { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; if is_sorted_aux (& current) { return 0 ; } for shift_count in 1 .. n { current = right_shift_once (& current) ; if is_sorted_aux (& current) { return shift_count as i32 ; } } - 1 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; if is_sorted_aux (& current) { return 0 ; } for shift_count in 1 .. n { current = right_shift_once (& current) ; if is_sorted_aux (& current) { return shift_count as i32 ; } } - 1 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; if is_sorted_aux (& current) { return 0 ; } for shift_count in 1 .. n { current = right_shift_once (& current) ; if is_sorted_aux (& current) { return shift_count as i32 ; } } - 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_53/verina_advanced_53_iter_1_current.rs", "verified": true, "metadata": {"original_id": "62a8cc71df06", "function_name": "minimum_right_shifts", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_d0ce9f93b5b4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { let c = str1 [idx] ; let toggled_char = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled_char) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled_char = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled_char) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : char) -> (result : char) { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn shift32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nfn to_toggle_case (str1 : & Vec < char >) -> (toggle_case : Vec < char >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled_char = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (toggled_char) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_557_impl.rs", "verified": true, "metadata": {"original_id": "d0ce9f93b5b4", "function_name": "to_toggle_case", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_374cf55dc764", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_74/verina_basic_74_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "374cf55dc764", "function_name": "max_array_aux", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_476e4fc506c2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len ()  { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , min >= 0 , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j , { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , min >= 0 , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j , { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_95_impl.rs", "verified": true, "metadata": {"original_id": "476e4fc506c2", "function_name": "smallest_list_length", "bug_type": "missing_invariant"}}
{"id": "task_a_f038eb73e65a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive4 (v : & [i32]) -> (b : bool)  { let mut result = true ; for i in 0 .. v . len ()  { if v [i] < 0 { result = false ; } } result }\n\n} // verus!", "target_text": "ensures b == positive (v @)\ninvariant result == (forall | u : int | 0 <= u < i ==> v [u] >= 0)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive4 (v : & [i32]) -> (b : bool) ensures b == positive (v @) { let mut result = true ; for i in 0 .. v . len () invariant result == (forall | u : int | 0 <= u < i ==> v [u] >= 0) { if v [i] < 0 { result = false ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "f038eb73e65a", "function_name": "mpositive4", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_c_missing_ensures_0a7649c8135d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 ,  { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\nfn max_array (a : & Vec < i32 >) -> (result : i32) requires max_array_precond (a) ,  { max_array_aux (a , 1 , a [0]) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\nfn max_array (a : & Vec < i32 >) -> (result : i32) requires max_array_precond (a) , ensures result == max_array_aux_spec (a , 1nat , a [0]) , forall | k : int | 0 <= k < a . len () ==> result >= a [k] , exists | k : int | 0 <= k < a . len () && result == a [k] , { max_array_aux (a , 1 , a [0]) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\nfn max_array (a : & Vec < i32 >) -> (result : i32) requires max_array_precond (a) , ensures result == max_array_aux_spec (a , 1nat , a [0]) , forall | k : int | 0 <= k < a . len () ==> result >= a [k] , exists | k : int | 0 <= k < a . len () && result == a [k] , { max_array_aux (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_74/verina_basic_74_iter_1_current.rs", "verified": true, "metadata": {"original_id": "0a7649c8135d", "function_name": "max_array", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_e3c963be11d9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn match_precond (s : Seq < char > , p : Seq < char >) -> bool { s . len () == p . len () }\nfn match_fn (s : Vec < char > , p : Vec < char >) -> (result : bool)  ensures result <==> forall | n : int | 0 <= n < s . len () ==> (s [n] == p [n] || p [n] == '?') { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s @ . len () == p @ . len () , forall | j : int | 0 <= j < i ==> (s [j] == p [j] || p [j] == '?') decreases s . len () - i { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn match_precond (s : Seq < char > , p : Seq < char >) -> bool { s . len () == p . len () }\nfn match_fn (s : Vec < char > , p : Vec < char >) -> (result : bool) requires match_precond (s @ , p @) ensures result <==> forall | n : int | 0 <= n < s . len () ==> (s [n] == p [n] || p [n] == '?') { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s @ . len () == p @ . len () , forall | j : int | 0 <= j < i ==> (s [j] == p [j] || p [j] == '?') decreases s . len () - i { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn match_precond (s : Seq < char > , p : Seq < char >) -> bool { s . len () == p . len () }\nfn match_fn (s : Vec < char > , p : Vec < char >) -> (result : bool) requires match_precond (s @ , p @) ensures result <==> forall | n : int | 0 <= n < s . len () ==> (s [n] == p [n] || p [n] == '?') { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s @ . len () == p @ . len () , forall | j : int | 0 <= j < i ==> (s [j] == p [j] || p [j] == '?') decreases s . len () - i { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_73/verina_basic_73_impl.rs", "verified": true, "metadata": {"original_id": "e3c963be11d9", "function_name": "match_fn", "bug_type": "missing_requires"}}
{"id": "task_a_f4ff2bf9c6d5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/res2_impl.rs", "verified": true, "metadata": {"original_id": "f4ff2bf9c6d5", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_decreases_827177e88870", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_75/verina_basic_75_iter_1_current.rs", "verified": true, "metadata": {"original_id": "827177e88870", "function_name": "min_array", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_c55fc8a62bc8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 ,  { k }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 , ensures k_out >= 0 , { k }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "c55fc8a62bc8", "function_name": "compute_k", "bug_type": "missing_ensures"}}
{"id": "task_b_75c8f0f25afe", "task": "task_b", "input_text": "fn main_method (x_init : u32 , y : u32) -> (z : u32)\nrequires (x_init as int) * (y as int) <= MAX as int \nensures z == 0", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand/verus_code.rs", "verified": true, "metadata": {"original_id": "75c8f0f25afe", "function_name": "main_method", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_326dcb4a9e07", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32)   { 0 }\n\n} // verus!", "target_text": "requires n > 0 , k > n , n <= 100 , k <= 200 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "326dcb4a9e07", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_decreases_844487d1e52b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize) requires idx <= nums . len () , curr_len <= nums . len () , max_len <= nums . len () ensures result <= nums . len () { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize) requires idx <= nums . len () , curr_len <= nums . len () , max_len <= nums . len () ensures result <= nums . len () decreases nums . len () - idx { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize) requires idx <= nums . len () , curr_len <= nums . len () , max_len <= nums . len () ensures result <= nums . len () decreases nums . len () - idx { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_30/verina_advanced_30_iter_0_original.rs", "verified": true, "metadata": {"original_id": "844487d1e52b", "function_name": "longest_increasing_streak_aux", "bug_type": "missing_decreases"}}
{"id": "task_b_350cc2d5a451", "task": "task_b", "input_text": "fn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)\nensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "350cc2d5a451", "function_name": "contains", "has_invariants": true, "has_asserts": false}}
{"id": "task_a_5086ae4db97e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >)   { for i in 0 .. x . len ()  { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "target_text": "requires old (y) . len () == 0 \nensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) \ninvariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { for i in 0 .. x . len () invariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/unverified/filter_weak_impl.rs", "verified": true, "metadata": {"original_id": "5086ae4db97e", "function_name": "myfun4", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_b_75c75f5ef6d8", "task": "task_b", "input_text": "fn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >)\nrequires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] \nensures if let Some (idx) = index", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >) requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] , ensures if let Some (idx) = index { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant forall | k : int | 0 <= k < index ==> arr [k] != target , index <= arr . len () , decreases arr . len () - index { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >) requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] , ensures if let Some (idx) = index { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant forall | k : int | 0 <= k < index ==> arr [k] != target , index <= arr . len () , decreases arr . len () - index { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_733_impl.rs", "verified": true, "metadata": {"original_id": "75c75f5ef6d8", "function_name": "find_first_occurrence", "has_invariants": true, "has_asserts": false}}
{"id": "task_a_f3d4824ffd91", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool)  { (c as u32) >= 48 && (c as u32) <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { (c as u32) >= 48 && (c as u32) <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "f3d4824ffd91", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_requires_4ff9e20b4700", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize)  ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "4ff9e20b4700", "function_name": "max_dafny_lsp", "bug_type": "missing_requires"}}
{"id": "task_b_f086a67575eb", "task": "task_b", "input_text": "fn main_method (n : i32 , k : i32) -> (k_out : i32)\nrequires n > 0 , k > n , n <= 100 , k <= 200 \nensures k_out >= 0 ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "f086a67575eb", "function_name": "main_method", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_a8949747f667", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882  { 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 ensures r == 3 * x { 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Triple1 (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "a8949747f667", "function_name": "Triple1", "bug_type": "missing_ensures"}}
{"id": "task_a_55cfdc94cc4a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >)   { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "target_text": "requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX \nensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX , ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_update_array/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "55cfdc94cc4a", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_requires_e067973e9642", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] == 6 * N , { sum . set (0 , 6 * N) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s5lif_impl.rs", "verified": true, "metadata": {"original_id": "e067973e9642", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_b_5dacaca36979", "task": "task_b", "input_text": "fn encode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >)\nrequires 65 <= c <= 90 , 65 <= c <= 90 , forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 \nensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , r == encode_char_spec (c as int) , 65 <= r <= 90 , s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == encode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> decode_char_spec (t [i] as int) == s [i] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn encode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == encode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 5) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn encode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == encode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> decode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == encode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> decode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let encoded = encode_char (s [i]) ; result . push (encoded) ; proof { opposite_encode_decode (s [i as int] as int) ; } i = i + 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn encode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == encode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 5) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn encode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == encode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> decode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == encode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> decode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let encoded = encode_char (s [i]) ; result . push (encoded) ; proof { opposite_encode_decode (s [i as int] as int) ; } i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/050-encode_shift_iter_2_current.rs", "verified": true, "metadata": {"original_id": "5dacaca36979", "function_name": "encode_shift", "has_invariants": true, "has_asserts": true}}
{"id": "task_c_missing_ensures_verus_exec_attr_8a9f2ac676ab", "task": "task_c", "input_text": "#![feature(proc_macro_hygiene)]\n\nuse vstd::prelude::*;\n\n// ANCHOR: verus_spec\n#[verus_spec(sum =>\n     requires\n         x < 100,\n         y < 100,\n\n{\n    x + y\n}\n// ANCHOR_END: verus_spec\n\n// ANCHOR: loop\n#[verus_spec(v =>  {\n    let mut v: Vec<u32> = Vec::new();\n\n    #[verus_spec(\n       invariant\n           v@ =~= Seq::new(i as nat, |k| k as u32),\n    )]\n    for i in 0..n {\n        v.push(i);\n    }\n    v\n}\n// ANCHOR_END: loop\n\n// ANCHOR: proof\n#[verus_spec]\nfn exec_with_proof() {\n   proof_decl!{\n     let ghost mut i = 0int;\n     assert(true);\n   }\n   test_for_loop(10);\n   proof!{\n     assert(i == 0);\n   }\n}\n// ANCHOR_END: proof\n\n// ANCHOR: proof_with\n#[verus_spec(ret =>\nwith\n  Tracked(y): Tracked<&mut u32>,\n  Ghost(w): Ghost<u32>\n     -> z: Ghost<u32>\nrequires\n  x < 100,\n  *old(y) < 100,\n {\n  proof! {\n    *y = x;\n  }\n  proof_with!(|= Ghost(x));\n  (x + 1)\n}\n\n#[verus_spec]\nfn exec_tracked_test(x: u32) {\n  proof_decl!{\n    let ghost mut z = 0u32;\n    let tracked mut y = 0u32;\n  }\n\n  proof_with!{Tracked(&mut y), Ghost(0) => Ghost(z)}\n  let x = exec_tracked(1);\n\n  proof!{\n    assert(y == 1);\n    assert(z == 1);\n    assert(x == 2);\n  }\n}\n\nfn exec_external_test(x: u32) -> u32 {\n   exec_tracked(1)\n}\n\n// ANCHOR_END: proof_with\n\n// ANCHOR: dual_spec\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n    returns f(x, y)\n)]\nfn f(x: u32, y: u32) -> u32 {\n    proof!{\n        assert(true);\n    }\n    {\n        proof!{assert(true);}\n        x + y\n    }\n}\n\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n    returns\n        f2(x),\n)]\npub fn f2(x: u32) -> u32 {\n    f(x, 1)\n}\n// ANCHOR_END: dual_spec\n", "target_text": "#![feature(proc_macro_hygiene)]\n\nuse vstd::prelude::*;\n\n// ANCHOR: verus_spec\n#[verus_spec(sum => \n     requires \n         x < 100, \n         y < 100, \n     ensures \n         sum < 200, \n)]\nfn my_exec_fun(x: u32, y: u32) -> u32 \n{ \n    x + y \n}\n// ANCHOR_END: verus_spec\n\n// ANCHOR: loop\n#[verus_spec(v => ensures true)]\nfn test_for_loop(n: u32) -> Vec<u32> {\n    let mut v: Vec<u32> = Vec::new();\n\n    #[verus_spec(\n       invariant\n           v@ =~= Seq::new(i as nat, |k| k as u32),\n    )]\n    for i in 0..n {\n        v.push(i);\n    }\n    v\n}\n// ANCHOR_END: loop\n\n// ANCHOR: proof\n#[verus_spec]\nfn exec_with_proof() {\n   proof_decl!{\n     let ghost mut i = 0int;\n     assert(true);\n   }\n   test_for_loop(10);\n   proof!{\n     assert(i == 0);\n   }\n}\n// ANCHOR_END: proof\n\n// ANCHOR: proof_with\n#[verus_spec(ret =>\nwith\n  Tracked(y): Tracked<&mut u32>,\n  Ghost(w): Ghost<u32> \n     -> z: Ghost<u32>\nrequires\n  x < 100,\n  *old(y) < 100,\nensures\n  *y == x,\n  ret == x + 1,\n  z@ == x,\n)]\nfn exec_tracked(x: u32) -> u32 {\n  proof! {\n    *y = x;\n  }\n  proof_with!(|= Ghost(x));\n  (x + 1)\n}\n\n\n#[verus_spec]\nfn exec_tracked_test(x: u32) {\n  proof_decl!{\n    let ghost mut z = 0u32;\n    let tracked mut y = 0u32;\n  }\n\n  proof_with!{Tracked(&mut y), Ghost(0) => Ghost(z)}\n  let x = exec_tracked(1);\n\n  proof!{\n    assert(y == 1);\n    assert(z == 1);\n    assert(x == 2);\n  }\n}\n\nfn exec_external_test(x: u32) -> u32 {\n   exec_tracked(1)\n}\n\n// ANCHOR_END: proof_with\n\n// ANCHOR: dual_spec\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n    returns f(x, y)\n)]\nfn f(x: u32, y: u32) -> u32 {\n    proof!{\n        assert(true);\n    }\n    {\n        proof!{assert(true);}\n        x + y\n    }\n}\n\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n    returns\n        f2(x),\n)]\npub fn f2(x: u32) -> u32 {\n    f(x, 1)\n}\n// ANCHOR_END: dual_spec\n", "full_verified_code": "#![feature(proc_macro_hygiene)]\n\nuse vstd::prelude::*;\n\n// ANCHOR: verus_spec\n#[verus_spec(sum => \n     requires \n         x < 100, \n         y < 100, \n     ensures \n         sum < 200, \n)]\nfn my_exec_fun(x: u32, y: u32) -> u32 \n{ \n    x + y \n}\n// ANCHOR_END: verus_spec\n\n// ANCHOR: loop\n#[verus_spec(v => ensures true)]\nfn test_for_loop(n: u32) -> Vec<u32> {\n    let mut v: Vec<u32> = Vec::new();\n\n    #[verus_spec(\n       invariant\n           v@ =~= Seq::new(i as nat, |k| k as u32),\n    )]\n    for i in 0..n {\n        v.push(i);\n    }\n    v\n}\n// ANCHOR_END: loop\n\n// ANCHOR: proof\n#[verus_spec]\nfn exec_with_proof() {\n   proof_decl!{\n     let ghost mut i = 0int;\n     assert(true);\n   }\n   test_for_loop(10);\n   proof!{\n     assert(i == 0);\n   }\n}\n// ANCHOR_END: proof\n\n// ANCHOR: proof_with\n#[verus_spec(ret =>\nwith\n  Tracked(y): Tracked<&mut u32>,\n  Ghost(w): Ghost<u32> \n     -> z: Ghost<u32>\nrequires\n  x < 100,\n  *old(y) < 100,\nensures\n  *y == x,\n  ret == x + 1,\n  z@ == x,\n)]\nfn exec_tracked(x: u32) -> u32 {\n  proof! {\n    *y = x;\n  }\n  proof_with!(|= Ghost(x));\n  (x + 1)\n}\n\n\n#[verus_spec]\nfn exec_tracked_test(x: u32) {\n  proof_decl!{\n    let ghost mut z = 0u32;\n    let tracked mut y = 0u32;\n  }\n\n  proof_with!{Tracked(&mut y), Ghost(0) => Ghost(z)}\n  let x = exec_tracked(1);\n\n  proof!{\n    assert(y == 1);\n    assert(z == 1);\n    assert(x == 2);\n  }\n}\n\nfn exec_external_test(x: u32) -> u32 {\n   exec_tracked(1)\n}\n\n// ANCHOR_END: proof_with\n\n// ANCHOR: dual_spec\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n    returns f(x, y)\n)]\nfn f(x: u32, y: u32) -> u32 {\n    proof!{\n        assert(true);\n    }\n    {\n        proof!{assert(true);}\n        x + y\n    }\n}\n\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n    returns\n        f2(x),\n)]\npub fn f2(x: u32) -> u32 {\n    f(x, 1)\n}\n// ANCHOR_END: dual_spec\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/exec_attr.rs", "verified": true, "metadata": {"original_id": "verus_exec_attr_8a9f2ac676ab", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_a_5b4d4afa6dde", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool)   { for k in 1 .. lst . len ()  { if lst [k - 1] > lst [k] { return false ; } } true }\n\n} // verus!", "target_text": "requires lst . len () >= 1 \nensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] \ninvariant forall | i : int , j : int | 0 <= i && i < j && j < k ==> lst [i] <= lst [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool) requires lst . len () >= 1 , ensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] , { for k in 1 .. lst . len () invariant forall | i : int , j : int | 0 <= i && i < j && j < k ==> lst [i] <= lst [j] , { if lst [k - 1] > lst [k] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/is_sorted_iter_1_current.rs", "verified": true, "metadata": {"original_id": "5b4d4afa6dde", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_87fad8385ba9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if arr [idx] == k { return true ; } idx += 1 ; } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ndecreases arr . len () - idx \ninvariant forall | i : int | 0 <= i < idx ==> arr [i] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut idx = 0 ; while idx < arr . len () invariant forall | i : int | 0 <= i < idx ==> arr [i] != k , decreases arr . len () - idx , { if arr [idx] == k { return true ; } idx += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_808_iter_2_current.rs", "verified": true, "metadata": {"original_id": "87fad8385ba9", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_requires_552d73d621e7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (idx < arr2 . len ()) ; result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (idx < arr2 . len ()) ; result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (idx < arr2 . len ()) ; result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_399_impl.rs", "verified": true, "metadata": {"original_id": "552d73d621e7", "function_name": "bit_wise_xor", "bug_type": "missing_requires"}}
{"id": "task_a_f9304443414a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_compare/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "f9304443414a", "function_name": "compare_int", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_7b5f7e94f536", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn findMax (a : & [i32]) -> (max : i32)   { let mut max = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] > max { max = a [i] ; } i += 1 ; } max }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures exists | k : int | 0 <= k < a . len () && max == a [k] , forall | k : int | 0 <= k < a . len () ==> max >= a [k]\ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , exists | k : int | 0 <= k < i && max == a [k] , forall | k : int | 0 <= k < i ==> max >= a [k]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn findMax (a : & [i32]) -> (max : i32) requires a . len () > 0 , ensures exists | k : int | 0 <= k < a . len () && max == a [k] , forall | k : int | 0 <= k < a . len () ==> max >= a [k] { let mut max = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , exists | k : int | 0 <= k < i && max == a [k] , forall | k : int | 0 <= k < i ==> max >= a [k] decreases a . len () - i { if a [i] > max { max = a [i] ; } i += 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/DafnyProjects_tmp_tmp2acw_s4s_findMax/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "7b5f7e94f536", "function_name": "findMax", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_requires_92d9db1ecdcf", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)  ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize)  ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize) requires binary_search_precond (a @ , key) , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize) requires binary_search_precond (a @ , key) , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_51/verina_basic_51_impl.rs", "verified": true, "metadata": {"original_id": "92d9db1ecdcf", "function_name": "binary_search", "bug_type": "missing_requires"}}
{"id": "task_b_34bfca31cda2", "task": "task_b", "input_text": "fn arithmetic_weird () -> (result : i32)\nensures result < 10", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/arithmetic_weird_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "34bfca31cda2", "function_name": "arithmetic_weird", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_requires_7a07e78bbb25", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int)  ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn decode_char (c : u8) -> (r : u8)  ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn decode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >)  ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == decode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> encode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == decode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> encode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let decoded = decode_char (s [i]) ; result . push (decoded) ; proof { opposite_encode_decode (decoded as int) ; } i = i + 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn decode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn decode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == decode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> encode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == decode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> encode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let decoded = decode_char (s [i]) ; result . push (decoded) ; proof { opposite_encode_decode (decoded as int) ; } i = i + 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn decode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn decode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == decode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> encode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == decode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> encode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let decoded = decode_char (s [i]) ; result . push (decoded) ; proof { opposite_encode_decode (decoded as int) ; } i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/050-encode_shift_impl.rs", "verified": true, "metadata": {"original_id": "7a07e78bbb25", "function_name": "decode_shift", "bug_type": "missing_requires"}}
{"id": "task_b_ffa6c1536e04", "task": "task_b", "input_text": "fn contains_z (text : & [u8]) -> (result : bool)\nensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "ffa6c1536e04", "function_name": "contains_z", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_invariant_94fc95a22d1f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/preconditions_removed/max_dafny_lsp_iter_2_current.rs", "verified": true, "metadata": {"original_id": "94fc95a22d1f", "function_name": "max", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_eacd0ad24593", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)  ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/two_way_sort_impl.rs", "verified": true, "metadata": {"original_id": "eacd0ad24593", "function_name": "swap", "bug_type": "missing_requires"}}
{"id": "task_b_vostd_conversion_f0265302a607", "task": "task_b", "input_text": "fn usize_mod_is_int_mod(x: usize, m: usize, z: usize)\nrequires x % m == z", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub axiom fn usize_mod_is_int_mod(x: usize, m: usize, z: usize)\n    requires\n        x % m == z,\n    ensures\n        (x as int) % (m as int) == (z as int),\n;\n\n} // verus!\n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub axiom fn usize_mod_is_int_mod(x: usize, m: usize, z: usize)\n    requires\n        x % m == z,\n    ensures\n        (x as int) % (m as int) == (z as int),\n;\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/lock-protocol-rcu/src/helpers/conversion.rs", "verified": true, "metadata": {"original_id": "vostd_conversion_f0265302a607", "function_name": "", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_2745f0d713b9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs_diff (a : i32 , b : i32) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires a >= - 1000000 && a <= 1000000 , b >= - 1000000 && b <= 1000000 \nensures result >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs_diff (a : i32 , b : i32) -> (result : i32) requires a >= - 1000000 && a <= 1000000 , b >= - 1000000 && b <= 1000000 , ensures result >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_63/verina_basic_63_iter_0_original.rs", "verified": true, "metadata": {"original_id": "2745f0d713b9", "function_name": "abs_diff", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_4eb753211bbd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >)  { }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >) ensures intervals @ . len () == old (intervals) @ . len () { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >) ensures intervals @ . len () == old (intervals) @ . len () { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_38/verina_advanced_38_iter_0_original.rs", "verified": true, "metadata": {"original_id": "4eb753211bbd", "function_name": "sort_intervals", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_aa6e977e59b2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool) requires true ,  { a == b }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_compare/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "aa6e977e59b2", "function_name": "compare_nat", "bug_type": "missing_ensures"}}
{"id": "task_b_211b69bf344d", "task": "task_b", "input_text": "fn add (x : i32 , y : i32) -> (res : Option < i32 >)\nensures res . is_some () ==> res . unwrap () == x + y ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >) ensures res . is_some () ==> res . unwrap () == x + y , { return None ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >) ensures res . is_some () ==> res . unwrap () == x + y , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/HumanEval-RustBench/053-add.rs", "verified": true, "metadata": {"original_id": "211b69bf344d", "function_name": "add", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_invariant_2981e1bee084", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len ()  { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_61/verina_basic_61_iter_3_current.rs", "verified": true, "metadata": {"original_id": "2981e1bee084", "function_name": "all_digits", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_3df3a1cef5df", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len ()  { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "3df3a1cef5df", "function_name": "shared_elements", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_f001f5ced977", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 ,  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f001f5ced977", "function_name": "main_method", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_c56c15f61812", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut i : usize = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i { let c = str1 [i] ; if c == ' ' || c == ',' || c == '.' { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let mut result = Vec :: new () ; let mut i : usize = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i { let c = str1 [i] ; if c == ' ' || c == ',' || c == '.' { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let mut result = Vec :: new () ; let mut i : usize = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i { let c = str1 [i] ; if c == ' ' || c == ',' || c == '.' { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_732_impl.rs", "verified": true, "metadata": {"original_id": "c56c15f61812", "function_name": "replace_with_colon", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_2c18f8f4e000", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32)  ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , decreases lst . len () - i , { if lst [i] > max_val { max_val = lst [i] ; } i += 1 ; } max_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , decreases lst . len () - i , { if lst [i] > max_val { max_val = lst [i] ; } i += 1 ; } max_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , decreases lst . len () - i , { if lst [i] > max_val { max_val = lst [i] ; } i += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_39/verina_advanced_39_impl.rs", "verified": true, "metadata": {"original_id": "2c18f8f4e000", "function_name": "max_of_list", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_292f839cb54c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int } , decreases s1 . len () - i , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ; assert (prefix_i1 . len () == i + 1) ; assert (prefix_i1 . last () == s1 [i]) ; assert (prefix_i1 . drop_last () =~= prefix_i) ; let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ; assert (s2_prefix_i1 . last () == s2 [i]) ; assert (s2_prefix_i1 . drop_last () =~= s2_prefix_i) ; let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ; assert (s3_prefix_i1 . last () == s3 [i]) ; assert (s3_prefix_i1 . drop_last () =~= s3_prefix_i) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len ()  { proof { lemma_count_identical_prefix (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; } proof { assert (arr1 @ . subrange (0 , arr1 @ . len () as int) =~= arr1 @) ; assert (arr2 @ . subrange (0 , arr2 @ . len () as int) =~= arr2 @) ; assert (arr3 @ . subrange (0 , arr3 @ . len () as int) =~= arr3 @) ; } count }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int } , decreases s1 . len () - i , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ; assert (prefix_i1 . len () == i + 1) ; assert (prefix_i1 . last () == s1 [i]) ; assert (prefix_i1 . drop_last () =~= prefix_i) ; let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ; assert (s2_prefix_i1 . last () == s2 [i]) ; assert (s2_prefix_i1 . drop_last () =~= s2_prefix_i) ; let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ; assert (s3_prefix_i1 . last () == s3 [i]) ; assert (s3_prefix_i1 . drop_last () =~= s3_prefix_i) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , 0 <= i <= arr1 . len () , 0 <= count <= i , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i { proof { lemma_count_identical_prefix (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; } proof { assert (arr1 @ . subrange (0 , arr1 @ . len () as int) =~= arr1 @) ; assert (arr2 @ . subrange (0 , arr2 @ . len () as int) =~= arr2 @) ; assert (arr3 @ . subrange (0 , arr3 @ . len () as int) =~= arr3 @) ; } count }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_prefix (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () && s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int } , decreases s1 . len () - i , { let prefix_i = s1 . subrange (0 , i) ; let prefix_i1 = s1 . subrange (0 , i + 1) ; assert (prefix_i1 . len () == i + 1) ; assert (prefix_i1 . last () == s1 [i]) ; assert (prefix_i1 . drop_last () =~= prefix_i) ; let s2_prefix_i = s2 . subrange (0 , i) ; let s2_prefix_i1 = s2 . subrange (0 , i + 1) ; assert (s2_prefix_i1 . last () == s2 [i]) ; assert (s2_prefix_i1 . drop_last () =~= s2_prefix_i) ; let s3_prefix_i = s3 . subrange (0 , i) ; let s3_prefix_i1 = s3 . subrange (0 , i + 1) ; assert (s3_prefix_i1 . last () == s3 [i]) ; assert (s3_prefix_i1 . drop_last () =~= s3_prefix_i) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , 0 <= i <= arr1 . len () , 0 <= count <= i , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i { proof { lemma_count_identical_prefix (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count += 1 ; } i += 1 ; } proof { assert (arr1 @ . subrange (0 , arr1 @ . len () as int) =~= arr1 @) ; assert (arr2 @ . subrange (0 , arr2 @ . len () as int) =~= arr2 @) ; assert (arr3 @ . subrange (0 , arr3 @ . len () as int) =~= arr3 @) ; } count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_142_impl.rs", "verified": true, "metadata": {"original_id": "292f839cb54c", "function_name": "count_identical_position", "bug_type": "missing_invariant"}}
{"id": "task_a_08fa248ef5f5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize)   { let mut i = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | i : int | 0 <= i < a . len () && a [i] == e \nensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_linear_search2/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "08fa248ef5f5", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_invariant_cda0fddb188b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX ensures c @ == a @ + seq ! [b] { let mut c = Vec :: new () ; for i in 0 .. a . len ()  { c . push (a [i]) ; } c . push (b) ; c }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX ensures c @ == a @ + seq ! [b] { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant c @ == a @ . subrange (0 , i as int) { c . push (a [i]) ; } c . push (b) ; c }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (a : & [int] , b : int) -> (c : Vec < int >) requires a . len () < MAX ensures c @ == a @ + seq ! [b] { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant c @ == a @ . subrange (0 , i as int) { c . push (a [i]) ; } c . push (b) ; c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_array_append/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "cda0fddb188b", "function_name": "append", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_90d3d3af14ce", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (str : & Vec < i32 > , key : i32) -> (result : bool) ensures result <==> (exists | i : int | 0 <= i < str . len () && (str [i] == key)) , { let mut idx = 0 ; while idx < str . len () invariant 0 <= idx <= str . len () , forall | j : int | 0 <= j < idx ==> str [j] != key , { if str [idx] == key { return true ; } idx += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (str : & Vec < i32 > , key : i32) -> (result : bool) ensures result <==> (exists | i : int | 0 <= i < str . len () && (str [i] == key)) , { let mut idx = 0 ; while idx < str . len () invariant 0 <= idx <= str . len () , forall | j : int | 0 <= j < idx ==> str [j] != key , decreases str . len () - idx , { if str [idx] == key { return true ; } idx += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (str : & Vec < i32 > , key : i32) -> (result : bool) ensures result <==> (exists | i : int | 0 <= i < str . len () && (str [i] == key)) , { let mut idx = 0 ; while idx < str . len () invariant 0 <= idx <= str . len () , forall | j : int | 0 <= j < idx ==> str [j] != key , decreases str . len () - idx , { if str [idx] == key { return true ; } idx += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_161_impl.rs", "verified": true, "metadata": {"original_id": "90d3d3af14ce", "function_name": "contains", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_0a6ed5b553c3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >)  ensures if let Some (idx) = index { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index ==> arr [k] != target , decreases arr . len () - index { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >) requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] , ensures if let Some (idx) = index { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index ==> arr [k] != target , decreases arr . len () - index { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >) requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] , ensures if let Some (idx) = index { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index ==> arr [k] != target , decreases arr . len () - index { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_733_impl.rs", "verified": true, "metadata": {"original_id": "0a6ed5b553c3", "function_name": "find_first_occurrence", "bug_type": "missing_requires"}}
{"id": "task_a_54cdc60873f4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >)  { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >)  { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len ()  { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len ()  { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len ()  { combination . push (rest [k]) ; } result . push (combination) ; } } result }\n\n} // verus!", "target_text": "requires start <= chars . len ()\nensures result @ == digit_to_letters (c)\ndecreases chars . len () - start\ninvariant 0 <= i <= current_letters . len (), 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len (), 0 <= k <= rest . len () , combination . len () == k + 1", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >) requires start <= chars . len () decreases chars . len () - start { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len () invariant 0 <= i <= current_letters . len () { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len () invariant 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len () { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len () invariant 0 <= k <= rest . len () , combination . len () == k + 1 { combination . push (rest [k]) ; } result . push (combination) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_26/verina_advanced_26_iter_5_current.rs", "verified": true, "metadata": {"original_id": "54cdc60873f4", "function_name": "go", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_assert_vostd_seq_extra_344700480285", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd::seq::*;\n\nverus! {\n\n#[verifier::external_body]\npub proof fn seq_tracked_new<T>(len: nat, f: impl Fn(int) -> T) -> (tracked res: Seq<T>)\n    ensures\n        res == Seq::<T>::new(len, f),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn seq_tracked_update<T>(s: Seq<T>, idx: int, x: T) -> (tracked res: Seq<T>)\n    requires\n        0 <= idx < s.len(),\n    ensures\n        res == s.update(idx, x),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn seq_tracked_add<T>(s1: Seq<T>, s2: Seq<T>) -> (tracked res: Seq<T>)\n    ensures\n        res == s1.add(s2),\n{\n    unimplemented!();\n}\n\npub proof fn lemma_seq_add_head_back<T>(s: Seq<T>)\n    requires\n        s.len() > 0,\n    ensures\n        s =~= seq![s[0]].add(s.drop_first()),\n{\n}\n\npub proof fn lemma_seq_push_head<T>(s: Seq<T>, hd: T)\n    ensures\n        seq![hd].add(s) =~= s.reverse().push(hd).reverse(),\n{\n}\n\npub proof fn lemma_seq_drop_pushed_head<T>(s: Seq<T>, hd: T)\n    ensures\n        seq![hd].add(s).drop_first() =~= s,\n{\n}\n\npub proof fn lemma_seq_push_head_take_head<T>(s: Seq<T>, hd: T)\n    ensures\n        seq![hd].add(s)[0] == hd,\n{\n}\n\n} // verus!\nverus! {\n\n/// The result of pushing elemrnt 'needle' into the sequence 's' contains 'needle'.\npub proof fn lemma_push_contains_same<T>(s: Seq<T>, needle: T)\n    ensures\n        #[trigger] s.push(needle).contains(needle),\n{\n\n}\n\n/// If element 'needle' is different from 'new_elem', then whether the sequence 's' contains 'needle'\n/// after pushing 'new_elem' depends on whether 's' contains 'needle' before the push.\npub proof fn lemma_push_contains_different<T>(s: Seq<T>, new_elem: T, needle: T)\n    requires\n        new_elem != needle,\n    ensures\n        #[trigger] s.push(new_elem).contains(needle) == s.contains(needle),\n{\n    if (s.contains(needle)) {\n        let i = choose|i: int| 0 <= i < s.len() && s[i] == needle;\n        axiom_seq_push_index_different(s, needle, i);\n\n    }\n}\n\n/// If the last element of the sequence 's' is different from 'needle', then whether the sequence\n/// 's' contains 'needle' after dropping the last element depends on whether 's' contains 'needle'\n/// before the drop.\npub proof fn lemma_drop_last_contains_different<T>(s: Seq<T>, needle: T)\n    requires\n        s.len() > 0,\n        s.last() != needle,\n    ensures\n        #[trigger] s.drop_last().contains(needle) == s.contains(needle),\n{\n    if (s.contains(needle)) {\n        let i = choose|i: int| 0 <= i < s.len() && s[i] == needle;\n\n    }\n}\n\n} // verus!\nverus! {\n\n/// Returns true if predicate `f(i,seq[i])` holds for all indices 'i'.\npub open spec fn forall_seq<T>(seq: Seq<T>, f: spec_fn(int, T) -> bool) -> bool {\n    forall|i| #![trigger seq[i]] 0 <= i < seq.len() ==> f(i, seq[i])\n}\n\npub broadcast group group_forall_seq_lemmas {\n    lemma_forall_seq_push,\n    lemma_seq_all_push,\n    lemma_forall_seq_drop_last,\n    lemma_seq_all_drop_last,\n    lemma_seq_all_add,\n    lemma_seq_all_index,\n}\n\n/// Index `i` of the sequence `s` satisfies `f(i,s[i])` if `forall_seq(s,f)` holds.\npub proof fn lemma_forall_seq_index<T>(s: Seq<T>, f: spec_fn(int, T) -> bool, i: int)\n    requires\n        forall_seq(s, f),\n        0 <= i < s.len(),\n    ensures\n        f(i, s[i]),\n{\n}\n\n/// Index `i` of the sequence `s` satisfies `f(s[i])` if `s.all(f)` holds.\n/// This proof is required due to the change of trigger by replacing the original `forall_seq_values` with `Seq::all`.\npub broadcast proof fn lemma_seq_all_index<T>(s: Seq<T>, f: spec_fn(T) -> bool, i: int)\n    requires\n        0 <= i < s.len(),\n        #[trigger] s.all(f),\n    ensures\n        f(#[trigger] (s[i])),\n{\n}\n\n/// `forall_seq(s.push(v),f)` is equivalent to `forall_seq(s,f)` and `f(s.len(),v)`.\npub broadcast proof fn lemma_forall_seq_push<T>(s: Seq<T>, f: spec_fn(int, T) -> bool, v: T)\n    ensures\n        forall_seq(s, f) && f(s.len() as int, v) <==> #[trigger] forall_seq(s.push(v), f),\n{\n    if (forall_seq(s.push(v), f)) {\n        }\n}\n\n/// s.push(v).all(f)` is equivalent to `s.all(f)` and `f(v)`.\npub broadcast proof fn lemma_seq_all_push<T>(s: Seq<T>, f: spec_fn(T) -> bool, v: T)\n    ensures\n        #[trigger] s.push(v).all(f) <==> s.all(f) && f(v),\n{\n    if (s.push(v).all(f)) {\n        }\n}\n\n/// `forall_seq(s,f)` is equivalent to `forall_seq(s.drop_last(),f)` and `f(s.len() as int - 1, s.last())`.\npub broadcast proof fn lemma_forall_seq_drop_last<T>(s: Seq<T>, f: spec_fn(int, T) -> bool)\n    requires\n        s.len() > 0,\n    ensures\n        forall_seq(s, f) <==> #[trigger] forall_seq(s.drop_last(), f) && f(\n            s.len() as int - 1,\n            s.last(),\n        ),\n{\n\n}\n\n/// `s.all(f)` is equivalent to `s.drop_last().all(f)` and `f(s.last())`.\npub broadcast proof fn lemma_seq_all_drop_last<T>(s: Seq<T>, f: spec_fn(T) -> bool)\n    requires\n        s.len() > 0,\n    ensures\n        s.all(f) <==> #[trigger] s.drop_last().all(f) && f(s.last()),\n{\n\n}\n\npub broadcast proof fn lemma_seq_all_add<T>(s1: Seq<T>, s2: Seq<T>, f: spec_fn(T) -> bool)\n    ensures\n        s1.all(f) && s2.all(f) <==> #[trigger] (s1 + s2).all(f),\n    decreases s2.len(),\n// Induction proof on the length of s2\n\n{\n    if s2.len() == 0 {\n\n    } else {\n        // Induction step: assume the lemma holds for s2.drop_last() and show that s2==s2.drop_last().push(s2.last()).\n        lemma_seq_all_add(s1, s2.drop_last(), f);\n        if s1.all(f) && s2.all(f) {\n\n        }\n        if (s1 + s2).all(f) {\n\n        }\n    }\n}\n\n/// If `source1` and `source2` are prefixes of `child`, then either `source1` is equal to `source2` or\n/// one of them is a prefix of the other.\npub proof fn lemma_prefix_of_common_sequence(source1: Seq<nat>, source2: Seq<nat>, child: Seq<nat>)\n    requires\n        source1.is_prefix_of(child),\n        source2.is_prefix_of(child),\n    ensures\n        source1 == source2 || source1.len() < source2.len() && source1.is_prefix_of(source2)\n            || source2.len() < source1.len() && source2.is_prefix_of(source1),\n{\n}\n\n} // verus!\n", "target_text": "use vstd::prelude::*;\nuse vstd::seq::*;\n\nverus! {\n\n#[verifier::external_body]\npub proof fn seq_tracked_new<T>(len: nat, f: impl Fn(int) -> T) -> (tracked res: Seq<T>)\n    ensures\n        res == Seq::<T>::new(len, f),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn seq_tracked_update<T>(s: Seq<T>, idx: int, x: T) -> (tracked res: Seq<T>)\n    requires\n        0 <= idx < s.len(),\n    ensures\n        res == s.update(idx, x),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn seq_tracked_add<T>(s1: Seq<T>, s2: Seq<T>) -> (tracked res: Seq<T>)\n    ensures\n        res == s1.add(s2),\n{\n    unimplemented!();\n}\n\npub proof fn lemma_seq_add_head_back<T>(s: Seq<T>)\n    requires\n        s.len() > 0,\n    ensures\n        s =~= seq![s[0]].add(s.drop_first()),\n{\n}\n\npub proof fn lemma_seq_push_head<T>(s: Seq<T>, hd: T)\n    ensures\n        seq![hd].add(s) =~= s.reverse().push(hd).reverse(),\n{\n}\n\npub proof fn lemma_seq_drop_pushed_head<T>(s: Seq<T>, hd: T)\n    ensures\n        seq![hd].add(s).drop_first() =~= s,\n{\n}\n\npub proof fn lemma_seq_push_head_take_head<T>(s: Seq<T>, hd: T)\n    ensures\n        seq![hd].add(s)[0] == hd,\n{\n}\n\n} // verus!\nverus! {\n\n/// The result of pushing elemrnt 'needle' into the sequence 's' contains 'needle'.\npub proof fn lemma_push_contains_same<T>(s: Seq<T>, needle: T)\n    ensures\n        #[trigger] s.push(needle).contains(needle),\n{\n    assert(s.push(needle).last() == needle);\n}\n\n/// If element 'needle' is different from 'new_elem', then whether the sequence 's' contains 'needle'\n/// after pushing 'new_elem' depends on whether 's' contains 'needle' before the push.\npub proof fn lemma_push_contains_different<T>(s: Seq<T>, new_elem: T, needle: T)\n    requires\n        new_elem != needle,\n    ensures\n        #[trigger] s.push(new_elem).contains(needle) == s.contains(needle),\n{\n    if (s.contains(needle)) {\n        let i = choose|i: int| 0 <= i < s.len() && s[i] == needle;\n        axiom_seq_push_index_different(s, needle, i);\n        assert(0 <= i < s.push(new_elem).len() && s.push(new_elem)[i] == needle);\n    }\n}\n\n/// If the last element of the sequence 's' is different from 'needle', then whether the sequence\n/// 's' contains 'needle' after dropping the last element depends on whether 's' contains 'needle'\n/// before the drop.\npub proof fn lemma_drop_last_contains_different<T>(s: Seq<T>, needle: T)\n    requires\n        s.len() > 0,\n        s.last() != needle,\n    ensures\n        #[trigger] s.drop_last().contains(needle) == s.contains(needle),\n{\n    if (s.contains(needle)) {\n        let i = choose|i: int| 0 <= i < s.len() && s[i] == needle;\n        assert(0 <= i < s.drop_last().len() && s.drop_last()[i] == needle);\n    }\n}\n\n} // verus!\nverus! {\n\n/// Returns true if predicate `f(i,seq[i])` holds for all indices 'i'.\npub open spec fn forall_seq<T>(seq: Seq<T>, f: spec_fn(int, T) -> bool) -> bool {\n    forall|i| #![trigger seq[i]] 0 <= i < seq.len() ==> f(i, seq[i])\n}\n\npub broadcast group group_forall_seq_lemmas {\n    lemma_forall_seq_push,\n    lemma_seq_all_push,\n    lemma_forall_seq_drop_last,\n    lemma_seq_all_drop_last,\n    lemma_seq_all_add,\n    lemma_seq_all_index,\n}\n\n/// Index `i` of the sequence `s` satisfies `f(i,s[i])` if `forall_seq(s,f)` holds.\npub proof fn lemma_forall_seq_index<T>(s: Seq<T>, f: spec_fn(int, T) -> bool, i: int)\n    requires\n        forall_seq(s, f),\n        0 <= i < s.len(),\n    ensures\n        f(i, s[i]),\n{\n}\n\n/// Index `i` of the sequence `s` satisfies `f(s[i])` if `s.all(f)` holds.\n/// This proof is required due to the change of trigger by replacing the original `forall_seq_values` with `Seq::all`.\npub broadcast proof fn lemma_seq_all_index<T>(s: Seq<T>, f: spec_fn(T) -> bool, i: int)\n    requires\n        0 <= i < s.len(),\n        #[trigger] s.all(f),\n    ensures\n        f(#[trigger] (s[i])),\n{\n}\n\n/// `forall_seq(s.push(v),f)` is equivalent to `forall_seq(s,f)` and `f(s.len(),v)`.\npub broadcast proof fn lemma_forall_seq_push<T>(s: Seq<T>, f: spec_fn(int, T) -> bool, v: T)\n    ensures\n        forall_seq(s, f) && f(s.len() as int, v) <==> #[trigger] forall_seq(s.push(v), f),\n{\n    if (forall_seq(s.push(v), f)) {\n        assert forall|i| 0 <= i < s.len() implies f(i, s[i]) by {\n            assert(s[i] === s.push(v)[i]);\n        }\n        assert(s.push(v)[s.len() as int] == v);\n    }\n}\n\n/// s.push(v).all(f)` is equivalent to `s.all(f)` and `f(v)`.\npub broadcast proof fn lemma_seq_all_push<T>(s: Seq<T>, f: spec_fn(T) -> bool, v: T)\n    ensures\n        #[trigger] s.push(v).all(f) <==> s.all(f) && f(v),\n{\n    if (s.push(v).all(f)) {\n        assert forall|i| 0 <= i < s.len() implies f(s[i]) by {\n            assert(s[i] === s.push(v)[i]);\n        }\n        assert(s.push(v)[s.len() as int] == v);\n    }\n}\n\n/// `forall_seq(s,f)` is equivalent to `forall_seq(s.drop_last(),f)` and `f(s.len() as int - 1, s.last())`.\npub broadcast proof fn lemma_forall_seq_drop_last<T>(s: Seq<T>, f: spec_fn(int, T) -> bool)\n    requires\n        s.len() > 0,\n    ensures\n        forall_seq(s, f) <==> #[trigger] forall_seq(s.drop_last(), f) && f(\n            s.len() as int - 1,\n            s.last(),\n        ),\n{\n    assert(s == s.drop_last().push(s.last()));\n}\n\n/// `s.all(f)` is equivalent to `s.drop_last().all(f)` and `f(s.last())`.\npub broadcast proof fn lemma_seq_all_drop_last<T>(s: Seq<T>, f: spec_fn(T) -> bool)\n    requires\n        s.len() > 0,\n    ensures\n        s.all(f) <==> #[trigger] s.drop_last().all(f) && f(s.last()),\n{\n    assert(s == s.drop_last().push(s.last()));\n}\n\npub broadcast proof fn lemma_seq_all_add<T>(s1: Seq<T>, s2: Seq<T>, f: spec_fn(T) -> bool)\n    ensures\n        s1.all(f) && s2.all(f) <==> #[trigger] (s1 + s2).all(f),\n    decreases s2.len(),\n// Induction proof on the length of s2\n\n{\n    if s2.len() == 0 {\n        assert(s1 + s2 == s1);\n    } else {\n        // Induction step: assume the lemma holds for s2.drop_last() and show that s2==s2.drop_last().push(s2.last()).\n        lemma_seq_all_add(s1, s2.drop_last(), f);\n        if s1.all(f) && s2.all(f) {\n            assert((s1 + s2).all(f));\n        }\n        if (s1 + s2).all(f) {\n            assert((s1 + s2).drop_last() == s1 + s2.drop_last());\n            assert(s2 == s2.drop_last().push(s2.last()));\n            assert((s1 + s2).last() == s2.last());\n        }\n    }\n}\n\n/// If `source1` and `source2` are prefixes of `child`, then either `source1` is equal to `source2` or\n/// one of them is a prefix of the other.\npub proof fn lemma_prefix_of_common_sequence(source1: Seq<nat>, source2: Seq<nat>, child: Seq<nat>)\n    requires\n        source1.is_prefix_of(child),\n        source2.is_prefix_of(child),\n    ensures\n        source1 == source2 || source1.len() < source2.len() && source1.is_prefix_of(source2)\n            || source2.len() < source1.len() && source2.is_prefix_of(source1),\n{\n}\n\n} // verus!\n", "full_verified_code": "use vstd::prelude::*;\nuse vstd::seq::*;\n\nverus! {\n\n#[verifier::external_body]\npub proof fn seq_tracked_new<T>(len: nat, f: impl Fn(int) -> T) -> (tracked res: Seq<T>)\n    ensures\n        res == Seq::<T>::new(len, f),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn seq_tracked_update<T>(s: Seq<T>, idx: int, x: T) -> (tracked res: Seq<T>)\n    requires\n        0 <= idx < s.len(),\n    ensures\n        res == s.update(idx, x),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn seq_tracked_add<T>(s1: Seq<T>, s2: Seq<T>) -> (tracked res: Seq<T>)\n    ensures\n        res == s1.add(s2),\n{\n    unimplemented!();\n}\n\npub proof fn lemma_seq_add_head_back<T>(s: Seq<T>)\n    requires\n        s.len() > 0,\n    ensures\n        s =~= seq![s[0]].add(s.drop_first()),\n{\n}\n\npub proof fn lemma_seq_push_head<T>(s: Seq<T>, hd: T)\n    ensures\n        seq![hd].add(s) =~= s.reverse().push(hd).reverse(),\n{\n}\n\npub proof fn lemma_seq_drop_pushed_head<T>(s: Seq<T>, hd: T)\n    ensures\n        seq![hd].add(s).drop_first() =~= s,\n{\n}\n\npub proof fn lemma_seq_push_head_take_head<T>(s: Seq<T>, hd: T)\n    ensures\n        seq![hd].add(s)[0] == hd,\n{\n}\n\n} // verus!\nverus! {\n\n/// The result of pushing elemrnt 'needle' into the sequence 's' contains 'needle'.\npub proof fn lemma_push_contains_same<T>(s: Seq<T>, needle: T)\n    ensures\n        #[trigger] s.push(needle).contains(needle),\n{\n    assert(s.push(needle).last() == needle);\n}\n\n/// If element 'needle' is different from 'new_elem', then whether the sequence 's' contains 'needle'\n/// after pushing 'new_elem' depends on whether 's' contains 'needle' before the push.\npub proof fn lemma_push_contains_different<T>(s: Seq<T>, new_elem: T, needle: T)\n    requires\n        new_elem != needle,\n    ensures\n        #[trigger] s.push(new_elem).contains(needle) == s.contains(needle),\n{\n    if (s.contains(needle)) {\n        let i = choose|i: int| 0 <= i < s.len() && s[i] == needle;\n        axiom_seq_push_index_different(s, needle, i);\n        assert(0 <= i < s.push(new_elem).len() && s.push(new_elem)[i] == needle);\n    }\n}\n\n/// If the last element of the sequence 's' is different from 'needle', then whether the sequence\n/// 's' contains 'needle' after dropping the last element depends on whether 's' contains 'needle'\n/// before the drop.\npub proof fn lemma_drop_last_contains_different<T>(s: Seq<T>, needle: T)\n    requires\n        s.len() > 0,\n        s.last() != needle,\n    ensures\n        #[trigger] s.drop_last().contains(needle) == s.contains(needle),\n{\n    if (s.contains(needle)) {\n        let i = choose|i: int| 0 <= i < s.len() && s[i] == needle;\n        assert(0 <= i < s.drop_last().len() && s.drop_last()[i] == needle);\n    }\n}\n\n} // verus!\nverus! {\n\n/// Returns true if predicate `f(i,seq[i])` holds for all indices 'i'.\npub open spec fn forall_seq<T>(seq: Seq<T>, f: spec_fn(int, T) -> bool) -> bool {\n    forall|i| #![trigger seq[i]] 0 <= i < seq.len() ==> f(i, seq[i])\n}\n\npub broadcast group group_forall_seq_lemmas {\n    lemma_forall_seq_push,\n    lemma_seq_all_push,\n    lemma_forall_seq_drop_last,\n    lemma_seq_all_drop_last,\n    lemma_seq_all_add,\n    lemma_seq_all_index,\n}\n\n/// Index `i` of the sequence `s` satisfies `f(i,s[i])` if `forall_seq(s,f)` holds.\npub proof fn lemma_forall_seq_index<T>(s: Seq<T>, f: spec_fn(int, T) -> bool, i: int)\n    requires\n        forall_seq(s, f),\n        0 <= i < s.len(),\n    ensures\n        f(i, s[i]),\n{\n}\n\n/// Index `i` of the sequence `s` satisfies `f(s[i])` if `s.all(f)` holds.\n/// This proof is required due to the change of trigger by replacing the original `forall_seq_values` with `Seq::all`.\npub broadcast proof fn lemma_seq_all_index<T>(s: Seq<T>, f: spec_fn(T) -> bool, i: int)\n    requires\n        0 <= i < s.len(),\n        #[trigger] s.all(f),\n    ensures\n        f(#[trigger] (s[i])),\n{\n}\n\n/// `forall_seq(s.push(v),f)` is equivalent to `forall_seq(s,f)` and `f(s.len(),v)`.\npub broadcast proof fn lemma_forall_seq_push<T>(s: Seq<T>, f: spec_fn(int, T) -> bool, v: T)\n    ensures\n        forall_seq(s, f) && f(s.len() as int, v) <==> #[trigger] forall_seq(s.push(v), f),\n{\n    if (forall_seq(s.push(v), f)) {\n        assert forall|i| 0 <= i < s.len() implies f(i, s[i]) by {\n            assert(s[i] === s.push(v)[i]);\n        }\n        assert(s.push(v)[s.len() as int] == v);\n    }\n}\n\n/// s.push(v).all(f)` is equivalent to `s.all(f)` and `f(v)`.\npub broadcast proof fn lemma_seq_all_push<T>(s: Seq<T>, f: spec_fn(T) -> bool, v: T)\n    ensures\n        #[trigger] s.push(v).all(f) <==> s.all(f) && f(v),\n{\n    if (s.push(v).all(f)) {\n        assert forall|i| 0 <= i < s.len() implies f(s[i]) by {\n            assert(s[i] === s.push(v)[i]);\n        }\n        assert(s.push(v)[s.len() as int] == v);\n    }\n}\n\n/// `forall_seq(s,f)` is equivalent to `forall_seq(s.drop_last(),f)` and `f(s.len() as int - 1, s.last())`.\npub broadcast proof fn lemma_forall_seq_drop_last<T>(s: Seq<T>, f: spec_fn(int, T) -> bool)\n    requires\n        s.len() > 0,\n    ensures\n        forall_seq(s, f) <==> #[trigger] forall_seq(s.drop_last(), f) && f(\n            s.len() as int - 1,\n            s.last(),\n        ),\n{\n    assert(s == s.drop_last().push(s.last()));\n}\n\n/// `s.all(f)` is equivalent to `s.drop_last().all(f)` and `f(s.last())`.\npub broadcast proof fn lemma_seq_all_drop_last<T>(s: Seq<T>, f: spec_fn(T) -> bool)\n    requires\n        s.len() > 0,\n    ensures\n        s.all(f) <==> #[trigger] s.drop_last().all(f) && f(s.last()),\n{\n    assert(s == s.drop_last().push(s.last()));\n}\n\npub broadcast proof fn lemma_seq_all_add<T>(s1: Seq<T>, s2: Seq<T>, f: spec_fn(T) -> bool)\n    ensures\n        s1.all(f) && s2.all(f) <==> #[trigger] (s1 + s2).all(f),\n    decreases s2.len(),\n// Induction proof on the length of s2\n\n{\n    if s2.len() == 0 {\n        assert(s1 + s2 == s1);\n    } else {\n        // Induction step: assume the lemma holds for s2.drop_last() and show that s2==s2.drop_last().push(s2.last()).\n        lemma_seq_all_add(s1, s2.drop_last(), f);\n        if s1.all(f) && s2.all(f) {\n            assert((s1 + s2).all(f));\n        }\n        if (s1 + s2).all(f) {\n            assert((s1 + s2).drop_last() == s1 + s2.drop_last());\n            assert(s2 == s2.drop_last().push(s2.last()));\n            assert((s1 + s2).last() == s2.last());\n        }\n    }\n}\n\n/// If `source1` and `source2` are prefixes of `child`, then either `source1` is equal to `source2` or\n/// one of them is a prefix of the other.\npub proof fn lemma_prefix_of_common_sequence(source1: Seq<nat>, source2: Seq<nat>, child: Seq<nat>)\n    requires\n        source1.is_prefix_of(child),\n        source2.is_prefix_of(child),\n    ensures\n        source1 == source2 || source1.len() < source2.len() && source1.is_prefix_of(source2)\n            || source2.len() < source1.len() && source2.is_prefix_of(source1),\n{\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/vstd_extra/src/seq_extra.rs", "verified": true, "metadata": {"original_id": "vostd_seq_extra_344700480285", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_c_missing_ensures_ea5b1ba7cfac", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32) requires x <= 0x55555555u32 ,  { let doubled = x + x ; doubled + x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { let doubled = x + x ; doubled + x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { let doubled = x + x ; doubled + x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ea5b1ba7cfac", "function_name": "triple_over", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_849aa2fc577e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "849aa2fc577e", "function_name": "contains", "bug_type": "missing_invariant"}}
{"id": "task_b_1f909d4aa1a2", "task": "task_b", "input_text": "pub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)\nrequires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures sum [0] == N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] == N , { sum . set (0 , N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] == N , { sum . set (0 , N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/s1if_impl.rs", "verified": true, "metadata": {"original_id": "1f909d4aa1a2", "function_name": "myfun", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_invariant_0f2f1427ef78", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_spec (seq : Seq < i32 >) -> int recommends 0 < seq . len () , decreases seq . len () , { if seq . len () == 1 { seq [0] as int } else if seq . len () == 0 { 0 } else { let later_min = min_spec (seq . drop_first ()) ; if seq [0] <= later_min { seq [0] as int } else { later_min as int } } }\nfn second_smallest (numbers : & Vec < i32 >) -> (indices : (usize , usize)) requires numbers . len () >= 2 , ensures forall | k : int | 0 <= k < numbers . len () && k != indices . 0 && numbers [indices . 0 as int] == min_spec (numbers @ ,) ==> (# [trigger] numbers [k] >= numbers [indices . 1 as int]) , exists | k : int | 0 <= k < numbers . len () && k != indices . 0 && (# [trigger] numbers [k] == numbers [indices . 1 as int]) , { let mut min_idx : usize = 0 ; let mut second_min_idx : usize = 1 ; let mut i = 1 ; while i < numbers . len ()  { if numbers [i] < numbers [min_idx] { min_idx = i ; } i += 1 ; } if min_idx == 0 { second_min_idx = 1 ; } else { second_min_idx = 0 ; } i = 0 ; while i < numbers . len ()  { if i != min_idx && numbers [i] < numbers [second_min_idx] { second_min_idx = i ; } i += 1 ; } (min_idx , second_min_idx) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_spec (seq : Seq < i32 >) -> int recommends 0 < seq . len () , decreases seq . len () , { if seq . len () == 1 { seq [0] as int } else if seq . len () == 0 { 0 } else { let later_min = min_spec (seq . drop_first ()) ; if seq [0] <= later_min { seq [0] as int } else { later_min as int } } }\nfn second_smallest (numbers : & Vec < i32 >) -> (indices : (usize , usize)) requires numbers . len () >= 2 , ensures forall | k : int | 0 <= k < numbers . len () && k != indices . 0 && numbers [indices . 0 as int] == min_spec (numbers @ ,) ==> (# [trigger] numbers [k] >= numbers [indices . 1 as int]) , exists | k : int | 0 <= k < numbers . len () && k != indices . 0 && (# [trigger] numbers [k] == numbers [indices . 1 as int]) , { let mut min_idx : usize = 0 ; let mut second_min_idx : usize = 1 ; let mut i = 1 ; while i < numbers . len () invariant 0 <= min_idx < numbers . len () , 1 <= i <= numbers . len () , forall | j : int | 0 <= j < i ==> numbers [min_idx as int] <= numbers [j] , decreases numbers . len () - i , { if numbers [i] < numbers [min_idx] { min_idx = i ; } i += 1 ; } if min_idx == 0 { second_min_idx = 1 ; } else { second_min_idx = 0 ; } i = 0 ; while i < numbers . len () invariant 0 <= min_idx < numbers . len () , 0 <= second_min_idx < numbers . len () , min_idx != second_min_idx , 0 <= i <= numbers . len () , forall | j : int | 0 <= j < numbers . len () ==> numbers [min_idx as int] <= numbers [j] , forall | j : int | 0 <= j < i && j != min_idx ==> numbers [second_min_idx as int] <= numbers [j] , decreases numbers . len () - i , { if i != min_idx && numbers [i] < numbers [second_min_idx] { second_min_idx = i ; } i += 1 ; } (min_idx , second_min_idx) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_spec (seq : Seq < i32 >) -> int recommends 0 < seq . len () , decreases seq . len () , { if seq . len () == 1 { seq [0] as int } else if seq . len () == 0 { 0 } else { let later_min = min_spec (seq . drop_first ()) ; if seq [0] <= later_min { seq [0] as int } else { later_min as int } } }\nfn second_smallest (numbers : & Vec < i32 >) -> (indices : (usize , usize)) requires numbers . len () >= 2 , ensures forall | k : int | 0 <= k < numbers . len () && k != indices . 0 && numbers [indices . 0 as int] == min_spec (numbers @ ,) ==> (# [trigger] numbers [k] >= numbers [indices . 1 as int]) , exists | k : int | 0 <= k < numbers . len () && k != indices . 0 && (# [trigger] numbers [k] == numbers [indices . 1 as int]) , { let mut min_idx : usize = 0 ; let mut second_min_idx : usize = 1 ; let mut i = 1 ; while i < numbers . len () invariant 0 <= min_idx < numbers . len () , 1 <= i <= numbers . len () , forall | j : int | 0 <= j < i ==> numbers [min_idx as int] <= numbers [j] , decreases numbers . len () - i , { if numbers [i] < numbers [min_idx] { min_idx = i ; } i += 1 ; } if min_idx == 0 { second_min_idx = 1 ; } else { second_min_idx = 0 ; } i = 0 ; while i < numbers . len () invariant 0 <= min_idx < numbers . len () , 0 <= second_min_idx < numbers . len () , min_idx != second_min_idx , 0 <= i <= numbers . len () , forall | j : int | 0 <= j < numbers . len () ==> numbers [min_idx as int] <= numbers [j] , forall | j : int | 0 <= j < i && j != min_idx ==> numbers [second_min_idx as int] <= numbers [j] , decreases numbers . len () - i , { if i != min_idx && numbers [i] < numbers [second_min_idx] { second_min_idx = i ; } i += 1 ; } (min_idx , second_min_idx) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_755_iter_3_current.rs", "verified": true, "metadata": {"original_id": "0f2f1427ef78", "function_name": "second_smallest", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_4b926e5d4b5b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_element (a : & Vec < i32 >) -> (max : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a [i] <= max , exists | i : int | 0 <= i < a . len () && a [i] == max , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 1 <= idx <= a . len () , forall | i : int | 0 <= i < idx ==> a [i] <= max , exists | i : int | 0 <= i < idx && a [i] == max , { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_element (a : & Vec < i32 >) -> (max : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a [i] <= max , exists | i : int | 0 <= i < a . len () && a [i] == max , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 1 <= idx <= a . len () , forall | i : int | 0 <= i < idx ==> a [i] <= max , exists | i : int | 0 <= i < idx && a [i] == max , decreases a . len () - idx { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_element (a : & Vec < i32 >) -> (max : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a [i] <= max , exists | i : int | 0 <= i < a . len () && a [i] == max , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 1 <= idx <= a . len () , forall | i : int | 0 <= i < idx ==> a [i] <= max , exists | i : int | 0 <= i < idx && a [i] == max , decreases a . len () - idx { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/035-max-element_impl.rs", "verified": true, "metadata": {"original_id": "4b926e5d4b5b", "function_name": "max_element", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_4da0545c264f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 ,  { x * 3 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { x * 3 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "4da0545c264f", "function_name": "triple_conditions", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_0c10f306fe6d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_424_iter_2_current.rs", "verified": true, "metadata": {"original_id": "0c10f306fe6d", "function_name": "extract_rear_chars", "bug_type": "missing_decreases"}}
{"id": "task_b_5aff9921717a", "task": "task_b", "input_text": "fn longest_common_prefix (str1 : & Vec < char > , str2 : & Vec < char >) -> (result : Vec < char >)\nrequires longest_common_prefix_precond (str1 @ , str2 @)\nensures longest_common_prefix_postcond (str1 @ , str2 @ , result @)", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_common_prefix_precond (str1 : Seq < char > , str2 : Seq < char >) -> bool { true }\nspec fn longest_common_prefix_postcond (str1 : Seq < char > , str2 : Seq < char > , result : Seq < char >) -> bool { &&& result . len () <= str1 . len () &&& result == str1 . subrange (0 , result . len () as int) &&& result . len () <= str2 . len () &&& result == str2 . subrange (0 , result . len () as int) &&& (result . len () == str1 . len () || result . len () == str2 . len () || (result . len () < str1 . len () && result . len () < str2 . len () && str1 [result . len () as int] != str2 [result . len () as int])) }\nfn longest_common_prefix (str1 : & Vec < char > , str2 : & Vec < char >) -> (result : Vec < char >) requires longest_common_prefix_precond (str1 @ , str2 @) ensures longest_common_prefix_postcond (str1 @ , str2 @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () && i < str2 . len () && str1 [i] == str2 [i] invariant 0 <= i <= str1 . len () , 0 <= i <= str2 . len () , result @ == str1 @ . subrange (0 , i as int) , result @ == str2 @ . subrange (0 , i as int) , forall | j : int | 0 <= j < i ==> str1 @ [j] == str2 @ [j] decreases str1 @ . len () - i { result . push (str1 [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_common_prefix_precond (str1 : Seq < char > , str2 : Seq < char >) -> bool { true }\nspec fn longest_common_prefix_postcond (str1 : Seq < char > , str2 : Seq < char > , result : Seq < char >) -> bool { &&& result . len () <= str1 . len () &&& result == str1 . subrange (0 , result . len () as int) &&& result . len () <= str2 . len () &&& result == str2 . subrange (0 , result . len () as int) &&& (result . len () == str1 . len () || result . len () == str2 . len () || (result . len () < str1 . len () && result . len () < str2 . len () && str1 [result . len () as int] != str2 [result . len () as int])) }\nfn longest_common_prefix (str1 : & Vec < char > , str2 : & Vec < char >) -> (result : Vec < char >) requires longest_common_prefix_precond (str1 @ , str2 @) ensures longest_common_prefix_postcond (str1 @ , str2 @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () && i < str2 . len () && str1 [i] == str2 [i] invariant 0 <= i <= str1 . len () , 0 <= i <= str2 . len () , result @ == str1 @ . subrange (0 , i as int) , result @ == str2 @ . subrange (0 , i as int) , forall | j : int | 0 <= j < i ==> str1 @ [j] == str2 @ [j] decreases str1 @ . len () - i { result . push (str1 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_71/verina_basic_71_impl.rs", "verified": true, "metadata": {"original_id": "5aff9921717a", "function_name": "longest_common_prefix", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_6fe2a4613e65", "task": "task_b", "input_text": "fn single_digit_number_to_char_impl (n : u8) -> (output : char)\nrequires 0 <= n <= 9 \nensures single_digit_number_to_char (n as nat) == output ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 , ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 , ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/015-string_sequence_iter_2_current.rs", "verified": true, "metadata": {"original_id": "6fe2a4613e65", "function_name": "single_digit_number_to_char_impl", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_requires_fee542870c4e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32 , m : i32)  ensures forall | k : int | 0 <= k < N ==> a [k] <= N , { let mut i : usize = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N , decreases a . len () - i { if a [i] > N { a . set (i , N) ; } i = i + 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32 , m : i32) requires N > 0 , old (a) . len () == N , ensures forall | k : int | 0 <= k < N ==> a [k] <= N , { let mut i : usize = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N , decreases a . len () - i { if a [i] > N { a . set (i , N) ; } i = i + 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32 , m : i32) requires N > 0 , old (a) . len () == N , ensures forall | k : int | 0 <= k < N ==> a [k] <= N , { let mut i : usize = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N , decreases a . len () - i { if a [i] > N { a . set (i , N) ; } i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/condn_impl.rs", "verified": true, "metadata": {"original_id": "fee542870c4e", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_243d54a45475", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/brs3_impl.rs", "verified": true, "metadata": {"original_id": "243d54a45475", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_a_b3811a931a4b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >)  { return None ; }\n\n} // verus!", "target_text": "ensures res . is_some () ==> res . unwrap () == x + y ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >) ensures res . is_some () ==> res . unwrap () == x + y , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/HumanEval-RustBench/053-add_iter_0_original.rs", "verified": true, "metadata": {"original_id": "b3811a931a4b", "function_name": "add", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_bd72405ce164", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum [0] = N ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures sum [0] <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= N , { sum [0] = N ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/brs1_impl.rs", "verified": true, "metadata": {"original_id": "bd72405ce164", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_b_7b4e306fcb99", "task": "task_b", "input_text": "fn swap (a : & mut Vec < i32 > , i : usize , j : usize)\nrequires i < old (a) . len () , j < old (a) . len () \nensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_52/verina_basic_52_impl.rs", "verified": true, "metadata": {"original_id": "7b4e306fcb99", "function_name": "swap", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_43fe1daa1d32", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. arr1 . len ()  { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_249_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "43fe1daa1d32", "function_name": "intersection", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_c_missing_ensures_70233d5ac46f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) ,  { let result = arr [k - 1] ; proof { let witness_idx = k as int - 1 ; assert (0 <= witness_idx < arr @ . len ()) by { assert (k >= 1 && k <= arr @ . len ()) ; assert (k as int >= 1) ; assert (k as int - 1 >= 0) ; assert (k as int <= arr @ . len ()) ; assert (k as int - 1 < arr @ . len ()) ; } ; assert (arr @ [witness_idx] == result) ; assert (result as int == arr @ [k as int - 1] as int) ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) , ensures kth_element_postcond (arr @ , k as nat , result as int) , { let result = arr [k - 1] ; proof { let witness_idx = k as int - 1 ; assert (0 <= witness_idx < arr @ . len ()) by { assert (k >= 1 && k <= arr @ . len ()) ; assert (k as int >= 1) ; assert (k as int - 1 >= 0) ; assert (k as int <= arr @ . len ()) ; assert (k as int - 1 < arr @ . len ()) ; } ; assert (arr @ [witness_idx] == result) ; assert (result as int == arr @ [k as int - 1] as int) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) , ensures kth_element_postcond (arr @ , k as nat , result as int) , { let result = arr [k - 1] ; proof { let witness_idx = k as int - 1 ; assert (0 <= witness_idx < arr @ . len ()) by { assert (k >= 1 && k <= arr @ . len ()) ; assert (k as int >= 1) ; assert (k as int - 1 >= 0) ; assert (k as int <= arr @ . len ()) ; assert (k as int - 1 < arr @ . len ()) ; } ; assert (arr @ [witness_idx] == result) ; assert (result as int == arr @ [k as int - 1] as int) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_4/verina_basic_4_impl.rs", "verified": true, "metadata": {"original_id": "70233d5ac46f", "function_name": "kth_element", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_4586f8902d83", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 ,  { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Diffy/verified/s52if_impl.rs", "verified": true, "metadata": {"original_id": "4586f8902d83", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_305d04ab1d29", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000  { (a + b) / 2 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_avg/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "305d04ab1d29", "function_name": "compute_avg", "bug_type": "missing_ensures"}}
{"id": "task_b_352fd7cf6f7e", "task": "task_b", "input_text": "fn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize)\nrequires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] \nensures r < v . len () , k == v [r as int] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop invariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases high - low { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop invariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases high - low { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/binary_search_iter_2_current.rs", "verified": true, "metadata": {"original_id": "352fd7cf6f7e", "function_name": "binary_search", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_invariant_5d39fa8616fb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; for i in 0 .. arr . len ()  { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_251_iter_1_current.rs", "verified": true, "metadata": {"original_id": "5d39fa8616fb", "function_name": "insert_before_each", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_699aeebfbb04", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases a . len () - i { a . set (i , N) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases a . len () - i { a . set (i , N) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases a . len () - i { a . set (i , N) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/sina1_impl.rs", "verified": true, "metadata": {"original_id": "699aeebfbb04", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_b_4562143ddd22", "task": "task_b", "input_text": "fn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)\nrequires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len ()", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/unverified/choose_odd.rs", "verified": true, "metadata": {"original_id": "4562143ddd22", "function_name": "choose_odd", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_ba2b93e9b86f", "task": "task_b", "input_text": "pub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)\nrequires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Diffy/unverified/res2o_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ba2b93e9b86f", "function_name": "myfun", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_ca4fd00d9375", "task": "task_b", "input_text": "fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool)\nrequires i != MIN , threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX\nensures i < 0 ==> res == - i , i >= 0 ==> res == i, flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0usize ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold decreases numbers . len () - i { let mut j = 0usize ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0usize ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold decreases numbers . len () - i { let mut j = 0usize ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/has_close_elements_impl.rs", "verified": true, "metadata": {"original_id": "ca4fd00d9375", "function_name": "has_close_elements", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_invariant_86054ae2b654", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/remove_duplicates_iter_1_current.rs", "verified": true, "metadata": {"original_id": "86054ae2b654", "function_name": "remove_duplicates", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_f7e30aac2398", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool) requires a . len () > 0  { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> n > a [j] { if n <= a [i] { return false ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool) requires a . len () > 0 ensures result <==> (forall | i : int | 0 <= i < a . len () ==> n > a [i]) { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> n > a [j] { if n <= a [i] { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool) requires a . len () > 0 ensures result <==> (forall | i : int | 0 <= i < a . len () ==> n > a [i]) { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> n > a [j] { if n <= a [i] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_10/verina_basic_10_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "f7e30aac2398", "function_name": "is_greater", "bug_type": "missing_ensures"}}
{"id": "task_b_c52c4e10370a", "task": "task_b", "input_text": "fn barrier (arr : & [i32] , p : usize) -> (result : bool)\nrequires arr . len () > 0 , 0 <= p < arr . len () \nensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut k : usize = 0 ; while k <= p invariant 0 <= k <= p + 1 , forall | k2 : int , l : int | 0 <= k2 < k && p < l < arr . len () ==> arr [k2] < arr [l] , decreases p + 1 - k { let mut l : usize = p + 1 ; while l < arr . len () invariant p + 1 <= l <= arr . len () , forall | l2 : int | p < l2 < l ==> arr [k as int] < arr [l2] , forall | k2 : int , l2 : int | 0 <= k2 < k && p < l2 < arr . len () ==> arr [k2] < arr [l2] , decreases arr . len () - l { if arr [k] >= arr [l] { return false ; } l += 1 ; } k += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut k : usize = 0 ; while k <= p invariant 0 <= k <= p + 1 , forall | k2 : int , l : int | 0 <= k2 < k && p < l < arr . len () ==> arr [k2] < arr [l] , decreases p + 1 - k { let mut l : usize = p + 1 ; while l < arr . len () invariant p + 1 <= l <= arr . len () , forall | l2 : int | p < l2 < l ==> arr [k as int] < arr [l2] , forall | k2 : int , l2 : int | 0 <= k2 < k && p < l2 < arr . len () ==> arr [k2] < arr [l2] , decreases arr . len () - l { if arr [k] >= arr [l] { return false ; } l += 1 ; } k += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/barrier_iter_3_current.rs", "verified": true, "metadata": {"original_id": "c52c4e10370a", "function_name": "barrier", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_requires_ffe96f793371", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] == 5 * N , { sum . set (0 , 5 * N) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , 5 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , 5 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s4lif_impl.rs", "verified": true, "metadata": {"original_id": "ffe96f793371", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_b_1b206db906d0", "task": "task_b", "input_text": "pub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize)\nrequires old (a) . len () == N , old (sum) . len () == 1 , N > 0 \nensures sum [0] <= N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/ms2_impl.rs", "verified": true, "metadata": {"original_id": "1b206db906d0", "function_name": "myfun", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_requires_5ba740165f1a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)  ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut k : usize = 0 ; while k <= p invariant 0 <= k <= p + 1 , forall | k2 : int , l : int | 0 <= k2 < k && p < l < arr . len () ==> arr [k2] < arr [l] , decreases p + 1 - k { let mut l : usize = p + 1 ; while l < arr . len () invariant p + 1 <= l <= arr . len () , forall | l2 : int | p < l2 < l ==> arr [k as int] < arr [l2] , forall | k2 : int , l2 : int | 0 <= k2 < k && p < l2 < arr . len () ==> arr [k2] < arr [l2] , decreases arr . len () - l { if arr [k] >= arr [l] { return false ; } l += 1 ; } k += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut k : usize = 0 ; while k <= p invariant 0 <= k <= p + 1 , forall | k2 : int , l : int | 0 <= k2 < k && p < l < arr . len () ==> arr [k2] < arr [l] , decreases p + 1 - k { let mut l : usize = p + 1 ; while l < arr . len () invariant p + 1 <= l <= arr . len () , forall | l2 : int | p < l2 < l ==> arr [k as int] < arr [l2] , forall | k2 : int , l2 : int | 0 <= k2 < k && p < l2 < arr . len () ==> arr [k2] < arr [l2] , decreases arr . len () - l { if arr [k] >= arr [l] { return false ; } l += 1 ; } k += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut k : usize = 0 ; while k <= p invariant 0 <= k <= p + 1 , forall | k2 : int , l : int | 0 <= k2 < k && p < l < arr . len () ==> arr [k2] < arr [l] , decreases p + 1 - k { let mut l : usize = p + 1 ; while l < arr . len () invariant p + 1 <= l <= arr . len () , forall | l2 : int | p < l2 < l ==> arr [k as int] < arr [l2] , forall | k2 : int , l2 : int | 0 <= k2 < k && p < l2 < arr . len () ==> arr [k2] < arr [l2] , decreases arr . len () - l { if arr [k] >= arr [l] { return false ; } l += 1 ; } k += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/barrier_impl.rs", "verified": true, "metadata": {"original_id": "5ba740165f1a", "function_name": "barrier", "bug_type": "missing_requires"}}
{"id": "task_b_3b2fd06c1aa9", "task": "task_b", "input_text": "fn longest_increasing_subsequence (nums : Vec < i32 >) -> (result : i32)\nrequires longest_increasing_subsequence_precond (nums @) , nums . len () <= MAX\nensures longest_increasing_subsequence_postcond (nums @ , result)", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_precond (nums : Seq < i32 >) -> bool { true }\nspec fn longest_increasing_subsequence_postcond (nums : Seq < i32 > , result : i32) -> bool { 0 <= result <= nums . len () }\nfn longest_increasing_subsequence (nums : Vec < i32 >) -> (result : i32) requires longest_increasing_subsequence_precond (nums @) , nums . len () <= MAX ensures longest_increasing_subsequence_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_precond (nums : Seq < i32 >) -> bool { true }\nspec fn longest_increasing_subsequence_postcond (nums : Seq < i32 > , result : i32) -> bool { 0 <= result <= nums . len () }\nfn longest_increasing_subsequence (nums : Vec < i32 >) -> (result : i32) requires longest_increasing_subsequence_precond (nums @) , nums . len () <= MAX ensures longest_increasing_subsequence_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_34/verina_advanced_34_iter_0_original.rs", "verified": true, "metadata": {"original_id": "3b2fd06c1aa9", "function_name": "longest_increasing_subsequence", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_invariant_b2f06b5278a0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len ()  { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len () invariant s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= i <= s1 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result @ [3 * j] == s1 @ [j] && result @ [3 * j + 1] == s2 @ [j] && result @ [3 * j + 2] == s3 @ [j]) , decreases s1 @ . len () - i { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len () invariant s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= i <= s1 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result @ [3 * j] == s1 @ [j] && result @ [3 * j + 1] == s2 @ [j] && result @ [3 * j + 2] == s3 @ [j]) , decreases s1 @ . len () - i { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_578_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b2f06b5278a0", "function_name": "interleave", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_1b6ca1d9ff6b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/remove_elements_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "1b6ca1d9ff6b", "function_name": "in_array_exec", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_fa22a39ad343", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1  { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] , decreases arr . len () - 1 - idx { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] , decreases arr . len () - 1 - idx { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_567_impl.rs", "verified": true, "metadata": {"original_id": "fa22a39ad343", "function_name": "is_sorted", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_583c089d4d04", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) { proof { assert (exists | k : int | 0 <= k < arr2 . len () && arr2 [k] == arr1 [i as int]) ; assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (exists | k : int | 0 <= k < arr2 . len () && arr2 [k] == arr1 [i as int]) ; assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (exists | k : int | 0 <= k < arr2 . len () && arr2 [k] == arr1 [i as int]) ; assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_414_iter_3_current.rs", "verified": true, "metadata": {"original_id": "583c089d4d04", "function_name": "any_value_exists", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_ec3952de258a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 ,  { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/brs1_impl.rs", "verified": true, "metadata": {"original_id": "ec3952de258a", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_4b07a583ad56", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32)  ensures k_out >= 0 , { k }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 , ensures k_out >= 0 , { k }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "4b07a583ad56", "function_name": "compute_k", "bug_type": "missing_requires"}}
{"id": "task_a_ed3f59736a95", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn search (lst : & Vec < usize > , start_idx : usize , n : usize) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires start_idx <= lst . len () \ndecreases lst . len () - start_idx", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn search (lst : & Vec < usize > , start_idx : usize , n : usize) -> (result : usize) requires start_idx <= lst . len () , decreases lst . len () - start_idx { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_73/verina_advanced_73_iter_0_original.rs", "verified": true, "metadata": {"original_id": "ed3f59736a95", "function_name": "search", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_c_missing_requires_cc4d8d29f131", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32)  ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_avg/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "cc4d8d29f131", "function_name": "compute_avg", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_016fa353e019", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF ,  { 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/unverified/cell_2_sum_impl.rs", "verified": true, "metadata": {"original_id": "016fa353e019", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_80ac35f4ccfb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn trap_rain_water_postcond (height : Seq < u32 > , result : u32 , h_precond : bool) -> bool { result >= 0 && (height . len () == 0 ==> result == 0) && (height . len () == 1 ==> result == 0) }\nspec fn trap_rain_water_precond (height : Seq < u32 >) -> bool { true }\nfn trap_rain_water (height : Vec < u32 >) -> (result : u32)  ensures trap_rain_water_postcond (height @ , result , trap_rain_water_precond (height @)) { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn trap_rain_water_postcond (height : Seq < u32 > , result : u32 , h_precond : bool) -> bool { result >= 0 && (height . len () == 0 ==> result == 0) && (height . len () == 1 ==> result == 0) }\nspec fn trap_rain_water_precond (height : Seq < u32 >) -> bool { true }\nfn trap_rain_water (height : Vec < u32 >) -> (result : u32) requires trap_rain_water_precond (height @) ensures trap_rain_water_postcond (height @ , result , trap_rain_water_precond (height @)) { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn trap_rain_water_postcond (height : Seq < u32 > , result : u32 , h_precond : bool) -> bool { result >= 0 && (height . len () == 0 ==> result == 0) && (height . len () == 1 ==> result == 0) }\nspec fn trap_rain_water_precond (height : Seq < u32 >) -> bool { true }\nfn trap_rain_water (height : Vec < u32 >) -> (result : u32) requires trap_rain_water_precond (height @) ensures trap_rain_water_postcond (height @ , result , trap_rain_water_precond (height @)) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_77/verina_advanced_77_iter_0_original.rs", "verified": true, "metadata": {"original_id": "80ac35f4ccfb", "function_name": "trap_rain_water", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_verus_imo_1988_6_f8ab3b9c8f41", "task": "task_c", "input_text": "#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n\n// IMO 1988, #6.\n// Let a and b be positive integers such that (a^2 + b^2) / (ab + 1) is an integer.\n// Prove that it is a perfect square.\n//\n// This is a classic example of \"vieta jumping\". It makes a decent exercise\n// utilizing nonlinear arithmetic in Verus.\n// Closely following the solution given here:\n//    https://en.wikipedia.org/wiki/Vieta_jumping#Geometric_interpretation\n\nverus! {\n\nproof fn vieta_jump(b: int, c: int, x: int)\n    by (nonlinear_arith)\n\n    ensures\n        ({\n            let y = b - x;\n            y * y - b * y + c == 0 && y * x == c\n        }),\n{\n}\n\nproof fn sqrt2_contradiction(a: int)\n\n    ensures\n        false,\n{\n    assert(a * a == 2 ==> false) by (nonlinear_arith);\n}\n\nproof fn is_perfect_square_wlog(a: int, b: int, q: int) -> (sqrt: int)\n\n    ensures\n        sqrt * sqrt == q,\n    decreases a + b, 0int,\n{\n    if a == 0 {\n        assert(a * a == 0);\n        assert(a * b == 0);\n        return b;\n    } else {\n        assert(b * b - (q * a) * b + (a * a - q) == 0) by {\n            assert((a * b + 1) * q == (a * b) * q + q) by (nonlinear_arith);\n            assert((a * b) * q == (q * a) * b) by (nonlinear_arith);\n        }\n        vieta_jump(q * a, a * a - q, b);\n        let b1 = q * a - b;\n        assert(b1 * b1 - (q * a) * b1 + (a * a - q) == 0);\n        assert(a * a + b1 * b1 == (a * b1 + 1) * q) by {\n            assert((a * b1 + 1) * q == (a * b1) * q + q) by (nonlinear_arith);\n            assert((a * b1) * q == (q * a) * b1) by (nonlinear_arith);\n        }\n        assert(b1 < b) by {\n            assert(a > 0);\n            assert(b1 * b == a * a - q);\n            assert(b1 <= a) by {\n                assert(a >= 0 && b >= 0 && b1 > a && b > a ==> b1 * b >= a * a)\n                    by (nonlinear_arith);\n            }\n        }\n        assert(b1 >= 0) by {\n            assert(a * a + b1 * b1 == (a * b1 + 1) * q && a >= 1 && q > 2 ==> a * b1 + 1 > 0)\n                by (nonlinear_arith);\n            assert(a * b1 + 1 > 0 && a > 0 ==> b1 >= 0) by (nonlinear_arith);\n        }\n        return is_perfect_square(a, b1, q);\n    }\n}\n\n// Main result\nproof fn is_perfect_square(a: int, b: int, q: int) -> (sqrt: int)\n\n    ensures\n        sqrt * sqrt == q,\n    decreases a + b, 1int,\n{\n    if q < 0 {\n        assert(a >= 0 && b >= 0 && a * a + b * b == (a * b + 1) * q ==> q >= 0)\n            by (nonlinear_arith);\n        assert(false);\n        return 0;\n    } else if q == 0 {\n        return 0;\n    } else if q == 1 {\n        return 1;\n    } else if q == 2 {\n        assert((a - b) * (a - b) == 2) by (nonlinear_arith)\n            requires\n                a * a + b * b == (a * b + 1) * 2,\n        ;\n        sqrt2_contradiction(a - b);\n        return 0;\n    } else {\n        assert(q > 2);\n        if a == b {\n            assert(2 * a * a == a * a + a * a) by (nonlinear_arith);\n            assert(q > 2 ==> (a * a + 1) * q >= (a * a + 1) * 2) by (nonlinear_arith);\n            assert(false);\n            return 0;\n        } else if a < b {\n            return is_perfect_square_wlog(a, b, q);\n        } else {\n            assert(a > b);\n            return is_perfect_square_wlog(b, a, q);\n        }\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n\n// IMO 1988, #6.\n// Let a and b be positive integers such that (a^2 + b^2) / (ab + 1) is an integer.\n// Prove that it is a perfect square.\n//\n// This is a classic example of \"vieta jumping\". It makes a decent exercise\n// utilizing nonlinear arithmetic in Verus.\n// Closely following the solution given here:\n//    https://en.wikipedia.org/wiki/Vieta_jumping#Geometric_interpretation\n\nverus! {\n\nproof fn vieta_jump(b: int, c: int, x: int)\n    by (nonlinear_arith)\n    requires\n        x * x - b * x + c == 0,\n    ensures\n        ({\n            let y = b - x;\n            y * y - b * y + c == 0 && y * x == c\n        }),\n{\n}\n\nproof fn sqrt2_contradiction(a: int)\n    requires\n        a * a == 2,\n    ensures\n        false,\n{\n    assert(a * a == 2 ==> false) by (nonlinear_arith);\n}\n\nproof fn is_perfect_square_wlog(a: int, b: int, q: int) -> (sqrt: int)\n    requires\n        a >= 0,\n        b >= 0,\n        a * a + b * b == (a * b + 1) * q,\n        q > 2,\n        a < b,\n    ensures\n        sqrt * sqrt == q,\n    decreases a + b, 0int,\n{\n    if a == 0 {\n        assert(a * a == 0);\n        assert(a * b == 0);\n        return b;\n    } else {\n        assert(b * b - (q * a) * b + (a * a - q) == 0) by {\n            assert((a * b + 1) * q == (a * b) * q + q) by (nonlinear_arith);\n            assert((a * b) * q == (q * a) * b) by (nonlinear_arith);\n        }\n        vieta_jump(q * a, a * a - q, b);\n        let b1 = q * a - b;\n        assert(b1 * b1 - (q * a) * b1 + (a * a - q) == 0);\n        assert(a * a + b1 * b1 == (a * b1 + 1) * q) by {\n            assert((a * b1 + 1) * q == (a * b1) * q + q) by (nonlinear_arith);\n            assert((a * b1) * q == (q * a) * b1) by (nonlinear_arith);\n        }\n        assert(b1 < b) by {\n            assert(a > 0);\n            assert(b1 * b == a * a - q);\n            assert(b1 <= a) by {\n                assert(a >= 0 && b >= 0 && b1 > a && b > a ==> b1 * b >= a * a)\n                    by (nonlinear_arith);\n            }\n        }\n        assert(b1 >= 0) by {\n            assert(a * a + b1 * b1 == (a * b1 + 1) * q && a >= 1 && q > 2 ==> a * b1 + 1 > 0)\n                by (nonlinear_arith);\n            assert(a * b1 + 1 > 0 && a > 0 ==> b1 >= 0) by (nonlinear_arith);\n        }\n        return is_perfect_square(a, b1, q);\n    }\n}\n\n// Main result\nproof fn is_perfect_square(a: int, b: int, q: int) -> (sqrt: int)\n    requires\n        a >= 0,\n        b >= 0,\n        a * a + b * b == (a * b + 1) * q,\n    ensures\n        sqrt * sqrt == q,\n    decreases a + b, 1int,\n{\n    if q < 0 {\n        assert(a >= 0 && b >= 0 && a * a + b * b == (a * b + 1) * q ==> q >= 0)\n            by (nonlinear_arith);\n        assert(false);\n        return 0;\n    } else if q == 0 {\n        return 0;\n    } else if q == 1 {\n        return 1;\n    } else if q == 2 {\n        assert((a - b) * (a - b) == 2) by (nonlinear_arith)\n            requires\n                a * a + b * b == (a * b + 1) * 2,\n        ;\n        sqrt2_contradiction(a - b);\n        return 0;\n    } else {\n        assert(q > 2);\n        if a == b {\n            assert(2 * a * a == a * a + a * a) by (nonlinear_arith);\n            assert(q > 2 ==> (a * a + 1) * q >= (a * a + 1) * 2) by (nonlinear_arith);\n            assert(false);\n            return 0;\n        } else if a < b {\n            return is_perfect_square_wlog(a, b, q);\n        } else {\n            assert(a > b);\n            return is_perfect_square_wlog(b, a, q);\n        }\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n\n// IMO 1988, #6.\n// Let a and b be positive integers such that (a^2 + b^2) / (ab + 1) is an integer.\n// Prove that it is a perfect square.\n//\n// This is a classic example of \"vieta jumping\". It makes a decent exercise\n// utilizing nonlinear arithmetic in Verus.\n// Closely following the solution given here:\n//    https://en.wikipedia.org/wiki/Vieta_jumping#Geometric_interpretation\n\nverus! {\n\nproof fn vieta_jump(b: int, c: int, x: int)\n    by (nonlinear_arith)\n    requires\n        x * x - b * x + c == 0,\n    ensures\n        ({\n            let y = b - x;\n            y * y - b * y + c == 0 && y * x == c\n        }),\n{\n}\n\nproof fn sqrt2_contradiction(a: int)\n    requires\n        a * a == 2,\n    ensures\n        false,\n{\n    assert(a * a == 2 ==> false) by (nonlinear_arith);\n}\n\nproof fn is_perfect_square_wlog(a: int, b: int, q: int) -> (sqrt: int)\n    requires\n        a >= 0,\n        b >= 0,\n        a * a + b * b == (a * b + 1) * q,\n        q > 2,\n        a < b,\n    ensures\n        sqrt * sqrt == q,\n    decreases a + b, 0int,\n{\n    if a == 0 {\n        assert(a * a == 0);\n        assert(a * b == 0);\n        return b;\n    } else {\n        assert(b * b - (q * a) * b + (a * a - q) == 0) by {\n            assert((a * b + 1) * q == (a * b) * q + q) by (nonlinear_arith);\n            assert((a * b) * q == (q * a) * b) by (nonlinear_arith);\n        }\n        vieta_jump(q * a, a * a - q, b);\n        let b1 = q * a - b;\n        assert(b1 * b1 - (q * a) * b1 + (a * a - q) == 0);\n        assert(a * a + b1 * b1 == (a * b1 + 1) * q) by {\n            assert((a * b1 + 1) * q == (a * b1) * q + q) by (nonlinear_arith);\n            assert((a * b1) * q == (q * a) * b1) by (nonlinear_arith);\n        }\n        assert(b1 < b) by {\n            assert(a > 0);\n            assert(b1 * b == a * a - q);\n            assert(b1 <= a) by {\n                assert(a >= 0 && b >= 0 && b1 > a && b > a ==> b1 * b >= a * a)\n                    by (nonlinear_arith);\n            }\n        }\n        assert(b1 >= 0) by {\n            assert(a * a + b1 * b1 == (a * b1 + 1) * q && a >= 1 && q > 2 ==> a * b1 + 1 > 0)\n                by (nonlinear_arith);\n            assert(a * b1 + 1 > 0 && a > 0 ==> b1 >= 0) by (nonlinear_arith);\n        }\n        return is_perfect_square(a, b1, q);\n    }\n}\n\n// Main result\nproof fn is_perfect_square(a: int, b: int, q: int) -> (sqrt: int)\n    requires\n        a >= 0,\n        b >= 0,\n        a * a + b * b == (a * b + 1) * q,\n    ensures\n        sqrt * sqrt == q,\n    decreases a + b, 1int,\n{\n    if q < 0 {\n        assert(a >= 0 && b >= 0 && a * a + b * b == (a * b + 1) * q ==> q >= 0)\n            by (nonlinear_arith);\n        assert(false);\n        return 0;\n    } else if q == 0 {\n        return 0;\n    } else if q == 1 {\n        return 1;\n    } else if q == 2 {\n        assert((a - b) * (a - b) == 2) by (nonlinear_arith)\n            requires\n                a * a + b * b == (a * b + 1) * 2,\n        ;\n        sqrt2_contradiction(a - b);\n        return 0;\n    } else {\n        assert(q > 2);\n        if a == b {\n            assert(2 * a * a == a * a + a * a) by (nonlinear_arith);\n            assert(q > 2 ==> (a * a + 1) * q >= (a * a + 1) * 2) by (nonlinear_arith);\n            assert(false);\n            return 0;\n        } else if a < b {\n            return is_perfect_square_wlog(a, b, q);\n        } else {\n            assert(a > b);\n            return is_perfect_square_wlog(b, a, q);\n        }\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/imo_1988_6.rs", "verified": true, "metadata": {"original_id": "verus_imo_1988_6_f8ab3b9c8f41", "function_name": "", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_c9556ae06624", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32)  { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i = i + 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i = i + 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/replace_impl.rs", "verified": true, "metadata": {"original_id": "c9556ae06624", "function_name": "replace", "bug_type": "missing_ensures"}}
{"id": "task_b_c64127304c51", "task": "task_b", "input_text": "fn m1 (x : i32 , y : i32) -> (z : i32)\nrequires 0 < x < y \nensures z >= 0 && z <= y && z != x ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn m1 (x : i32 , y : i32) -> (z : i32) requires 0 < x < y , ensures z >= 0 && z <= y && z != x , { 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn m1 (x : i32 , y : i32) -> (z : i32) requires 0 < x < y , ensures z >= 0 && z <= y && z != x , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "c64127304c51", "function_name": "m1", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_invariant_0306fe9a5801", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn selection_sort (a : & mut Vec < int >) ensures a . len () == old (a) . len () , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , { let len = a . len () ; let mut i : usize = 0 ; while i < len  { let mut min_idx : usize = i ; let mut j : usize = i + 1 ; while j < len  { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn selection_sort (a : & mut Vec < int >) ensures a . len () == old (a) . len () , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , { let len = a . len () ; let mut i : usize = 0 ; while i < len invariant i <= len , a . len () == len , forall | x : int , y : int | 0 <= x < y < i ==> a [x] <= a [y] , forall | x : int , y : int | 0 <= x < i && i <= y < len ==> a [x] <= a [y] , decreases len - i { let mut min_idx : usize = i ; let mut j : usize = i + 1 ; while j < len invariant i <= min_idx < len , i <= j <= len , a . len () == len , forall | k : int | i <= k < j ==> a [min_idx as int] <= a [k] , decreases len - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn selection_sort (a : & mut Vec < int >) ensures a . len () == old (a) . len () , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , { let len = a . len () ; let mut i : usize = 0 ; while i < len invariant i <= len , a . len () == len , forall | x : int , y : int | 0 <= x < y < i ==> a [x] <= a [y] , forall | x : int , y : int | 0 <= x < i && i <= y < len ==> a [x] <= a [y] , decreases len - i { let mut min_idx : usize = i ; let mut j : usize = i + 1 ; while j < len invariant i <= min_idx < len , i <= j <= len , a . len () == len , forall | k : int | i <= k < j ==> a [min_idx as int] <= a [k] , decreases len - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_selectionsort/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "0306fe9a5801", "function_name": "selection_sort", "bug_type": "missing_invariant"}}
{"id": "task_a_43adf6cc9347", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = a . len () ; while i > 0  { i = i - 1 ; result . push (a [i]) ; } result }\n\n} // verus!", "target_text": "ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] \ndecreases i\ninvariant result . len () == a . len () - i , forall | j : int | 0 <= j && j < result . len () ==> result [j] == a [a . len () - 1 - j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut i = a . len () ; while i > 0 invariant result . len () == a . len () - i , forall | j : int | 0 <= j && j < result . len () ==> result [j] == a [a . len () - 1 - j] , decreases i { i = i - 1 ; result . push (a [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/reverse_impl.rs", "verified": true, "metadata": {"original_id": "43adf6cc9347", "function_name": "reverse", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_requires_17cf6cd3a3c8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)  { }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/unverified/havoc_inline_post_impl.rs", "verified": true, "metadata": {"original_id": "17cf6cd3a3c8", "function_name": "havoc_inline_post", "bug_type": "missing_requires"}}
{"id": "task_c_missing_assert_0cd632baea02", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - idx {  if arr1 [idx] <= arr2 [idx] { return false ; } idx = idx + 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - idx { assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { return false ; } idx = idx + 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - idx { assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { return false ; } idx = idx + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_809_impl.rs", "verified": true, "metadata": {"original_id": "0cd632baea02", "function_name": "is_smaller", "bug_type": "missing_assert"}}
{"id": "task_c_missing_invariant_d2dfd0f1cbe2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) , { let mut result = Vec :: new () ; let mut i = n ; while i > 0  { i -= 1 ; result . push (list [i]) ; } let mut j = n ; while j < list . len ()  { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) , { let mut result = Vec :: new () ; let mut i = n ; while i > 0 invariant 0 <= i <= n , n < list @ . len () , result @ . len () == n - i , forall | j : int | 0 <= j < result @ . len () ==> result @ [j] == list @ [n - 1 - j] , decreases i { i -= 1 ; result . push (list [i]) ; } let mut j = n ; while j < list . len () invariant n <= j <= list @ . len () , result @ . len () == n + (j - n) , forall | k : int | 0 <= k < n ==> result @ [k] == list @ [n - 1 - k] , forall | k : int | n <= k < result @ . len () ==> result @ [k] == list @ [n + (k - n)] , decreases list @ . len () - j { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) , { let mut result = Vec :: new () ; let mut i = n ; while i > 0 invariant 0 <= i <= n , n < list @ . len () , result @ . len () == n - i , forall | j : int | 0 <= j < result @ . len () ==> result @ [j] == list @ [n - 1 - j] , decreases i { i -= 1 ; result . push (list [i]) ; } let mut j = n ; while j < list . len () invariant n <= j <= list @ . len () , result @ . len () == n + (j - n) , forall | k : int | 0 <= k < n ==> result @ [k] == list @ [n - 1 - k] , forall | k : int | n <= k < result @ . len () ==> result @ [k] == list @ [n + (k - n)] , decreases list @ . len () - j { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_644_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d2dfd0f1cbe2", "function_name": "reverse_to_k", "bug_type": "missing_invariant"}}
{"id": "task_b_d13e9b30a13d", "task": "task_b", "input_text": "fn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize)\nrequires s1 . len () == s2 . len () == s3 . len () , 0 <= i < s1 . len () , arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () \nensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + (if s1 [i] == s2 [i] && s2 [i] == s3 [i], 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_extend (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + (if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int }) , decreases i , { let sub1 = s1 . subrange (0 , i + 1) ; let sub2 = s2 . subrange (0 , i + 1) ; let sub3 = s3 . subrange (0 , i + 1) ; assert (sub1 . last () == s1 [i]) ; assert (sub2 . last () == s2 [i]) ; assert (sub3 . last () == s3 [i]) ; assert (sub1 . drop_last () == s1 . subrange (0 , i)) ; assert (sub2 . drop_last () == s2 . subrange (0 , i)) ; assert (sub3 . drop_last () == s3 . subrange (0 , i)) ; assert (count_identical (sub1 , sub2 , sub3) == count_identical (sub1 . drop_last () , sub2 . drop_last () , sub3 . drop_last ()) + (if sub1 . last () == sub2 . last () && sub2 . last () == sub3 . last () { 1int } else { 0int })) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , 0 <= count <= i , arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i , { proof { lemma_count_identical_extend (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count = count + 1 ; } i = i + 1 ; } assert (i == arr1 . len ()) ; assert (arr1 @ . subrange (0 , i as int) == arr1 @) ; assert (arr2 @ . subrange (0 , i as int) == arr2 @) ; assert (arr3 @ . subrange (0 , i as int) == arr3 @) ; count }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_extend (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + (if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int }) , decreases i , { let sub1 = s1 . subrange (0 , i + 1) ; let sub2 = s2 . subrange (0 , i + 1) ; let sub3 = s3 . subrange (0 , i + 1) ; assert (sub1 . last () == s1 [i]) ; assert (sub2 . last () == s2 [i]) ; assert (sub3 . last () == s3 [i]) ; assert (sub1 . drop_last () == s1 . subrange (0 , i)) ; assert (sub2 . drop_last () == s2 . subrange (0 , i)) ; assert (sub3 . drop_last () == s3 . subrange (0 , i)) ; assert (count_identical (sub1 , sub2 , sub3) == count_identical (sub1 . drop_last () , sub2 . drop_last () , sub3 . drop_last ()) + (if sub1 . last () == sub2 . last () && sub2 . last () == sub3 . last () { 1int } else { 0int })) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , 0 <= count <= i , arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i , { proof { lemma_count_identical_extend (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count = count + 1 ; } i = i + 1 ; } assert (i == arr1 . len ()) ; assert (arr1 @ . subrange (0 , i as int) == arr1 @) ; assert (arr2 @ . subrange (0 , i as int) == arr2 @) ; assert (arr3 @ . subrange (0 , i as int) == arr3 @) ; count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_142_impl.rs", "verified": true, "metadata": {"original_id": "d13e9b30a13d", "function_name": "count_identical_position", "has_invariants": true, "has_asserts": true}}
{"id": "task_a_51851ecb2982", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >)  { idx < arr . len () && arr @ [idx as int] % 2 == 1 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len ()  { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "target_text": "ensures if let Some (idx) = index\ndecreases arr . len () - index \ninvariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures if let Some (idx) = index { idx < arr . len () && arr @ [idx as int] % 2 == 1 && forall | k : int | 0 <= k < idx as int ==> (arr @ [k] % 2 == 0) } else { forall | k : int | 0 <= k < arr . len () ==> (arr @ [k] % 2 == 0) } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index as int ==> (arr @ [k] % 2 == 0) , decreases arr . len () - index , { if arr [index] % 2 != 0 { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_807_iter_4_current.rs", "verified": true, "metadata": {"original_id": "51851ecb2982", "function_name": "find_first_odd", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_ensures_f7de326d8817", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/array_copy_impl.rs", "verified": true, "metadata": {"original_id": "f7de326d8817", "function_name": "array_copy", "bug_type": "missing_ensures"}}
{"id": "task_b_c19ba825f92e", "task": "task_b", "input_text": "fn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >)\nensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx , { let new_char = if str1 [idx] == ' ' { ch } else { str1 [idx] } ; result . push (new_char) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx , { let new_char = if str1 [idx] == ' ' { ch } else { str1 [idx] } ; result . push (new_char) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_230_iter_3_current.rs", "verified": true, "metadata": {"original_id": "c19ba825f92e", "function_name": "replace_blanks_with_chars", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_requires_d196e324da0e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)  ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)  ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)  ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >)  ensures result . len () == a . len () , { let mut result = a ; if result . len () >= 2 { let len = result . len () ; bubble_outer (& mut result , len - 2) ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >) requires bubble_sort_precond (a @) , ensures result . len () == a . len () , { let mut result = a ; if result . len () >= 2 { let len = result . len () ; bubble_outer (& mut result , len - 2) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >) requires bubble_sort_precond (a @) , ensures result . len () == a . len () , { let mut result = a ; if result . len () >= 2 { let len = result . len () ; bubble_outer (& mut result , len - 2) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d196e324da0e", "function_name": "bubble_sort", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_fd74f839e512", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut last_pos = 0 ; let mut found = false ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , found ==> (0 <= last_pos < i && a [last_pos as int] == elem) , found ==> forall | j : int | last_pos < j < i ==> a [j] != elem , found <==> exists | j : int | 0 <= j < i && a [j] == elem , { if a [i] == elem { last_pos = i ; found = true ; } i += 1 ; } last_pos }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut last_pos = 0 ; let mut found = false ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , found ==> (0 <= last_pos < i && a [last_pos as int] == elem) , found ==> forall | j : int | last_pos < j < i ==> a [j] != elem , found <==> exists | j : int | 0 <= j < i && a [j] == elem , decreases a . len () - i { if a [i] == elem { last_pos = i ; found = true ; } i += 1 ; } last_pos }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut last_pos = 0 ; let mut found = false ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , found ==> (0 <= last_pos < i && a [last_pos as int] == elem) , found ==> forall | j : int | last_pos < j < i ==> a [j] != elem , found <==> exists | j : int | 0 <= j < i && a [j] == elem , decreases a . len () - i { if a [i] == elem { last_pos = i ; found = true ; } i += 1 ; } last_pos }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/last_position_impl.rs", "verified": true, "metadata": {"original_id": "fd74f839e512", "function_name": "last_position", "bug_type": "missing_decreases"}}
{"id": "task_b_3aa4fc4de8e2", "task": "task_b", "input_text": "fn max_strength (nums : Vec < i64 >) -> (result : i64)\nrequires max_strength_precond (nums @)\nensures max_strength_postcond (nums @ , result)", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_43/verina_advanced_43.rs", "verified": true, "metadata": {"original_id": "3aa4fc4de8e2", "function_name": "max_strength", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_requires_ba3b88d6691c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32)  ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/has_close_elements_impl.rs", "verified": true, "metadata": {"original_id": "ba3b88d6691c", "function_name": "abs", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_2d2df738f15b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >)  ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_94/verina_basic_94_impl.rs", "verified": true, "metadata": {"original_id": "2d2df738f15b", "function_name": "iter_copy", "bug_type": "missing_requires"}}
{"id": "task_a_3dab0ffa2913", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32)   { let mut max_val = arr [0] ; let mut min_val = arr [0] ; let mut idx = 1 ; while idx < arr . len ()  { if arr [idx] > max_val { max_val = arr [idx] ; } if arr [idx] < min_val { min_val = arr [idx] ; } idx = idx + 1 ; } max_val - min_val }\n\n} // verus!", "target_text": "requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 \nensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff \ndecreases arr . len () - idx\ninvariant 1 <= idx <= arr . len () , forall | k : int | 0 <= k < idx ==> arr [k] <= max_val , forall | k : int | 0 <= k < idx ==> min_val <= arr [k] , exists | k : int | 0 <= k < idx && arr [k] == max_val , exists | k : int | 0 <= k < idx && arr [k] == min_val ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut max_val = arr [0] ; let mut min_val = arr [0] ; let mut idx = 1 ; while idx < arr . len () invariant 1 <= idx <= arr . len () , forall | k : int | 0 <= k < idx ==> arr [k] <= max_val , forall | k : int | 0 <= k < idx ==> min_val <= arr [k] , exists | k : int | 0 <= k < idx && arr [k] == max_val , exists | k : int | 0 <= k < idx && arr [k] == min_val , decreases arr . len () - idx { if arr [idx] > max_val { max_val = arr [idx] ; } if arr [idx] < min_val { min_val = arr [idx] ; } idx = idx + 1 ; } max_val - min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_145_impl.rs", "verified": true, "metadata": {"original_id": "3dab0ffa2913", "function_name": "max_difference", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_c1dd8816a528", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32)   { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "target_text": "requires a . len () > 0\nensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] \ndecreases a . len () - i\ninvariant 0 < i <= a . len () , forall | k : int | 0 <= k < i ==> min_val <= a [k] , exists | k : int | 0 <= k < i && min_val == a [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0 ensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] , { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 < i <= a . len () , forall | k : int | 0 <= k < i ==> min_val <= a [k] , exists | k : int | 0 <= k < i && min_val == a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "c1dd8816a528", "function_name": "minArray", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_816a9baf89c3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires old (v) . len () > 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize) requires old (v) . len () > 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "816a9baf89c3", "function_name": "separate", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_01647fd9aa11", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len ()  { result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] \ndecreases arr1 . len () - idx \ninvariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_399_iter_2_current.rs", "verified": true, "metadata": {"original_id": "01647fd9aa11", "function_name": "bit_wise_xor", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_invariant_1bc64135516d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; for i in 1 .. a . len ()  { if a [i] != first { return false ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; for i in 1 .. a . len () invariant forall | k : int | 0 <= k < i ==> a [k] == first , { if a [i] != first { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; for i in 1 .. a . len () invariant forall | k : int | 0 <= k < i ==> a [k] == first , { if a [i] != first { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/has_only_one_distinct_element_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1bc64135516d", "function_name": "has_only_one_distinct_element", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_f6ef943b7e3b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "f6ef943b7e3b", "function_name": "contains_z", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_34b41bac24b8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) { proof { assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "34b41bac24b8", "function_name": "any_value_exists", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_326dcb4a9e07", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 ,  { 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "326dcb4a9e07", "function_name": "main_method", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_b437235fabc6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >) requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX , ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >) requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX , ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >) requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX , ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_82/verina_basic_82_iter_1_current.rs", "verified": true, "metadata": {"original_id": "b437235fabc6", "function_name": "copy_from", "bug_type": "missing_decreases"}}
{"id": "task_b_62609aea4c5d", "task": "task_b", "input_text": "pub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)\nrequires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 2 * N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/brs2_impl.rs", "verified": true, "metadata": {"original_id": "62609aea4c5d", "function_name": "myfun", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_invariant_e91c94989fde", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant ! exists | j : int | 0 <= j < i && a @ [j] == x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant ! exists | j : int | 0 <= j < i && a @ [j] == x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_duplicates_iter_1_current.rs", "verified": true, "metadata": {"original_id": "e91c94989fde", "function_name": "remove_duplicates", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_verus_bst_map_generic_a07b70c89126", "task": "task_c", "input_text": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\n// ANCHOR: trait\npub enum Cmp { Less, Equal, Greater }\n\npub trait TotalOrdered : Sized {\n    spec fn le(self, other: Self) -> bool;\n\n    proof fn reflexive(x: Self)\n        ensures Self::le(x, x);\n\n    proof fn transitive(x: Self, y: Self, z: Self)\n        requires Self::le(x, y), Self::le(y, z),\n        ensures Self::le(x, z);\n\n    proof fn antisymmetric(x: Self, y: Self)\n        requires Self::le(x, y), Self::le(y, x),\n        ensures x == y;\n\n    proof fn total(x: Self, y: Self)\n        ensures Self::le(x, y) || Self::le(y, x);\n\n    fn compare(&self, other: &Self) -> (c: Cmp)\n        ensures (match c {\n            Cmp::Less => self.le(*other) && self != other,\n            Cmp::Equal => self == other,\n            Cmp::Greater => other.le(*self) && self != other,\n        });\n}\n// ANCHOR_END: trait\n\n// ANCHOR: structs\nstruct Node<K: TotalOrdered, V> {\n    key: K,\n    value: V,\n    left: Option<Box<Node<K, V>>>,\n    right: Option<Box<Node<K, V>>>,\n}\n\npub struct TreeMap<K: TotalOrdered, V> {\n    root: Option<Box<Node<K, V>>>,\n}\n// ANCHOR_END: structs\n\nimpl<K: TotalOrdered, V> Node<K, V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<K, V>>>) -> Map<K, V>\n        {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    pub closed spec fn as_map(self) -> Map<K, V>\n        {\n        Node::<K, V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<K, V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub closed spec fn as_map(self) -> Map<K, V> {\n        Node::<K, V>::optional_as_map(self.root)\n    }\n}\n\nimpl<K: TotalOrdered, V> View for TreeMap<K, V> {\n    type V = Map<K, V>;\n\n    open spec fn view(&self) -> Map<K, V> {\n        self.as_map()\n    }\n}\n\n// ANCHOR: well_formed\nimpl<K: TotalOrdered, V> Node<K, V> {\n    pub closed spec fn well_formed(self) -> bool\n        {\n        &&& (forall |elem| #[trigger] Node::<K, V>::optional_as_map(self.left).dom().contains(elem) ==> elem.le(self.key) && elem != self.key)\n        &&& (forall |elem| #[trigger] Node::<K, V>::optional_as_map(self.right).dom().contains(elem) ==> self.key.le(elem) && elem != self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    #[verifier::type_invariant]\n    spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: well_formed\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn new() -> (s: Self)\n        ensures\n            s@ == Map::<K, V>::empty(),\n    {\n        TreeMap::<K, V> { root: None }\n    }\n}\n\nimpl<K: TotalOrdered, V> Node<K, V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<K, V>>>, key: K, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).insert(key, value),\n        {\n        if node.is_none() {\n            *node = Some(Box::new(Node::<K, V> {\n                key: key,\n                value: value,\n                left: None,\n                right: None,\n            }));\n        } else {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            (&mut *boxed_node).insert(key, value);\n\n            *node = Some(boxed_node);\n        }\n    }\n\n    fn insert(&mut self, key: K, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        {\n        match key.compare(&self.key) {\n            Cmp::Equal => {\n                self.value = value;\n\n                assert(!Node::<K, V>::optional_as_map(self.left).dom().contains(key));\n                assert(!Node::<K, V>::optional_as_map(self.right).dom().contains(key));\n            }\n            Cmp::Less => {\n                Self::insert_into_optional(&mut self.left, key, value);\n\n                proof {\n                    if self.key.le(key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n                    }\n                    assert(!Node::<K, V>::optional_as_map(self.right).dom().contains(key));\n                }\n            }\n            Cmp::Greater => {\n                Self::insert_into_optional(&mut self.right, key, value);\n\n                proof {\n                    if key.le(self.key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n                    }\n                    assert(!Node::<K, V>::optional_as_map(self.left).dom().contains(key));\n                }\n            }\n        }\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn insert(&mut self, key: K, value: V)\n        ensures\n            self@ == old(self)@.insert(key, value)\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<K, V>::insert_into_optional(&mut root, key, value);\n        self.root = root;\n    }\n}\n\nimpl<K: TotalOrdered, V> Node<K, V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<K, V>>>, key: K)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).remove(key),\n        {\n        if node.is_some() {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            match key.compare(&boxed_node.key) {\n                Cmp::Equal => {\n                    assert(!Node::<K, V>::optional_as_map(boxed_node.left).dom().contains(key));\n                    assert(!Node::<K, V>::optional_as_map(boxed_node.right).dom().contains(key));\n                    assert(boxed_node.right.is_some() ==> boxed_node.right.unwrap().well_formed());\n                    assert(boxed_node.left.is_some() ==> boxed_node.left.unwrap().well_formed());\n\n                    if boxed_node.left.is_none() {\n                        *node = boxed_node.right;\n                    } else {\n                        if boxed_node.right.is_none() {\n                            *node = boxed_node.left;\n                        } else {\n                            let (popped_key, popped_value) = Node::<K, V>::delete_rightmost(&mut boxed_node.left);\n                            boxed_node.key = popped_key;\n                            boxed_node.value = popped_value;\n                            *node = Some(boxed_node);\n\n                            proof {\n                                assert forall |elem| #[trigger] Node::<K, V>::optional_as_map(node.unwrap().right).dom().contains(elem) implies node.unwrap().key.le(elem) && elem != node.unwrap().key\n                                by {\n                                    TotalOrdered::transitive(node.unwrap().key, key, elem);\n                                    if elem == node.unwrap().key {\n                                        TotalOrdered::antisymmetric(elem, key);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                Cmp::Less => {\n                    proof {\n                        if Node::<K, V>::optional_as_map(boxed_node.right).dom().contains(key) {\n                            TotalOrdered::antisymmetric(boxed_node.key, key);\n                            assert(false);\n                        }\n                    }\n                    Node::<K, V>::delete_from_optional(&mut boxed_node.left, key);\n                    *node = Some(boxed_node);\n                }\n                Cmp::Greater => {\n                    proof {\n                        if Node::<K, V>::optional_as_map(boxed_node.left).dom().contains(key) {\n                            TotalOrdered::antisymmetric(boxed_node.key, key);\n                            assert(false);\n                        }\n                    }\n                    Node::<K, V>::delete_from_optional(&mut boxed_node.right, key);\n                    *node = Some(boxed_node);\n                }\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<K, V>>>) -> (popped: (K, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<K, V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<K, V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| #[trigger] Node::<K, V>::optional_as_map(*old(node)).dom().contains(elem) ==> elem.le(popped.0),\n        {\n        let mut tmp = None;\n        std::mem::swap(&mut tmp, node);\n        let mut boxed_node = tmp.unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            proof {\n                assert(Node::<K, V>::optional_as_map(boxed_node.right) =~= Map::empty());\n                assert(!Node::<K, V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n                TotalOrdered::reflexive(boxed_node.key);\n            }\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<K, V>::delete_rightmost(&mut boxed_node.right);\n            proof {\n                if Node::<K, V>::optional_as_map(boxed_node.left).dom().contains(popped_key) {\n                    TotalOrdered::antisymmetric(boxed_node.key, popped_key);\n                    assert(false);\n                }\n                assert forall |elem| #[trigger] Node::<K, V>::optional_as_map(*old(node)).dom().contains(elem) implies elem.le(popped_key)\n                by {\n                    if elem.le(boxed_node.key) {\n                        TotalOrdered::transitive(elem, boxed_node.key, popped_key);\n                    }\n                }\n            }\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn delete(&mut self, key: K)\n        ensures\n            self@ == old(self)@.remove(key),\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<K, V>::delete_from_optional(&mut root, key);\n        self.root = root;\n    }\n}\n\n// ANCHOR: node_get\nimpl<K: TotalOrdered, V> Node<K, V> {\n    fn get_from_optional(node: &Option<Box<Node<K, V>>>, key: K) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: K) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        {\n        match key.compare(&self.key) {\n            Cmp::Equal => {\n                Some(&self.value)\n            }\n            Cmp::Less => {\n                proof {\n                    if Node::<K, V>::optional_as_map(self.right).dom().contains(key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n                        assert(false);\n                    }\n                    assert(key != self.key);\n                    assert((match self.left {\n                            Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                            None => None,\n                        }) == (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }));\n                }\n                Self::get_from_optional(&self.left, key)\n            }\n            Cmp::Greater => {\n                proof {\n                    if Node::<K, V>::optional_as_map(self.left).dom().contains(key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n                        assert(false);\n                    }\n                    assert(key != self.key);\n                    assert((match self.right {\n                            Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                            None => None,\n                        }) == (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }));\n                }\n                Self::get_from_optional(&self.right, key)\n            }\n        }\n    }\n}\n// ANCHOR_END: node_get\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn get(&self, key: K) -> Option<&V>\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n    {\n        proof { use_type_invariant(&*self); }\n        Node::<K, V>::get_from_optional(&self.root, key)\n    }\n}\n\n// ANCHOR: clone_full_impl\nimpl<K: Copy + TotalOrdered, V: Clone> Clone for Node<K, V> {\n    fn clone(&self) -> (res: Self)\n        ensures\n            self.well_formed() ==> res.well_formed(),\n            self.as_map().dom() =~= res.as_map().dom(),\n            forall |key| #[trigger] res.as_map().dom().contains(key) ==>\n                cloned::<V>(self.as_map()[key], res.as_map()[key]),\n        {\n        let res = Node {\n            key: self.key,\n            value: self.value.clone(),\n            // Ordinarily, we would use Option<Node>::clone rather than inlining\n            // the case statement here; we write it this way to work around\n            // this issue: https://github.com/verus-lang/verus/issues/1346\n            left: (match &self.left {\n                Some(node) => Some(Box::new((&**node).clone())),\n                None => None,\n            }),\n            right: (match &self.right {\n                Some(node) => Some(Box::new((&**node).clone())),\n                None => None,\n            }),\n        };\n\n        proof {\n            assert(Node::optional_as_map(res.left).dom() =~=\n                Node::optional_as_map(self.left).dom());\n            assert(Node::optional_as_map(res.right).dom() =~=\n                Node::optional_as_map(self.right).dom());\n        }\n\n        return res;\n    }\n}\n\n// ANCHOR: clone_signature\nimpl<K: Copy + TotalOrdered, V: Clone> Clone for TreeMap<K, V> {\n    fn clone(&self) -> (res: Self)\n        ensures self@.dom() =~= res@.dom(),\n            forall |key| #[trigger] res@.dom().contains(key) ==>\n                cloned::<V>(self@[key], res@[key]),\n// ANCHOR_END: clone_signature\n    {\n        proof {\n            use_type_invariant(self);\n        }\n\n        TreeMap {\n            // This calls Option<Node<K, V>>::Clone\n            root: self.root.clone(),\n        }\n    }\n}\n// ANCHOR_END: clone_full_impl\n\nimpl TotalOrdered for u64 {\n    open spec fn le(self, other: Self) -> bool { self <= other }\n\n    proof fn reflexive(x: Self) { }\n    proof fn transitive(x: Self, y: Self, z: Self) { }\n    proof fn antisymmetric(x: Self, y: Self) { }\n    proof fn total(x: Self, y: Self) { }\n\n    fn compare(&self, other: &Self) -> (c: Cmp) {\n        if *self == *other {\n            Cmp::Equal\n        } else if *self < *other {\n            Cmp::Less\n        } else {\n            Cmp::Greater\n        }\n    }\n}\n\nfn test() {\n    let mut tree_map = TreeMap::<u64, bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n\n    test2(tree_map);\n}\n\nfn test2(tree_map: TreeMap<u64, bool>) {\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n\n// ANCHOR: clone_u32\nfn test_clone_u32(tree_map: TreeMap<u64, u32>) {\n    let tree_map2 = tree_map.clone();\n    assert(tree_map2@ =~= tree_map@);\n}\n// ANCHOR_END: clone_u32\n\n// ANCHOR: clone_int_wrapper\nstruct IntWrapper {\n    pub int_value: u32,\n}\n\nimpl Clone for IntWrapper {\n    fn clone(&self) -> (s: Self)\n        ensures s == *self\n    {\n        IntWrapper { int_value: self.int_value }\n    }\n}\n\nfn test_clone_int_wrapper(tree_map: TreeMap<u64, IntWrapper>) {\n    let tree_map2 = tree_map.clone();\n    assert(tree_map2@ =~= tree_map@);\n}\n// ANCHOR_END: clone_int_wrapper\n\n// ANCHOR: clone_weird_int\npub struct WeirdInt {\n    pub int_value: u32,\n    pub other: u32,\n}\n\nimpl Clone for WeirdInt {\n    fn clone(&self) -> (s: Self)\n        ensures\n            s.int_value == self.int_value,\n    {\n        WeirdInt { int_value: self.int_value, other: 0 }\n    }\n}\n\nfn test_clone_weird_int(tree_map: TreeMap<u64, WeirdInt>) {\n    let tree_map2 = tree_map.clone();\n\n    // assert(tree_map2@ =~= tree_map@); // this would fail\n\n    assert(tree_map2@.dom() == tree_map@.dom());\n    assert(forall |k| tree_map@.dom().contains(k) ==>\n        tree_map2@[k].int_value == tree_map@[k].int_value);\n}\n// ANCHOR_END: clone_weird_int\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "target_text": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\n// ANCHOR: trait\npub enum Cmp { Less, Equal, Greater }\n\npub trait TotalOrdered : Sized {\n    spec fn le(self, other: Self) -> bool;\n\n    proof fn reflexive(x: Self)\n        ensures Self::le(x, x);\n\n    proof fn transitive(x: Self, y: Self, z: Self)\n        requires Self::le(x, y), Self::le(y, z),\n        ensures Self::le(x, z);\n\n    proof fn antisymmetric(x: Self, y: Self)\n        requires Self::le(x, y), Self::le(y, x),\n        ensures x == y;\n\n    proof fn total(x: Self, y: Self)\n        ensures Self::le(x, y) || Self::le(y, x);\n\n    fn compare(&self, other: &Self) -> (c: Cmp)\n        ensures (match c {\n            Cmp::Less => self.le(*other) && self != other,\n            Cmp::Equal => self == other,\n            Cmp::Greater => other.le(*self) && self != other,\n        });\n}\n// ANCHOR_END: trait\n\n// ANCHOR: structs\nstruct Node<K: TotalOrdered, V> {\n    key: K,\n    value: V,\n    left: Option<Box<Node<K, V>>>,\n    right: Option<Box<Node<K, V>>>,\n}\n\npub struct TreeMap<K: TotalOrdered, V> {\n    root: Option<Box<Node<K, V>>>,\n}\n// ANCHOR_END: structs\n\nimpl<K: TotalOrdered, V> Node<K, V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<K, V>>>) -> Map<K, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    pub closed spec fn as_map(self) -> Map<K, V>\n        decreases self,\n    {\n        Node::<K, V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<K, V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub closed spec fn as_map(self) -> Map<K, V> {\n        Node::<K, V>::optional_as_map(self.root)\n    }\n}\n\nimpl<K: TotalOrdered, V> View for TreeMap<K, V> {\n    type V = Map<K, V>;\n\n    open spec fn view(&self) -> Map<K, V> {\n        self.as_map()\n    }\n}\n\n// ANCHOR: well_formed\nimpl<K: TotalOrdered, V> Node<K, V> {\n    pub closed spec fn well_formed(self) -> bool\n        decreases self\n    {\n        &&& (forall |elem| #[trigger] Node::<K, V>::optional_as_map(self.left).dom().contains(elem) ==> elem.le(self.key) && elem != self.key)\n        &&& (forall |elem| #[trigger] Node::<K, V>::optional_as_map(self.right).dom().contains(elem) ==> self.key.le(elem) && elem != self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    #[verifier::type_invariant]\n    spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: well_formed\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn new() -> (s: Self)\n        ensures\n            s@ == Map::<K, V>::empty(),\n    {\n        TreeMap::<K, V> { root: None }\n    }\n}\n\nimpl<K: TotalOrdered, V> Node<K, V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<K, V>>>, key: K, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n        if node.is_none() {\n            *node = Some(Box::new(Node::<K, V> {\n                key: key,\n                value: value,\n                left: None,\n                right: None,\n            }));\n        } else {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            (&mut *boxed_node).insert(key, value);\n\n            *node = Some(boxed_node);\n        }\n    }\n\n    fn insert(&mut self, key: K, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n        match key.compare(&self.key) {\n            Cmp::Equal => {\n                self.value = value;\n\n                assert(!Node::<K, V>::optional_as_map(self.left).dom().contains(key));\n                assert(!Node::<K, V>::optional_as_map(self.right).dom().contains(key));\n            }\n            Cmp::Less => {\n                Self::insert_into_optional(&mut self.left, key, value);\n\n                proof {\n                    if self.key.le(key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n                    }\n                    assert(!Node::<K, V>::optional_as_map(self.right).dom().contains(key));\n                }\n            }\n            Cmp::Greater => {\n                Self::insert_into_optional(&mut self.right, key, value);\n\n                proof {\n                    if key.le(self.key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n                    }\n                    assert(!Node::<K, V>::optional_as_map(self.left).dom().contains(key));\n                }\n            }\n        }\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn insert(&mut self, key: K, value: V)\n        ensures\n            self@ == old(self)@.insert(key, value)\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<K, V>::insert_into_optional(&mut root, key, value);\n        self.root = root;\n    }\n}\n\nimpl<K: TotalOrdered, V> Node<K, V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<K, V>>>, key: K)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n        if node.is_some() {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            match key.compare(&boxed_node.key) {\n                Cmp::Equal => {\n                    assert(!Node::<K, V>::optional_as_map(boxed_node.left).dom().contains(key));\n                    assert(!Node::<K, V>::optional_as_map(boxed_node.right).dom().contains(key));\n                    assert(boxed_node.right.is_some() ==> boxed_node.right.unwrap().well_formed());\n                    assert(boxed_node.left.is_some() ==> boxed_node.left.unwrap().well_formed());\n\n                    if boxed_node.left.is_none() {\n                        *node = boxed_node.right;\n                    } else {\n                        if boxed_node.right.is_none() {\n                            *node = boxed_node.left;\n                        } else {\n                            let (popped_key, popped_value) = Node::<K, V>::delete_rightmost(&mut boxed_node.left);\n                            boxed_node.key = popped_key;\n                            boxed_node.value = popped_value;\n                            *node = Some(boxed_node);\n\n                            proof {\n                                assert forall |elem| #[trigger] Node::<K, V>::optional_as_map(node.unwrap().right).dom().contains(elem) implies node.unwrap().key.le(elem) && elem != node.unwrap().key\n                                by {\n                                    TotalOrdered::transitive(node.unwrap().key, key, elem);\n                                    if elem == node.unwrap().key {\n                                        TotalOrdered::antisymmetric(elem, key);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                Cmp::Less => {\n                    proof {\n                        if Node::<K, V>::optional_as_map(boxed_node.right).dom().contains(key) {\n                            TotalOrdered::antisymmetric(boxed_node.key, key);\n                            assert(false);\n                        }\n                    }\n                    Node::<K, V>::delete_from_optional(&mut boxed_node.left, key);\n                    *node = Some(boxed_node);\n                }\n                Cmp::Greater => {\n                    proof {\n                        if Node::<K, V>::optional_as_map(boxed_node.left).dom().contains(key) {\n                            TotalOrdered::antisymmetric(boxed_node.key, key);\n                            assert(false);\n                        }\n                    }\n                    Node::<K, V>::delete_from_optional(&mut boxed_node.right, key);\n                    *node = Some(boxed_node);\n                }\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<K, V>>>) -> (popped: (K, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<K, V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<K, V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| #[trigger] Node::<K, V>::optional_as_map(*old(node)).dom().contains(elem) ==> elem.le(popped.0),\n        decreases *old(node),\n    {\n        let mut tmp = None;\n        std::mem::swap(&mut tmp, node);\n        let mut boxed_node = tmp.unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            proof {\n                assert(Node::<K, V>::optional_as_map(boxed_node.right) =~= Map::empty());\n                assert(!Node::<K, V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n                TotalOrdered::reflexive(boxed_node.key);\n            }\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<K, V>::delete_rightmost(&mut boxed_node.right);\n            proof {\n                if Node::<K, V>::optional_as_map(boxed_node.left).dom().contains(popped_key) {\n                    TotalOrdered::antisymmetric(boxed_node.key, popped_key);\n                    assert(false);\n                }\n                assert forall |elem| #[trigger] Node::<K, V>::optional_as_map(*old(node)).dom().contains(elem) implies elem.le(popped_key)\n                by {\n                    if elem.le(boxed_node.key) {\n                        TotalOrdered::transitive(elem, boxed_node.key, popped_key);\n                    }\n                }\n            }\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn delete(&mut self, key: K)\n        ensures\n            self@ == old(self)@.remove(key),\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<K, V>::delete_from_optional(&mut root, key);\n        self.root = root;\n    }\n}\n\n// ANCHOR: node_get\nimpl<K: TotalOrdered, V> Node<K, V> {\n    fn get_from_optional(node: &Option<Box<Node<K, V>>>, key: K) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: K) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        match key.compare(&self.key) {\n            Cmp::Equal => {\n                Some(&self.value)\n            }\n            Cmp::Less => {\n                proof {\n                    if Node::<K, V>::optional_as_map(self.right).dom().contains(key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n                        assert(false);\n                    }\n                    assert(key != self.key);\n                    assert((match self.left {\n                            Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                            None => None,\n                        }) == (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }));\n                }\n                Self::get_from_optional(&self.left, key)\n            }\n            Cmp::Greater => {\n                proof {\n                    if Node::<K, V>::optional_as_map(self.left).dom().contains(key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n                        assert(false);\n                    }\n                    assert(key != self.key);\n                    assert((match self.right {\n                            Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                            None => None,\n                        }) == (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }));\n                }\n                Self::get_from_optional(&self.right, key)\n            }\n        }\n    }\n}\n// ANCHOR_END: node_get\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn get(&self, key: K) -> Option<&V>\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n    {\n        proof { use_type_invariant(&*self); }\n        Node::<K, V>::get_from_optional(&self.root, key)\n    }\n}\n\n// ANCHOR: clone_full_impl\nimpl<K: Copy + TotalOrdered, V: Clone> Clone for Node<K, V> {\n    fn clone(&self) -> (res: Self)\n        ensures\n            self.well_formed() ==> res.well_formed(),\n            self.as_map().dom() =~= res.as_map().dom(),\n            forall |key| #[trigger] res.as_map().dom().contains(key) ==>\n                cloned::<V>(self.as_map()[key], res.as_map()[key]),\n        decreases self,\n    {\n        let res = Node {\n            key: self.key,\n            value: self.value.clone(),\n            // Ordinarily, we would use Option<Node>::clone rather than inlining\n            // the case statement here; we write it this way to work around\n            // this issue: https://github.com/verus-lang/verus/issues/1346\n            left: (match &self.left {\n                Some(node) => Some(Box::new((&**node).clone())),\n                None => None,\n            }),\n            right: (match &self.right {\n                Some(node) => Some(Box::new((&**node).clone())),\n                None => None,\n            }),\n        };\n\n        proof {\n            assert(Node::optional_as_map(res.left).dom() =~= \n                Node::optional_as_map(self.left).dom());\n            assert(Node::optional_as_map(res.right).dom() =~= \n                Node::optional_as_map(self.right).dom());\n        }\n\n        return res;\n    }\n}\n\n// ANCHOR: clone_signature\nimpl<K: Copy + TotalOrdered, V: Clone> Clone for TreeMap<K, V> {\n    fn clone(&self) -> (res: Self)\n        ensures self@.dom() =~= res@.dom(),\n            forall |key| #[trigger] res@.dom().contains(key) ==>\n                cloned::<V>(self@[key], res@[key]),\n// ANCHOR_END: clone_signature\n    {\n        proof {\n            use_type_invariant(self);\n        }\n\n        TreeMap {\n            // This calls Option<Node<K, V>>::Clone\n            root: self.root.clone(),\n        }\n    }\n}\n// ANCHOR_END: clone_full_impl\n\nimpl TotalOrdered for u64 {\n    open spec fn le(self, other: Self) -> bool { self <= other }\n\n    proof fn reflexive(x: Self) { }\n    proof fn transitive(x: Self, y: Self, z: Self) { }\n    proof fn antisymmetric(x: Self, y: Self) { }\n    proof fn total(x: Self, y: Self) { }\n\n    fn compare(&self, other: &Self) -> (c: Cmp) {\n        if *self == *other {\n            Cmp::Equal\n        } else if *self < *other {\n            Cmp::Less\n        } else {\n            Cmp::Greater\n        }\n    }\n}\n\nfn test() {\n    let mut tree_map = TreeMap::<u64, bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n\n    test2(tree_map);\n}\n\nfn test2(tree_map: TreeMap<u64, bool>) {\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n\n// ANCHOR: clone_u32\nfn test_clone_u32(tree_map: TreeMap<u64, u32>) {\n    let tree_map2 = tree_map.clone();\n    assert(tree_map2@ =~= tree_map@);\n}\n// ANCHOR_END: clone_u32\n\n// ANCHOR: clone_int_wrapper\nstruct IntWrapper {\n    pub int_value: u32,\n}\n\nimpl Clone for IntWrapper {\n    fn clone(&self) -> (s: Self)\n        ensures s == *self\n    {\n        IntWrapper { int_value: self.int_value }\n    }\n}\n\nfn test_clone_int_wrapper(tree_map: TreeMap<u64, IntWrapper>) {\n    let tree_map2 = tree_map.clone();\n    assert(tree_map2@ =~= tree_map@);\n}\n// ANCHOR_END: clone_int_wrapper\n\n// ANCHOR: clone_weird_int\npub struct WeirdInt {\n    pub int_value: u32,\n    pub other: u32,\n}\n\nimpl Clone for WeirdInt {\n    fn clone(&self) -> (s: Self)\n        ensures\n            s.int_value == self.int_value,\n    {\n        WeirdInt { int_value: self.int_value, other: 0 }\n    }\n}\n\nfn test_clone_weird_int(tree_map: TreeMap<u64, WeirdInt>) {\n    let tree_map2 = tree_map.clone();\n\n    // assert(tree_map2@ =~= tree_map@); // this would fail\n\n    assert(tree_map2@.dom() == tree_map@.dom());\n    assert(forall |k| tree_map@.dom().contains(k) ==>\n        tree_map2@[k].int_value == tree_map@[k].int_value);\n}\n// ANCHOR_END: clone_weird_int\n\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "full_verified_code": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\n// ANCHOR: trait\npub enum Cmp { Less, Equal, Greater }\n\npub trait TotalOrdered : Sized {\n    spec fn le(self, other: Self) -> bool;\n\n    proof fn reflexive(x: Self)\n        ensures Self::le(x, x);\n\n    proof fn transitive(x: Self, y: Self, z: Self)\n        requires Self::le(x, y), Self::le(y, z),\n        ensures Self::le(x, z);\n\n    proof fn antisymmetric(x: Self, y: Self)\n        requires Self::le(x, y), Self::le(y, x),\n        ensures x == y;\n\n    proof fn total(x: Self, y: Self)\n        ensures Self::le(x, y) || Self::le(y, x);\n\n    fn compare(&self, other: &Self) -> (c: Cmp)\n        ensures (match c {\n            Cmp::Less => self.le(*other) && self != other,\n            Cmp::Equal => self == other,\n            Cmp::Greater => other.le(*self) && self != other,\n        });\n}\n// ANCHOR_END: trait\n\n// ANCHOR: structs\nstruct Node<K: TotalOrdered, V> {\n    key: K,\n    value: V,\n    left: Option<Box<Node<K, V>>>,\n    right: Option<Box<Node<K, V>>>,\n}\n\npub struct TreeMap<K: TotalOrdered, V> {\n    root: Option<Box<Node<K, V>>>,\n}\n// ANCHOR_END: structs\n\nimpl<K: TotalOrdered, V> Node<K, V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<K, V>>>) -> Map<K, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    pub closed spec fn as_map(self) -> Map<K, V>\n        decreases self,\n    {\n        Node::<K, V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<K, V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub closed spec fn as_map(self) -> Map<K, V> {\n        Node::<K, V>::optional_as_map(self.root)\n    }\n}\n\nimpl<K: TotalOrdered, V> View for TreeMap<K, V> {\n    type V = Map<K, V>;\n\n    open spec fn view(&self) -> Map<K, V> {\n        self.as_map()\n    }\n}\n\n// ANCHOR: well_formed\nimpl<K: TotalOrdered, V> Node<K, V> {\n    pub closed spec fn well_formed(self) -> bool\n        decreases self\n    {\n        &&& (forall |elem| #[trigger] Node::<K, V>::optional_as_map(self.left).dom().contains(elem) ==> elem.le(self.key) && elem != self.key)\n        &&& (forall |elem| #[trigger] Node::<K, V>::optional_as_map(self.right).dom().contains(elem) ==> self.key.le(elem) && elem != self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    #[verifier::type_invariant]\n    spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: well_formed\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn new() -> (s: Self)\n        ensures\n            s@ == Map::<K, V>::empty(),\n    {\n        TreeMap::<K, V> { root: None }\n    }\n}\n\nimpl<K: TotalOrdered, V> Node<K, V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<K, V>>>, key: K, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n        if node.is_none() {\n            *node = Some(Box::new(Node::<K, V> {\n                key: key,\n                value: value,\n                left: None,\n                right: None,\n            }));\n        } else {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            (&mut *boxed_node).insert(key, value);\n\n            *node = Some(boxed_node);\n        }\n    }\n\n    fn insert(&mut self, key: K, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n        match key.compare(&self.key) {\n            Cmp::Equal => {\n                self.value = value;\n\n                assert(!Node::<K, V>::optional_as_map(self.left).dom().contains(key));\n                assert(!Node::<K, V>::optional_as_map(self.right).dom().contains(key));\n            }\n            Cmp::Less => {\n                Self::insert_into_optional(&mut self.left, key, value);\n\n                proof {\n                    if self.key.le(key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n                    }\n                    assert(!Node::<K, V>::optional_as_map(self.right).dom().contains(key));\n                }\n            }\n            Cmp::Greater => {\n                Self::insert_into_optional(&mut self.right, key, value);\n\n                proof {\n                    if key.le(self.key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n                    }\n                    assert(!Node::<K, V>::optional_as_map(self.left).dom().contains(key));\n                }\n            }\n        }\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn insert(&mut self, key: K, value: V)\n        ensures\n            self@ == old(self)@.insert(key, value)\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<K, V>::insert_into_optional(&mut root, key, value);\n        self.root = root;\n    }\n}\n\nimpl<K: TotalOrdered, V> Node<K, V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<K, V>>>, key: K)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n        if node.is_some() {\n            let mut tmp = None;\n            std::mem::swap(&mut tmp, node);\n            let mut boxed_node = tmp.unwrap();\n\n            match key.compare(&boxed_node.key) {\n                Cmp::Equal => {\n                    assert(!Node::<K, V>::optional_as_map(boxed_node.left).dom().contains(key));\n                    assert(!Node::<K, V>::optional_as_map(boxed_node.right).dom().contains(key));\n                    assert(boxed_node.right.is_some() ==> boxed_node.right.unwrap().well_formed());\n                    assert(boxed_node.left.is_some() ==> boxed_node.left.unwrap().well_formed());\n\n                    if boxed_node.left.is_none() {\n                        *node = boxed_node.right;\n                    } else {\n                        if boxed_node.right.is_none() {\n                            *node = boxed_node.left;\n                        } else {\n                            let (popped_key, popped_value) = Node::<K, V>::delete_rightmost(&mut boxed_node.left);\n                            boxed_node.key = popped_key;\n                            boxed_node.value = popped_value;\n                            *node = Some(boxed_node);\n\n                            proof {\n                                assert forall |elem| #[trigger] Node::<K, V>::optional_as_map(node.unwrap().right).dom().contains(elem) implies node.unwrap().key.le(elem) && elem != node.unwrap().key\n                                by {\n                                    TotalOrdered::transitive(node.unwrap().key, key, elem);\n                                    if elem == node.unwrap().key {\n                                        TotalOrdered::antisymmetric(elem, key);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                Cmp::Less => {\n                    proof {\n                        if Node::<K, V>::optional_as_map(boxed_node.right).dom().contains(key) {\n                            TotalOrdered::antisymmetric(boxed_node.key, key);\n                            assert(false);\n                        }\n                    }\n                    Node::<K, V>::delete_from_optional(&mut boxed_node.left, key);\n                    *node = Some(boxed_node);\n                }\n                Cmp::Greater => {\n                    proof {\n                        if Node::<K, V>::optional_as_map(boxed_node.left).dom().contains(key) {\n                            TotalOrdered::antisymmetric(boxed_node.key, key);\n                            assert(false);\n                        }\n                    }\n                    Node::<K, V>::delete_from_optional(&mut boxed_node.right, key);\n                    *node = Some(boxed_node);\n                }\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<K, V>>>) -> (popped: (K, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<K, V>::optional_as_map(*node) =~= Node::<K, V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<K, V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<K, V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| #[trigger] Node::<K, V>::optional_as_map(*old(node)).dom().contains(elem) ==> elem.le(popped.0),\n        decreases *old(node),\n    {\n        let mut tmp = None;\n        std::mem::swap(&mut tmp, node);\n        let mut boxed_node = tmp.unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            proof {\n                assert(Node::<K, V>::optional_as_map(boxed_node.right) =~= Map::empty());\n                assert(!Node::<K, V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n                TotalOrdered::reflexive(boxed_node.key);\n            }\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<K, V>::delete_rightmost(&mut boxed_node.right);\n            proof {\n                if Node::<K, V>::optional_as_map(boxed_node.left).dom().contains(popped_key) {\n                    TotalOrdered::antisymmetric(boxed_node.key, popped_key);\n                    assert(false);\n                }\n                assert forall |elem| #[trigger] Node::<K, V>::optional_as_map(*old(node)).dom().contains(elem) implies elem.le(popped_key)\n                by {\n                    if elem.le(boxed_node.key) {\n                        TotalOrdered::transitive(elem, boxed_node.key, popped_key);\n                    }\n                }\n            }\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn delete(&mut self, key: K)\n        ensures\n            self@ == old(self)@.remove(key),\n    {\n        proof { use_type_invariant(&*self); }\n        let mut root = None;\n        std::mem::swap(&mut root, &mut self.root);\n        Node::<K, V>::delete_from_optional(&mut root, key);\n        self.root = root;\n    }\n}\n\n// ANCHOR: node_get\nimpl<K: TotalOrdered, V> Node<K, V> {\n    fn get_from_optional(node: &Option<Box<Node<K, V>>>, key: K) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: K) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        match key.compare(&self.key) {\n            Cmp::Equal => {\n                Some(&self.value)\n            }\n            Cmp::Less => {\n                proof {\n                    if Node::<K, V>::optional_as_map(self.right).dom().contains(key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n                        assert(false);\n                    }\n                    assert(key != self.key);\n                    assert((match self.left {\n                            Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                            None => None,\n                        }) == (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }));\n                }\n                Self::get_from_optional(&self.left, key)\n            }\n            Cmp::Greater => {\n                proof {\n                    if Node::<K, V>::optional_as_map(self.left).dom().contains(key) {\n                        TotalOrdered::antisymmetric(self.key, key);\n                        assert(false);\n                    }\n                    assert(key != self.key);\n                    assert((match self.right {\n                            Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                            None => None,\n                        }) == (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }));\n                }\n                Self::get_from_optional(&self.right, key)\n            }\n        }\n    }\n}\n// ANCHOR_END: node_get\n\nimpl<K: TotalOrdered, V> TreeMap<K, V> {\n    pub fn get(&self, key: K) -> Option<&V>\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n    {\n        proof { use_type_invariant(&*self); }\n        Node::<K, V>::get_from_optional(&self.root, key)\n    }\n}\n\n// ANCHOR: clone_full_impl\nimpl<K: Copy + TotalOrdered, V: Clone> Clone for Node<K, V> {\n    fn clone(&self) -> (res: Self)\n        ensures\n            self.well_formed() ==> res.well_formed(),\n            self.as_map().dom() =~= res.as_map().dom(),\n            forall |key| #[trigger] res.as_map().dom().contains(key) ==>\n                cloned::<V>(self.as_map()[key], res.as_map()[key]),\n        decreases self,\n    {\n        let res = Node {\n            key: self.key,\n            value: self.value.clone(),\n            // Ordinarily, we would use Option<Node>::clone rather than inlining\n            // the case statement here; we write it this way to work around\n            // this issue: https://github.com/verus-lang/verus/issues/1346\n            left: (match &self.left {\n                Some(node) => Some(Box::new((&**node).clone())),\n                None => None,\n            }),\n            right: (match &self.right {\n                Some(node) => Some(Box::new((&**node).clone())),\n                None => None,\n            }),\n        };\n\n        proof {\n            assert(Node::optional_as_map(res.left).dom() =~= \n                Node::optional_as_map(self.left).dom());\n            assert(Node::optional_as_map(res.right).dom() =~= \n                Node::optional_as_map(self.right).dom());\n        }\n\n        return res;\n    }\n}\n\n// ANCHOR: clone_signature\nimpl<K: Copy + TotalOrdered, V: Clone> Clone for TreeMap<K, V> {\n    fn clone(&self) -> (res: Self)\n        ensures self@.dom() =~= res@.dom(),\n            forall |key| #[trigger] res@.dom().contains(key) ==>\n                cloned::<V>(self@[key], res@[key]),\n// ANCHOR_END: clone_signature\n    {\n        proof {\n            use_type_invariant(self);\n        }\n\n        TreeMap {\n            // This calls Option<Node<K, V>>::Clone\n            root: self.root.clone(),\n        }\n    }\n}\n// ANCHOR_END: clone_full_impl\n\nimpl TotalOrdered for u64 {\n    open spec fn le(self, other: Self) -> bool { self <= other }\n\n    proof fn reflexive(x: Self) { }\n    proof fn transitive(x: Self, y: Self, z: Self) { }\n    proof fn antisymmetric(x: Self, y: Self) { }\n    proof fn total(x: Self, y: Self) { }\n\n    fn compare(&self, other: &Self) -> (c: Cmp) {\n        if *self == *other {\n            Cmp::Equal\n        } else if *self < *other {\n            Cmp::Less\n        } else {\n            Cmp::Greater\n        }\n    }\n}\n\nfn test() {\n    let mut tree_map = TreeMap::<u64, bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n\n    test2(tree_map);\n}\n\nfn test2(tree_map: TreeMap<u64, bool>) {\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n\n// ANCHOR: clone_u32\nfn test_clone_u32(tree_map: TreeMap<u64, u32>) {\n    let tree_map2 = tree_map.clone();\n    assert(tree_map2@ =~= tree_map@);\n}\n// ANCHOR_END: clone_u32\n\n// ANCHOR: clone_int_wrapper\nstruct IntWrapper {\n    pub int_value: u32,\n}\n\nimpl Clone for IntWrapper {\n    fn clone(&self) -> (s: Self)\n        ensures s == *self\n    {\n        IntWrapper { int_value: self.int_value }\n    }\n}\n\nfn test_clone_int_wrapper(tree_map: TreeMap<u64, IntWrapper>) {\n    let tree_map2 = tree_map.clone();\n    assert(tree_map2@ =~= tree_map@);\n}\n// ANCHOR_END: clone_int_wrapper\n\n// ANCHOR: clone_weird_int\npub struct WeirdInt {\n    pub int_value: u32,\n    pub other: u32,\n}\n\nimpl Clone for WeirdInt {\n    fn clone(&self) -> (s: Self)\n        ensures\n            s.int_value == self.int_value,\n    {\n        WeirdInt { int_value: self.int_value, other: 0 }\n    }\n}\n\nfn test_clone_weird_int(tree_map: TreeMap<u64, WeirdInt>) {\n    let tree_map2 = tree_map.clone();\n\n    // assert(tree_map2@ =~= tree_map@); // this would fail\n\n    assert(tree_map2@.dom() == tree_map@.dom());\n    assert(forall |k| tree_map@.dom().contains(k) ==>\n        tree_map2@[k].int_value == tree_map@[k].int_value);\n}\n// ANCHOR_END: clone_weird_int\n\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/bst_map_generic.rs", "verified": true, "metadata": {"original_id": "verus_bst_map_generic_a07b70c89126", "function_name": "", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_cc4448042c54", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32)  ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32)  ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { let (minIdx , secondIdx) = if s [0] <= s [1] { (0 , 1) } else { (1 , 0) } ; secondSmallestAux (s , 2 , minIdx , secondIdx) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { let (minIdx , secondIdx) = if s [0] <= s [1] { (0 , 1) } else { (1 , 0) } ; secondSmallestAux (s , 2 , minIdx , secondIdx) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { let (minIdx , secondIdx) = if s [0] <= s [1] { (0 , 1) } else { (1 , 0) } ; secondSmallestAux (s , 2 , minIdx , secondIdx) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_40/verina_basic_40_impl.rs", "verified": true, "metadata": {"original_id": "cc4448042c54", "function_name": "secondSmallest", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_f8ad9f1fc9c0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32)  { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0  { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0 ensures result == is_sum_divisible_by (x as nat , d as nat) { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0 ensures result == is_sum_divisible_by (x as nat , d as nat) { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_9/verina_advanced_9_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f8ad9f1fc9c0", "function_name": "is_sum_divisible_by_exec", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_381dfa033c22", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_51/verina_basic_51_impl.rs", "verified": true, "metadata": {"original_id": "381dfa033c22", "function_name": "binary_search_loop", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_b944c8fc8f8d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant 0 <= idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) , { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant 0 <= idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant 0 <= idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_557_impl.rs", "verified": true, "metadata": {"original_id": "b944c8fc8f8d", "function_name": "to_toggle_case", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_c7b2a9edc407", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >)  ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == if i <= pos { i as int } else { (i as int) - 1 } , forall | j : int | 0 <= j < result . len () && j < pos ==> result [j] == a [j] , forall | j : int | pos <= j < result . len () ==> result [j] == a [j + 1] , decreases a . len () - i { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == if i <= pos { i as int } else { (i as int) - 1 } , forall | j : int | 0 <= j < result . len () && j < pos ==> result [j] == a [j] , forall | j : int | pos <= j < result . len () ==> result [j] == a [j + 1] , decreases a . len () - i { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == if i <= pos { i as int } else { (i as int) - 1 } , forall | j : int | 0 <= j < result . len () && j < pos ==> result [j] == a [j] , forall | j : int | pos <= j < result . len () ==> result [j] == a [j + 1] , decreases a . len () - i { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/remove_element_impl.rs", "verified": true, "metadata": {"original_id": "c7b2a9edc407", "function_name": "remove_element", "bug_type": "missing_requires"}}
{"id": "task_a_2f49a95aeca4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32)   { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; for shifts in 0 .. n { if is_sorted_aux (& current) { return shifts as i32 ; } current = right_shift_once (& current) ; } - 1 }\n\n} // verus!", "target_text": "requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int))\nensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int)\ndecreases k", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; for shifts in 0 .. n { if is_sorted_aux (& current) { return shifts as i32 ; } current = right_shift_once (& current) ; } - 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_53/verina_advanced_53_iter_1_current.rs", "verified": true, "metadata": {"original_id": "2f49a95aeca4", "function_name": "minimum_right_shifts", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_c_missing_ensures_75c8f0f25afe", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int ,  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand/verus_code.rs", "verified": true, "metadata": {"original_id": "75c8f0f25afe", "function_name": "main_method", "bug_type": "missing_ensures"}}
{"id": "task_a_41cf03444a7d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64)   { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len ()  { if nums [i] > max_val { max_val = nums [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "target_text": "requires max_strength_precond (nums @)\nensures max_strength_postcond (nums @ , result)\ndecreases nums . len () - i\ninvariant 0 <= i <= nums . len () , nums . len () > 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len () invariant 0 <= i <= nums . len () , nums . len () > 0 decreases nums . len () - i { if nums [i] > max_val { max_val = nums [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_43/verina_advanced_43_impl.rs", "verified": true, "metadata": {"original_id": "41cf03444a7d", "function_name": "max_strength", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_65c867af533c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_majority_element_precond (lst : Seq < i32 >) -> bool { true }\nfn find_majority_element (lst : Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires find_majority_element_precond (lst @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_majority_element_precond (lst : Seq < i32 >) -> bool { true }\nfn find_majority_element (lst : Vec < i32 >) -> (result : i32) requires find_majority_element_precond (lst @) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_11/verina_advanced_11_iter_0_original.rs", "verified": true, "metadata": {"original_id": "65c867af533c", "function_name": "find_majority_element", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_requires_f101c4cc3062", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn barrier (v : & [int] , p : usize) -> (b : bool)  ensures b == (forall | k : int , l : int | 0 <= k <= p && p < l < v . len () ==> v [k] < v [l]) { let mut i = 0 ; if p >= v . len () - 1 { return true ; } while i <= p invariant 0 <= i <= p + 1 , i <= v . len () , p < v . len () - 1 , forall | k : int , l : int | 0 <= k < i && p < l < v . len () ==> v [k] < v [l] decreases p + 1 - i { let mut j = p + 1 ; while j < v . len () invariant 0 <= i <= p , i < v . len () , p + 1 <= j <= v . len () , p < v . len () - 1 , forall | l : int | p < l < j ==> v [i as int] < v [l] , forall | k : int , l : int | 0 <= k < i && p < l < v . len () ==> v [k] < v [l] decreases v . len () - j { if v [i] >= v [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn barrier (v : & [int] , p : usize) -> (b : bool) requires v . len () > 0 , p < v . len () , ensures b == (forall | k : int , l : int | 0 <= k <= p && p < l < v . len () ==> v [k] < v [l]) { let mut i = 0 ; if p >= v . len () - 1 { return true ; } while i <= p invariant 0 <= i <= p + 1 , i <= v . len () , p < v . len () - 1 , forall | k : int , l : int | 0 <= k < i && p < l < v . len () ==> v [k] < v [l] decreases p + 1 - i { let mut j = p + 1 ; while j < v . len () invariant 0 <= i <= p , i < v . len () , p + 1 <= j <= v . len () , p < v . len () - 1 , forall | l : int | p < l < j ==> v [i as int] < v [l] , forall | k : int , l : int | 0 <= k < i && p < l < v . len () ==> v [k] < v [l] decreases v . len () - j { if v [i] >= v [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn barrier (v : & [int] , p : usize) -> (b : bool) requires v . len () > 0 , p < v . len () , ensures b == (forall | k : int , l : int | 0 <= k <= p && p < l < v . len () ==> v [k] < v [l]) { let mut i = 0 ; if p >= v . len () - 1 { return true ; } while i <= p invariant 0 <= i <= p + 1 , i <= v . len () , p < v . len () - 1 , forall | k : int , l : int | 0 <= k < i && p < l < v . len () ==> v [k] < v [l] decreases p + 1 - i { let mut j = p + 1 ; while j < v . len () invariant 0 <= i <= p , i < v . len () , p + 1 <= j <= v . len () , p < v . len () - 1 , forall | l : int | p < l < j ==> v [i as int] < v [l] , forall | k : int , l : int | 0 <= k < i && p < l < v . len () ==> v [k] < v [l] decreases v . len () - j { if v [i] >= v [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny-Exercises_tmp_tmpjm75muf__Session10Exercises_ExerciseBarrier/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "f101c4cc3062", "function_name": "barrier", "bug_type": "missing_requires"}}
{"id": "task_a_17f671e04a49", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len ()  { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX \nensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) \ndecreases s1 @ . len () - i\ninvariant 0 <= i <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result [3 * j] == s1 [j] && result [3 * j + 1] == s2 [j] && result [3 * j + 2] == s3 [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len () invariant 0 <= i <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result [3 * j] == s1 [j] && result [3 * j + 1] == s2 [j] && result [3 * j + 2] == s3 [j]) , decreases s1 @ . len () - i { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_578_impl.rs", "verified": true, "metadata": {"original_id": "17f671e04a49", "function_name": "interleave", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_requires_6fe2a4613e65", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char)  ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 , ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_number_to_char (n : nat) -> (result : char) { if n == 0 { '0' } else if n == 1 { '1' } else if n == 2 { '2' } else if n == 3 { '3' } else if n == 4 { '4' } else if n == 5 { '5' } else if n == 6 { '6' } else if n == 7 { '7' } else if n == 8 { '8' } else { '9' } }\nfn single_digit_number_to_char_impl (n : u8) -> (output : char) requires 0 <= n <= 9 , ensures single_digit_number_to_char (n as nat) == output , { match n { 0 => '0' , 1 => '1' , 2 => '2' , 3 => '3' , 4 => '4' , 5 => '5' , 6 => '6' , 7 => '7' , 8 => '8' , _ => '9' , } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/015-string_sequence_iter_2_current.rs", "verified": true, "metadata": {"original_id": "6fe2a4613e65", "function_name": "single_digit_number_to_char_impl", "bug_type": "missing_requires"}}
{"id": "task_c_missing_assert_23bdb60d18e6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) , decreases arr1 . len () - i , {   let diff = arr1 [i] - arr2 [i] ; result . push (diff) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (MIN <= arr1 [i as int] - arr2 [i as int] <= MAX) ; let diff = arr1 [i] - arr2 [i] ; result . push (diff) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (MIN <= arr1 [i as int] - arr2 [i as int] <= MAX) ; let diff = arr1 [i] - arr2 [i] ; result . push (diff) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_282_impl.rs", "verified": true, "metadata": {"original_id": "23bdb60d18e6", "function_name": "element_wise_subtract", "bug_type": "missing_assert"}}
{"id": "task_a_d745fce2eea3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len ()  { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) \ndecreases str1 . len () - j\ninvariant j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_epxr_replace_chars (str1 : & Vec < char > , old_char : char , new_char : char , i : int) -> (result : char) { if str1 @ [i] == old_char { new_char } else { str1 @ [i] } }\nfn replace_chars (str1 : & Vec < char > , old_char : char , new_char : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , { let mut result = Vec :: new () ; let mut j = 0 ; while j < str1 . len () invariant j <= str1 . len () , result . len () == j , forall | i : int | 0 <= i < j ==> result @ [i] == inner_epxr_replace_chars (str1 , old_char , new_char , i) , decreases str1 . len () - j { let ch = if str1 [j] == old_char { new_char } else { str1 [j] } ; result . push (ch) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_474_impl.rs", "verified": true, "metadata": {"original_id": "d745fce2eea3", "function_name": "replace_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_b_verus_lib_bfbf64080aaf", "task": "task_b", "input_text": "pub fn double(x: u16) -> (z: u32)\nensures z == x * 2", "target_text": "use vstd::prelude::*;\n\nverus! {\n\n\n// Library function for use in verified and unverified functions\npub fn double(x: u16) -> (z: u32)\n    ensures z == x * 2,\n{\n    x as u32 + x as u32\n}\n\n// Some corner cases that have been problematic for cargo-verus in the past\n\ntrait Trait: View {}\n\nimpl<T: View> Trait for Option<T> {}\n\nfn test(f:spec_fn(nat) -> nat) {\n}\n\n} // verus!\n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\n\n// Library function for use in verified and unverified functions\npub fn double(x: u16) -> (z: u32)\n    ensures z == x * 2,\n{\n    x as u32 + x as u32\n}\n\n// Some corner cases that have been problematic for cargo-verus in the past\n\ntrait Trait: View {}\n\nimpl<T: View> Trait for Option<T> {}\n\nfn test(f:spec_fn(nat) -> nat) {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/source/rust_verify_test/tests/cargo-tests/verified/basic_verified_lib/src/lib.rs", "verified": true, "metadata": {"original_id": "verus_lib_bfbf64080aaf", "function_name": "", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_0e759adffffd", "task": "task_b", "input_text": "fn cum_sum (a : & Vec < int >) -> (res : Vec < int >)\nensures res . len () == a . len () , a . len () > 0 ==> res [0] == a [0] , forall | i : int | 1 <= i < a . len () ==> res [i] == res [i - 1] + a [i] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cum_sum (a : & Vec < int >) -> (res : Vec < int >) ensures res . len () == a . len () , a . len () > 0 ==> res [0] == a [0] , forall | i : int | 1 <= i < a . len () ==> res [i] == res [i - 1] + a [i] , { let mut res : Vec < int > = Vec :: new () ; for i in 0 .. a . len () invariant res . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] res [j] == if j == 0 { a [0] } else { res [j - 1] + a [j] } , { if i == 0 { res . push (a [i]) ; } else { let prev_val = res [i - 1] ; res . push (prev_val + a [i]) ; } } res }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cum_sum (a : & Vec < int >) -> (res : Vec < int >) ensures res . len () == a . len () , a . len () > 0 ==> res [0] == a [0] , forall | i : int | 1 <= i < a . len () ==> res [i] == res [i - 1] + a [i] , { let mut res : Vec < int > = Vec :: new () ; for i in 0 .. a . len () invariant res . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] res [j] == if j == 0 { a [0] } else { res [j - 1] + a [j] } , { if i == 0 { res . push (a [i]) ; } else { let prev_val = res [i - 1] ; res . push (prev_val + a [i]) ; } } res }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/vericoding_dafny_to_verus_specs/numpy_specs/np_cum_sum_iter_4_current.rs", "verified": true, "metadata": {"original_id": "0e759adffffd", "function_name": "cum_sum", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_requires_e813472caced", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subseq_length_postcond (xs : Seq < i32 > , result : nat) -> bool { result <= xs . len () }\nspec fn longest_increasing_subseq_length_precond (xs : Seq < i32 >) -> bool { true }\nfn longest_increasing_subseq_length (xs : & Vec < i32 >) -> (result : usize)  ensures longest_increasing_subseq_length_postcond (xs @ , result as nat) , { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subseq_length_postcond (xs : Seq < i32 > , result : nat) -> bool { result <= xs . len () }\nspec fn longest_increasing_subseq_length_precond (xs : Seq < i32 >) -> bool { true }\nfn longest_increasing_subseq_length (xs : & Vec < i32 >) -> (result : usize) requires longest_increasing_subseq_length_precond (xs @) , ensures longest_increasing_subseq_length_postcond (xs @ , result as nat) , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subseq_length_postcond (xs : Seq < i32 > , result : nat) -> bool { result <= xs . len () }\nspec fn longest_increasing_subseq_length_precond (xs : Seq < i32 >) -> bool { true }\nfn longest_increasing_subseq_length (xs : & Vec < i32 >) -> (result : usize) requires longest_increasing_subseq_length_precond (xs @) , ensures longest_increasing_subseq_length_postcond (xs @ , result as nat) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_31/verina_advanced_31_iter_0_original.rs", "verified": true, "metadata": {"original_id": "e813472caced", "function_name": "longest_increasing_subseq_length", "bug_type": "missing_requires"}}
{"id": "task_a_8c1f49608d2b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_consecutive_precond (nums : & Vec < i32 >) -> bool { forall | i : int , j : int | 0 <= i < nums . len () && 0 <= j < nums . len () && i != j ==> nums [i] != nums [j] }\nspec fn longest_consecutive_postcond (nums : & Vec < i32 > , result : nat) -> bool { (nums . len () == 0 ==> result == 0) && result <= nums . len () }\nfn longest_consecutive (nums : & Vec < i32 >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_consecutive_precond (nums) \nensures longest_consecutive_postcond (nums , result as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_consecutive_precond (nums : & Vec < i32 >) -> bool { forall | i : int , j : int | 0 <= i < nums . len () && 0 <= j < nums . len () && i != j ==> nums [i] != nums [j] }\nspec fn longest_consecutive_postcond (nums : & Vec < i32 > , result : nat) -> bool { (nums . len () == 0 ==> result == 0) && result <= nums . len () }\nfn longest_consecutive (nums : & Vec < i32 >) -> (result : usize) requires longest_consecutive_precond (nums) , ensures longest_consecutive_postcond (nums , result as nat) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_28/verina_advanced_28.rs", "verified": true, "metadata": {"original_id": "8c1f49608d2b", "function_name": "longest_consecutive", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_3561a6ec4545", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_not_equal (N : i32) -> (i : i32) requires 0 <= N ,  { let mut i = 0 ; while i != N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_not_equal (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i != N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_not_equal (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i != N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "3561a6ec4545", "function_name": "up_while_not_equal", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_f10934436d39", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { i as int } else { i as int - 1 } , forall | j : int | 0 <= j < pos && j < i ==> result [j] == a [j] , forall | j : int | pos < j < i ==> result [j - 1] == a [j] , decreases a . len () - i { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= pos < a . len () , result . len () == if i <= pos { i as int } else { i as int - 1 } , forall | j : int | 0 <= j < pos && j < i ==> result [j] == a [j] , forall | j : int | pos < j < i ==> result [j - 1] == a [j] , decreases a . len () - i { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= pos < a . len () , result . len () == if i <= pos { i as int } else { i as int - 1 } , forall | j : int | 0 <= j < pos && j < i ==> result [j] == a [j] , forall | j : int | pos < j < i ==> result [j - 1] == a [j] , decreases a . len () - i { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/remove_element_iter_3_current.rs", "verified": true, "metadata": {"original_id": "f10934436d39", "function_name": "remove_element", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_5e9cc255e917", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool)  ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () - 1 invariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , decreases nums . len () - 1 - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN , ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () - 1 invariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , decreases nums . len () - 1 - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN , ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () - 1 invariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , decreases nums . len () - 1 - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/043-pairs-sum-to-zero_impl.rs", "verified": true, "metadata": {"original_id": "5e9cc255e917", "function_name": "pairs_sum_to_zero", "bug_type": "missing_requires"}}
{"id": "task_a_a17cd7dcaa30", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool)  { n % 2 == 0 }\n\n} // verus!", "target_text": "ensures result == even (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool) ensures result == even (n as int) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "a17cd7dcaa30", "function_name": "even_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_requires_565b6f8306ad", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool)  ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () - 1 invariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , decreases nums . len () - 1 - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN , ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () - 1 invariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , decreases nums . len () - 1 - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN , ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () - 1 invariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , decreases nums . len () - 1 - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/043-pairs-sum-to-zero_iter_4_current.rs", "verified": true, "metadata": {"original_id": "565b6f8306ad", "function_name": "pairs_sum_to_zero", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_4238801bac99", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool)  ensures true , { return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool) requires true , ensures true , { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool) requires true , ensures true , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "4238801bac99", "function_name": "tangent", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_34b41bac24b8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "34b41bac24b8", "function_name": "any_value_exists", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_c20b16b4f66b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_22/verina_advanced_22_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "c20b16b4f66b", "function_name": "aux", "bug_type": "missing_requires"}}
{"id": "task_b_2229ff3b20ec", "task": "task_b", "input_text": "fn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize)\nensures pos <= dp . len ()", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize) ensures pos <= dp . len () { let mut left : usize = 0 ; let mut right : usize = dp . len () ; while left < right invariant left <= right <= dp . len () decreases right - left { let mid = left + (right - left) / 2 ; if dp [mid] < x { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize) ensures pos <= dp . len () { let mut left : usize = 0 ; let mut right : usize = dp . len () ; while left < right invariant left <= right <= dp . len () decreases right - left { let mid = left + (right - left) / 2 ; if dp [mid] < x { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_24/verina_advanced_24_impl.rs", "verified": true, "metadata": {"original_id": "2229ff3b20ec", "function_name": "binary_search_position", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_invariant_fa3fc34cebcd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut index = 0 ; while index < arr . len ()  { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] , decreases arr . len () - index , { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] , decreases arr . len () - index , { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_433_iter_2_current.rs", "verified": true, "metadata": {"original_id": "fa3fc34cebcd", "function_name": "is_greater", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_e6e7ef5c8f6f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len ()  { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_790_impl.rs", "verified": true, "metadata": {"original_id": "e6e7ef5c8f6f", "function_name": "is_even_at_even_index", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_b46b25419bbd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >)  ensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] , forall | k : int | i <= k < x . len () ==> x @ [k] <= 0x7FFF_FFFB , decreases x . len () - i { let old_val = x [i] ; assert (old_val <= 0x7FFF_FFFB) ; assert (old_val + 4 <= 0x7FFF_FFFF) ; x . set (i , old_val + 4) ; assert (forall | k : int | 0 <= k < i + 1 ==> # [trigger] x @ [k] == old (x) @ [k] + 4) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >) requires forall | k : int | 0 <= k < old (x) . len () ==> old (x) [k] <= 0x7FFF_FFFB , ensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] , forall | k : int | i <= k < x . len () ==> x @ [k] <= 0x7FFF_FFFB , decreases x . len () - i { let old_val = x [i] ; assert (old_val <= 0x7FFF_FFFB) ; assert (old_val + 4 <= 0x7FFF_FFFF) ; x . set (i , old_val + 4) ; assert (forall | k : int | 0 <= k < i + 1 ==> # [trigger] x @ [k] == old (x) @ [k] + 4) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun2 (x : & mut Vec < i32 >) requires forall | k : int | 0 <= k < old (x) . len () ==> old (x) [k] <= 0x7FFF_FFFB , ensures x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , { let mut i = 0 ; while i < x . len () invariant 0 <= i <= x . len () , x @ . len () == old (x) @ . len () , forall | k : int | 0 <= k < i ==> # [trigger] x @ [k] == old (x) @ [k] + 4 , forall | k : int | i <= k < x . len () ==> # [trigger] x @ [k] == old (x) @ [k] , forall | k : int | i <= k < x . len () ==> x @ [k] <= 0x7FFF_FFFB , decreases x . len () - i { let old_val = x [i] ; assert (old_val <= 0x7FFF_FFFB) ; assert (old_val + 4 <= 0x7FFF_FFFF) ; x . set (i , old_val + 4) ; assert (forall | k : int | 0 <= k < i + 1 ==> # [trigger] x @ [k] == old (x) @ [k] + 4) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/map_impl.rs", "verified": true, "metadata": {"original_id": "b46b25419bbd", "function_name": "myfun2", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_c7e6da5e5ec9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n  { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n  { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/largest_prime_factor_impl.rs", "verified": true, "metadata": {"original_id": "c7e6da5e5ec9", "function_name": "largest_prime_factor", "bug_type": "missing_invariant"}}
{"id": "task_a_9fcf5e920c1b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >)  { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "target_text": "ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] \ndecreases arr . len () - i \ninvariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i , { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_307_iter_2_current.rs", "verified": true, "metadata": {"original_id": "9fcf5e920c1b", "function_name": "list_deep_clone", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_requires_93ad0d5e060c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >)  ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_94/verina_basic_94_iter_2_current.rs", "verified": true, "metadata": {"original_id": "93ad0d5e060c", "function_name": "iter_copy", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_ef35a5194918", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) ,  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_618_impl.rs", "verified": true, "metadata": {"original_id": "ef35a5194918", "function_name": "element_wise_divide", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_a439577991c0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | j : int | 0 <= j < arr2 . len () ==> # [trigger] arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] / arr2 [j]) <= MAX) , decreases arr1 . len () - i { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | j : int | 0 <= j < arr2 . len () ==> # [trigger] arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] / arr2 [j]) <= MAX) , decreases arr1 . len () - i { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_618_impl.rs", "verified": true, "metadata": {"original_id": "a439577991c0", "function_name": "element_wise_divide", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_b9ac506e9e48", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF ,  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/unverified/cell_2_sum.rs", "verified": true, "metadata": {"original_id": "b9ac506e9e48", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_b_576bec463ce8", "task": "task_b", "input_text": "fn compare_bool (a : bool , b : bool) -> (eq : bool)\nrequires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_compare/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "576bec463ce8", "function_name": "compare_bool", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_requires_5f30ac57404f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn append_postcond (a : Seq < int > , b : int , result : Seq < int >) -> bool { (forall | i : int | 0 <= i < a . len () ==> result [i] == a [i]) && result [a . len () as int] == b && result . len () == a . len () + 1 }\npub open spec fn append_precond (a : Seq < int > , b : int) -> bool { true }\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >)  ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\npub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >)  ensures append_postcond (a @ , b , result @) , { let mut result = Vec :: new () ; copy (a , 0 , & mut result) ; result . push (b) ; result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn append_postcond (a : Seq < int > , b : int , result : Seq < int >) -> bool { (forall | i : int | 0 <= i < a . len () ==> result [i] == a [i]) && result [a . len () as int] == b && result . len () == a . len () + 1 }\npub open spec fn append_precond (a : Seq < int > , b : int) -> bool { true }\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\npub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >) requires append_precond (a @ , b) , ensures append_postcond (a @ , b , result @) , { let mut result = Vec :: new () ; copy (a , 0 , & mut result) ; result . push (b) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn append_postcond (a : Seq < int > , b : int , result : Seq < int >) -> bool { (forall | i : int | 0 <= i < a . len () ==> result [i] == a [i]) && result [a . len () as int] == b && result . len () == a . len () + 1 }\npub open spec fn append_precond (a : Seq < int > , b : int) -> bool { true }\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\npub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >) requires append_precond (a @ , b) , ensures append_postcond (a @ , b , result @) , { let mut result = Vec :: new () ; copy (a , 0 , & mut result) ; result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_72/verina_basic_72_impl.rs", "verified": true, "metadata": {"original_id": "5f30ac57404f", "function_name": "append", "bug_type": "missing_requires"}}
{"id": "task_a_8b7ef890f90f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool)  { if a . len () == 0 { return true ; } let first = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] != first { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] \ndecreases a . len () - i\ninvariant 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; let mut i = 1 ; while i < a . len () invariant 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first , decreases a . len () - i { if a [i] != first { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/has_only_one_distinct_element_impl.rs", "verified": true, "metadata": {"original_id": "8b7ef890f90f", "function_name": "has_only_one_distinct_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_ensures_68ef5666482a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) ,  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_261_impl.rs", "verified": true, "metadata": {"original_id": "68ef5666482a", "function_name": "element_wise_division", "bug_type": "missing_ensures"}}
{"id": "task_b_fa86143af6a0", "task": "task_b", "input_text": "fn is_integer (text : & [u8]) -> (result : bool)\nensures res == is_digit_spec (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut idx = 0 ; while idx < text . len () invariant forall | i : int | 0 <= i < idx ==> is_digit_spec (text [i]) , decreases text . len () - idx , { if ! is_digit (text [idx]) { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut idx = 0 ; while idx < text . len () invariant forall | i : int | 0 <= i < idx ==> is_digit_spec (text [i]) , decreases text . len () - idx , { if ! is_digit (text [idx]) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "fa86143af6a0", "function_name": "is_integer", "has_invariants": true, "has_asserts": false}}
{"id": "task_a_4d9cde7f473c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32)   { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "target_text": "requires single_digit_prime_factor_precond (n as nat) \nensures single_digit_prime_factor_postcond (n as nat , result as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn single_digit_prime_factor_postcond (n : nat , result : nat) -> bool { (result == 0 || result == 2 || result == 3 || result == 5 || result == 7) && (result == 0 ==> (n == 0 || (n % 2 != 0 && n % 3 != 0 && n % 5 != 0 && n % 7 != 0))) && (result != 0 ==> (n != 0 && n % result == 0 && smaller_prime_factors_dont_divide (n , result))) }\nspec fn single_digit_prime_factor_precond (n : nat) -> bool { true }\nspec fn smaller_prime_factors_dont_divide (n : nat , result : nat) -> bool { if result == 2 { true } else if result == 3 { n % 2 != 0 } else if result == 5 { n % 2 != 0 && n % 3 != 0 } else if result == 7 { n % 2 != 0 && n % 3 != 0 && n % 5 != 0 } else { true } }\nfn single_digit_prime_factor (n : u32) -> (result : u32) requires single_digit_prime_factor_precond (n as nat) , ensures single_digit_prime_factor_postcond (n as nat , result as nat) , { if n == 0 { return 0 ; } if n % 2 == 0 { return 2 ; } if n % 3 == 0 { return 3 ; } if n % 5 == 0 { return 5 ; } if n % 7 == 0 { return 7 ; } return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_72/verina_advanced_72_iter_1_current.rs", "verified": true, "metadata": {"original_id": "4d9cde7f473c", "function_name": "single_digit_prime_factor", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_b_ceaf04c10a8e", "task": "task_b", "input_text": "fn arithmetic_weird () -> (result : i32)\nensures result < 10", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/arithmetic_weird_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ceaf04c10a8e", "function_name": "arithmetic_weird", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_requires_4da0545c264f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32)  ensures r as int == 3 * (x as int) { x * 3 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { x * 3 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "4da0545c264f", "function_name": "triple_conditions", "bug_type": "missing_requires"}}
{"id": "task_a_2ea1bb6c0ea6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32)  { 5 }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { 5 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/arithmetic_weird_impl.rs", "verified": true, "metadata": {"original_id": "2ea1bb6c0ea6", "function_name": "arithmetic_weird", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_invariant_c5833f44f944", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut index = 0 ; while index < arr1 . len ()  { result . push (arr1 [index] ^ arr2 [index]) ; index += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut index = 0 ; while index < arr1 . len () invariant index <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == index , forall | i : int | 0 <= i < index && i < arr1 . len () && i < arr2 . len () ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - index , { result . push (arr1 [index] ^ arr2 [index]) ; index += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut index = 0 ; while index < arr1 . len () invariant index <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == index , forall | i : int | 0 <= i < index && i < arr1 . len () && i < arr2 . len () ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - index , { result . push (arr1 [index] ^ arr2 [index]) ; index += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_399_impl.rs", "verified": true, "metadata": {"original_id": "c5833f44f944", "function_name": "bit_wise_xor", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_d13e9b30a13d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_extend (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () == s3 . len () , 0 <= i < s1 . len () ,  { 1int } else { 0int }) , decreases i , { let sub1 = s1 . subrange (0 , i + 1) ; let sub2 = s2 . subrange (0 , i + 1) ; let sub3 = s3 . subrange (0 , i + 1) ; assert (sub1 . last () == s1 [i]) ; assert (sub2 . last () == s2 [i]) ; assert (sub3 . last () == s3 [i]) ; assert (sub1 . drop_last () == s1 . subrange (0 , i)) ; assert (sub2 . drop_last () == s2 . subrange (0 , i)) ; assert (sub3 . drop_last () == s3 . subrange (0 , i)) ; assert (count_identical (sub1 , sub2 , sub3) == count_identical (sub1 . drop_last () , sub2 . drop_last () , sub3 . drop_last ()) + (if sub1 . last () == sub2 . last () && sub2 . last () == sub3 . last () { 1int } else { 0int })) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () ,  { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , 0 <= count <= i , arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i , { proof { lemma_count_identical_extend (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count = count + 1 ; } i = i + 1 ; } assert (i == arr1 . len ()) ; assert (arr1 @ . subrange (0 , i as int) == arr1 @) ; assert (arr2 @ . subrange (0 , i as int) == arr2 @) ; assert (arr3 @ . subrange (0 , i as int) == arr3 @) ; count }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_extend (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + (if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int }) , decreases i , { let sub1 = s1 . subrange (0 , i + 1) ; let sub2 = s2 . subrange (0 , i + 1) ; let sub3 = s3 . subrange (0 , i + 1) ; assert (sub1 . last () == s1 [i]) ; assert (sub2 . last () == s2 [i]) ; assert (sub3 . last () == s3 [i]) ; assert (sub1 . drop_last () == s1 . subrange (0 , i)) ; assert (sub2 . drop_last () == s2 . subrange (0 , i)) ; assert (sub3 . drop_last () == s3 . subrange (0 , i)) ; assert (count_identical (sub1 , sub2 , sub3) == count_identical (sub1 . drop_last () , sub2 . drop_last () , sub3 . drop_last ()) + (if sub1 . last () == sub2 . last () && sub2 . last () == sub3 . last () { 1int } else { 0int })) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , 0 <= count <= i , arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i , { proof { lemma_count_identical_extend (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count = count + 1 ; } i = i + 1 ; } assert (i == arr1 . len ()) ; assert (arr1 @ . subrange (0 , i as int) == arr1 @) ; assert (arr2 @ . subrange (0 , i as int) == arr2 @) ; assert (arr3 @ . subrange (0 , i as int) == arr3 @) ; count }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_extend (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + (if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int }) , decreases i , { let sub1 = s1 . subrange (0 , i + 1) ; let sub2 = s2 . subrange (0 , i + 1) ; let sub3 = s3 . subrange (0 , i + 1) ; assert (sub1 . last () == s1 [i]) ; assert (sub2 . last () == s2 [i]) ; assert (sub3 . last () == s3 [i]) ; assert (sub1 . drop_last () == s1 . subrange (0 , i)) ; assert (sub2 . drop_last () == s2 . subrange (0 , i)) ; assert (sub3 . drop_last () == s3 . subrange (0 , i)) ; assert (count_identical (sub1 , sub2 , sub3) == count_identical (sub1 . drop_last () , sub2 . drop_last () , sub3 . drop_last ()) + (if sub1 . last () == sub2 . last () && sub2 . last () == sub3 . last () { 1int } else { 0int })) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , 0 <= count <= i , arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i , { proof { lemma_count_identical_extend (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count = count + 1 ; } i = i + 1 ; } assert (i == arr1 . len ()) ; assert (arr1 @ . subrange (0 , i as int) == arr1 @) ; assert (arr2 @ . subrange (0 , i as int) == arr2 @) ; assert (arr3 @ . subrange (0 , i as int) == arr3 @) ; count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_142_impl.rs", "verified": true, "metadata": {"original_id": "d13e9b30a13d", "function_name": "count_identical_position", "bug_type": "missing_ensures"}}
{"id": "task_b_d7a8db92880e", "task": "task_b", "input_text": "fn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)\nensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; let mut found_in_list2 = false ; for j in 0 .. list2 . len () invariant found_in_list2 == (exists | k : int | 0 <= k < j && list2 [k] == elem) , { if list2 [j] == elem { found_in_list2 = true ; } } if found_in_list2 { let mut already_added = false ; for k in 0 .. result . len () invariant already_added == (exists | m : int | 0 <= m < k && result [m] == elem) , { if result [k] == elem { already_added = true ; } } if ! already_added { result . push (elem) ; } } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (result [k]) && list2 @ . contains (result [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; let mut found_in_list2 = false ; for j in 0 .. list2 . len () invariant found_in_list2 == (exists | k : int | 0 <= k < j && list2 [k] == elem) , { if list2 [j] == elem { found_in_list2 = true ; } } if found_in_list2 { let mut already_added = false ; for k in 0 .. result . len () invariant already_added == (exists | m : int | 0 <= m < k && result [m] == elem) , { if result [k] == elem { already_added = true ; } } if ! already_added { result . push (elem) ; } } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "d7a8db92880e", "function_name": "shared_elements", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_ensures_33fe3b1c79f2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 ,  { for i in 0 .. x . len () invariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { for i in 0 .. x . len () invariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { for i in 0 .. x . len () invariant forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { if x [i] % 3 == 0 { y . push (x [i]) ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/filter_weak_impl.rs", "verified": true, "metadata": {"original_id": "33fe3b1c79f2", "function_name": "myfun4", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_36ef68a1fdb4", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn round_up_to_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { addr + space_needed_for_alignment (addr , alignment) }\npub open spec fn is_aligned (addr : int , alignment : int) -> bool recommends 0 < alignment { addr % alignment == 0 }\npub closed spec fn space_needed_for_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { let remainder = addr % alignment ; if remainder == 0 { 0 } else { alignment - remainder } }\npub proof fn lemma_space_needed_for_alignment_works (addr : int , alignment : int) requires 0 < alignment ,  { let remainder = addr % alignment ; if remainder != 0 { assert (addr == alignment * (addr / alignment) + (addr % alignment)) by { lemma_fundamental_div_mod (addr , alignment) ; } assert (addr + alignment - remainder == alignment * (addr / alignment) + alignment) ; assert ((addr + alignment - remainder) % alignment == alignment % alignment) by { lemma_mod_multiples_vanish (addr / alignment , alignment , alignment) ; } } }\npub exec fn get_space_needed_for_alignment (addr : u64 , alignment : u64) -> (result : u64) requires 0 < alignment ,  { let remainder = addr % alignment ; if remainder == 0 { remainder } else { alignment - remainder } }\n# [inline] pub exec fn align_checked_u64 (v : & CheckedU64 , alignment : u64) -> (result : CheckedU64) requires 0 < alignment ,  { proof { lemma_space_needed_for_alignment_works (v @ as int , alignment as int) ; } if v . is_overflowed () { CheckedU64 :: new_overflowed (Ghost (round_up_to_alignment (v @ as int , alignment as int))) } else { v . add_value (get_space_needed_for_alignment (v . unwrap () , alignment)) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn round_up_to_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { addr + space_needed_for_alignment (addr , alignment) }\npub open spec fn is_aligned (addr : int , alignment : int) -> bool recommends 0 < alignment { addr % alignment == 0 }\npub closed spec fn space_needed_for_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { let remainder = addr % alignment ; if remainder == 0 { 0 } else { alignment - remainder } }\npub proof fn lemma_space_needed_for_alignment_works (addr : int , alignment : int) requires 0 < alignment , ensures 0 <= space_needed_for_alignment (addr , alignment) < alignment , is_aligned (addr + space_needed_for_alignment (addr , alignment) , alignment) { let remainder = addr % alignment ; if remainder != 0 { assert (addr == alignment * (addr / alignment) + (addr % alignment)) by { lemma_fundamental_div_mod (addr , alignment) ; } assert (addr + alignment - remainder == alignment * (addr / alignment) + alignment) ; assert ((addr + alignment - remainder) % alignment == alignment % alignment) by { lemma_mod_multiples_vanish (addr / alignment , alignment , alignment) ; } } }\npub exec fn get_space_needed_for_alignment (addr : u64 , alignment : u64) -> (result : u64) requires 0 < alignment , ensures result == space_needed_for_alignment (addr as int , alignment as int) { let remainder = addr % alignment ; if remainder == 0 { remainder } else { alignment - remainder } }\n# [inline] pub exec fn align_checked_u64 (v : & CheckedU64 , alignment : u64) -> (result : CheckedU64) requires 0 < alignment , ensures v @ <= result @ , result @ < v @ + alignment , result @ == round_up_to_alignment (v @ as int , alignment as int) , is_aligned (result @ as int , alignment as int) , { proof { lemma_space_needed_for_alignment_works (v @ as int , alignment as int) ; } if v . is_overflowed () { CheckedU64 :: new_overflowed (Ghost (round_up_to_alignment (v @ as int , alignment as int))) } else { v . add_value (get_space_needed_for_alignment (v . unwrap () , alignment)) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn round_up_to_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { addr + space_needed_for_alignment (addr , alignment) }\npub open spec fn is_aligned (addr : int , alignment : int) -> bool recommends 0 < alignment { addr % alignment == 0 }\npub closed spec fn space_needed_for_alignment (addr : int , alignment : int) -> int recommends 0 < alignment { let remainder = addr % alignment ; if remainder == 0 { 0 } else { alignment - remainder } }\npub proof fn lemma_space_needed_for_alignment_works (addr : int , alignment : int) requires 0 < alignment , ensures 0 <= space_needed_for_alignment (addr , alignment) < alignment , is_aligned (addr + space_needed_for_alignment (addr , alignment) , alignment) { let remainder = addr % alignment ; if remainder != 0 { assert (addr == alignment * (addr / alignment) + (addr % alignment)) by { lemma_fundamental_div_mod (addr , alignment) ; } assert (addr + alignment - remainder == alignment * (addr / alignment) + alignment) ; assert ((addr + alignment - remainder) % alignment == alignment % alignment) by { lemma_mod_multiples_vanish (addr / alignment , alignment , alignment) ; } } }\npub exec fn get_space_needed_for_alignment (addr : u64 , alignment : u64) -> (result : u64) requires 0 < alignment , ensures result == space_needed_for_alignment (addr as int , alignment as int) { let remainder = addr % alignment ; if remainder == 0 { remainder } else { alignment - remainder } }\n# [inline] pub exec fn align_checked_u64 (v : & CheckedU64 , alignment : u64) -> (result : CheckedU64) requires 0 < alignment , ensures v @ <= result @ , result @ < v @ + alignment , result @ == round_up_to_alignment (v @ as int , alignment as int) , is_aligned (result @ as int , alignment as int) , { proof { lemma_space_needed_for_alignment_works (v @ as int , alignment as int) ; } if v . is_overflowed () { CheckedU64 :: new_overflowed (Ghost (round_up_to_alignment (v @ as int , alignment as int))) } else { v . add_value (get_space_needed_for_alignment (v . unwrap () , alignment)) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "capybarakv_inlined.rs", "verified": true, "metadata": {"original_id": "36ef68a1fdb4", "function_name": "align_checked_u64", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_verus_result_d00d0a51788b", "task": "task_c", "input_text": "use vstd::pervasive::runtime_assert;\nuse vstd::prelude::*;\n\nverus! {\n\nfn is_ok_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.is_ok() == true);\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.is_ok() == false);\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.is_ok() == false);\n}\n\nfn map_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    let op = |x: i32| -> (y: i32)\n        requires\n            x < 100000,\n\n        { x + 1 };\n    let r2 = r1.map(op);\n    runtime_assert(r2.unwrap() > 7);\n    let r3: Result<i32, i32> = Err(9);\n    let r4: Result<i32, i32> = r3.map(op);\n    runtime_assert(r4.unwrap_err() == 9);\n}\n\nfn ok_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.ok().is_some());\n    runtime_assert(r1.ok().unwrap() == 7);\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.ok().is_none());\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.ok().is_none());\n    let r4: Result<bool, i32> = Ok(false);\n    runtime_assert(r4.ok().is_some());\n    runtime_assert(r4.ok().unwrap() == false);\n}\n\nfn err_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.err().is_none());\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.err().is_some());\n    runtime_assert(r2.err().unwrap() == 7);\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.err().is_some());\n    runtime_assert(r3.err().unwrap() == true);\n    let r4: Result<bool, i32> = Ok(true);\n    runtime_assert(r4.err().is_none());\n}\n\nfn expect_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.ok().is_some());\n    runtime_assert(r1.ok().expect(\"is ok\") == 7);\n    let r2: Result<bool, i32> = Ok(false);\n    runtime_assert(r2.ok().is_some());\n    runtime_assert(r2.ok().expect(\"is ok\") == false);\n}\n\n} // verus!\n", "target_text": "use vstd::pervasive::runtime_assert;\nuse vstd::prelude::*;\n\nverus! {\n\nfn is_ok_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.is_ok() == true);\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.is_ok() == false);\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.is_ok() == false);\n}\n\nfn map_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    let op = |x: i32| -> (y: i32)\n        requires\n            x < 100000,\n        ensures\n            y > x,\n        { x + 1 };\n    let r2 = r1.map(op);\n    runtime_assert(r2.unwrap() > 7);\n    let r3: Result<i32, i32> = Err(9);\n    let r4: Result<i32, i32> = r3.map(op);\n    runtime_assert(r4.unwrap_err() == 9);\n}\n\nfn ok_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.ok().is_some());\n    runtime_assert(r1.ok().unwrap() == 7);\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.ok().is_none());\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.ok().is_none());\n    let r4: Result<bool, i32> = Ok(false);\n    runtime_assert(r4.ok().is_some());\n    runtime_assert(r4.ok().unwrap() == false);\n}\n\nfn err_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.err().is_none());\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.err().is_some());\n    runtime_assert(r2.err().unwrap() == 7);\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.err().is_some());\n    runtime_assert(r3.err().unwrap() == true);\n    let r4: Result<bool, i32> = Ok(true);\n    runtime_assert(r4.err().is_none());\n}\n\nfn expect_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.ok().is_some());\n    runtime_assert(r1.ok().expect(\"is ok\") == 7);\n    let r2: Result<bool, i32> = Ok(false);\n    runtime_assert(r2.ok().is_some());\n    runtime_assert(r2.ok().expect(\"is ok\") == false);\n}\n\n} // verus!\n", "full_verified_code": "use vstd::pervasive::runtime_assert;\nuse vstd::prelude::*;\n\nverus! {\n\nfn is_ok_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.is_ok() == true);\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.is_ok() == false);\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.is_ok() == false);\n}\n\nfn map_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    let op = |x: i32| -> (y: i32)\n        requires\n            x < 100000,\n        ensures\n            y > x,\n        { x + 1 };\n    let r2 = r1.map(op);\n    runtime_assert(r2.unwrap() > 7);\n    let r3: Result<i32, i32> = Err(9);\n    let r4: Result<i32, i32> = r3.map(op);\n    runtime_assert(r4.unwrap_err() == 9);\n}\n\nfn ok_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.ok().is_some());\n    runtime_assert(r1.ok().unwrap() == 7);\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.ok().is_none());\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.ok().is_none());\n    let r4: Result<bool, i32> = Ok(false);\n    runtime_assert(r4.ok().is_some());\n    runtime_assert(r4.ok().unwrap() == false);\n}\n\nfn err_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.err().is_none());\n    let r2: Result<i32, i32> = Err(7);\n    runtime_assert(r2.err().is_some());\n    runtime_assert(r2.err().unwrap() == 7);\n    let r3: Result<i32, bool> = Err(true);\n    runtime_assert(r3.err().is_some());\n    runtime_assert(r3.err().unwrap() == true);\n    let r4: Result<bool, i32> = Ok(true);\n    runtime_assert(r4.err().is_none());\n}\n\nfn expect_test() {\n    let r1: Result<i32, i32> = Ok(7);\n    runtime_assert(r1.ok().is_some());\n    runtime_assert(r1.ok().expect(\"is ok\") == 7);\n    let r2: Result<bool, i32> = Ok(false);\n    runtime_assert(r2.ok().is_some());\n    runtime_assert(r2.ok().expect(\"is ok\") == false);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/std_test/result.rs", "verified": true, "metadata": {"original_id": "verus_result_d00d0a51788b", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_a_67588e015e9d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32)   { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len ()  { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "target_text": "requires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] \ndecreases nums . len () - j\ninvariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len () invariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] , decreases nums . len () - j { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_62_iter_2_current.rs", "verified": true, "metadata": {"original_id": "67588e015e9d", "function_name": "smallest_num", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_requires_08e5cbd8d9f4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize)  ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut pos = 0 ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; break ; } i += 1 ; } i += 1 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= pos < a . len () , a [pos as int] == elem , forall | j : int | pos < j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; } i += 1 ; } pos }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut pos = 0 ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; break ; } i += 1 ; } i += 1 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= pos < a . len () , a [pos as int] == elem , forall | j : int | pos < j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; } i += 1 ; } pos }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut pos = 0 ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | j : int | 0 <= j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; break ; } i += 1 ; } i += 1 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= pos < a . len () , a [pos as int] == elem , forall | j : int | pos < j < i ==> a [j] != elem , decreases a . len () - i { if a [i] == elem { pos = i ; } i += 1 ; } pos }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/last_position_impl.rs", "verified": true, "metadata": {"original_id": "08e5cbd8d9f4", "function_name": "last_position", "bug_type": "missing_requires"}}
{"id": "task_b_464782cdce4a", "task": "task_b", "input_text": "pub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)\nrequires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum [0] = 6 * (N as i32) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum [0] = 6 * (N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/verified/s52if_impl.rs", "verified": true, "metadata": {"original_id": "464782cdce4a", "function_name": "myfun", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_76d66feff36e", "task": "task_b", "input_text": "pub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)\nrequires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 5 * N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , (5 * N) as i32) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , (5 * N) as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s42if_impl.rs", "verified": true, "metadata": {"original_id": "76d66feff36e", "function_name": "myfun", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_a71ab9dcb389", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize)   { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right  { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] \nensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key \ndecreases right - left\ninvariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_binary_search/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "a71ab9dcb389", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_ensures_4cfbdb158521", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX ,  { return Vec :: new () ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { return Vec :: new () ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_even_list/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "4cfbdb158521", "function_name": "find_even_numbers", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_e7149d4ece38", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () ,  { let mut index = 0 ; while index < arr1 . len () invariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - index , { assert (index < arr2 . len ()) ; if arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut index = 0 ; while index < arr1 . len () invariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - index , { assert (index < arr2 . len ()) ; if arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut index = 0 ; while index < arr1 . len () invariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - index , { assert (index < arr2 . len ()) ; if arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_809_impl.rs", "verified": true, "metadata": {"original_id": "e7149d4ece38", "function_name": "is_smaller", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_41e970df2ec5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool)  ensures is <==> three_distinct_spec (s @ , i as int) , { s [i - 1] != s [i] && s [i] != s [i + 1] && s [i] != s [i + 1] }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { s [i - 1] != s [i] && s [i] != s [i + 1] && s [i] != s [i + 1] }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { s [i - 1] != s [i] && s [i] != s [i + 1] && s [i] != s [i + 1] }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/080-is_happy_impl.rs", "verified": true, "metadata": {"original_id": "41e970df2ec5", "function_name": "three_distinct", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_9a96518386dd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)  ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/is_non_prime_impl.rs", "verified": true, "metadata": {"original_id": "9a96518386dd", "function_name": "is_non_prime", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_49b80751079c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool)  { for i in 0 .. l . len () invariant forall | j : int | 0 <= j < i ==> l [j] < t , { if l [i] >= t { return false ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool) ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t , { for i in 0 .. l . len () invariant forall | j : int | 0 <= j < i ==> l [j] < t , { if l [i] >= t { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn below_threshold (l : & [i32] , t : i32) -> (result : bool) ensures result == forall | i : int | 0 <= i < l . len () ==> l [i] < t , { for i in 0 .. l . len () invariant forall | j : int | 0 <= j < i ==> l [j] < t , { if l [i] >= t { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/052-below-threshold_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "49b80751079c", "function_name": "below_threshold", "bug_type": "missing_ensures"}}
{"id": "task_b_70d2271b1232", "task": "task_b", "input_text": "fn is_integer (text : & [u8]) -> (result : bool)\nensures res == is_digit_spec (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "70d2271b1232", "function_name": "is_integer", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_decreases_87fad8385ba9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut idx = 0 ; while idx < arr . len () invariant forall | i : int | 0 <= i < idx ==> arr [i] != k , { if arr [idx] == k { return true ; } idx += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut idx = 0 ; while idx < arr . len () invariant forall | i : int | 0 <= i < idx ==> arr [i] != k , decreases arr . len () - idx , { if arr [idx] == k { return true ; } idx += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut idx = 0 ; while idx < arr . len () invariant forall | i : int | 0 <= i < idx ==> arr [i] != k , decreases arr . len () - idx , { if arr [idx] == k { return true ; } idx += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_808_iter_2_current.rs", "verified": true, "metadata": {"original_id": "87fad8385ba9", "function_name": "contains_k", "bug_type": "missing_decreases"}}
{"id": "task_b_10a228758399", "task": "task_b", "input_text": "fn monotonic (l : Vec < i32 >) -> (ret : bool)\nensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; let mut i = 0 ; while i < l . len () - 1 invariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) , decreases l . len () - 1 - i { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } i += 1 ; } is_non_decreasing || is_non_increasing }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; let mut i = 0 ; while i < l . len () - 1 invariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) , decreases l . len () - 1 - i { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } i += 1 ; } is_non_decreasing || is_non_increasing }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/057-monotonic_iter_2_current.rs", "verified": true, "metadata": {"original_id": "10a228758399", "function_name": "monotonic", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_invariant_f5ab7af4643e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 decreases a . len () { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >) requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1 ensures out . len () == size { let mut result = Vec :: new () ; let mut i = 0 ; while i < size  { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 decreases a . len () { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >) requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1 ensures out . len () == size { let mut result = Vec :: new () ; let mut i = 0 ; while i < size invariant i <= size , result . len () == i decreases size - i { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 decreases a . len () { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >) requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1 ensures out . len () == size { let mut result = Vec :: new () ; let mut i = 0 ; while i < size invariant i <= size , result . len () == i decreases size - i { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/703FinalProject_tmp_tmpr_10rn4z_gaussian/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f5ab7af4643e", "function_name": "gaussian", "bug_type": "missing_invariant"}}
{"id": "task_a_4e6d0475eead", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 4 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s3lif_impl.rs", "verified": true, "metadata": {"original_id": "4e6d0475eead", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_df3e93b849b3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32)  { if a >= b { a } else { b } }\n\n} // verus!", "target_text": "ensures c >= a && c >= b", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32) ensures c >= a && c >= b { if a >= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Programs_tmp_tmp99966ew4_mymax/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "df3e93b849b3", "function_name": "max", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_invariant_aef9dfb8e0b7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut i = a . len () - 1 ; loop  { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; } proof { assert (forall | j : int | 0 <= j < a . len () ==> a [j] != elem) ; assert (exists | k : int | 0 <= k < a . len () && a [k] == elem) ; assert (false) ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut i = a . len () - 1 ; loop invariant 0 <= i < a . len () , forall | j : int | i < j < a . len () ==> a [j] != elem , decreases i { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; } proof { assert (forall | j : int | 0 <= j < a . len () ==> a [j] != elem) ; assert (exists | k : int | 0 <= k < a . len () && a [k] == elem) ; assert (false) ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut i = a . len () - 1 ; loop invariant 0 <= i < a . len () , forall | j : int | i < j < a . len () ==> a [j] != elem , decreases i { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; } proof { assert (forall | j : int | 0 <= j < a . len () ==> a [j] != elem) ; assert (exists | k : int | 0 <= k < a . len () && a [k] == elem) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/preconditions_removed/last_position_iter_2_current.rs", "verified": true, "metadata": {"original_id": "aef9dfb8e0b7", "function_name": "last_position", "bug_type": "missing_invariant"}}
{"id": "task_a_d5076568e671", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  {   let div_result = arr1 [i] / arr2 [i] ; result . push (div_result) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) \ndecreases arr1 . len () - i \ninvariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i , { assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let div_result = arr1 [i] / arr2 [i] ; result . push (div_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_261_impl.rs", "verified": true, "metadata": {"original_id": "d5076568e671", "function_name": "element_wise_division", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_1cb00516fc41", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32)   { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , min_array_precond (a) \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_75/verina_basic_75_impl.rs", "verified": true, "metadata": {"original_id": "1cb00516fc41", "function_name": "min_array", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_c_missing_invariant_350655feed65", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_characters_same_precond (chars : & Vec < char >) -> bool { true }\nspec fn all_characters_same_postcond (chars : & Vec < char > , result : bool) -> bool { let char_seq = chars @ ; (result ==> pairwise_equal (char_seq)) && (! result ==> (char_seq . len () != 0 && exists_different_from_first (char_seq))) }\nspec fn pairwise_equal < T > (seq : Seq < T >) -> bool { forall | i : int , j : int | 0 <= i < seq . len () && 0 <= j < seq . len () ==> seq [i] == seq [j] }\nspec fn exists_different_from_first < T : PartialEq > (seq : Seq < T >) -> bool { seq . len () > 0 && exists | i : int | 1 <= i < seq . len () && # [trigger] seq [i] != seq [0] }\nfn all_characters_same (chars : & Vec < char >) -> (result : bool) requires all_characters_same_precond (chars) ensures all_characters_same_postcond (chars , result) { if chars . len () == 0 { return true ; } let first_char = chars [0] ; let mut i = 1 ; while i < chars . len ()  { if chars [i] != first_char { return false ; } i += 1 ; } proof { assert (forall | j : int , k : int | 0 <= j < chars @ . len () && 0 <= k < chars @ . len () ==> chars @ [j] == chars @ [k]) by { assert (forall | j : int | 0 <= j < chars @ . len () ==> chars @ [j] == first_char) ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_characters_same_precond (chars : & Vec < char >) -> bool { true }\nspec fn all_characters_same_postcond (chars : & Vec < char > , result : bool) -> bool { let char_seq = chars @ ; (result ==> pairwise_equal (char_seq)) && (! result ==> (char_seq . len () != 0 && exists_different_from_first (char_seq))) }\nspec fn pairwise_equal < T > (seq : Seq < T >) -> bool { forall | i : int , j : int | 0 <= i < seq . len () && 0 <= j < seq . len () ==> seq [i] == seq [j] }\nspec fn exists_different_from_first < T : PartialEq > (seq : Seq < T >) -> bool { seq . len () > 0 && exists | i : int | 1 <= i < seq . len () && # [trigger] seq [i] != seq [0] }\nfn all_characters_same (chars : & Vec < char >) -> (result : bool) requires all_characters_same_precond (chars) ensures all_characters_same_postcond (chars , result) { if chars . len () == 0 { return true ; } let first_char = chars [0] ; let mut i = 1 ; while i < chars . len () invariant 1 <= i <= chars . len () , forall | j : int | 0 <= j < i ==> chars @ [j] == first_char , decreases chars . len () - i { if chars [i] != first_char { return false ; } i += 1 ; } proof { assert (forall | j : int , k : int | 0 <= j < chars @ . len () && 0 <= k < chars @ . len () ==> chars @ [j] == chars @ [k]) by { assert (forall | j : int | 0 <= j < chars @ . len () ==> chars @ [j] == first_char) ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_characters_same_precond (chars : & Vec < char >) -> bool { true }\nspec fn all_characters_same_postcond (chars : & Vec < char > , result : bool) -> bool { let char_seq = chars @ ; (result ==> pairwise_equal (char_seq)) && (! result ==> (char_seq . len () != 0 && exists_different_from_first (char_seq))) }\nspec fn pairwise_equal < T > (seq : Seq < T >) -> bool { forall | i : int , j : int | 0 <= i < seq . len () && 0 <= j < seq . len () ==> seq [i] == seq [j] }\nspec fn exists_different_from_first < T : PartialEq > (seq : Seq < T >) -> bool { seq . len () > 0 && exists | i : int | 1 <= i < seq . len () && # [trigger] seq [i] != seq [0] }\nfn all_characters_same (chars : & Vec < char >) -> (result : bool) requires all_characters_same_precond (chars) ensures all_characters_same_postcond (chars , result) { if chars . len () == 0 { return true ; } let first_char = chars [0] ; let mut i = 1 ; while i < chars . len () invariant 1 <= i <= chars . len () , forall | j : int | 0 <= j < i ==> chars @ [j] == first_char , decreases chars . len () - i { if chars [i] != first_char { return false ; } i += 1 ; } proof { assert (forall | j : int , k : int | 0 <= j < chars @ . len () && 0 <= k < chars @ . len () ==> chars @ [j] == chars @ [k]) by { assert (forall | j : int | 0 <= j < chars @ . len () ==> chars @ [j] == first_char) ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_38/verina_basic_38_impl.rs", "verified": true, "metadata": {"original_id": "350655feed65", "function_name": "all_characters_same", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_c7975defa497", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () ,  { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ . len () == i , new_list @ == list @ . subrange (0 , i as int) , decreases (k - 1) - i , { assert (i < list . len ()) ; new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len () invariant k <= j <= list . len () , new_list @ . len () == (k - 1) + (j - k) , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ . len () == i , new_list @ == list @ . subrange (0 , i as int) , decreases (k - 1) - i , { assert (i < list . len ()) ; new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len () invariant k <= j <= list . len () , new_list @ . len () == (k - 1) + (j - k) , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ . len () == i , new_list @ == list @ . subrange (0 , i as int) , decreases (k - 1) - i , { assert (i < list . len ()) ; new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len () invariant k <= j <= list . len () , new_list @ . len () == (k - 1) + (j - k) , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_610_impl.rs", "verified": true, "metadata": {"original_id": "c7975defa497", "function_name": "remove_kth_element", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_f8c555db494e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len ()  { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , decreases a . len () - idx , { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , decreases a . len () - idx , { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_product_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f8c555db494e", "function_name": "array_product", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_7a561411b753", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/ms3_impl.rs", "verified": true, "metadata": {"original_id": "7a561411b753", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_b_ce07ee509f10", "task": "task_b", "input_text": "pub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)\nrequires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 2 * N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s2if_impl.rs", "verified": true, "metadata": {"original_id": "ce07ee509f10", "function_name": "myfun", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_8859c72c44f1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_element (a : & Vec < i32 >) -> (max : i32)   { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len ()  { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures forall | i : int | 0 <= i < a . len () ==> a @ [i] <= max , exists | i : int | 0 <= i < a . len () && a @ [i] == max \ndecreases a . len () - idx\ninvariant 1 <= idx <= a . len () , forall | i : int | 0 <= i < idx ==> a @ [i] <= max , exists | i : int | 0 <= i < idx && a @ [i] == max ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_element (a : & Vec < i32 >) -> (max : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a @ [i] <= max , exists | i : int | 0 <= i < a . len () && a @ [i] == max , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 1 <= idx <= a . len () , forall | i : int | 0 <= i < idx ==> a @ [i] <= max , exists | i : int | 0 <= i < idx && a @ [i] == max , decreases a . len () - idx { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/035-max-element_impl.rs", "verified": true, "metadata": {"original_id": "8859c72c44f1", "function_name": "max_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_b_fe45d7bb9bcc", "task": "task_b", "input_text": "fn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)\nensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] , { if arr [i] >= number { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] , { if arr [i] >= number { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_433_impl.rs", "verified": true, "metadata": {"original_id": "fe45d7bb9bcc", "function_name": "is_greater", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_ensures_7103b723a5f6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_808_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "7103b723a5f6", "function_name": "contains_k", "bug_type": "missing_ensures"}}
{"id": "task_a_0a223afbb7a1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >)   { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "target_text": "requires v . len () <= 100 \nensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/CloverBench/verified/array_append_strong_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "0a223afbb7a1", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_decreases_ec8090f2b64a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_567_impl.rs", "verified": true, "metadata": {"original_id": "ec8090f2b64a", "function_name": "is_sorted", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_67c91cec2fab", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >)  ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | # ! [auto] 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { row . push (a [i] [j] + b [i] [j]) ; } c . push (row) ; } c }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | # ! [auto] 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { row . push (a [i] [j] + b [i] [j]) ; } c . push (row) ; } c }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | # ! [auto] 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { row . push (a [i] [j] + b [i] [j]) ; } c . push (row) ; } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/invariants_removed/index_wise_addition_impl.rs", "verified": true, "metadata": {"original_id": "67c91cec2fab", "function_name": "index_wise_addition", "bug_type": "missing_requires"}}
{"id": "task_a_950e363ff8ac", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 \nensures sum [0] <= 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/res1o_impl.rs", "verified": true, "metadata": {"original_id": "950e363ff8ac", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_invariant_ed503af431ee", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len ()  { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_230_impl.rs", "verified": true, "metadata": {"original_id": "ed503af431ee", "function_name": "replace_blanks_with_chars", "bug_type": "missing_invariant"}}
{"id": "task_a_74c99236de02", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn merge_intervals (sorted_intervals : Vec < (usize , usize) >) -> (result : Vec < (usize , usize) >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "ensures result @ . len () <= sorted_intervals @ . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn merge_intervals (sorted_intervals : Vec < (usize , usize) >) -> (result : Vec < (usize , usize) >) ensures result @ . len () <= sorted_intervals @ . len () { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_38/verina_advanced_38_iter_0_original.rs", "verified": true, "metadata": {"original_id": "74c99236de02", "function_name": "merge_intervals", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_requires_3815f6d0de6e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s3if_impl.rs", "verified": true, "metadata": {"original_id": "3815f6d0de6e", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_ca639623ac23", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >) requires a . len () <= 100 , ensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] , { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { b . push (a [i]) ; i += 1 ; } b }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >) requires a . len () <= 100 , ensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] , { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] , decreases a . len () - i , { b . push (a [i]) ; i += 1 ; } b }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >) requires a . len () <= 100 , ensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] , { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] , decreases a . len () - i , { b . push (a [i]) ; i += 1 ; } b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/unverified/array_copy_strong_impl.rs", "verified": true, "metadata": {"original_id": "ca639623ac23", "function_name": "copy", "bug_type": "missing_invariant"}}
{"id": "task_a_60174e37a666", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 4 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 4 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/ms5_impl.rs", "verified": true, "metadata": {"original_id": "60174e37a666", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_b_3b59283454f1", "task": "task_b", "input_text": "pub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >)\nrequires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , append_precond (a @ , b) \nensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , append_postcond (a @ , b , result @) , acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn append_postcond (a : Seq < int > , b : int , result : Seq < int >) -> bool { (forall | i : int | 0 <= i < a . len () ==> result [i] == a [i]) && result [a . len () as int] == b && result . len () == a . len () + 1 }\npub open spec fn append_precond (a : Seq < int > , b : int) -> bool { true }\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\npub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >) requires append_precond (a @ , b) , ensures append_postcond (a @ , b , result @) , { let mut result = Vec :: new () ; copy (a , 0 , & mut result) ; result . push (b) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn append_postcond (a : Seq < int > , b : int , result : Seq < int >) -> bool { (forall | i : int | 0 <= i < a . len () ==> result [i] == a [i]) && result [a . len () as int] == b && result . len () == a . len () + 1 }\npub open spec fn append_precond (a : Seq < int > , b : int) -> bool { true }\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\npub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >) requires append_precond (a @ , b) , ensures append_postcond (a @ , b , result @) , { let mut result = Vec :: new () ; copy (a , 0 , & mut result) ; result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_72/verina_basic_72_iter_1_current.rs", "verified": true, "metadata": {"original_id": "3b59283454f1", "function_name": "append", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_decreases_3fd1866c621d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_69/verina_basic_69_iter_1_current.rs", "verified": true, "metadata": {"original_id": "3fd1866c621d", "function_name": "linear_search_aux", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_bd72405ce164", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 ,  { sum [0] = N ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= N , { sum [0] = N ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= N , { sum [0] = N ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/brs1_impl.rs", "verified": true, "metadata": {"original_id": "bd72405ce164", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_ef181f52950f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isSublist_precond (sub : Seq < i32 > , main : Seq < i32 >) -> bool { true }\nfn main () { }\nfn isSublist (sub : Vec < i32 > , main : Vec < i32 >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isSublist_precond (sub : Seq < i32 > , main : Seq < i32 >) -> bool { true }\nfn main () { }\nfn isSublist (sub : Vec < i32 > , main : Vec < i32 >) -> (result : bool) requires isSublist_precond (sub @ , main @) { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isSublist_precond (sub : Seq < i32 > , main : Seq < i32 >) -> bool { true }\nfn main () { }\nfn isSublist (sub : Vec < i32 > , main : Vec < i32 >) -> (result : bool) requires isSublist_precond (sub @ , main @) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_21/verina_basic_21.rs", "verified": true, "metadata": {"original_id": "ef181f52950f", "function_name": "isSublist", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_fcc40bdcef11", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn letter_combinations_postcond (digits : Seq < char > , result : Seq < Seq < char > >) -> bool { if digits . len () == 0 { result . len () == 0 } else if has_invalid_digit (digits) { result . len () == 0 } else { true } }\nspec fn is_valid_digit (c : char) -> bool { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nspec fn letter_combinations_precond (digits : Seq < char >) -> bool { true }\nspec fn has_invalid_digit (digits : Seq < char >) -> bool { exists | i : int | 0 <= i < digits . len () && ! is_valid_digit (digits [i]) }\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >)  { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len () invariant 0 <= i <= current_letters . len () { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len () invariant 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len () { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len () invariant 0 <= k <= rest . len () , combination . len () == k + 1 { combination . push (rest [k]) ; } result . push (combination) ; } } result }\nfn is_valid_digit_exec (c : char) -> (result : bool) ensures result == is_valid_digit (c) { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn letter_combinations (digits : Vec < char >) -> (result : Vec < Vec < char > >)  ensures letter_combinations_postcond (digits @ , result @ . map_values (| s : Vec < char > | s @)) { if digits . len () == 0 { return Vec :: new () ; } for i in 0 .. digits . len () invariant 0 <= i <= digits . len () , forall | j : int | 0 <= j < i ==> is_valid_digit (digits @ [j]) { if ! is_valid_digit_exec (digits [i]) { return Vec :: new () ; } } go (& digits , 0) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn letter_combinations_postcond (digits : Seq < char > , result : Seq < Seq < char > >) -> bool { if digits . len () == 0 { result . len () == 0 } else if has_invalid_digit (digits) { result . len () == 0 } else { true } }\nspec fn is_valid_digit (c : char) -> bool { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nspec fn letter_combinations_precond (digits : Seq < char >) -> bool { true }\nspec fn has_invalid_digit (digits : Seq < char >) -> bool { exists | i : int | 0 <= i < digits . len () && ! is_valid_digit (digits [i]) }\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >) requires start <= chars . len () decreases chars . len () - start { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len () invariant 0 <= i <= current_letters . len () { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len () invariant 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len () { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len () invariant 0 <= k <= rest . len () , combination . len () == k + 1 { combination . push (rest [k]) ; } result . push (combination) ; } } result }\nfn is_valid_digit_exec (c : char) -> (result : bool) ensures result == is_valid_digit (c) { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn letter_combinations (digits : Vec < char >) -> (result : Vec < Vec < char > >) requires letter_combinations_precond (digits @) ensures letter_combinations_postcond (digits @ , result @ . map_values (| s : Vec < char > | s @)) { if digits . len () == 0 { return Vec :: new () ; } for i in 0 .. digits . len () invariant 0 <= i <= digits . len () , forall | j : int | 0 <= j < i ==> is_valid_digit (digits @ [j]) { if ! is_valid_digit_exec (digits [i]) { return Vec :: new () ; } } go (& digits , 0) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn letter_combinations_postcond (digits : Seq < char > , result : Seq < Seq < char > >) -> bool { if digits . len () == 0 { result . len () == 0 } else if has_invalid_digit (digits) { result . len () == 0 } else { true } }\nspec fn is_valid_digit (c : char) -> bool { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nspec fn letter_combinations_precond (digits : Seq < char >) -> bool { true }\nspec fn has_invalid_digit (digits : Seq < char >) -> bool { exists | i : int | 0 <= i < digits . len () && ! is_valid_digit (digits [i]) }\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >) requires start <= chars . len () decreases chars . len () - start { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len () invariant 0 <= i <= current_letters . len () { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len () invariant 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len () { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len () invariant 0 <= k <= rest . len () , combination . len () == k + 1 { combination . push (rest [k]) ; } result . push (combination) ; } } result }\nfn is_valid_digit_exec (c : char) -> (result : bool) ensures result == is_valid_digit (c) { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn letter_combinations (digits : Vec < char >) -> (result : Vec < Vec < char > >) requires letter_combinations_precond (digits @) ensures letter_combinations_postcond (digits @ , result @ . map_values (| s : Vec < char > | s @)) { if digits . len () == 0 { return Vec :: new () ; } for i in 0 .. digits . len () invariant 0 <= i <= digits . len () , forall | j : int | 0 <= j < i ==> is_valid_digit (digits @ [j]) { if ! is_valid_digit_exec (digits [i]) { return Vec :: new () ; } } go (& digits , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_26/verina_advanced_26_iter_5_current.rs", "verified": true, "metadata": {"original_id": "fcc40bdcef11", "function_name": "letter_combinations", "bug_type": "missing_requires"}}
{"id": "task_a_2d7c9dd4ee5e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - idx\ninvariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_775_iter_2_current.rs", "verified": true, "metadata": {"original_id": "2d7c9dd4ee5e", "function_name": "is_odd_at_odd_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_ensures_aa21f257d2de", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& shared , elem) { shared . push (elem) ; } } shared }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& shared , elem) { shared . push (elem) ; } } shared }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& shared , elem) { shared . push (elem) ; } } shared }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "aa21f257d2de", "function_name": "shared_elements", "bug_type": "missing_ensures"}}
{"id": "task_b_6f431219a479", "task": "task_b", "input_text": "fn unique_better (a : & [i32]) -> (result : Vec < i32 >)\nrequires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] \nensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique_better (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () > 0 , result [result . len () - 1] == a [i - 1] || (exists | k : int | 0 <= k < i - 1 && result [result . len () - 1] == a [k] && forall | j : int | k < j < i ==> a [j] == a [k]) , forall | x : int , y : int | 0 <= x < y < result . len () ==> result [x] < result [y] , forall | j : int | # ! [trigger result [j]] 0 <= j < result . len () ==> exists | k : int | 0 <= k < i && result [j] == a [k] , decreases a . len () - i { if a [i] > result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique_better (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { let mut result = Vec :: new () ; if a . len () == 0 { return result ; } result . push (a [0]) ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () > 0 , result [result . len () - 1] == a [i - 1] || (exists | k : int | 0 <= k < i - 1 && result [result . len () - 1] == a [k] && forall | j : int | k < j < i ==> a [j] == a [k]) , forall | x : int , y : int | 0 <= x < y < result . len () ==> result [x] < result [y] , forall | j : int | # ! [trigger result [j]] 0 <= j < result . len () ==> exists | k : int | 0 <= k < i && result [j] == a [k] , decreases a . len () - i { if a [i] > result [result . len () - 1] { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/unique_better_impl.rs", "verified": true, "metadata": {"original_id": "6f431219a479", "function_name": "unique_better", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_decreases_19a0ce8547b0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/max_dafny_lsp_iter_2_current.rs", "verified": true, "metadata": {"original_id": "19a0ce8547b0", "function_name": "max_dafny_lsp", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_assert_verus_broadcast_proof_a0c86e101dd0", "task": "task_c", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)] use vstd::prelude::*;\n\nverus! {\n  mod lib {\n    #[allow(unused_imports)] use super::*;\n\n    pub proof fn mod_add_zero(a: int, b: int, c: int)\n        // by (integer_ring)\n        requires\n            a % c == 0,\n            b % c == 0,\n        ensures\n            (a + b) % c == 0,\n    {\n      admit();\n    }\n\n    pub open spec fn same_or_arbitrary<A>(a1: A, a2: A) -> A {\n      if a1 == a2 {\n        a1\n      } else {\n        arbitrary()\n      }\n    }\n  }\n\n  mod multiple_open {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n\n    impl Multiple {\n      pub open spec fn aligned(&self) -> bool {\n        &&& self.i % self.modulo == 0\n      }\n\n      pub open spec fn add(&self, v: nat) -> Self {\n        Multiple { i: self.i + v, ..*self }\n      }\n    }\n  }\n\n  mod m1 {\n    #[allow(unused_imports)] use super::*;\n\n    use super::multiple_open::Multiple;\n\n    proof fn lemma_increase_by_twice(\n        p1: Multiple, v: nat, p2: Multiple)\n      requires\n        p1.modulo != 0, p1.aligned(),\n        v % p1.modulo == 0,\n        p1.modulo == p2.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n      //\n        super::lib::mod_add_zero(\n          p1.i as int + v as int, v as int, p2.modulo as int);\n      }\n    }\n  }\n\n  mod multiple_broadcast_proof {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n\n    impl Multiple {\n      pub closed spec fn aligned(&self) -> bool {\n        &&& self.modulo != 0\n        &&& self.i % self.modulo == 0\n      }\n\n      pub closed spec fn add(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i + v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n\n      pub closed spec fn mul(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i * v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n\n      pub broadcast proof fn lemma_add_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.add(v)).aligned(),\n          p.add(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        super::lib::mod_add_zero(p.i as int, v.i as int, p.modulo as int);\n      }\n\n      pub broadcast proof fn lemma_mul_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.mul(v)).aligned(),\n          p.mul(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        // TODO\n        admit();\n      }\n\n      pub broadcast group group_properties {\n        Multiple::lemma_add_aligned,\n        Multiple::lemma_mul_aligned,\n      }\n    }\n  }\n\n  mod m2 {\n    #[allow(unused_imports)] use super::*;\n\n    use super::multiple_broadcast_proof::Multiple;\n\n    broadcast use Multiple::lemma_add_aligned;\n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    }\n\n  }\n\n  mod m3 {\n    #[allow(unused_imports)] use super::*;\n\n    use super::multiple_broadcast_proof::Multiple;\n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n\n    proof fn multiply_add(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.mul(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n\n    proof fn some_vstd_lemma()\n    {\n      let a = seq![1nat, 2, 3];\n\n    }\n  }\n\n} // verus!", "target_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)] use vstd::prelude::*;\n\nverus! {\n  mod lib {\n    #[allow(unused_imports)] use super::*;\n\n    pub proof fn mod_add_zero(a: int, b: int, c: int)\n        // by (integer_ring)\n        requires\n            a % c == 0,\n            b % c == 0,\n        ensures\n            (a + b) % c == 0,\n    {\n      admit();\n    }\n    \n    pub open spec fn same_or_arbitrary<A>(a1: A, a2: A) -> A {\n      if a1 == a2 {\n        a1\n      } else {\n        arbitrary()\n      }\n    }\n  }\n\n  mod multiple_open {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n    \n    impl Multiple {\n      pub open spec fn aligned(&self) -> bool {\n        &&& self.i % self.modulo == 0\n      }\n    \n      pub open spec fn add(&self, v: nat) -> Self {\n        Multiple { i: self.i + v, ..*self }\n      }\n    }\n  }\n  \n  mod m1 {\n    #[allow(unused_imports)] use super::*;\n\n    use super::multiple_open::Multiple;\n  \n    proof fn lemma_increase_by_twice(\n        p1: Multiple, v: nat, p2: Multiple)\n      requires\n        p1.modulo != 0, p1.aligned(),\n        v % p1.modulo == 0,\n        p1.modulo == p2.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n      // assert((p1.i + v + v) % p2.modulo == 0) by (nonlinear_arith)\n      //   requires\n      //     p1.i % p2.modulo == 0,\n      //     v % p2.modulo == 0,\n      //     p2.modulo != 0,\n      // { }\n      assert((p1.i + v + v) % p2.modulo == 0) by {\n        super::lib::mod_add_zero(\n          p1.i as int, v as int, p2.modulo as int);\n        super::lib::mod_add_zero(\n          p1.i as int + v as int, v as int, p2.modulo as int);\n      }\n    }\n  }\n  \n  \n  mod multiple_broadcast_proof {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n    \n    impl Multiple {\n      pub closed spec fn aligned(&self) -> bool {\n        &&& self.modulo != 0\n        &&& self.i % self.modulo == 0\n      }\n\n      pub closed spec fn add(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i + v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n\n      pub closed spec fn mul(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i * v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n      \n      pub broadcast proof fn lemma_add_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.add(v)).aligned(),\n          p.add(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        super::lib::mod_add_zero(p.i as int, v.i as int, p.modulo as int);\n      }\n\n      pub broadcast proof fn lemma_mul_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.mul(v)).aligned(),\n          p.mul(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        // TODO\n        admit();\n      }\n\n      pub broadcast group group_properties {\n        Multiple::lemma_add_aligned,\n        Multiple::lemma_mul_aligned,\n      }\n    }\n  }\n\n  mod m2 {\n    #[allow(unused_imports)] use super::*;\n      \n    use super::multiple_broadcast_proof::Multiple;\n    \n    broadcast use Multiple::lemma_add_aligned;\n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    }\n\n  }\n\n  mod m3 {\n    #[allow(unused_imports)] use super::*;\n      \n    use super::multiple_broadcast_proof::Multiple;\n    \n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n    \n    proof fn multiply_add(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.mul(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n    \n    proof fn some_vstd_lemma()\n    {\n      let a = seq![1nat, 2, 3];\n      assert(a[2] == 3);\n    }\n  }\n  \n} // verus!", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)] use vstd::prelude::*;\n\nverus! {\n  mod lib {\n    #[allow(unused_imports)] use super::*;\n\n    pub proof fn mod_add_zero(a: int, b: int, c: int)\n        // by (integer_ring)\n        requires\n            a % c == 0,\n            b % c == 0,\n        ensures\n            (a + b) % c == 0,\n    {\n      admit();\n    }\n    \n    pub open spec fn same_or_arbitrary<A>(a1: A, a2: A) -> A {\n      if a1 == a2 {\n        a1\n      } else {\n        arbitrary()\n      }\n    }\n  }\n\n  mod multiple_open {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n    \n    impl Multiple {\n      pub open spec fn aligned(&self) -> bool {\n        &&& self.i % self.modulo == 0\n      }\n    \n      pub open spec fn add(&self, v: nat) -> Self {\n        Multiple { i: self.i + v, ..*self }\n      }\n    }\n  }\n  \n  mod m1 {\n    #[allow(unused_imports)] use super::*;\n\n    use super::multiple_open::Multiple;\n  \n    proof fn lemma_increase_by_twice(\n        p1: Multiple, v: nat, p2: Multiple)\n      requires\n        p1.modulo != 0, p1.aligned(),\n        v % p1.modulo == 0,\n        p1.modulo == p2.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n      // assert((p1.i + v + v) % p2.modulo == 0) by (nonlinear_arith)\n      //   requires\n      //     p1.i % p2.modulo == 0,\n      //     v % p2.modulo == 0,\n      //     p2.modulo != 0,\n      // { }\n      assert((p1.i + v + v) % p2.modulo == 0) by {\n        super::lib::mod_add_zero(\n          p1.i as int, v as int, p2.modulo as int);\n        super::lib::mod_add_zero(\n          p1.i as int + v as int, v as int, p2.modulo as int);\n      }\n    }\n  }\n  \n  \n  mod multiple_broadcast_proof {\n    #[allow(unused_imports)] use super::*;\n\n    pub struct Multiple {\n      pub i: nat,\n      pub modulo: nat,\n    }\n    \n    impl Multiple {\n      pub closed spec fn aligned(&self) -> bool {\n        &&& self.modulo != 0\n        &&& self.i % self.modulo == 0\n      }\n\n      pub closed spec fn add(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i + v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n\n      pub closed spec fn mul(&self, v: Self) -> Self {\n        Multiple {\n            i: self.i * v.i,\n            modulo: lib::same_or_arbitrary(self.modulo, v.modulo)\n        }\n      }\n      \n      pub broadcast proof fn lemma_add_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.add(v)).aligned(),\n          p.add(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        super::lib::mod_add_zero(p.i as int, v.i as int, p.modulo as int);\n      }\n\n      pub broadcast proof fn lemma_mul_aligned(p: Self, v: Self)\n        requires\n          p.aligned(), v.aligned(), p.modulo == v.modulo,\n        ensures\n          (#[trigger] p.mul(v)).aligned(),\n          p.mul(v).modulo == lib::same_or_arbitrary(p.modulo, v.modulo),\n      {\n        // TODO\n        admit();\n      }\n\n      pub broadcast group group_properties {\n        Multiple::lemma_add_aligned,\n        Multiple::lemma_mul_aligned,\n      }\n    }\n  }\n\n  mod m2 {\n    #[allow(unused_imports)] use super::*;\n      \n    use super::multiple_broadcast_proof::Multiple;\n    \n    broadcast use Multiple::lemma_add_aligned;\n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    }\n\n  }\n\n  mod m3 {\n    #[allow(unused_imports)] use super::*;\n      \n    use super::multiple_broadcast_proof::Multiple;\n    \n\n    proof fn increase_twice(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.add(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n    \n    proof fn multiply_add(\n        p1: Multiple, v: Multiple, p2: Multiple)\n      requires\n        p1.aligned(), v.aligned(), p1.modulo == v.modulo,\n        p2 == p1.mul(v).add(v),\n      ensures\n        p2.aligned()\n    {\n    broadcast use Multiple::group_properties;\n    }\n    \n    proof fn some_vstd_lemma()\n    {\n      let a = seq![1nat, 2, 3];\n      assert(a[2] == 3);\n    }\n  }\n  \n} // verus!", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/broadcast_proof.rs", "verified": true, "metadata": {"original_id": "verus_broadcast_proof_a0c86e101dd0", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_c_missing_ensures_18d0b3583f5d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 ,  { sum . set (0 , 2 * N as i32) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N as i32) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s12if_impl.rs", "verified": true, "metadata": {"original_id": "18d0b3583f5d", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_365d1b5de023", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "365d1b5de023", "function_name": "any_value_exists", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_2d2df738f15b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_94/verina_basic_94_impl.rs", "verified": true, "metadata": {"original_id": "2d2df738f15b", "function_name": "iter_copy", "bug_type": "missing_invariant"}}
{"id": "task_b_b97b454af90a", "task": "task_b", "input_text": "fn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >)\nensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (# [trigger] str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (# [trigger] str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_557_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b97b454af90a", "function_name": "to_toggle_case", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_ensures_df05bebd4caf", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >) requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] ,  { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant forall | k : int | 0 <= k < index ==> arr [k] != target , index <= arr . len () , decreases arr . len () - index { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >) requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] , ensures if let Some (idx) = index { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant forall | k : int | 0 <= k < index ==> arr [k] != target , index <= arr . len () , decreases arr . len () - index { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >) requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] , ensures if let Some (idx) = index { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant forall | k : int | 0 <= k < index ==> arr [k] != target , index <= arr . len () , decreases arr . len () - index { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_733_iter_2_current.rs", "verified": true, "metadata": {"original_id": "df05bebd4caf", "function_name": "find_first_occurrence", "bug_type": "missing_ensures"}}
{"id": "task_b_2d9744ed7747", "task": "task_b", "input_text": "fn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)\nensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , decreases arr . len () - i , { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , decreases arr . len () - i , { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_251_impl.rs", "verified": true, "metadata": {"original_id": "2d9744ed7747", "function_name": "insert_before_each", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_requires_b9cc7f1e51fc", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd :: pervasive :: runtime_assert ;\nuse vstd :: bytes :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: seq_lib :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: opaque] pub open spec fn spec_padding_needed (offset : nat , align : nat) -> nat { let misalignment = offset % align ; if misalignment > 0 { (align - misalignment) as nat } else { 0 } }\npub const fn padding_needed (offset : usize , align : usize) -> (out : usize)  ensures out <= align , out as nat == spec_padding_needed (offset as nat , align as nat) { reveal (spec_padding_needed) ; let misalignment = offset % align ; if misalignment > 0 { align - misalignment } else { 0 } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\nuse vstd :: pervasive :: runtime_assert ;\nuse vstd :: bytes :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: seq_lib :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: opaque] pub open spec fn spec_padding_needed (offset : nat , align : nat) -> nat { let misalignment = offset % align ; if misalignment > 0 { (align - misalignment) as nat } else { 0 } }\npub const fn padding_needed (offset : usize , align : usize) -> (out : usize) requires align > 0 , ensures out <= align , out as nat == spec_padding_needed (offset as nat , align as nat) { reveal (spec_padding_needed) ; let misalignment = offset % align ; if misalignment > 0 { align - misalignment } else { 0 } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: pervasive :: runtime_assert ;\nuse vstd :: bytes :: * ;\nuse vstd :: arithmetic :: div_mod :: * ;\nuse vstd :: slice :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: seq_lib :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: opaque] pub open spec fn spec_padding_needed (offset : nat , align : nat) -> nat { let misalignment = offset % align ; if misalignment > 0 { (align - misalignment) as nat } else { 0 } }\npub const fn padding_needed (offset : usize , align : usize) -> (out : usize) requires align > 0 , ensures out <= align , out as nat == spec_padding_needed (offset as nat , align as nat) { reveal (spec_padding_needed) ; let misalignment = offset % align ; if misalignment > 0 { align - misalignment } else { 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "multilog_inlined.rs", "verified": true, "metadata": {"original_id": "b9cc7f1e51fc", "function_name": "padding_needed", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_c893d9589bae", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted_postcond (a : Seq < i32 > , result : bool) -> bool { (forall | i : int | 0 <= i < a . len () - 1 ==> # [trigger] a [i] <= a [i + 1]) <==> result }\nspec fn is_sorted_precond (a : Seq < i32 >) -> bool { true }\nfn is_sorted (a : & [i32]) -> (result : bool) requires is_sorted_precond (a @) , ensures is_sorted_postcond (a @ , result) , { if a . len () <= 1 { return true ; } let mut i = 0 ; while i < a . len () - 1 invariant 0 <= i <= a . len () - 1 , forall | j : int | 0 <= j < i ==> # [trigger] a @ [j] <= a @ [j + 1] , { if a [i] > a [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted_postcond (a : Seq < i32 > , result : bool) -> bool { (forall | i : int | 0 <= i < a . len () - 1 ==> # [trigger] a [i] <= a [i + 1]) <==> result }\nspec fn is_sorted_precond (a : Seq < i32 >) -> bool { true }\nfn is_sorted (a : & [i32]) -> (result : bool) requires is_sorted_precond (a @) , ensures is_sorted_postcond (a @ , result) , { if a . len () <= 1 { return true ; } let mut i = 0 ; while i < a . len () - 1 invariant 0 <= i <= a . len () - 1 , forall | j : int | 0 <= j < i ==> # [trigger] a @ [j] <= a @ [j + 1] , decreases a . len () - i , { if a [i] > a [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted_postcond (a : Seq < i32 > , result : bool) -> bool { (forall | i : int | 0 <= i < a . len () - 1 ==> # [trigger] a [i] <= a [i + 1]) <==> result }\nspec fn is_sorted_precond (a : Seq < i32 >) -> bool { true }\nfn is_sorted (a : & [i32]) -> (result : bool) requires is_sorted_precond (a @) , ensures is_sorted_postcond (a @ , result) , { if a . len () <= 1 { return true ; } let mut i = 0 ; while i < a . len () - 1 invariant 0 <= i <= a . len () - 1 , forall | j : int | 0 <= j < i ==> # [trigger] a @ [j] <= a @ [j + 1] , decreases a . len () - i , { if a [i] > a [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_19/verina_basic_19_impl.rs", "verified": true, "metadata": {"original_id": "c893d9589bae", "function_name": "is_sorted", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_ca25f043cf9a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , { i = i + 1 ; } i }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "ca25f043cf9a", "function_name": "up_while_less", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_086bd322fe63", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high  { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high invariant 0 <= low <= high <= a . len () , decreases high - low , { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high invariant 0 <= low <= high <= a . len () , decreases high - low , { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "086bd322fe63", "function_name": "binary_search", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_606681853ccd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize)  ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize)  ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_69/verina_advanced_69_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "606681853ccd", "function_name": "search_insert", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_be5b60c99ead", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)  ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)  ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)  ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >)  ensures result . len () == a . len () , { let mut result = a ; if result . len () > 1 { let result_len = result . len () ; bubble_outer (& mut result , result_len - 2) ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >) requires bubble_sort_precond (a @) , ensures result . len () == a . len () , { let mut result = a ; if result . len () > 1 { let result_len = result . len () ; bubble_outer (& mut result , result_len - 2) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >) requires bubble_sort_precond (a @) , ensures result . len () == a . len () , { let mut result = a ; if result . len () > 1 { let result_len = result . len () ; bubble_outer (& mut result , result_len - 2) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_52/verina_basic_52_iter_4_current.rs", "verified": true, "metadata": {"original_id": "be5b60c99ead", "function_name": "bubble_sort", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_2f011f6ff8c8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_2_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "2f011f6ff8c8", "function_name": "contains", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_a1c226ba5ecf", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool)  ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_bool (a : bool , b : bool) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_compare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "a1c226ba5ecf", "function_name": "compare_bool", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_3bbf27449524", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn is_non_prime (n : u64) -> (result : bool)  ensures result == (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; return true ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn is_non_prime (n : u64) -> (result : bool) requires n >= 2 , ensures result == (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; return true ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_divisible (n : int , divisor : int) -> bool { (n % divisor) == 0 }\nfn is_non_prime (n : u64) -> (result : bool) requires n >= 2 , ensures result == (exists | k : int | 2 <= k < n && is_divisible (n as int , k)) , { let mut i : u64 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> ! is_divisible (n as int , k) , decreases n - i { if n % i == 0 { assert (is_divisible (n as int , i as int)) ; assert (2 <= i < n) ; return true ; } i = i + 1 ; } assert (i == n) ; assert (forall | k : int | 2 <= k < n ==> ! is_divisible (n as int , k)) ; false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_3_impl.rs", "verified": true, "metadata": {"original_id": "3bbf27449524", "function_name": "is_non_prime", "bug_type": "missing_requires"}}
{"id": "task_a_ec65c331810f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ninvariant forall | j : int | 0 <= j < i ==> number > arr [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_433_impl.rs", "verified": true, "metadata": {"original_id": "ec65c331810f", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_b_164190bd6377", "task": "task_b", "input_text": "fn is_integer (text : & [u8]) -> (result : bool)\nensures res == is_digit_sepc (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i , { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i , { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "164190bd6377", "function_name": "is_integer", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_assert_dfab1c7c31dc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; }  index += 1 ; }  upper_case }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } assert (upper_case [index as int] == (if is_lower_case (str1 [index as int]) { shift_minus_32_spec (str1 [index as int]) } else { str1 [index as int] })) ; index += 1 ; } assert (forall | i : int | 0 <= i < str1 . len () ==> upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) ; upper_case }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } assert (upper_case [index as int] == (if is_lower_case (str1 [index as int]) { shift_minus_32_spec (str1 [index as int]) } else { str1 [index as int] })) ; index += 1 ; } assert (forall | i : int | 0 <= i < str1 . len () ==> upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) ; upper_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_624_iter_2_current.rs", "verified": true, "metadata": {"original_id": "dfab1c7c31dc", "function_name": "to_uppercase", "bug_type": "missing_assert"}}
{"id": "task_a_cd60df574312", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >)   { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "target_text": "requires a . len () >= 1 \nensures result == in_array (a @ , x) , forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x , forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_duplicates (a : & [i32]) -> (result : Vec < i32 >) requires a . len () >= 1 , ensures forall | i : int | # ! [auto] 0 <= i < result . len () ==> in_array (a @ , result [i]) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { if ! in_array_exec (& result , a [i]) { result . push (a [i]) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "cd60df574312", "function_name": "remove_duplicates", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_b_cb6172ad4867", "task": "task_b", "input_text": "fn even_exec (n : u32) -> (result : bool)\nensures result == even (n as int)", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool) ensures result == even (n as int) { n % 2 == 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool) ensures result == even (n as int) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "cb6172ad4867", "function_name": "even_exec", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_requires_4749b06bd7ea", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >)  ensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] , { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] , decreases a . len () - i { b . push (a [i]) ; i += 1 ; } b }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >) requires a . len () <= 100 , ensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] , { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] , decreases a . len () - i { b . push (a [i]) ; i += 1 ; } b }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >) requires a . len () <= 100 , ensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] , { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] , decreases a . len () - i { b . push (a [i]) ; i += 1 ; } b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/CloverBench/verified/array_copy_strong_impl.rs", "verified": true, "metadata": {"original_id": "4749b06bd7ea", "function_name": "copy", "bug_type": "missing_requires"}}
{"id": "task_b_0ccc6a238222", "task": "task_b", "input_text": "fn arithmetic () -> (result : i32)\nensures result < 10", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/arithmetic_weird_impl.rs", "verified": true, "metadata": {"original_id": "0ccc6a238222", "function_name": "arithmetic", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_a9338b565e15", "task": "task_b", "input_text": "fn min_of_vec (v : & Vec < i32 >) -> (min : i32)\nrequires v . len () > 0 \nensures exists | i : int | 0 <= i < v . len () && v [i] == min , forall | i : int | 0 <= i < v . len () ==> min <= v [i] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn min_of_vec (v : & Vec < i32 >) -> (min : i32) requires v . len () > 0 , ensures exists | i : int | 0 <= i < v . len () && v [i] == min , forall | i : int | 0 <= i < v . len () ==> min <= v [i] , { let mut min_val = v [0] ; let mut idx = 1 ; while idx < v . len () invariant 1 <= idx <= v . len () , exists | i : int | 0 <= i < idx && v [i] == min_val , forall | i : int | 0 <= i < idx ==> min_val <= v [i] , decreases v . len () - idx { if v [idx] < min_val { min_val = v [idx] ; } idx += 1 ; } min_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn min_of_vec (v : & Vec < i32 >) -> (min : i32) requires v . len () > 0 , ensures exists | i : int | 0 <= i < v . len () && v [i] == min , forall | i : int | 0 <= i < v . len () ==> min <= v [i] , { let mut min_val = v [0] ; let mut idx = 1 ; while idx < v . len () invariant 1 <= idx <= v . len () , exists | i : int | 0 <= i < idx && v [i] == min_val , forall | i : int | 0 <= i < idx ==> min_val <= v [i] , decreases v . len () - idx { if v [idx] < min_val { min_val = v [idx] ; } idx += 1 ; } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_SelectionSortMultiset/verus_code_iter_4_current.rs", "verified": true, "metadata": {"original_id": "a9338b565e15", "function_name": "min_of_vec", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_2981e1bee084", "task": "task_b", "input_text": "fn all_digits (s : & Vec < char >) -> (result : bool)\nrequires all_digits_precond (s @) \nensures result == is_digit_spec (c) , all_digits_postcond (s @ , result) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_61/verina_basic_61_iter_3_current.rs", "verified": true, "metadata": {"original_id": "2981e1bee084", "function_name": "all_digits", "has_invariants": true, "has_asserts": false}}
{"id": "task_a_6c8caa643a82", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type AbstractValue = Seq < u8 > ;\npub open spec fn valid_value (value : AbstractValue) -> bool { value . len () < max_val_len () }\npub open spec fn max_val_len () -> int { 1024 }\npub fn is_value_valid (val : & Vec < u8 >) -> (b : bool)  { val . len () < 1024 }\n\n} // verus!", "target_text": "ensures b == valid_value (val @)", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type AbstractValue = Seq < u8 > ;\npub open spec fn valid_value (value : AbstractValue) -> bool { value . len () < max_val_len () }\npub open spec fn max_val_len () -> int { 1024 }\npub fn is_value_valid (val : & Vec < u8 >) -> (b : bool) ensures b == valid_value (val @) { val . len () < 1024 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "ironsht_inlined.rs", "verified": true, "metadata": {"original_id": "6c8caa643a82", "function_name": "is_value_valid", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_verus_monotonic_counter_1a36c6e4f57c", "task": "task_a", "input_text": "//! This file implements monotonic counters using a custom resource\n//! algebra.\n//!\n//! To use it, use MonotonicCounterResource::alloc(), which will\n//! create a fresh monotonic counter and return a resource granting\n//! full access to it. You can increment it the counter by calling\n//! `increment` on a resource. For example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//!\n//!\n//! ```\n//!\n//! To split a full right to advance into two half rights to advance,\n//! use `split`. This is useful, for instance, to stash half inside an\n//!  {\n\n// A monotonic counter permission represents a resource with one of\n// the following three values:\n//\n// `LowerBound{ lower_bound }` -- knowledge that the monotonic counter\n// is at least `lower_bound`\n//\n// `FullRightToAdvance{ value }` -- knowledge that the monotonic counter is\n// exactly `value` and the authority to advance it past that value\n//\n// `HalfRightToAdvance{ value }` -- knowledge that the monotonic\n// counter is exactly `value` and half the authority to advance it\n// past that value. Can be combined with another half authority to\n// make a full authority.\npub enum MonotonicCounterResourceValue {\n    LowerBound { lower_bound: nat },\n    HalfRightToAdvance { value: nat },\n    FullRightToAdvance { value: nat },\n    Invalid,\n}\n\n// To use `MonotonicCounterResourceValue` as a resource, we have to implement\n// `PCM`, showing how to use it in a resource algebra.\nimpl PCM for MonotonicCounterResourceValue {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            // Two lower bounds can be combined into a lower bound\n            // that's the maximum of the two lower bounds.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound1 },\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound2 },\n            ) => {\n                let max_lower_bound = if lower_bound1 > lower_bound2 {\n                    lower_bound1\n                } else {\n                    lower_bound2\n                };\n                MonotonicCounterResourceValue::LowerBound { lower_bound: max_lower_bound }\n            },\n            // A lower bound can be combined with a right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // A lower bound can be combined with a half right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the half right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Two half rights to advance can be combined to make\n            // a whole right to advance, as long as the two values\n            // agree with each other.\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value1 },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value2 },\n            ) => if value1 == value2 {\n                MonotonicCounterResourceValue::FullRightToAdvance { value: value1 }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Any other combination is invalid\n            (_, _) => MonotonicCounterResourceValue::Invalid {  },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        MonotonicCounterResourceValue::LowerBound { lower_bound: 0 }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\nimpl MonotonicCounterResourceValue {\n    pub open spec fn n(self) -> nat {\n        match self {\n            MonotonicCounterResourceValue::LowerBound { lower_bound } => lower_bound,\n            MonotonicCounterResourceValue::HalfRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::FullRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::Invalid => 0,\n        }\n    }\n}\n\npub struct MonotonicCounterResource {\n    r: Resource<MonotonicCounterResourceValue>,\n}\n\nimpl MonotonicCounterResource {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> MonotonicCounterResourceValue {\n        self.r.value()\n    }\n\n    // This function creates a monotonic counter and returns a\n    // resource granting full authority to advance it and giving\n    // knowledge that the current value is 0.\n    pub proof fn alloc() -> (tracked result: Self)\n         { value: 0 }),\n    {\n        let v = MonotonicCounterResourceValue::FullRightToAdvance { value: 0 };\n        let tracked mut r = Resource::<MonotonicCounterResourceValue>::alloc(v);\n        Self { r }\n    }\n\n    // Join two resources\n    pub proof fn join(tracked self: Self, tracked other: Self) -> (tracked r: Self)\n\n    {\n        let tracked mut r = self.r.join(other.r);\n        Self { r }\n    }\n\n    // This function splits a resource granting full authority to\n    // advance a monotonic counter into two resources each granting\n    // half authority to advance it. They both have the same `id()`,\n    // meaning they correspond to the same monotonic counter.\n    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))\n\n        {\n                let (r1, r2) = return_value;\n                let value = self@->FullRightToAdvance_value;\n                &&& r1.id() == r2.id() == self.id()\n                &&& r1@ == (MonotonicCounterResourceValue::HalfRightToAdvance { value })\n                &&& r2@ == r1@\n            }),\n    {\n        let value = self@->FullRightToAdvance_value;\n        let v_half = MonotonicCounterResourceValue::HalfRightToAdvance { value };\n        let tracked (r1, r2) = self.r.split(v_half, v_half);\n        (Self { r: r1 }, Self { r: r2 })\n    }\n\n    // This function uses a resource granting full authority to\n    // advance a monotonic counter to increment the counter.\n    pub proof fn increment(tracked &mut self)\n\n         {\n                value: old(self)@->FullRightToAdvance_value + 1,\n            }),\n    {\n        let v = self@->FullRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::FullRightToAdvance { value: v + 1 };\n        update_mut(&mut self.r, r);\n    }\n\n    // This function uses two tracked resources, each granting half\n    // authority to advance a monotonic counter, to increment the\n    // counter. The two permissions must have the same `id()` values.\n    //\n    // It's not a requirement that the two halves match in value; this\n    // function can figure out that they match just from the fact that\n    // they co-exist.\n    pub proof fn increment_using_two_halves(tracked &mut self, tracked other: &mut Self)\n\n         {\n                value: old(self)@->HalfRightToAdvance_value + 1,\n            }),\n    {\n        self.r.validate_2(&other.r);\n        let v = self@->HalfRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::HalfRightToAdvance { value: v + 1 };\n        update_and_redistribute(&mut self.r, &mut other.r, r, r);\n    }\n\n    pub proof fn extract_lower_bound(tracked &self) -> (tracked out: Self)\n         { lower_bound: self@.n() }),\n    {\n        self.r.validate();\n        let v = MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() };\n        let tracked r = copy_duplicable_part(&self.r, v);\n        Self { r }\n    }\n\n    pub proof fn lemma_lower_bound(tracked &mut self, tracked other: &Self)\n\n    {\n        self.r.validate_2(&other.r)\n    }\n}\n\n// This example illustrates some uses of the monotonic counter.\nfn main() {\n    let tracked full = MonotonicCounterResource::alloc();\n\n    let tracked full = MonotonicCounterResource::alloc();\n    let tracked zero_lower_bound = full.extract_lower_bound();\n    let tracked (mut half1, mut half2) = full.split();\n\n    let ghost id = half1.id();\n    let ghost v1 = half1@.n();\n    let ghost v2 = half2@.n();\n\n    let tracked mut lower_bound = half1.extract_lower_bound();\n\n    let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();\n\n}\n\n} // verus!\n", "target_text": "requires self.id() == other.id(),\n            self@.n() == other@.n(), self@ is FullRightToAdvance, old(self)@ is FullRightToAdvance, old(self).id() == old(other).id(),\n            old(self)@ is HalfRightToAdvance,\n            old(other)@ is HalfRightToAdvance, old(self).id() == other.id()\nensures result@ == (MonotonicCounterResourceValue::FullRightToAdvance, r.id() == self.id(),\n            r@.n() == self@.op(other@).n(), (, self.id() == old(self).id(),\n            self@ == (MonotonicCounterResourceValue::FullRightToAdvance, old(self)@ == old(other)@,\n            self.id() == other.id() == old(self).id(),\n            other@ == self@,\n            self@ == (MonotonicCounterResourceValue::HalfRightToAdvance, out@ is LowerBound,\n            out.id() == self.id(),\n            out@ == (MonotonicCounterResourceValue::LowerBound, self@ == old(self)@,\n            self@ is LowerBound && other@ is FullRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is FullRightToAdvance ==> other@.n() <= self@.n(),\n            self@ is LowerBound && other@ is HalfRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is HalfRightToAdvance ==> other@.n() <= self@.n()\ninvariant and pass the other half to the thread having the right\n//! to advance. Both halves will have the same `id()` value,\n//! indicating they correspond to the same monotonic counter. For\n//! example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//! let tracked (mut half1, mut half2) = full.split();\n//! assert(half1.id() == half2.id());\n//! assert(half1@.n() == 0);\n//! assert(half2@.n() == 0);\n//! ```\n//!\n//! You can use two half authorities together to increment the\n//! associated counter, as in this example:\n//!\n//! ```\n//! let ghost v1 == half1@.n();\n//! proof", "full_verified_code": "//! This file implements monotonic counters using a custom resource\n//! algebra.\n//!\n//! To use it, use MonotonicCounterResource::alloc(), which will\n//! create a fresh monotonic counter and return a resource granting\n//! full access to it. You can increment it the counter by calling\n//! `increment` on a resource. For example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//! proof { full.increment(); }\n//! assert(full@.n() == 1);\n//! ```\n//!\n//! To split a full right to advance into two half rights to advance,\n//! use `split`. This is useful, for instance, to stash half inside an\n//! invariant and pass the other half to the thread having the right\n//! to advance. Both halves will have the same `id()` value,\n//! indicating they correspond to the same monotonic counter. For\n//! example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//! let tracked (mut half1, mut half2) = full.split();\n//! assert(half1.id() == half2.id());\n//! assert(half1@.n() == 0);\n//! assert(half2@.n() == 0);\n//! ```\n//!\n//! You can use two half authorities together to increment the\n//! associated counter, as in this example:\n//!\n//! ```\n//! let ghost v1 == half1@.n();\n//! proof { half1.increment_using_two_halves(&mut half2); }\n//! assert(half1.id() == half2.id());\n//! assert(half1@ == half2@);\n//! assert(half1@.n() == half2@.n() == v1 + 1);\n//! ```\n//!\n//! From any `MonotonicCounterResource`, one can use\n//! `extract_lower_bound()` to extract a `MonotonicCounterResource`\n//! that represents knowledge of a lower bound on the current value of\n//! the monotonic counter. You can also duplicate a\n//! `MonotonicCounterResource` using this function. Here are examples:\n//!\n//! ```\n//! let tracked mut lower_bound = half1.extract_lower_bound();\n//! assert(lower_bound@.n() == 1);\n//! let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();\n//! assert(lower_bound_duplicate@.n() == 1);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// A monotonic counter permission represents a resource with one of\n// the following three values:\n//\n// `LowerBound{ lower_bound }` -- knowledge that the monotonic counter\n// is at least `lower_bound`\n//\n// `FullRightToAdvance{ value }` -- knowledge that the monotonic counter is\n// exactly `value` and the authority to advance it past that value\n//\n// `HalfRightToAdvance{ value }` -- knowledge that the monotonic\n// counter is exactly `value` and half the authority to advance it\n// past that value. Can be combined with another half authority to\n// make a full authority.\npub enum MonotonicCounterResourceValue {\n    LowerBound { lower_bound: nat },\n    HalfRightToAdvance { value: nat },\n    FullRightToAdvance { value: nat },\n    Invalid,\n}\n\n// To use `MonotonicCounterResourceValue` as a resource, we have to implement\n// `PCM`, showing how to use it in a resource algebra.\nimpl PCM for MonotonicCounterResourceValue {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            // Two lower bounds can be combined into a lower bound\n            // that's the maximum of the two lower bounds.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound1 },\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound2 },\n            ) => {\n                let max_lower_bound = if lower_bound1 > lower_bound2 {\n                    lower_bound1\n                } else {\n                    lower_bound2\n                };\n                MonotonicCounterResourceValue::LowerBound { lower_bound: max_lower_bound }\n            },\n            // A lower bound can be combined with a right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // A lower bound can be combined with a half right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the half right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Two half rights to advance can be combined to make\n            // a whole right to advance, as long as the two values\n            // agree with each other.\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value1 },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value2 },\n            ) => if value1 == value2 {\n                MonotonicCounterResourceValue::FullRightToAdvance { value: value1 }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Any other combination is invalid\n            (_, _) => MonotonicCounterResourceValue::Invalid {  },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        MonotonicCounterResourceValue::LowerBound { lower_bound: 0 }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\nimpl MonotonicCounterResourceValue {\n    pub open spec fn n(self) -> nat {\n        match self {\n            MonotonicCounterResourceValue::LowerBound { lower_bound } => lower_bound,\n            MonotonicCounterResourceValue::HalfRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::FullRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::Invalid => 0,\n        }\n    }\n}\n\npub struct MonotonicCounterResource {\n    r: Resource<MonotonicCounterResourceValue>,\n}\n\nimpl MonotonicCounterResource {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> MonotonicCounterResourceValue {\n        self.r.value()\n    }\n\n    // This function creates a monotonic counter and returns a\n    // resource granting full authority to advance it and giving\n    // knowledge that the current value is 0.\n    pub proof fn alloc() -> (tracked result: Self)\n        ensures\n            result@ == (MonotonicCounterResourceValue::FullRightToAdvance { value: 0 }),\n    {\n        let v = MonotonicCounterResourceValue::FullRightToAdvance { value: 0 };\n        let tracked mut r = Resource::<MonotonicCounterResourceValue>::alloc(v);\n        Self { r }\n    }\n\n\n    // Join two resources\n    pub proof fn join(tracked self: Self, tracked other: Self) -> (tracked r: Self)\n        requires\n            self.id() == other.id(),\n            self@.n() == other@.n()\n        ensures\n            r.id() == self.id(),\n            r@.n() == self@.op(other@).n(),\n    {\n        let tracked mut r = self.r.join(other.r);\n        Self { r }\n    }\n\n    // This function splits a resource granting full authority to\n    // advance a monotonic counter into two resources each granting\n    // half authority to advance it. They both have the same `id()`,\n    // meaning they correspond to the same monotonic counter.\n    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))\n        requires\n            self@ is FullRightToAdvance,\n        ensures\n            ({\n                let (r1, r2) = return_value;\n                let value = self@->FullRightToAdvance_value;\n                &&& r1.id() == r2.id() == self.id()\n                &&& r1@ == (MonotonicCounterResourceValue::HalfRightToAdvance { value })\n                &&& r2@ == r1@\n            }),\n    {\n        let value = self@->FullRightToAdvance_value;\n        let v_half = MonotonicCounterResourceValue::HalfRightToAdvance { value };\n        let tracked (r1, r2) = self.r.split(v_half, v_half);\n        (Self { r: r1 }, Self { r: r2 })\n    }\n\n    // This function uses a resource granting full authority to\n    // advance a monotonic counter to increment the counter.\n    pub proof fn increment(tracked &mut self)\n        requires\n            old(self)@ is FullRightToAdvance,\n        ensures\n            self.id() == old(self).id(),\n            self@ == (MonotonicCounterResourceValue::FullRightToAdvance {\n                value: old(self)@->FullRightToAdvance_value + 1,\n            }),\n    {\n        let v = self@->FullRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::FullRightToAdvance { value: v + 1 };\n        update_mut(&mut self.r, r);\n    }\n\n    // This function uses two tracked resources, each granting half\n    // authority to advance a monotonic counter, to increment the\n    // counter. The two permissions must have the same `id()` values.\n    //\n    // It's not a requirement that the two halves match in value; this\n    // function can figure out that they match just from the fact that\n    // they co-exist.\n    pub proof fn increment_using_two_halves(tracked &mut self, tracked other: &mut Self)\n        requires\n            old(self).id() == old(other).id(),\n            old(self)@ is HalfRightToAdvance,\n            old(other)@ is HalfRightToAdvance,\n        ensures\n            old(self)@ == old(other)@,\n            self.id() == other.id() == old(self).id(),\n            other@ == self@,\n            self@ == (MonotonicCounterResourceValue::HalfRightToAdvance {\n                value: old(self)@->HalfRightToAdvance_value + 1,\n            }),\n    {\n        self.r.validate_2(&other.r);\n        let v = self@->HalfRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::HalfRightToAdvance { value: v + 1 };\n        update_and_redistribute(&mut self.r, &mut other.r, r, r);\n    }\n\n    pub proof fn extract_lower_bound(tracked &self) -> (tracked out: Self)\n        ensures\n            out@ is LowerBound,\n            out.id() == self.id(),\n            out@ == (MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() }),\n    {\n        self.r.validate();\n        let v = MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() };\n        let tracked r = copy_duplicable_part(&self.r, v);\n        Self { r }\n    }\n\n    pub proof fn lemma_lower_bound(tracked &mut self, tracked other: &Self)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self@ == old(self)@,\n            self@ is LowerBound && other@ is FullRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is FullRightToAdvance ==> other@.n() <= self@.n(),\n            self@ is LowerBound && other@ is HalfRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is HalfRightToAdvance ==> other@.n() <= self@.n(),\n\n    {\n        self.r.validate_2(&other.r)\n    }\n}\n\n// This example illustrates some uses of the monotonic counter.\nfn main() {\n    let tracked full = MonotonicCounterResource::alloc();\n    proof {\n        full.increment();\n    }\n    assert(full@.n() == 1);\n    let tracked full = MonotonicCounterResource::alloc();\n    let tracked zero_lower_bound = full.extract_lower_bound();\n    let tracked (mut half1, mut half2) = full.split();\n    assert(half1.id() == half2.id());\n    assert(half1@.n() == 0);\n    assert(half2@.n() == 0);\n    let ghost id = half1.id();\n    let ghost v1 = half1@.n();\n    let ghost v2 = half2@.n();\n    assert(v1 == v2);\n    proof {\n        half1.increment_using_two_halves(&mut half2);\n    }\n    assert(half1.id() == half2.id() == id);\n    assert(half1@.n() == half2@.n() == v1 + 1);\n    assert(half1@.n() == 1);\n    let tracked mut lower_bound = half1.extract_lower_bound();\n    assert(lower_bound@.n() == 1);\n    let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();\n    assert(lower_bound_duplicate@.n() == 1);\n\n\n    proof {\n        let tracked reconstructed_full = half1.join(half2);\n        zero_lower_bound.lemma_lower_bound(&reconstructed_full);\n        assert(zero_lower_bound@.n() <= reconstructed_full@.n());\n    }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/pcm/monotonic_counter.rs", "verified": true, "metadata": {"original_id": "verus_monotonic_counter_1a36c6e4f57c", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_b_6d4cd0860435", "task": "task_b", "input_text": "fn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32)\nrequires index <= a . len () , a . len () > 0 \nensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_74/verina_basic_74_iter_1_current.rs", "verified": true, "metadata": {"original_id": "6d4cd0860435", "function_name": "max_array_aux", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_314920209f24", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] >= number { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ninvariant forall | j : int | 0 <= j < i ==> number > arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] , { if arr [i] >= number { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_433_iter_1_current.rs", "verified": true, "metadata": {"original_id": "314920209f24", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_c_missing_requires_f853734a797b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize)  ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut last_pos = 0 ; let mut found = false ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , found ==> (0 <= last_pos < i && a [last_pos as int] == elem) , found ==> forall | j : int | last_pos < j < i ==> a [j] != elem , found <==> exists | j : int | 0 <= j < i && a [j] == elem , decreases a . len () - i { if a [i] == elem { last_pos = i ; found = true ; } i += 1 ; } last_pos }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut last_pos = 0 ; let mut found = false ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , found ==> (0 <= last_pos < i && a [last_pos as int] == elem) , found ==> forall | j : int | last_pos < j < i ==> a [j] != elem , found <==> exists | j : int | 0 <= j < i && a [j] == elem , decreases a . len () - i { if a [i] == elem { last_pos = i ; found = true ; } i += 1 ; } last_pos }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires 0 < a . len () < 100_000 , exists | i : int | 0 <= i < a . len () && a [i] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut last_pos = 0 ; let mut found = false ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , found ==> (0 <= last_pos < i && a [last_pos as int] == elem) , found ==> forall | j : int | last_pos < j < i ==> a [j] != elem , found <==> exists | j : int | 0 <= j < i && a [j] == elem , decreases a . len () - i { if a [i] == elem { last_pos = i ; found = true ; } i += 1 ; } last_pos }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/last_position_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f853734a797b", "function_name": "last_position", "bug_type": "missing_requires"}}
{"id": "task_c_missing_assert_verus_recursion_e42edfec3663", "task": "task_c", "input_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nspec fn arith_sum_int(i: int) -> int\n    decreases i,\n{\n    if i <= 0 {\n        0\n    } else {\n        i + arith_sum_int(i - 1)\n    }\n}\n\n#[verifier::opaque]\nspec fn arith_sum_u64(i: u64) -> u64\n    decreases i,\n{\n    if i == 0 {\n        0\n    } else {\n        (i + arith_sum_u64((i - 1) as u64)) as u64\n    }\n}\n\nproof fn arith_sum_int_nonneg(i: nat)\n    ensures\n        arith_sum_int(i as int) >= 0,\n    decreases i,\n{\n    if i > 0 {\n        arith_sum_int_nonneg((i - 1) as nat);\n    }\n}\n\nproof fn arith_sum_test1() {\n\n    // Recursive functions default to 1 fuel, so without the assert above,\n    // the following assert will fail\n\n}\n\nproof fn arith_sum_test2() {\n    // Instead of writing out intermediate assertions,\n    // we can instead boost the fuel setting\n    reveal_with_fuel(arith_sum_int, 4);\n\n}\n\nproof fn arith_sum_test3() {\n    reveal_with_fuel(arith_sum_u64, 4);\n\n}\n\nproof fn arith_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        arith_sum_int(i as int) <= arith_sum_int(j as int),\n    decreases j,\n{\n    if i < j {\n        arith_sum_monotonic(i, (j - 1) as nat);\n    }\n}\n\nfn compute_arith_sum(n: u64) -> (sum: u64)\n    requires\n        n < 100,\n    ensures\n        arith_sum_int(n as int) == sum,\n{\n    let mut sum: u64 = 0;\n    for i in 0..n\n        invariant\n            n < 100,\n            arith_sum_int(i as int) == sum,\n            sum <= 100 * i,\n    {\n        sum = sum + (i + 1);\n    }\n    sum\n}\n\nfn run_arith_sum(n: u64) -> u64 {\n    let mut result: u64 = 0;\n    if n < 100 {\n        result = compute_arith_sum(n);\n    }\n    result\n}\n\nfn exec_with_decreases(n: u64) -> u64\n    decreases 100 - n,\n{\n    if n < 100 {\n        exec_with_decreases(n + 1)\n    } else {\n        n\n    }\n}\n\n} // verus!\nfn main() {\n    let args = std::env::args();\n    for arg in args {\n        if let Ok(n) = arg.parse::<u64>() {\n            println!(\"{}\", run_arith_sum(n));\n        }\n    }\n}\n", "target_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nspec fn arith_sum_int(i: int) -> int\n    decreases i,\n{\n    if i <= 0 {\n        0\n    } else {\n        i + arith_sum_int(i - 1)\n    }\n}\n\n#[verifier::opaque]\nspec fn arith_sum_u64(i: u64) -> u64\n    decreases i,\n{\n    if i == 0 {\n        0\n    } else {\n        (i + arith_sum_u64((i - 1) as u64)) as u64\n    }\n}\n\nproof fn arith_sum_int_nonneg(i: nat)\n    ensures\n        arith_sum_int(i as int) >= 0,\n    decreases i,\n{\n    if i > 0 {\n        arith_sum_int_nonneg((i - 1) as nat);\n    }\n}\n\nproof fn arith_sum_test1() {\n    assert(arith_sum_int(0) == 0);\n    // Recursive functions default to 1 fuel, so without the assert above,\n    // the following assert will fail\n    assert(arith_sum_int(1) == 1);\n    assert(arith_sum_int(2) == 3);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test2() {\n    // Instead of writing out intermediate assertions,\n    // we can instead boost the fuel setting\n    reveal_with_fuel(arith_sum_int, 4);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test3() {\n    reveal_with_fuel(arith_sum_u64, 4);\n    assert(arith_sum_u64(3) == 6);\n}\n\nproof fn arith_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        arith_sum_int(i as int) <= arith_sum_int(j as int),\n    decreases j,\n{\n    if i < j {\n        arith_sum_monotonic(i, (j - 1) as nat);\n    }\n}\n\nfn compute_arith_sum(n: u64) -> (sum: u64)\n    requires\n        n < 100,\n    ensures\n        arith_sum_int(n as int) == sum,\n{\n    let mut sum: u64 = 0;\n    for i in 0..n\n        invariant\n            n < 100,\n            arith_sum_int(i as int) == sum,\n            sum <= 100 * i,\n    {\n        sum = sum + (i + 1);\n    }\n    sum\n}\n\nfn run_arith_sum(n: u64) -> u64 {\n    let mut result: u64 = 0;\n    if n < 100 {\n        result = compute_arith_sum(n);\n    }\n    result\n}\n\nfn exec_with_decreases(n: u64) -> u64\n    decreases 100 - n,\n{\n    if n < 100 {\n        exec_with_decreases(n + 1)\n    } else {\n        n\n    }\n}\n\n} // verus!\nfn main() {\n    let args = std::env::args();\n    for arg in args {\n        if let Ok(n) = arg.parse::<u64>() {\n            println!(\"{}\", run_arith_sum(n));\n        }\n    }\n}\n", "full_verified_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nspec fn arith_sum_int(i: int) -> int\n    decreases i,\n{\n    if i <= 0 {\n        0\n    } else {\n        i + arith_sum_int(i - 1)\n    }\n}\n\n#[verifier::opaque]\nspec fn arith_sum_u64(i: u64) -> u64\n    decreases i,\n{\n    if i == 0 {\n        0\n    } else {\n        (i + arith_sum_u64((i - 1) as u64)) as u64\n    }\n}\n\nproof fn arith_sum_int_nonneg(i: nat)\n    ensures\n        arith_sum_int(i as int) >= 0,\n    decreases i,\n{\n    if i > 0 {\n        arith_sum_int_nonneg((i - 1) as nat);\n    }\n}\n\nproof fn arith_sum_test1() {\n    assert(arith_sum_int(0) == 0);\n    // Recursive functions default to 1 fuel, so without the assert above,\n    // the following assert will fail\n    assert(arith_sum_int(1) == 1);\n    assert(arith_sum_int(2) == 3);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test2() {\n    // Instead of writing out intermediate assertions,\n    // we can instead boost the fuel setting\n    reveal_with_fuel(arith_sum_int, 4);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test3() {\n    reveal_with_fuel(arith_sum_u64, 4);\n    assert(arith_sum_u64(3) == 6);\n}\n\nproof fn arith_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        arith_sum_int(i as int) <= arith_sum_int(j as int),\n    decreases j,\n{\n    if i < j {\n        arith_sum_monotonic(i, (j - 1) as nat);\n    }\n}\n\nfn compute_arith_sum(n: u64) -> (sum: u64)\n    requires\n        n < 100,\n    ensures\n        arith_sum_int(n as int) == sum,\n{\n    let mut sum: u64 = 0;\n    for i in 0..n\n        invariant\n            n < 100,\n            arith_sum_int(i as int) == sum,\n            sum <= 100 * i,\n    {\n        sum = sum + (i + 1);\n    }\n    sum\n}\n\nfn run_arith_sum(n: u64) -> u64 {\n    let mut result: u64 = 0;\n    if n < 100 {\n        result = compute_arith_sum(n);\n    }\n    result\n}\n\nfn exec_with_decreases(n: u64) -> u64\n    decreases 100 - n,\n{\n    if n < 100 {\n        exec_with_decreases(n + 1)\n    } else {\n        n\n    }\n}\n\n} // verus!\nfn main() {\n    let args = std::env::args();\n    for arg in args {\n        if let Ok(n) = arg.parse::<u64>() {\n            println!(\"{}\", run_arith_sum(n));\n        }\n    }\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/recursion.rs", "verified": true, "metadata": {"original_id": "verus_recursion_e42edfec3663", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_b_9d1ba670100f", "task": "task_b", "input_text": "fn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >)\nrequires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1\nensures out . len () == size", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 decreases a . len () { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >) requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1 ensures out . len () == size { let mut result = Vec :: new () ; let mut i = 0 ; while i < size invariant i <= size , result . len () == i decreases size - i { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 decreases a . len () { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >) requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1 ensures out . len () == size { let mut result = Vec :: new () ; let mut i = 0 ; while i < size invariant i <= size , result . len () == i decreases size - i { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/703FinalProject_tmp_tmpr_10rn4z_gaussian/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9d1ba670100f", "function_name": "gaussian", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_ensures_4e3a229ecf7b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> (result : bool) { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool)  { (n % 2) == 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> (result : bool) { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool) ensures result == is_even (n) { (n % 2) == 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> (result : bool) { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool) ensures result == is_even (n) { (n % 2) == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "4e3a229ecf7b", "function_name": "is_even_exec", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_95c98c5dcabd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] ,  { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_58/verina_basic_58_impl.rs", "verified": true, "metadata": {"original_id": "95c98c5dcabd", "function_name": "double_array_elements_aux", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_verus_assert_by_compute_ef8e5465ddbe", "task": "task_c", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::seq::*;\n\nfn main() {}\n\nverus! {\n\n// ANCHOR: pow_concrete\n// Naive definition of exponentiation\nspec fn pow(base: nat, exp: nat) -> nat\n    decreases exp,\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow(base, (exp - 1) as nat)\n    }\n}\n\nproof fn concrete_pow() {\n      // Assertion 1\n      // Assertion 2\n      // Assertion 3\n}\n// ANCHOR_END: pow_concrete\n\n/*\n// ANCHOR: let_fails\nlet x = 2;\n\n// ANCHOR_END: let_fails\n*/\n\n// ANCHOR: let_passes\nproof fn let_passes() {\n    assert({\n        let x = 2;\n        pow(2, x) == 4\n    }) by (compute_only);\n}\n// ANCHOR_END: let_passes\n\n// ANCHOR: seq_example\nproof fn seq_example(a: Seq<int>, b: Seq<int>, c: Seq<int>, d: Seq<int>) {\n\n}\n// ANCHOR_END: seq_example\n\n// ANCHOR: fibonacci_memoize\n#[verifier::memoize]\nspec fn fibonacci(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibonacci((n - 2) as nat) + fibonacci((n - 1) as nat)\n    }\n}\n\nproof fn test_fibonacci() {\n\n}\n// ANCHOR_END: fibonacci_memoize\n\n// ANCHOR: all_spec\nuse vstd::compute::RangeAll;\n\nspec fn p(u: usize) -> bool {\n    u >> 8 == 0\n}\n\nproof fn range_property(u: usize)\n    requires 25 <= u < 100,\n    ensures p(u),\n{\n\n    let prop = |x| p(x as usize);\n\n}\n// ANCHOR_END: all_spec\n\n} // verus!\n", "target_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::seq::*;\n\nfn main() {}\n\nverus! {\n\n// ANCHOR: pow_concrete\n// Naive definition of exponentiation\nspec fn pow(base: nat, exp: nat) -> nat\n    decreases exp,\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow(base, (exp - 1) as nat)\n    }\n}\n\nproof fn concrete_pow() {\n    assert(pow(2, 8) == 256) by (compute);  // Assertion 1\n    assert(pow(2, 9) == 512);  // Assertion 2\n    assert(pow(2, 8) == 256) by (compute_only);  // Assertion 3\n}\n// ANCHOR_END: pow_concrete\n\n/*\n// ANCHOR: let_fails\nlet x = 2;\nassert(pow(2, x) == 4) by (compute_only);\n// ANCHOR_END: let_fails\n*/\n\n// ANCHOR: let_passes\nproof fn let_passes() {\n    assert({\n        let x = 2;\n        pow(2, x) == 4\n    }) by (compute_only);\n}\n// ANCHOR_END: let_passes\n\n// ANCHOR: seq_example\nproof fn seq_example(a: Seq<int>, b: Seq<int>, c: Seq<int>, d: Seq<int>) {\n    assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);\n}\n// ANCHOR_END: seq_example\n\n// ANCHOR: fibonacci_memoize\n#[verifier::memoize]\nspec fn fibonacci(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibonacci((n - 2) as nat) + fibonacci((n - 1) as nat)\n    }\n}\n\nproof fn test_fibonacci() {\n    assert(fibonacci(63) == 6557470319842) by(compute_only);\n}\n// ANCHOR_END: fibonacci_memoize\n\n// ANCHOR: all_spec\nuse vstd::compute::RangeAll;\n\nspec fn p(u: usize) -> bool {\n    u >> 8 == 0\n}\n\nproof fn range_property(u: usize)\n    requires 25 <= u < 100,\n    ensures p(u),\n{\n    assert((25..100int).all_spec(|x| p(x as usize))) by (compute_only);\n    let prop = |x| p(x as usize);\n    assert(prop(u));\n}\n// ANCHOR_END: all_spec\n\n} // verus!\n", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::seq::*;\n\nfn main() {}\n\nverus! {\n\n// ANCHOR: pow_concrete\n// Naive definition of exponentiation\nspec fn pow(base: nat, exp: nat) -> nat\n    decreases exp,\n{\n    if exp == 0 {\n        1\n    } else {\n        base * pow(base, (exp - 1) as nat)\n    }\n}\n\nproof fn concrete_pow() {\n    assert(pow(2, 8) == 256) by (compute);  // Assertion 1\n    assert(pow(2, 9) == 512);  // Assertion 2\n    assert(pow(2, 8) == 256) by (compute_only);  // Assertion 3\n}\n// ANCHOR_END: pow_concrete\n\n/*\n// ANCHOR: let_fails\nlet x = 2;\nassert(pow(2, x) == 4) by (compute_only);\n// ANCHOR_END: let_fails\n*/\n\n// ANCHOR: let_passes\nproof fn let_passes() {\n    assert({\n        let x = 2;\n        pow(2, x) == 4\n    }) by (compute_only);\n}\n// ANCHOR_END: let_passes\n\n// ANCHOR: seq_example\nproof fn seq_example(a: Seq<int>, b: Seq<int>, c: Seq<int>, d: Seq<int>) {\n    assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);\n}\n// ANCHOR_END: seq_example\n\n// ANCHOR: fibonacci_memoize\n#[verifier::memoize]\nspec fn fibonacci(n: nat) -> nat\n    decreases n\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibonacci((n - 2) as nat) + fibonacci((n - 1) as nat)\n    }\n}\n\nproof fn test_fibonacci() {\n    assert(fibonacci(63) == 6557470319842) by(compute_only);\n}\n// ANCHOR_END: fibonacci_memoize\n\n// ANCHOR: all_spec\nuse vstd::compute::RangeAll;\n\nspec fn p(u: usize) -> bool {\n    u >> 8 == 0\n}\n\nproof fn range_property(u: usize)\n    requires 25 <= u < 100,\n    ensures p(u),\n{\n    assert((25..100int).all_spec(|x| p(x as usize))) by (compute_only);\n    let prop = |x| p(x as usize);\n    assert(prop(u));\n}\n// ANCHOR_END: all_spec\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/assert_by_compute.rs", "verified": true, "metadata": {"original_id": "verus_assert_by_compute_ef8e5465ddbe", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_a_d06bc91882dd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool)   { let mut i = 0 ; while i < lst . len () - 1  { if lst [i] > lst [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "requires lst . len () >= 1 \nensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] \ndecreases lst . len () - 1 - i \ninvariant 0 <= i <= lst . len () - 1 , forall | k : int , l : int | 0 <= k && k < l && l < i + 1 ==> lst [k] <= lst [l] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_sorted (lst : & [i32]) -> (result : bool) requires lst . len () >= 1 , ensures result <== forall | i : int , j : int | 0 <= i && i < j && j < lst . len () ==> lst [i] <= lst [j] , ! result ==> exists | i : int , j : int | 0 <= i && i < j && j < lst . len () && lst [i] > lst [j] , { let mut i = 0 ; while i < lst . len () - 1 invariant 0 <= i <= lst . len () - 1 , forall | k : int , l : int | 0 <= k && k < l && l < i + 1 ==> lst [k] <= lst [l] , decreases lst . len () - 1 - i , { if lst [i] > lst [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/is_sorted_impl.rs", "verified": true, "metadata": {"original_id": "d06bc91882dd", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_68528a612e39", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "68528a612e39", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_b_df05bebd4caf", "task": "task_b", "input_text": "fn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >)\nrequires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] \nensures if let Some (idx) = index", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >) requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] , ensures if let Some (idx) = index { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant forall | k : int | 0 <= k < index ==> arr [k] != target , index <= arr . len () , decreases arr . len () - index { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >) requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] , ensures if let Some (idx) = index { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant forall | k : int | 0 <= k < index ==> arr [k] != target , index <= arr . len () , decreases arr . len () - index { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_733_iter_2_current.rs", "verified": true, "metadata": {"original_id": "df05bebd4caf", "function_name": "find_first_occurrence", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_ensures_8f3fd5a0a3d4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >)  { a . clone () }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { a . clone () }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { a . clone () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_copy_impl.rs", "verified": true, "metadata": {"original_id": "8f3fd5a0a3d4", "function_name": "array_copy", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_1114468138b6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; assert (k > 0) ; assert (k < list . len ()) ; assert (k - 1 < list . len ()) ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 < list . len () , i <= list . len () , new_list @ == list @ . subrange (0 , i as int) , { assert (i < k - 1) ; assert (i < list . len ()) ; new_list . push (list [i]) ; i += 1 ; } assert (i == k - 1) ; assert (k - 1 < list . len ()) ; let mut j = k ; while j < list . len () invariant k <= j <= list . len () , k < list . len () , k - 1 < list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , { assert (j < list . len ()) ; new_list . push (list [j]) ; j += 1 ; } assert (j == list . len ()) ; assert (new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int))) ; new_list }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; assert (k > 0) ; assert (k < list . len ()) ; assert (k - 1 < list . len ()) ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 < list . len () , i <= list . len () , new_list @ == list @ . subrange (0 , i as int) , decreases k - 1 - i , { assert (i < k - 1) ; assert (i < list . len ()) ; new_list . push (list [i]) ; i += 1 ; } assert (i == k - 1) ; assert (k - 1 < list . len ()) ; let mut j = k ; while j < list . len () invariant k <= j <= list . len () , k < list . len () , k - 1 < list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { assert (j < list . len ()) ; new_list . push (list [j]) ; j += 1 ; } assert (j == list . len ()) ; assert (new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int))) ; new_list }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; assert (k > 0) ; assert (k < list . len ()) ; assert (k - 1 < list . len ()) ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 < list . len () , i <= list . len () , new_list @ == list @ . subrange (0 , i as int) , decreases k - 1 - i , { assert (i < k - 1) ; assert (i < list . len ()) ; new_list . push (list [i]) ; i += 1 ; } assert (i == k - 1) ; assert (k - 1 < list . len ()) ; let mut j = k ; while j < list . len () invariant k <= j <= list . len () , k < list . len () , k - 1 < list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { assert (j < list . len ()) ; new_list . push (list [j]) ; j += 1 ; } assert (j == list . len ()) ; assert (new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int))) ; new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_610_impl.rs", "verified": true, "metadata": {"original_id": "1114468138b6", "function_name": "remove_kth_element", "bug_type": "missing_decreases"}}
{"id": "task_b_9410727caeb6", "task": "task_b", "input_text": "fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >)\nrequires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p \nensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >) requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p , ensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) , { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos invariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , decreases at_pos - i { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p invariant j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , decreases p - j { result . push (nl [j]) ; j += 1 ; } let mut k = at_pos ; while k < l invariant at_pos <= k <= l , result . len () == at_pos + p + (k - at_pos) , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k - at_pos ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] , decreases l - k { result . push (oline [k]) ; k += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >) requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p , ensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) , { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos invariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , decreases at_pos - i { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p invariant j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , decreases p - j { result . push (nl [j]) ; j += 1 ; } let mut k = at_pos ; while k < l invariant at_pos <= k <= l , result . len () == at_pos + p + (k - at_pos) , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k - at_pos ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] , decreases l - k { result . push (oline [k]) ; k += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_64/verina_basic_64_iter_3_current.rs", "verified": true, "metadata": {"original_id": "9410727caeb6", "function_name": "insert", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_e6e7ef5c8f6f", "task": "task_b", "input_text": "fn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)\nensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_790_impl.rs", "verified": true, "metadata": {"original_id": "e6e7ef5c8f6f", "function_name": "is_even_at_even_index", "has_invariants": true, "has_asserts": false}}
{"id": "task_a_8256f1cd1471", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Diffy/verified/res2o_iter_1_current.rs", "verified": true, "metadata": {"original_id": "8256f1cd1471", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_b_740a5e98952d", "task": "task_b", "input_text": "fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool)\nrequires true \nensures true ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool) requires true , ensures true , { r . len () == x . len () }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [doc = \"\\n      Ather, Mohammad Faiz (s4648481/3)\\n      CSSE3100\\n      Assignment 3\\n      The University of Queensland\\n     \"] fn tangent (r : Vec < i32 > , x : Vec < i32 >) -> (found : bool) requires true , ensures true , { r . len () == x . len () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "740a5e98952d", "function_name": "tangent", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_decreases_ed70253ccf77", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , decreases a . len () - idx { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , decreases a . len () - idx { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/array_product_impl.rs", "verified": true, "metadata": {"original_id": "ed70253ccf77", "function_name": "array_product", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_9d367969c578", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF ,  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/cell_2_sum.rs", "verified": true, "metadata": {"original_id": "9d367969c578", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_b_e042e9cac08d", "task": "task_b", "input_text": "fn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >)\nrequires list @ . len () > 0 , 0 < n < list @ . len () \nensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant 0 < n < list @ . len () , n <= i <= list @ . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list @ . len () - i { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 < n < list @ . len () , 0 <= j <= n , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant 0 < n < list @ . len () , n <= i <= list @ . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list @ . len () - i { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 < n < list @ . len () , 0 <= j <= n , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_586_iter_2_current.rs", "verified": true, "metadata": {"original_id": "e042e9cac08d", "function_name": "split_and_append", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_d2dfd0f1cbe2", "task": "task_b", "input_text": "fn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >)\nrequires list @ . len () > 0 , 0 < n < list @ . len () \nensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) , { let mut result = Vec :: new () ; let mut i = n ; while i > 0 invariant 0 <= i <= n , n < list @ . len () , result @ . len () == n - i , forall | j : int | 0 <= j < result @ . len () ==> result @ [j] == list @ [n - 1 - j] , decreases i { i -= 1 ; result . push (list [i]) ; } let mut j = n ; while j < list . len () invariant n <= j <= list @ . len () , result @ . len () == n + (j - n) , forall | k : int | 0 <= k < n ==> result @ [k] == list @ [n - 1 - k] , forall | k : int | n <= k < result @ . len () ==> result @ [k] == list @ [n + (k - n)] , decreases list @ . len () - j { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) , { let mut result = Vec :: new () ; let mut i = n ; while i > 0 invariant 0 <= i <= n , n < list @ . len () , result @ . len () == n - i , forall | j : int | 0 <= j < result @ . len () ==> result @ [j] == list @ [n - 1 - j] , decreases i { i -= 1 ; result . push (list [i]) ; } let mut j = n ; while j < list . len () invariant n <= j <= list @ . len () , result @ . len () == n + (j - n) , forall | k : int | 0 <= k < n ==> result @ [k] == list @ [n - 1 - k] , forall | k : int | n <= k < result @ . len () ==> result @ [k] == list @ [n + (k - n)] , decreases list @ . len () - j { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_644_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d2dfd0f1cbe2", "function_name": "reverse_to_k", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_be7063317a85", "task": "task_b", "input_text": "fn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)\nensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "be7063317a85", "function_name": "contains", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_requires_verus_const_4a3b8978107b", "task": "task_c", "input_text": "// rust_verify/tests/example.rs expect-success\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: spec_const\nspec const SPEC_ONE: int = 1;\n\nspec fn spec_add_one(x: int) -> int {\n    x + SPEC_ONE\n}\n\n// ANCHOR_END: spec_const\n// ANCHOR: exec_const_syntax\nexec const C: u64\n    ensures\n        C == 7,\n{\n    7\n}\n\n// ANCHOR_END: exec_const_syntax\n// ANCHOR: exec_const_complicated\nspec fn f() -> int {\n    1\n}\n\nconst fn e() -> (u: u64)\n    ensures\n        u == f(),\n{\n    1\n}\n\nexec const E: u64\n    ensures\n        E == 2,\n{\n    assert(f() == 1);\n    1 + e()\n}\n\n// ANCHOR_END: exec_const_complicated\n// ANCHOR: spec_exec_const\nconst ONE: u8 = 1;\n\nfn add_one(x: u8) -> (ret: u8)\n\n    ensures\n        ret == x + ONE,  // use \"ONE\" in spec code\n{\n    x + ONE  // use \"ONE\" in exec code\n\n}\n\n// ANCHOR_END: spec_exec_const\n// ANCHOR: when_used_as_spec\nuse vstd::layout;\n\nglobal layout usize is size == 8;\n\nspec const SPEC_USIZE_BYTES: usize = layout::size_of_as_usize::<usize>();\n\n#[verifier::when_used_as_spec(SPEC_USIZE_BYTES)]\nexec const USIZE_BYTES: usize\n    ensures\n        USIZE_BYTES as nat == layout::size_of::<usize>(),\n{\n    8\n}\n\n// ANCHOR_END: when_used_as_spec\n// ANCHOR: nonlinear\npub const FOO: u8 = 4;\n\npub const BAR: u8 = FOO;\n\npub const BAR_PLUS_ONE: u8 = BAR + 1;\n\n#[verifier::nonlinear]\npub const G: u8 = BAR_PLUS_ONE * BAR;\n\n// ANCHOR_END: nonlinear\nfn main() {\n}\n\n} // verus!\n", "target_text": "// rust_verify/tests/example.rs expect-success\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: spec_const\nspec const SPEC_ONE: int = 1;\n\nspec fn spec_add_one(x: int) -> int {\n    x + SPEC_ONE\n}\n\n// ANCHOR_END: spec_const\n// ANCHOR: exec_const_syntax\nexec const C: u64\n    ensures\n        C == 7,\n{\n    7\n}\n\n// ANCHOR_END: exec_const_syntax\n// ANCHOR: exec_const_complicated\nspec fn f() -> int {\n    1\n}\n\nconst fn e() -> (u: u64)\n    ensures\n        u == f(),\n{\n    1\n}\n\nexec const E: u64\n    ensures\n        E == 2,\n{\n    assert(f() == 1);\n    1 + e()\n}\n\n// ANCHOR_END: exec_const_complicated\n// ANCHOR: spec_exec_const\nconst ONE: u8 = 1;\n\nfn add_one(x: u8) -> (ret: u8)\n    requires\n        x < 0xff,\n    ensures\n        ret == x + ONE,  // use \"ONE\" in spec code\n{\n    x + ONE  // use \"ONE\" in exec code\n\n}\n\n// ANCHOR_END: spec_exec_const\n// ANCHOR: when_used_as_spec\nuse vstd::layout;\n\nglobal layout usize is size == 8;\n\nspec const SPEC_USIZE_BYTES: usize = layout::size_of_as_usize::<usize>();\n\n#[verifier::when_used_as_spec(SPEC_USIZE_BYTES)]\nexec const USIZE_BYTES: usize\n    ensures\n        USIZE_BYTES as nat == layout::size_of::<usize>(),\n{\n    8\n}\n\n// ANCHOR_END: when_used_as_spec\n// ANCHOR: nonlinear\npub const FOO: u8 = 4;\n\npub const BAR: u8 = FOO;\n\npub const BAR_PLUS_ONE: u8 = BAR + 1;\n\n#[verifier::nonlinear]\npub const G: u8 = BAR_PLUS_ONE * BAR;\n\n// ANCHOR_END: nonlinear\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "// rust_verify/tests/example.rs expect-success\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: spec_const\nspec const SPEC_ONE: int = 1;\n\nspec fn spec_add_one(x: int) -> int {\n    x + SPEC_ONE\n}\n\n// ANCHOR_END: spec_const\n// ANCHOR: exec_const_syntax\nexec const C: u64\n    ensures\n        C == 7,\n{\n    7\n}\n\n// ANCHOR_END: exec_const_syntax\n// ANCHOR: exec_const_complicated\nspec fn f() -> int {\n    1\n}\n\nconst fn e() -> (u: u64)\n    ensures\n        u == f(),\n{\n    1\n}\n\nexec const E: u64\n    ensures\n        E == 2,\n{\n    assert(f() == 1);\n    1 + e()\n}\n\n// ANCHOR_END: exec_const_complicated\n// ANCHOR: spec_exec_const\nconst ONE: u8 = 1;\n\nfn add_one(x: u8) -> (ret: u8)\n    requires\n        x < 0xff,\n    ensures\n        ret == x + ONE,  // use \"ONE\" in spec code\n{\n    x + ONE  // use \"ONE\" in exec code\n\n}\n\n// ANCHOR_END: spec_exec_const\n// ANCHOR: when_used_as_spec\nuse vstd::layout;\n\nglobal layout usize is size == 8;\n\nspec const SPEC_USIZE_BYTES: usize = layout::size_of_as_usize::<usize>();\n\n#[verifier::when_used_as_spec(SPEC_USIZE_BYTES)]\nexec const USIZE_BYTES: usize\n    ensures\n        USIZE_BYTES as nat == layout::size_of::<usize>(),\n{\n    8\n}\n\n// ANCHOR_END: when_used_as_spec\n// ANCHOR: nonlinear\npub const FOO: u8 = 4;\n\npub const BAR: u8 = FOO;\n\npub const BAR_PLUS_ONE: u8 = BAR + 1;\n\n#[verifier::nonlinear]\npub const G: u8 = BAR_PLUS_ONE * BAR;\n\n// ANCHOR_END: nonlinear\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/const.rs", "verified": true, "metadata": {"original_id": "verus_const_4a3b8978107b", "function_name": "", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_21723d6ef86c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn double_array_elements (s : & mut Vec < i32 >) requires forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] old (s) [i] >= - 1073741824 && old (s) [i] <= 1073741823 , ensures forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] s [i] == 2 * old (s) [i] , s . len () == old (s) . len () , { let mut i = 0 ; while i < s . len ()  { let val = s [i] ; s . set (i , 2 * val) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn double_array_elements (s : & mut Vec < i32 >) requires forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] old (s) [i] >= - 1073741824 && old (s) [i] <= 1073741823 , ensures forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] s [i] == 2 * old (s) [i] , s . len () == old (s) . len () , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s . len () == old (s) . len () , forall | j : int | 0 <= j < i ==> # [trigger] s [j] == 2 * old (s) [j] , forall | j : int | i <= j < s . len () ==> # [trigger] s [j] == old (s) [j] , forall | j : int | 0 <= j < s . len () ==> old (s) [j] >= - 1073741824 && old (s) [j] <= 1073741823 , decreases s . len () - i { let val = s [i] ; s . set (i , 2 * val) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn double_array_elements (s : & mut Vec < i32 >) requires forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] old (s) [i] >= - 1073741824 && old (s) [i] <= 1073741823 , ensures forall | i : int | 0 <= i < old (s) . len () ==> # [trigger] s [i] == 2 * old (s) [i] , s . len () == old (s) . len () , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s . len () == old (s) . len () , forall | j : int | 0 <= j < i ==> # [trigger] s [j] == 2 * old (s) [j] , forall | j : int | i <= j < s . len () ==> # [trigger] s [j] == old (s) [j] , forall | j : int | 0 <= j < s . len () ==> old (s) [j] >= - 1073741824 && old (s) [j] <= 1073741823 , decreases s . len () - i { let val = s [i] ; s . set (i , 2 * val) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_double_array_elements/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "21723d6ef86c", "function_name": "double_array_elements", "bug_type": "missing_invariant"}}
{"id": "task_a_eadce0a1fdef", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)   { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize)   { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "target_text": "requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , binary_search_precond (a @ , key) \nensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo\ndecreases hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize) requires binary_search_precond (a @ , key) , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_51/verina_basic_51_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "eadce0a1fdef", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_verus_lib_c84f959a601d", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse verus_state_machines_macros::*;\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::modes::*;\nuse vstd::thread::*;\n\nverus! {\n\nstate_machine!{ Y {\n            fields {\n                pub x: int,\n                pub y: int,\n                pub z: int,\n            }\n\n            init!{\n                initialize(x: int, y: int, z: int) {\n                    init x = x;\n                    init y = y;\n                    require(y <= z);\n                    if x == y {\n                        init z = z;\n                    } else {\n                        init z = z + 1;\n                    }\n                }\n            }\n\n            transition!{\n                tr1(b: bool, c: bool) {\n                    require(b);\n\n                    require(c);\n                    update z = pre.z + 1;\n                }\n            }\n\n            transition!{\n                tr2(b: bool, c: bool) {\n                    if b {\n                        update z = pre.z + 1;\n                    } else {\n\n                    }\n                    require(c);\n                }\n            }\n\n            transition!{\n                tr3(b: bool, c: bool) {\n                    if b {\n\n                    } else {\n                        let j = pre.z + 1;\n                        update z = j;\n                    }\n                    require(c);\n                }\n            }\n\n            #[invariant]\n            pub fn the_inv(self) -> bool { self.y <= self.z }\n\n            #[inductive(initialize)]\n            fn init_inductive(post: Self, x: int, y: int, z: int) { }\n\n            #[inductive(tr1)]\n            fn tr1_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n            #[inductive(tr2)]\n            fn tr2_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n            #[inductive(tr3)]\n            fn tr3_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n}}\n\ntokenized_state_machine!(\n    X {\n        fields {\n            #[sharding(variable)]\n            pub counter: int,\n\n            #[sharding(variable)]\n            pub inc_a: bool,\n\n            #[sharding(variable)]\n            pub inc_b: bool,\n        }\n\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == (if self.inc_a { 1 as int } else { 0 }) + (if self.inc_b { 1 as int } else { 0 })\n        }\n\n        init!{\n            initialize() {\n                init counter = 0;\n                init inc_a = false;\n                init inc_b = false;\n            }\n        }\n\n        transition!{\n            tr_inc_a() {\n                require(!pre.inc_a);\n                update counter = pre.counter + 1;\n                update inc_a = true;\n            }\n        }\n\n        transition!{\n            tr_inc_b() {\n                require(!pre.inc_b);\n                update counter = pre.counter + 1;\n                update inc_b = true;\n            }\n        }\n\n        property!{\n            increment_will_not_overflow_u32() {\n                assert 0 <= pre.counter < 0xffff_ffff;\n            }\n        }\n\n        property!{\n            finalize() {\n                require(pre.inc_a);\n                require(pre.inc_b);\n                assert pre.counter == 2;\n            }\n        }\n\n        #[inductive(tr_inc_a)]\n        fn tr_inc_a_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(tr_inc_b)]\n        fn tr_inc_b_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inv(post: Self) {\n        }\n    }\n);\n\nstruct_with_invariants!{\n    pub struct Global {\n        // An AtomicU32 that matches with the `counter` field of the ghost protocol.\n        pub atomic: AtomicU32<_, X::counter, _>,\n\n        // The instance of the protocol that the `counter` is part of.\n        pub instance: Tracked<X::Instance>,\n    }\n\n    spec fn wf(&self) -> bool {\n        // Specify the  {\n            g.instance_id() == instance@.id()\n            && g.value() == v as int\n        }\n    }\n}\n\nfn main() {\n    // Initialize protocol\n    let tracked (\n        Tracked(instance),\n        Tracked(counter_token),\n        Tracked(inc_a_token),\n        Tracked(inc_b_token),\n    ) = X::Instance::initialize();\n    // Initialize the counter\n    let tr_instance: Tracked<X::Instance> = Tracked(instance.clone());\n    let atomic = AtomicU32::new(Ghost(tr_instance), 0, Tracked(counter_token));\n    let global = Global { atomic, instance: Tracked(instance.clone()) };\n    let global_arc = Arc::new(global);\n\n    // Spawn threads\n\n    // Thread 1\n    let global_arc1 = global_arc.clone();\n    let join_handle1 = spawn(\n        (move || -> (new_token: Tracked<X::inc_a>)\n\n            {\n                // `inc_a_token` is moved into the closure\n                let tracked mut token = inc_a_token;\n                let globals = &*global_arc1;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&c);\n                            globals.instance.borrow().tr_inc_a(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Thread 2\n    let global_arc2 = global_arc.clone();\n    let join_handle2 = spawn(\n        (move || -> (new_token: Tracked<X::inc_b>)\n\n            {\n                // `inc_b_token` is moved into the closure\n                let tracked mut token = inc_b_token;\n                let globals = &*global_arc2;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&mut c);\n                            globals.instance.borrow().tr_inc_b(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Join threads\n    let tracked inc_a_token;\n    match join_handle1.join() {\n        Result::Ok(token) => {\n\n        },\n        _ => {\n            return ;\n        },\n    };\n    let tracked inc_b_token;\n    match join_handle2.join() {\n        Result::Ok(token) => {\n\n        },\n        _ => {\n            return ;\n        },\n    };\n\n    // Join threads, load the atomic again\n    let global = &*global_arc;\n    let x =\n        atomic_with_ghost!(&global.atomic => load();\n        ghost c => {\n            instance.finalize(&c, &inc_a_token, &inc_b_token);\n        }\n    );\n\n}\n\n} // verus!\n", "target_text": "ensures new_token@.instance_id() == instance.id() && new_token@.value() == true, new_token@.instance_id() == instance.id() && new_token@.value() == true\ninvariant that should hold on the AtomicU32<X::counter>.\n        // Specifically the ghost token (`g`) should have\n        // the same value as the atomic (`v`).\n        // Furthermore, the ghost token should have the appropriate `instance`.\n        invariant on atomic with (instance) is (v: u32, g: X::counter)", "full_verified_code": "use vstd::prelude::*;\nuse verus_state_machines_macros::*;\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::modes::*;\nuse vstd::thread::*;\n\nverus! {\n\nstate_machine!{ Y {\n            fields {\n                pub x: int,\n                pub y: int,\n                pub z: int,\n            }\n\n            init!{\n                initialize(x: int, y: int, z: int) {\n                    init x = x;\n                    init y = y;\n                    require(y <= z);\n                    if x == y {\n                        init z = z;\n                    } else {\n                        init z = z + 1;\n                    }\n                }\n            }\n\n            transition!{\n                tr1(b: bool, c: bool) {\n                    require(b);\n                    assert(pre.y <= pre.z);\n                    require(c);\n                    update z = pre.z + 1;\n                }\n            }\n\n            transition!{\n                tr2(b: bool, c: bool) {\n                    if b {\n                        update z = pre.z + 1;\n                    } else {\n                        assert(pre.y <= pre.z);\n                    }\n                    require(c);\n                }\n            }\n\n            transition!{\n                tr3(b: bool, c: bool) {\n                    if b {\n                        assert(pre.y <= pre.z);\n                    } else {\n                        let j = pre.z + 1;\n                        update z = j;\n                    }\n                    require(c);\n                }\n            }\n\n            #[invariant]\n            pub fn the_inv(self) -> bool { self.y <= self.z }\n\n            #[inductive(initialize)]\n            fn init_inductive(post: Self, x: int, y: int, z: int) { }\n\n            #[inductive(tr1)]\n            fn tr1_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n            #[inductive(tr2)]\n            fn tr2_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n            #[inductive(tr3)]\n            fn tr3_inductive(pre: Self, post: Self, b: bool, c: bool) { }\n\n}}\n\n\ntokenized_state_machine!(\n    X {\n        fields {\n            #[sharding(variable)]\n            pub counter: int,\n\n            #[sharding(variable)]\n            pub inc_a: bool,\n\n            #[sharding(variable)]\n            pub inc_b: bool,\n        }\n\n        #[invariant]\n        pub fn main_inv(&self) -> bool {\n            self.counter == (if self.inc_a { 1 as int } else { 0 }) + (if self.inc_b { 1 as int } else { 0 })\n        }\n\n        init!{\n            initialize() {\n                init counter = 0;\n                init inc_a = false;\n                init inc_b = false;\n            }\n        }\n\n        transition!{\n            tr_inc_a() {\n                require(!pre.inc_a);\n                update counter = pre.counter + 1;\n                update inc_a = true;\n            }\n        }\n\n        transition!{\n            tr_inc_b() {\n                require(!pre.inc_b);\n                update counter = pre.counter + 1;\n                update inc_b = true;\n            }\n        }\n\n        property!{\n            increment_will_not_overflow_u32() {\n                assert 0 <= pre.counter < 0xffff_ffff;\n            }\n        }\n\n        property!{\n            finalize() {\n                require(pre.inc_a);\n                require(pre.inc_b);\n                assert pre.counter == 2;\n            }\n        }\n\n        #[inductive(tr_inc_a)]\n        fn tr_inc_a_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(tr_inc_b)]\n        fn tr_inc_b_preserves(pre: Self, post: Self) {\n        }\n\n        #[inductive(initialize)]\n        fn initialize_inv(post: Self) {\n        }\n    }\n);\n\nstruct_with_invariants!{\n    pub struct Global {\n        // An AtomicU32 that matches with the `counter` field of the ghost protocol.\n        pub atomic: AtomicU32<_, X::counter, _>,\n\n        // The instance of the protocol that the `counter` is part of.\n        pub instance: Tracked<X::Instance>,\n    }\n\n    spec fn wf(&self) -> bool {\n        // Specify the invariant that should hold on the AtomicU32<X::counter>.\n        // Specifically the ghost token (`g`) should have\n        // the same value as the atomic (`v`).\n        // Furthermore, the ghost token should have the appropriate `instance`.\n        invariant on atomic with (instance) is (v: u32, g: X::counter) {\n            g.instance_id() == instance@.id()\n            && g.value() == v as int\n        }\n    }\n}\n\n\nfn main() {\n    // Initialize protocol\n    let tracked (\n        Tracked(instance),\n        Tracked(counter_token),\n        Tracked(inc_a_token),\n        Tracked(inc_b_token),\n    ) = X::Instance::initialize();\n    // Initialize the counter\n    let tr_instance: Tracked<X::Instance> = Tracked(instance.clone());\n    let atomic = AtomicU32::new(Ghost(tr_instance), 0, Tracked(counter_token));\n    let global = Global { atomic, instance: Tracked(instance.clone()) };\n    let global_arc = Arc::new(global);\n\n    // Spawn threads\n\n    // Thread 1\n    let global_arc1 = global_arc.clone();\n    let join_handle1 = spawn(\n        (move || -> (new_token: Tracked<X::inc_a>)\n            ensures\n                new_token@.instance_id() == instance.id() && new_token@.value() == true,\n            {\n                // `inc_a_token` is moved into the closure\n                let tracked mut token = inc_a_token;\n                let globals = &*global_arc1;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&c);\n                            globals.instance.borrow().tr_inc_a(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Thread 2\n    let global_arc2 = global_arc.clone();\n    let join_handle2 = spawn(\n        (move || -> (new_token: Tracked<X::inc_b>)\n            ensures\n                new_token@.instance_id() == instance.id() && new_token@.value() == true,\n            {\n                // `inc_b_token` is moved into the closure\n                let tracked mut token = inc_b_token;\n                let globals = &*global_arc2;\n                let _ =\n                    atomic_with_ghost!(&globals.atomic => fetch_add(1);\n                        ghost c => {\n                            globals.instance.borrow().increment_will_not_overflow_u32(&mut c);\n                            globals.instance.borrow().tr_inc_b(&mut c, &mut token); // atomic increment\n                        }\n                    );\n                Tracked(token)\n            }),\n    );\n\n    // Join threads\n    let tracked inc_a_token;\n    match join_handle1.join() {\n        Result::Ok(token) => {\n            proof {\n                inc_a_token = token.get();\n            }\n        },\n        _ => {\n            return ;\n        },\n    };\n    let tracked inc_b_token;\n    match join_handle2.join() {\n        Result::Ok(token) => {\n            proof {\n                inc_b_token = token.get();\n            }\n        },\n        _ => {\n            return ;\n        },\n    };\n\n    // Join threads, load the atomic again\n    let global = &*global_arc;\n    let x =\n        atomic_with_ghost!(&global.atomic => load();\n        ghost c => {\n            instance.finalize(&c, &inc_a_token, &inc_b_token);\n        }\n    );\n\n    assert(x == 2);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/source/rust_verify_test/tests/cargo-tests/verified/state_machine_macro_usage/src/lib.rs", "verified": true, "metadata": {"original_id": "verus_lib_c84f959a601d", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_c_missing_ensures_a7fd77c8cb35", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target ,  { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_69/verina_advanced_69_iter_1_current.rs", "verified": true, "metadata": {"original_id": "a7fd77c8cb35", "function_name": "helper", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_63f93a3ee908", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF ,  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/cell_2_sum_iter_0_original.rs", "verified": true, "metadata": {"original_id": "63f93a3ee908", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_b_f6c55e5b2b96", "task": "task_b", "input_text": "fn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)\nrequires start < l . len ()", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_22/verina_advanced_22.rs", "verified": true, "metadata": {"original_id": "f6c55e5b2b96", "function_name": "aux", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_f56724e263b0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)   { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "target_text": "requires i < old (a) . len () , j < old (a) . len () , j <= i , i + 1 < old (a) . len () \nensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a . len () == old (a) . len () , decreases i - j \ndecreases i - j ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_52/verina_basic_52_iter_4_current.rs", "verified": true, "metadata": {"original_id": "f56724e263b0", "function_name": "bubble_inner", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_58fb96ec49ca", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool)   { let mut i = 2 ; while i < n  { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32)   { let mut largest = 1 ; let mut i = 2 ; while i <= n  { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "target_text": "requires n >= 2 , 2 <= n <= MAX - 1 \nensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result))\ndecreases n - i, n + 1 - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/largest_prime_factor_iter_2_current.rs", "verified": true, "metadata": {"original_id": "58fb96ec49ca", "function_name": "largest_prime_factor", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_requires_verus_basic_lock2_23c0941244c7", "task": "task_c", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse vstd::prelude::*;\nuse vstd::atomic_ghost::*;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::modes::*;\n\nverus!{\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        pub atomic: AtomicBool<_, Option<cell::PointsTo<T>>, _>,\n        pub cell: PCell<T>,\n    }\n\n    spec fn wf(self) -> bool {\n        invariant on atomic with (cell) is (v: bool, g: Option<cell::PointsTo<T>>) {\n            match g {\n                None => {\n                    // When there's no PointsTo, the lock must be taken, thus\n                    // the boolean value is 'true'.\n                    v == true\n                }\n                Some(points_to) => {\n                    points_to.id() == cell.id()\n                      && points_to.is_init()\n                      && v == false\n                }\n            }\n        }\n    }\n}\n\nimpl<T> Lock<T> {\n    fn new(t: T) -> (lock: Self)\n        ensures lock.wf()\n    {\n        let (cell, Tracked(cell_perm)) = PCell::new(t);\n        let atomic = AtomicBool::new(Ghost(cell), false, Tracked(Some(cell_perm)));\n        Lock { atomic, cell }\n    }\n\n    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)\n\n        ensures points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        loop\n            invariant self.wf(),\n        {\n            let tracked mut points_to_opt = None;\n            let res = atomic_with_ghost!(&self.atomic => compare_exchange(false, true);\n                ghost points_to_inv => {\n                    tracked_swap(&mut points_to_opt, &mut points_to_inv);\n                }\n            );\n            if res.is_ok() {\n                return Tracked(points_to_opt.tracked_unwrap());\n            }\n        }\n    }\n\n    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)\n\n    {\n        atomic_with_ghost!(&self.atomic => store(false);\n            ghost points_to_inv => {\n                points_to_inv = Some(points_to.get());\n            }\n        );\n    }\n}\n\n}\n\nfn main() { }\n", "target_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse vstd::prelude::*;\nuse vstd::atomic_ghost::*;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::modes::*;\n\nverus!{\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        pub atomic: AtomicBool<_, Option<cell::PointsTo<T>>, _>,\n        pub cell: PCell<T>,\n    }\n\n    spec fn wf(self) -> bool {\n        invariant on atomic with (cell) is (v: bool, g: Option<cell::PointsTo<T>>) {\n            match g {\n                None => {\n                    // When there's no PointsTo, the lock must be taken, thus\n                    // the boolean value is 'true'.\n                    v == true\n                }\n                Some(points_to) => {\n                    points_to.id() == cell.id()\n                      && points_to.is_init()\n                      && v == false\n                }\n            }\n        }\n    }\n}\n\nimpl<T> Lock<T> {\n    fn new(t: T) -> (lock: Self)\n        ensures lock.wf()\n    {\n        let (cell, Tracked(cell_perm)) = PCell::new(t);\n        let atomic = AtomicBool::new(Ghost(cell), false, Tracked(Some(cell_perm)));\n        Lock { atomic, cell }\n    }\n\n    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)\n        requires self.wf(),\n        ensures points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        loop\n            invariant self.wf(),\n        {\n            let tracked mut points_to_opt = None;\n            let res = atomic_with_ghost!(&self.atomic => compare_exchange(false, true);\n                ghost points_to_inv => {\n                    tracked_swap(&mut points_to_opt, &mut points_to_inv);\n                }\n            );\n            if res.is_ok() {\n                return Tracked(points_to_opt.tracked_unwrap());\n            }\n        }\n    }\n\n    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)\n        requires\n            self.wf(),\n            points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        atomic_with_ghost!(&self.atomic => store(false);\n            ghost points_to_inv => {\n                points_to_inv = Some(points_to.get());\n            }\n        );\n    }\n}\n\n}\n\nfn main() { }\n", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nuse vstd::prelude::*;\nuse vstd::atomic_ghost::*;\nuse vstd::cell;\nuse vstd::cell::*;\nuse vstd::modes::*;\n\nverus!{\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        pub atomic: AtomicBool<_, Option<cell::PointsTo<T>>, _>,\n        pub cell: PCell<T>,\n    }\n\n    spec fn wf(self) -> bool {\n        invariant on atomic with (cell) is (v: bool, g: Option<cell::PointsTo<T>>) {\n            match g {\n                None => {\n                    // When there's no PointsTo, the lock must be taken, thus\n                    // the boolean value is 'true'.\n                    v == true\n                }\n                Some(points_to) => {\n                    points_to.id() == cell.id()\n                      && points_to.is_init()\n                      && v == false\n                }\n            }\n        }\n    }\n}\n\nimpl<T> Lock<T> {\n    fn new(t: T) -> (lock: Self)\n        ensures lock.wf()\n    {\n        let (cell, Tracked(cell_perm)) = PCell::new(t);\n        let atomic = AtomicBool::new(Ghost(cell), false, Tracked(Some(cell_perm)));\n        Lock { atomic, cell }\n    }\n\n    fn acquire(&self) -> (points_to: Tracked<cell::PointsTo<T>>)\n        requires self.wf(),\n        ensures points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        loop\n            invariant self.wf(),\n        {\n            let tracked mut points_to_opt = None;\n            let res = atomic_with_ghost!(&self.atomic => compare_exchange(false, true);\n                ghost points_to_inv => {\n                    tracked_swap(&mut points_to_opt, &mut points_to_inv);\n                }\n            );\n            if res.is_ok() {\n                return Tracked(points_to_opt.tracked_unwrap());\n            }\n        }\n    }\n\n    fn release(&self, points_to: Tracked<cell::PointsTo<T>>)\n        requires\n            self.wf(),\n            points_to@.id() == self.cell.id(), points_to@.is_init()\n    {\n        atomic_with_ghost!(&self.atomic => store(false);\n            ghost points_to_inv => {\n                points_to_inv = Some(points_to.get());\n            }\n        );\n    }\n}\n\n}\n\nfn main() { }\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/basic_lock2.rs", "verified": true, "metadata": {"original_id": "verus_basic_lock2_23c0941244c7", "function_name": "", "bug_type": "missing_requires"}}
{"id": "task_a_verus_fifo_7d613aff30a4", "task": "task_a", "input_text": "// rust_verify/tests/example.rs expect-warnings\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\n// port of single-producer single-consumer queue from LinearDafny\n// https://github.com/vmware-labs/verified-betrfs/tree/concurrency-experiments/concurrency/spsc-queue\n\n// ANCHOR:full\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::cell::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nverus! {\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\n// ANCHOR: enum_state\n#[is_variant]\npub enum ProducerState {\n    Idle(nat),  // local copy of tail\n    Producing(nat),\n}\n\n#[is_variant]\npub enum ConsumerState {\n    Idle(nat),  // local copy of head\n    Consuming(nat),\n}\n// ANCHOR_END: enum_state\n\n// ANCHOR: fields\ntokenized_state_machine!{FifoQueue<T> {\n    fields {\n        // IDs of the cells used in the ring buffer.\n        // These are fixed throughout the protocol.\n\n        #[sharding(constant)]\n        pub backing_cells: Seq<CellId>,\n\n        // All the stored permissions\n\n        #[sharding(storage_map)]\n        pub storage: Map<nat, cell::PointsTo<T>>,\n\n        // Represents the shared `head` field\n\n        #[sharding(variable)]\n        pub head: nat,\n\n        // Represents the shared `tail` field\n\n        #[sharding(variable)]\n        pub tail: nat,\n\n        // Represents the local state of the single-producer\n\n        #[sharding(variable)]\n        pub producer: ProducerState,\n\n        // Represents the local state of the single-consumer\n\n        #[sharding(variable)]\n        pub consumer: ConsumerState,\n    }\n    // ANCHOR_END: fields\n\n    pub open spec fn len(&self) -> nat {\n        self.backing_cells.len()\n    }\n\n    // ANCHOR: inc_wrap\n    pub open spec fn inc_wrap(i: nat, len: nat) -> nat {\n        if i + 1 == len { 0 } else { i + 1 }\n    }\n    // ANCHOR_END: inc_wrap\n\n    // Make sure the producer state and the consumer state aren't inconsistent.\n\n    #[invariant]\n    pub fn not_overlapping(&self) -> bool {\n        match (self.producer, self.consumer) {\n            (ProducerState::Producing(tail), ConsumerState::Idle(head)) => {\n                Self::inc_wrap(tail, self.len()) != head\n            }\n            (ProducerState::Producing(tail), ConsumerState::Consuming(head)) => {\n                head != tail\n                && Self::inc_wrap(tail, self.len()) != head\n            }\n            (ProducerState::Idle(tail), ConsumerState::Idle(head)) => {\n                true\n            }\n            (ProducerState::Idle(tail), ConsumerState::Consuming(head)) => {\n                head != tail\n            }\n        }\n    }\n\n    // `head` and `tail` are in-bounds\n    // shared `head` and `tail` fields agree with the ProducerState and ConsumerState\n\n    #[invariant]\n    pub fn in_bounds(&self) -> bool {\n        0 <= self.head && self.head < self.len() &&\n        0 <= self.tail && self.tail < self.len()\n        && match self.producer {\n            ProducerState::Producing(tail) => {\n                self.tail == tail\n            }\n            ProducerState::Idle(tail) => {\n                self.tail == tail\n            }\n        }\n        && match self.consumer {\n            ConsumerState::Consuming(head) => {\n                self.head == head\n            }\n            ConsumerState::Idle(head) => {\n                self.head == head\n            }\n        }\n    }\n\n    // Indicates whether we expect the cell at index `i` to be full based on\n    // the values of the `head` and `tail`.\n\n    pub open spec fn in_active_range(&self, i: nat) -> bool {\n        // Note that self.head = self.tail means empty range\n        0 <= i && i < self.len() && (\n            if self.head <= self.tail {\n                self.head <= i && i < self.tail\n            } else {\n                i >= self.head || i < self.tail\n            }\n        )\n    }\n\n    // Indicates whether we expect a cell to be checked out or not,\n    // based on the producer/consumer state.\n\n    pub open spec fn is_checked_out(&self, i: nat) -> bool {\n        self.producer === ProducerState::Producing(i)\n        || self.consumer === ConsumerState::Consuming(i)\n    }\n\n    // Predicate to determine that the state at cell index `i`\n    // is correct. For each index, there are three possibilities:\n    //\n    //  1. No cell permission is stored\n    //  2. Permission is stored; permission indicates a full cell\n    //  3. Permission is stored; permission indicates an empty cell\n    //\n    // Which of these 3 possibilities we should be in depends on the\n    // producer/consumer/head/tail state.\n\n    pub open spec fn valid_storage_at_idx(&self, i: nat) -> bool {\n        if self.is_checked_out(i) {\n            // No cell permission is stored\n            !self.storage.dom().contains(i)\n        } else {\n            // Permission is stored\n            self.storage.dom().contains(i)\n\n            // Permission must be for the correct cell:\n            && self.storage.index(i).id() === self.backing_cells.index(i as int)\n\n            && if self.in_active_range(i) {\n                // The cell is full\n                self.storage.index(i).is_init()\n            } else {\n                // The cell is empty\n                self.storage.index(i).is_uninit()\n            }\n        }\n    }\n\n    #[invariant]\n    pub fn valid_storage_all(&self) -> bool {\n        forall|i: nat| 0 <= i && i < self.len() ==>\n            self.valid_storage_at_idx(i)\n    }\n\n    init!{\n        initialize(backing_cells: Seq<CellId>, storage: Map<nat, cell::PointsTo<T>>) {\n            // Upon initialization, the user needs to deposit _all_ the relevant\n            // cell permissions to start with. Each permission should indicate\n            // an empty cell.\n\n            require(\n                (forall|i: nat| 0 <= i && i < backing_cells.len() ==>\n                    #[trigger] storage.dom().contains(i)\n                    && storage.index(i).id() === backing_cells.index(i as int)\n                    && storage.index(i).is_uninit())\n            );\n            require(backing_cells.len() > 0);\n\n            init backing_cells = backing_cells;\n            init storage = storage;\n            init head = 0;\n            init tail = 0;\n            init producer = ProducerState::Idle(0);\n            init consumer = ConsumerState::Idle(0);\n        }\n    }\n\n    // ANCHOR: transition_produce_start\n    transition!{\n        produce_start() {\n            // In order to begin, we have to be in ProducerState::Idle.\n            require(pre.producer.is_Idle());\n\n            // We'll be comparing the producer's _local_ copy of the tail\n            // with the _shared_ version of the head.\n            let tail = pre.producer.get_Idle_0();\n            let head = pre.head;\n\n            // Compute the incremented tail, wrapping around if necessary.\n            let next_tail = Self::inc_wrap(tail, pre.backing_cells.len());\n\n            // We have to check that the buffer isn't full to proceed.\n            require(next_tail != head);\n\n            // Update the producer's local state to be in the `Producing` state.\n            update producer = ProducerState::Producing(tail);\n\n            // Withdraw (\"check out\") the permission stored at index `tail`.\n            // This creates a proof obligation for the transition system to prove that\n            // there is actually a permission stored at this index.\n            withdraw storage -= [tail => let perm] by {\n\n            };\n\n            // The transition needs to guarantee to the client that the\n            // permission they are checking out:\n            //  (i) is for the cell at index `tail` (the IDs match)\n            //  (ii) the permission indicates that the cell is empty\n\n            };\n        }\n    }\n    // ANCHOR_END: transition_produce_start\n\n    // ANCHOR: transition_produce_end\n    transition!{\n        // This transition is parameterized by the value of the permission\n        // being inserted. Since the permission is being deposited\n        // (coming from \"outside\" the system) we can't compute it as a\n        // function of the current state, unlike how we did it for the\n        // `produce_start` transition).\n        produce_end(perm: cell::PointsTo<T>) {\n            // In order to complete the produce step,\n            // we have to be in ProducerState::Producing.\n            require(pre.producer.is_Producing());\n            let tail = pre.producer.get_Producing_0();\n\n            // Compute the incremented tail, wrapping around if necessary.\n            let next_tail = Self::inc_wrap(tail, pre.backing_cells.len());\n\n            // This time, we don't need to compare the `head` and `tail` - we already\n            // check that, and anyway, we don't have access to the `head` field\n            // for this transition. (This transition is supposed to occur while\n            // modifying the `tail` field, so we can't do both.)\n\n            // However, we _do_ need to check that the permission token being\n            // checked in satisfies its requirements. It has to be associated\n            // with the correct cell, and it has to be full.\n\n            require(perm.id() === pre.backing_cells.index(tail as int)\n              && perm.is_init());\n\n            // Perform our updates. Update the tail to the computed value,\n            // both the shared version and the producer's local copy.\n            // Also, move back to the Idle state.\n            update producer = ProducerState::Idle(next_tail);\n            update tail = next_tail;\n\n            // Check the permission back into the storage map.\n            deposit storage += [tail => perm] by {  };\n        }\n    }\n    // ANCHOR_END: transition_produce_end\n\n    transition!{\n        consume_start() {\n            // In order to begin, we have to be in ConsumerState::Idle.\n            require(pre.consumer.is_Idle());\n\n            // We'll be comparing the consumer's _local_ copy of the head\n            // with the _shared_ version of the tail.\n            let head = pre.consumer.get_Idle_0();\n            let tail = pre.tail;\n\n            // We have to check that the buffer isn't empty to proceed.\n            require(head != tail);\n\n            // Update the consumer's local state to be in the `Consuming` state.\n            update consumer = ConsumerState::Consuming(head);\n\n            // Withdraw (\"check out\") the permission stored at index `tail`.\n\n            birds_eye let perm = pre.storage.index(head);\n            withdraw storage -= [head => perm] by {\n\n            };\n\n            };\n\n            };\n        }\n    }\n\n    transition!{\n        consume_end(perm: cell::PointsTo<T>) {\n            require(pre.consumer.is_Consuming());\n            let head = pre.consumer.get_Consuming_0();\n\n            let next_head = Self::inc_wrap(head, pre.backing_cells.len());\n\n            update consumer = ConsumerState::Idle(next_head);\n            update head = next_head;\n\n            require(perm.id() === pre.backing_cells.index(head as int)\n              && perm.is_uninit());\n            deposit storage += [head => perm] by {  };\n        }\n    }\n\n    #[inductive(initialize)]\n    fn initialize_inductive(post: Self, backing_cells: Seq<CellId>, storage: Map<nat, cell::PointsTo<T>>) {\n        }\n\n    //// Invariant proofs\n\n    #[inductive(produce_start)]\n    fn produce_start_inductive(pre: Self, post: Self) {\n        let tail = pre.producer.get_Idle_0();\n\n        match (post.producer, post.consumer) {\n            (ProducerState::Producing(tail), ConsumerState::Idle(head)) => {\n\n            }\n            (ProducerState::Producing(tail), ConsumerState::Consuming(head)) => {\n\n            }\n            (ProducerState::Idle(tail), ConsumerState::Idle(head)) => {\n            }\n            (ProducerState::Idle(tail), ConsumerState::Consuming(head)) => {\n\n            }\n        }\n\n    }\n\n    #[inductive(produce_end)]\n    fn produce_end_inductive(pre: Self, post: Self, perm: cell::PointsTo<T>) {\n        else {\n\n            }*/\n        }\n    }\n\n    #[inductive(consume_start)]\n    fn consume_start_inductive(pre: Self, post: Self) {\n        }\n\n    #[inductive(consume_end)]\n    fn consume_end_inductive(pre: Self, post: Self, perm: cell::PointsTo<T>) {\n        let head = pre.consumer.get_Consuming_0();\n\n        match (pre.producer, pre.consumer) {\n            (ProducerState::Producing(tail), ConsumerState::Idle(head)) => {\n\n            }\n            (ProducerState::Producing(tail), ConsumerState::Consuming(head)) => {\n\n            }\n            (ProducerState::Idle(tail), ConsumerState::Idle(head)) => {\n\n            }\n            (ProducerState::Idle(tail), ConsumerState::Consuming(head)) => {\n\n            }\n        };\n\n        }\n}}\n\n// ANCHOR: impl_queue_struct\nstruct_with_invariants!{\n    struct Queue<T> {\n        buffer: Vec<PCell<T>>,\n        head: AtomicU64<_, FifoQueue::head<T>, _>,\n        tail: AtomicU64<_, FifoQueue::tail<T>, _>,\n\n        instance: Tracked<FifoQueue::Instance<T>>,\n    }\n\n    pub closed spec fn wf(&self) -> bool {\n        predicate {\n            // The Cell IDs in the instance protocol match the cell IDs in the actual vector:\n            &&& self.instance@.backing_cells().len() == self.buffer@.len()\n            &&& forall|i: int| 0 <= i && i < self.buffer@.len() as int ==>\n                self.instance@.backing_cells().index(i) ===\n                    self.buffer@.index(i).id()\n        }\n\n         {\n            &&& g.instance_id() === instance@.id()\n            &&& g.value() == v as int\n        }\n\n         {\n            &&& g.instance_id() === instance@.id()\n            &&& g.value() == v as int\n        }\n    }\n}\n// ANCHOR_END: impl_queue_struct\n\n// ANCHOR: impl_producer_struct\npub struct Producer<T> {\n    queue: Arc<Queue<T>>,\n    tail: usize,\n    producer: Tracked<FifoQueue::producer<T>>,\n}\n\nimpl<T> Producer<T> {\n    pub closed spec fn wf(&self) -> bool {\n        (*self.queue).wf()\n            && self.producer@.instance_id() == (*self.queue).instance@.id()\n            && self.producer@.value() == ProducerState::Idle(self.tail as nat)\n            && (self.tail as int) < (*self.queue).buffer@.len()\n    }\n}\n// ANCHOR_END: impl_producer_struct\n\n// ANCHOR: impl_consumer_struct\npub struct Consumer<T> {\n    queue: Arc<Queue<T>>,\n    head: usize,\n    consumer: Tracked<FifoQueue::consumer<T>>,\n}\n\nimpl<T> Consumer<T> {\n    pub closed spec fn wf(&self) -> bool {\n        (*self.queue).wf()\n            && self.consumer@.instance_id() === (*self.queue).instance@.id()\n            && self.consumer@.value() === ConsumerState::Idle(self.head as nat)\n            && (self.head as int) < (*self.queue).buffer@.len()\n    }\n}\n// ANCHOR_END: impl_consumer_struct\n\n// ANCHOR: impl_new_queue\npub fn new_queue<T>(len: usize) -> (pc: (Producer<T>, Consumer<T>))\n\n{\n    // Initialize the vector to store the cells\n    let mut backing_cells_vec = Vec::<PCell<T>>::new();\n    // Initialize map for the permissions to the cells\n    // (keyed by the indices into the vector)\n    let tracked mut perms = Map::<nat, cell::PointsTo<T>>::tracked_empty();\n    while backing_cells_vec.len() < len\n\n    {\n        let ghost i = backing_cells_vec.len();\n        let (cell, cell_perm) = PCell::empty();\n        backing_cells_vec.push(cell);\n\n    }\n    // Vector for ids\n\n    let ghost mut backing_cells_ids = Seq::<CellId>::new(\n        backing_cells_vec@.len(),\n        |i: int| backing_cells_vec@.index(i).id(),\n    );\n    // Initialize an instance of the FIFO queue\n    let tracked (\n        Tracked(instance),\n        Tracked(head_token),\n        Tracked(tail_token),\n        Tracked(producer_token),\n        Tracked(consumer_token),\n    ) = FifoQueue::Instance::initialize(backing_cells_ids, perms, perms);\n    // Initialize atomics\n    let tracked_inst: Tracked<FifoQueue::Instance<T>> = Tracked(instance.clone());\n    let head_atomic = AtomicU64::new(Ghost(tracked_inst), 0, Tracked(head_token));\n    let tail_atomic = AtomicU64::new(Ghost(tracked_inst), 0, Tracked(tail_token));\n    // Initialize the queue\n    let queue = Queue::<T> {\n        instance: Tracked(instance),\n        head: head_atomic,\n        tail: tail_atomic,\n        buffer: backing_cells_vec,\n    };\n    // Share the queue between the producer and consumer\n    let queue_arc = Arc::new(queue);\n    let prod = Producer::<T> {\n        queue: queue_arc.clone(),\n        tail: 0,\n        producer: Tracked(producer_token),\n    };\n    let cons = Consumer::<T> { queue: queue_arc, head: 0, consumer: Tracked(consumer_token) };\n    (prod, cons)\n}\n// ANCHOR_END: impl_new_queue\n\n// ANCHOR: impl_producer\nimpl<T> Producer<T> {\n    fn enqueue(&mut self, t: T)\n\n    {\n        // Loop: if the queue is full, then block until it is not.\n        loop\n\n        {\n            let queue = &*self.queue;\n            let len = queue.buffer.len();\n\n            // Calculate the index of the slot right after `tail`, wrapping around\n            // if necessary. If the enqueue is successful, then we will be updating\n            // the `tail` to this value.\n            let next_tail = if self.tail + 1 == len {\n                0\n            } else {\n                self.tail + 1\n            };\n            let tracked cell_perm: Option<cell::PointsTo<T>>;\n            // Get the current `head` value from the shared atomic.\n            let head =\n                atomic_with_ghost!(&queue.head => load();\n                returning head;\n                ghost head_token => {\n                    // If `head != next_tail`, then we proceed with the operation.\n                    // We check here, ghostily, in the `open_atomic_invariant` block if that's the case.\n                    // If so, we proceed with the `produce_start` transition\n                    // and obtain the cell permission.\n                    cell_perm = if head != next_tail as u64 {\n                        let tracked cp = queue.instance.borrow().produce_start(&head_token, self.producer.borrow_mut());\n                        Option::Some(cp)\n                    } else {\n                        Option::None\n                    };\n                }\n            );\n            // Here's where we \"actually\" do the `head != next_tail` check:\n            if head != next_tail as u64 {\n                // Unwrap the cell_perm from the option.\n                let tracked mut cell_perm = match cell_perm {\n                    Option::Some(cp) => cp,\n                    Option::None => {\n\n                        proof_from_false()\n                    },\n                };\n                // Write the element t into the buffer, updating the cell\n                // from uninitialized to initialized (to the value t).\n                queue.buffer[self.tail].put(Tracked(&mut cell_perm), t);\n                // Store the updated tail to the shared `tail` atomic,\n                // while performing the `produce_end` transition.\n                atomic_with_ghost!(&queue.tail => store(next_tail as u64); ghost tail_token => {\n                    queue.instance.borrow().produce_end(cell_perm,\n                        cell_perm, &mut tail_token, self.producer.borrow_mut());\n                });\n                self.tail = next_tail;\n                return ;\n            }\n        }\n    }\n}\n// ANCHOR_END: impl_producer\n\n// ANCHOR: impl_consumer\nimpl<T> Consumer<T> {\n    fn dequeue(&mut self) -> (t: T)\n\n    {\n        loop\n\n        {\n            let queue = &*self.queue;\n            let len = queue.buffer.len();\n\n            let next_head = if self.head + 1 == len {\n                0\n            } else {\n                self.head + 1\n            };\n            let tracked cell_perm: Option<cell::PointsTo<T>>;\n            let tail =\n                atomic_with_ghost!(&queue.tail => load();\n                returning tail;\n                ghost tail_token => {\n                    cell_perm = if self.head as u64 != tail {\n                        let tracked (_, Tracked(cp)) = queue.instance.borrow().consume_start(&tail_token, self.consumer.borrow_mut());\n                        Option::Some(cp)\n                    } else {\n                        Option::None\n                    };\n                }\n            );\n            if self.head as u64 != tail {\n                let tracked mut cell_perm = match cell_perm {\n                    Option::Some(cp) => cp,\n                    Option::None => {\n\n                        proof_from_false()\n                    },\n                };\n                let t = queue.buffer[self.head].take(Tracked(&mut cell_perm));\n                atomic_with_ghost!(&queue.head => store(next_head as u64); ghost head_token => {\n                    queue.instance.borrow().consume_end(cell_perm,\n                        cell_perm, &mut head_token, self.consumer.borrow_mut());\n                });\n                self.head = next_head;\n                return t;\n            }\n        }\n    }\n}\n\nfn main() {\n    let (mut producer, mut consumer) = new_queue(20);\n\n    // Simple test:\n\n    producer.enqueue(5);\n    producer.enqueue(6);\n    producer.enqueue(7);\n\n    let x = consumer.dequeue();\n    print_u64(x);\n\n    let x = consumer.dequeue();\n    print_u64(x);\n\n    let x = consumer.dequeue();\n    print_u64(x);\n\n    // Multi-threaded test:\n\n    let producer = producer;\n    let _join_handle = vstd::thread::spawn(\n        move ||\n            {\n                let mut producer = producer;\n                let mut i = 0;\n                while i < 100\n\n                {\n                    producer.enqueue(i);\n                    i = i + 1;\n                }\n            },\n    );\n    let mut i = 0;\n    while i < 100\n\n    {\n        let x = consumer.dequeue();\n        print_u64(x);\n        i = i + 1;\n    }\n}\n\n} // verus!\n// ANCHOR_END: impl_consumer\n// ANCHOR_END: full\n", "target_text": "requires len > 0, old(self).wf(), old(self).wf()\nensures pc.0.wf(),\n        pc.1.wf(), self.wf(), self.wf()\ninvariant on head with (instance) is (v: u64, g: FifoQueue::head<T>), on tail with (instance) is (v: u64, g: FifoQueue::tail<T>), forall|j: nat|\n                #![trigger( perms.dom().contains(j) )]\n                #![trigger( backing_cells_vec@.index(j as int) )]\n                #![trigger( perms.index(j) )]\n                0 <= j && j < backing_cells_vec.len() as int ==> perms.dom().contains(j)\n                    && backing_cells_vec@.index(j as int).id() === perms.index(j).id()\n                    && perms.index(j).is_uninit(), self.wf(), self.wf(), producer.wf(), consumer.wf()", "full_verified_code": "// rust_verify/tests/example.rs expect-warnings\n#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\n// port of single-producer single-consumer queue from LinearDafny\n// https://github.com/vmware-labs/verified-betrfs/tree/concurrency-experiments/concurrency/spsc-queue\n\n// ANCHOR:full\nuse std::sync::Arc;\nuse vstd::atomic_ghost::*;\nuse vstd::cell::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nverus! {\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\n// ANCHOR: enum_state\n#[is_variant]\npub enum ProducerState {\n    Idle(nat),  // local copy of tail\n    Producing(nat),\n}\n\n#[is_variant]\npub enum ConsumerState {\n    Idle(nat),  // local copy of head\n    Consuming(nat),\n}\n// ANCHOR_END: enum_state\n\n// ANCHOR: fields\ntokenized_state_machine!{FifoQueue<T> {\n    fields {\n        // IDs of the cells used in the ring buffer.\n        // These are fixed throughout the protocol.\n\n        #[sharding(constant)]\n        pub backing_cells: Seq<CellId>,\n\n        // All the stored permissions\n\n        #[sharding(storage_map)]\n        pub storage: Map<nat, cell::PointsTo<T>>,\n\n        // Represents the shared `head` field\n\n        #[sharding(variable)]\n        pub head: nat,\n\n        // Represents the shared `tail` field\n\n        #[sharding(variable)]\n        pub tail: nat,\n\n        // Represents the local state of the single-producer\n\n        #[sharding(variable)]\n        pub producer: ProducerState,\n\n        // Represents the local state of the single-consumer\n\n        #[sharding(variable)]\n        pub consumer: ConsumerState,\n    }\n    // ANCHOR_END: fields\n\n    pub open spec fn len(&self) -> nat {\n        self.backing_cells.len()\n    }\n\n    // ANCHOR: inc_wrap\n    pub open spec fn inc_wrap(i: nat, len: nat) -> nat {\n        if i + 1 == len { 0 } else { i + 1 }\n    }\n    // ANCHOR_END: inc_wrap\n\n    // Make sure the producer state and the consumer state aren't inconsistent.\n\n    #[invariant]\n    pub fn not_overlapping(&self) -> bool {\n        match (self.producer, self.consumer) {\n            (ProducerState::Producing(tail), ConsumerState::Idle(head)) => {\n                Self::inc_wrap(tail, self.len()) != head\n            }\n            (ProducerState::Producing(tail), ConsumerState::Consuming(head)) => {\n                head != tail\n                && Self::inc_wrap(tail, self.len()) != head\n            }\n            (ProducerState::Idle(tail), ConsumerState::Idle(head)) => {\n                true\n            }\n            (ProducerState::Idle(tail), ConsumerState::Consuming(head)) => {\n                head != tail\n            }\n        }\n    }\n\n    // `head` and `tail` are in-bounds\n    // shared `head` and `tail` fields agree with the ProducerState and ConsumerState\n\n    #[invariant]\n    pub fn in_bounds(&self) -> bool {\n        0 <= self.head && self.head < self.len() &&\n        0 <= self.tail && self.tail < self.len()\n        && match self.producer {\n            ProducerState::Producing(tail) => {\n                self.tail == tail\n            }\n            ProducerState::Idle(tail) => {\n                self.tail == tail\n            }\n        }\n        && match self.consumer {\n            ConsumerState::Consuming(head) => {\n                self.head == head\n            }\n            ConsumerState::Idle(head) => {\n                self.head == head\n            }\n        }\n    }\n\n    // Indicates whether we expect the cell at index `i` to be full based on\n    // the values of the `head` and `tail`.\n\n    pub open spec fn in_active_range(&self, i: nat) -> bool {\n        // Note that self.head = self.tail means empty range\n        0 <= i && i < self.len() && (\n            if self.head <= self.tail {\n                self.head <= i && i < self.tail\n            } else {\n                i >= self.head || i < self.tail\n            }\n        )\n    }\n\n    // Indicates whether we expect a cell to be checked out or not,\n    // based on the producer/consumer state.\n\n    pub open spec fn is_checked_out(&self, i: nat) -> bool {\n        self.producer === ProducerState::Producing(i)\n        || self.consumer === ConsumerState::Consuming(i)\n    }\n\n    // Predicate to determine that the state at cell index `i`\n    // is correct. For each index, there are three possibilities:\n    //\n    //  1. No cell permission is stored\n    //  2. Permission is stored; permission indicates a full cell\n    //  3. Permission is stored; permission indicates an empty cell\n    //\n    // Which of these 3 possibilities we should be in depends on the\n    // producer/consumer/head/tail state.\n\n    pub open spec fn valid_storage_at_idx(&self, i: nat) -> bool {\n        if self.is_checked_out(i) {\n            // No cell permission is stored\n            !self.storage.dom().contains(i)\n        } else {\n            // Permission is stored\n            self.storage.dom().contains(i)\n\n            // Permission must be for the correct cell:\n            && self.storage.index(i).id() === self.backing_cells.index(i as int)\n\n            && if self.in_active_range(i) {\n                // The cell is full\n                self.storage.index(i).is_init()\n            } else {\n                // The cell is empty\n                self.storage.index(i).is_uninit()\n            }\n        }\n    }\n\n    #[invariant]\n    pub fn valid_storage_all(&self) -> bool {\n        forall|i: nat| 0 <= i && i < self.len() ==>\n            self.valid_storage_at_idx(i)\n    }\n\n    init!{\n        initialize(backing_cells: Seq<CellId>, storage: Map<nat, cell::PointsTo<T>>) {\n            // Upon initialization, the user needs to deposit _all_ the relevant\n            // cell permissions to start with. Each permission should indicate\n            // an empty cell.\n\n            require(\n                (forall|i: nat| 0 <= i && i < backing_cells.len() ==>\n                    #[trigger] storage.dom().contains(i)\n                    && storage.index(i).id() === backing_cells.index(i as int)\n                    && storage.index(i).is_uninit())\n            );\n            require(backing_cells.len() > 0);\n\n            init backing_cells = backing_cells;\n            init storage = storage;\n            init head = 0;\n            init tail = 0;\n            init producer = ProducerState::Idle(0);\n            init consumer = ConsumerState::Idle(0);\n        }\n    }\n\n    // ANCHOR: transition_produce_start\n    transition!{\n        produce_start() {\n            // In order to begin, we have to be in ProducerState::Idle.\n            require(pre.producer.is_Idle());\n\n            // We'll be comparing the producer's _local_ copy of the tail\n            // with the _shared_ version of the head.\n            let tail = pre.producer.get_Idle_0();\n            let head = pre.head;\n\n            assert(0 <= tail && tail < pre.backing_cells.len());\n\n            // Compute the incremented tail, wrapping around if necessary.\n            let next_tail = Self::inc_wrap(tail, pre.backing_cells.len());\n\n            // We have to check that the buffer isn't full to proceed.\n            require(next_tail != head);\n\n            // Update the producer's local state to be in the `Producing` state.\n            update producer = ProducerState::Producing(tail);\n\n            // Withdraw (\"check out\") the permission stored at index `tail`.\n            // This creates a proof obligation for the transition system to prove that\n            // there is actually a permission stored at this index.\n            withdraw storage -= [tail => let perm] by {\n                assert(pre.valid_storage_at_idx(tail));\n            };\n\n            // The transition needs to guarantee to the client that the\n            // permission they are checking out:\n            //  (i) is for the cell at index `tail` (the IDs match)\n            //  (ii) the permission indicates that the cell is empty\n            assert(\n                perm.id() === pre.backing_cells.index(tail as int)\n                && perm.is_uninit()\n            ) by {\n                assert(!pre.in_active_range(tail));\n                assert(pre.valid_storage_at_idx(tail));\n            };\n        }\n    }\n    // ANCHOR_END: transition_produce_start\n\n    // ANCHOR: transition_produce_end\n    transition!{\n        // This transition is parameterized by the value of the permission\n        // being inserted. Since the permission is being deposited\n        // (coming from \"outside\" the system) we can't compute it as a\n        // function of the current state, unlike how we did it for the\n        // `produce_start` transition).\n        produce_end(perm: cell::PointsTo<T>) {\n            // In order to complete the produce step,\n            // we have to be in ProducerState::Producing.\n            require(pre.producer.is_Producing());\n            let tail = pre.producer.get_Producing_0();\n\n            assert(0 <= tail && tail < pre.backing_cells.len());\n\n            // Compute the incremented tail, wrapping around if necessary.\n            let next_tail = Self::inc_wrap(tail, pre.backing_cells.len());\n\n            // This time, we don't need to compare the `head` and `tail` - we already\n            // check that, and anyway, we don't have access to the `head` field\n            // for this transition. (This transition is supposed to occur while\n            // modifying the `tail` field, so we can't do both.)\n\n            // However, we _do_ need to check that the permission token being\n            // checked in satisfies its requirements. It has to be associated\n            // with the correct cell, and it has to be full.\n\n            require(perm.id() === pre.backing_cells.index(tail as int)\n              && perm.is_init());\n\n            // Perform our updates. Update the tail to the computed value,\n            // both the shared version and the producer's local copy.\n            // Also, move back to the Idle state.\n            update producer = ProducerState::Idle(next_tail);\n            update tail = next_tail;\n\n            // Check the permission back into the storage map.\n            deposit storage += [tail => perm] by { assert(pre.valid_storage_at_idx(tail)); };\n        }\n    }\n    // ANCHOR_END: transition_produce_end\n\n    transition!{\n        consume_start() {\n            // In order to begin, we have to be in ConsumerState::Idle.\n            require(pre.consumer.is_Idle());\n\n            // We'll be comparing the consumer's _local_ copy of the head\n            // with the _shared_ version of the tail.\n            let head = pre.consumer.get_Idle_0();\n            let tail = pre.tail;\n\n            assert(0 <= head && head < pre.backing_cells.len());\n\n            // We have to check that the buffer isn't empty to proceed.\n            require(head != tail);\n\n            // Update the consumer's local state to be in the `Consuming` state.\n            update consumer = ConsumerState::Consuming(head);\n\n            // Withdraw (\"check out\") the permission stored at index `tail`.\n\n            birds_eye let perm = pre.storage.index(head);\n            withdraw storage -= [head => perm] by {\n                assert(pre.valid_storage_at_idx(head));\n            };\n\n            assert(perm.id() === pre.backing_cells.index(head as int)) by {\n                assert(pre.valid_storage_at_idx(head));\n            };\n            assert(perm.is_init()) by {\n                assert(pre.in_active_range(head));\n                assert(pre.valid_storage_at_idx(head));\n            };\n        }\n    }\n\n    transition!{\n        consume_end(perm: cell::PointsTo<T>) {\n            require(pre.consumer.is_Consuming());\n            let head = pre.consumer.get_Consuming_0();\n\n            assert(0 <= head && head < pre.backing_cells.len());\n            let next_head = Self::inc_wrap(head, pre.backing_cells.len());\n\n            update consumer = ConsumerState::Idle(next_head);\n            update head = next_head;\n\n            require(perm.id() === pre.backing_cells.index(head as int)\n              && perm.is_uninit());\n            deposit storage += [head => perm] by { assert(pre.valid_storage_at_idx(head)); };\n        }\n    }\n\n    #[inductive(initialize)]\n    fn initialize_inductive(post: Self, backing_cells: Seq<CellId>, storage: Map<nat, cell::PointsTo<T>>) {\n        assert forall|i: nat|\n            0 <= i && i < post.len() implies post.valid_storage_at_idx(i)\n        by {\n            assert(post.storage.dom().contains(i));\n            /*\n            assert(\n                post.storage.index(i).id() ===\n                post.backing_cells.index(i)\n            );\n            assert(if post.in_active_range(i) {\n                post.storage.index(i).value.is_Some()\n            } else {\n                post.storage.index(i).value.is_None()\n            });*/\n        }\n    }\n\n    //// Invariant proofs\n\n    #[inductive(produce_start)]\n    fn produce_start_inductive(pre: Self, post: Self) {\n        let tail = pre.producer.get_Idle_0();\n        assert(!pre.in_active_range(tail));\n        match (post.producer, post.consumer) {\n            (ProducerState::Producing(tail), ConsumerState::Idle(head)) => {\n                assert(Self::inc_wrap(tail, post.len()) != head);\n            }\n            (ProducerState::Producing(tail), ConsumerState::Consuming(head)) => {\n                assert(head != tail);\n                assert(Self::inc_wrap(tail, post.len()) != head);\n            }\n            (ProducerState::Idle(tail), ConsumerState::Idle(head)) => {\n            }\n            (ProducerState::Idle(tail), ConsumerState::Consuming(head)) => {\n                assert(head != tail);\n            }\n        }\n        assert(forall|i| pre.valid_storage_at_idx(i) ==> post.valid_storage_at_idx(i));\n    }\n\n    #[inductive(produce_end)]\n    fn produce_end_inductive(pre: Self, post: Self, perm: cell::PointsTo<T>) {\n        assert forall |i|\n            pre.valid_storage_at_idx(i) implies\n            post.valid_storage_at_idx(i)\n        by {\n            /*if post.is_checked_out(i) {\n                assert(!post.storage.dom().contains(i));\n            } else {\n                assert(post.storage.dom().contains(i));\n                assert(\n                    post.storage.index(i).id() ===\n                    post.backing_cells.index(i)\n                );\n                assert(if post.in_active_range(i) {\n                    post.storage.index(i).value.is_Some()\n                } else {\n                    post.storage.index(i).value.is_None()\n                });\n            }*/\n        }\n    }\n\n    #[inductive(consume_start)]\n    fn consume_start_inductive(pre: Self, post: Self) {\n        assert forall |i|\n            pre.valid_storage_at_idx(i) implies post.valid_storage_at_idx(i)\n        by { }\n    }\n\n    #[inductive(consume_end)]\n    fn consume_end_inductive(pre: Self, post: Self, perm: cell::PointsTo<T>) {\n        let head = pre.consumer.get_Consuming_0();\n        assert(post.storage.dom().contains(head));\n        assert(\n                post.storage.index(head).id() ===\n                post.backing_cells.index(head as int)\n            );\n        assert(if post.in_active_range(head) {\n                post.storage.index(head).is_init()\n            } else {\n                post.storage.index(head).is_uninit()\n            });\n\n        match (pre.producer, pre.consumer) {\n            (ProducerState::Producing(tail), ConsumerState::Idle(head)) => {\n                assert(pre.head != pre.tail);\n            }\n            (ProducerState::Producing(tail), ConsumerState::Consuming(head)) => {\n                assert(pre.head != pre.tail);\n            }\n            (ProducerState::Idle(tail), ConsumerState::Idle(head)) => {\n                assert(pre.head != pre.tail);\n            }\n            (ProducerState::Idle(tail), ConsumerState::Consuming(head)) => {\n                assert(pre.head != pre.tail);\n            }\n        };\n\n        assert(pre.head != pre.tail);\n        assert(!post.is_checked_out(head));\n        assert(post.valid_storage_at_idx(head));\n\n        assert forall |i|\n            pre.valid_storage_at_idx(i) implies post.valid_storage_at_idx(i)\n        by { }\n    }\n}}\n\n// ANCHOR: impl_queue_struct\nstruct_with_invariants!{\n    struct Queue<T> {\n        buffer: Vec<PCell<T>>,\n        head: AtomicU64<_, FifoQueue::head<T>, _>,\n        tail: AtomicU64<_, FifoQueue::tail<T>, _>,\n\n        instance: Tracked<FifoQueue::Instance<T>>,\n    }\n\n    pub closed spec fn wf(&self) -> bool {\n        predicate {\n            // The Cell IDs in the instance protocol match the cell IDs in the actual vector:\n            &&& self.instance@.backing_cells().len() == self.buffer@.len()\n            &&& forall|i: int| 0 <= i && i < self.buffer@.len() as int ==>\n                self.instance@.backing_cells().index(i) ===\n                    self.buffer@.index(i).id()\n        }\n\n        invariant on head with (instance) is (v: u64, g: FifoQueue::head<T>) {\n            &&& g.instance_id() === instance@.id()\n            &&& g.value() == v as int\n        }\n\n        invariant on tail with (instance) is (v: u64, g: FifoQueue::tail<T>) {\n            &&& g.instance_id() === instance@.id()\n            &&& g.value() == v as int\n        }\n    }\n}\n// ANCHOR_END: impl_queue_struct\n\n// ANCHOR: impl_producer_struct\npub struct Producer<T> {\n    queue: Arc<Queue<T>>,\n    tail: usize,\n    producer: Tracked<FifoQueue::producer<T>>,\n}\n\nimpl<T> Producer<T> {\n    pub closed spec fn wf(&self) -> bool {\n        (*self.queue).wf()\n            && self.producer@.instance_id() == (*self.queue).instance@.id()\n            && self.producer@.value() == ProducerState::Idle(self.tail as nat)\n            && (self.tail as int) < (*self.queue).buffer@.len()\n    }\n}\n// ANCHOR_END: impl_producer_struct\n\n// ANCHOR: impl_consumer_struct\npub struct Consumer<T> {\n    queue: Arc<Queue<T>>,\n    head: usize,\n    consumer: Tracked<FifoQueue::consumer<T>>,\n}\n\nimpl<T> Consumer<T> {\n    pub closed spec fn wf(&self) -> bool {\n        (*self.queue).wf()\n            && self.consumer@.instance_id() === (*self.queue).instance@.id()\n            && self.consumer@.value() === ConsumerState::Idle(self.head as nat)\n            && (self.head as int) < (*self.queue).buffer@.len()\n    }\n}\n// ANCHOR_END: impl_consumer_struct\n\n// ANCHOR: impl_new_queue\npub fn new_queue<T>(len: usize) -> (pc: (Producer<T>, Consumer<T>))\n    requires\n        len > 0,\n    ensures\n        pc.0.wf(),\n        pc.1.wf(),\n{\n    // Initialize the vector to store the cells\n    let mut backing_cells_vec = Vec::<PCell<T>>::new();\n    // Initialize map for the permissions to the cells\n    // (keyed by the indices into the vector)\n    let tracked mut perms = Map::<nat, cell::PointsTo<T>>::tracked_empty();\n    while backing_cells_vec.len() < len\n        invariant\n            forall|j: nat|\n                #![trigger( perms.dom().contains(j) )]\n                #![trigger( backing_cells_vec@.index(j as int) )]\n                #![trigger( perms.index(j) )]\n                0 <= j && j < backing_cells_vec.len() as int ==> perms.dom().contains(j)\n                    && backing_cells_vec@.index(j as int).id() === perms.index(j).id()\n                    && perms.index(j).is_uninit(),\n    {\n        let ghost i = backing_cells_vec.len();\n        let (cell, cell_perm) = PCell::empty();\n        backing_cells_vec.push(cell);\n        proof {\n            perms.tracked_insert(i as nat, cell_perm.get());\n        }\n        assert(perms.dom().contains(i as nat));\n        assert(backing_cells_vec@.index(i as int).id() === perms.index(i as nat).id());\n        assert(perms.index(i as nat).is_uninit());\n    }\n    // Vector for ids\n\n    let ghost mut backing_cells_ids = Seq::<CellId>::new(\n        backing_cells_vec@.len(),\n        |i: int| backing_cells_vec@.index(i).id(),\n    );\n    // Initialize an instance of the FIFO queue\n    let tracked (\n        Tracked(instance),\n        Tracked(head_token),\n        Tracked(tail_token),\n        Tracked(producer_token),\n        Tracked(consumer_token),\n    ) = FifoQueue::Instance::initialize(backing_cells_ids, perms, perms);\n    // Initialize atomics\n    let tracked_inst: Tracked<FifoQueue::Instance<T>> = Tracked(instance.clone());\n    let head_atomic = AtomicU64::new(Ghost(tracked_inst), 0, Tracked(head_token));\n    let tail_atomic = AtomicU64::new(Ghost(tracked_inst), 0, Tracked(tail_token));\n    // Initialize the queue\n    let queue = Queue::<T> {\n        instance: Tracked(instance),\n        head: head_atomic,\n        tail: tail_atomic,\n        buffer: backing_cells_vec,\n    };\n    // Share the queue between the producer and consumer\n    let queue_arc = Arc::new(queue);\n    let prod = Producer::<T> {\n        queue: queue_arc.clone(),\n        tail: 0,\n        producer: Tracked(producer_token),\n    };\n    let cons = Consumer::<T> { queue: queue_arc, head: 0, consumer: Tracked(consumer_token) };\n    (prod, cons)\n}\n// ANCHOR_END: impl_new_queue\n\n// ANCHOR: impl_producer\nimpl<T> Producer<T> {\n    fn enqueue(&mut self, t: T)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n    {\n        // Loop: if the queue is full, then block until it is not.\n        loop\n            invariant\n                self.wf(),\n        {\n            let queue = &*self.queue;\n            let len = queue.buffer.len();\n            assert(0 <= self.tail && self.tail < len);\n            // Calculate the index of the slot right after `tail`, wrapping around\n            // if necessary. If the enqueue is successful, then we will be updating\n            // the `tail` to this value.\n            let next_tail = if self.tail + 1 == len {\n                0\n            } else {\n                self.tail + 1\n            };\n            let tracked cell_perm: Option<cell::PointsTo<T>>;\n            // Get the current `head` value from the shared atomic.\n            let head =\n                atomic_with_ghost!(&queue.head => load();\n                returning head;\n                ghost head_token => {\n                    // If `head != next_tail`, then we proceed with the operation.\n                    // We check here, ghostily, in the `open_atomic_invariant` block if that's the case.\n                    // If so, we proceed with the `produce_start` transition\n                    // and obtain the cell permission.\n                    cell_perm = if head != next_tail as u64 {\n                        let tracked cp = queue.instance.borrow().produce_start(&head_token, self.producer.borrow_mut());\n                        Option::Some(cp)\n                    } else {\n                        Option::None\n                    };\n                }\n            );\n            // Here's where we \"actually\" do the `head != next_tail` check:\n            if head != next_tail as u64 {\n                // Unwrap the cell_perm from the option.\n                let tracked mut cell_perm = match cell_perm {\n                    Option::Some(cp) => cp,\n                    Option::None => {\n                        assert(false);\n                        proof_from_false()\n                    },\n                };\n                // Write the element t into the buffer, updating the cell\n                // from uninitialized to initialized (to the value t).\n                queue.buffer[self.tail].put(Tracked(&mut cell_perm), t);\n                // Store the updated tail to the shared `tail` atomic,\n                // while performing the `produce_end` transition.\n                atomic_with_ghost!(&queue.tail => store(next_tail as u64); ghost tail_token => {\n                    queue.instance.borrow().produce_end(cell_perm,\n                        cell_perm, &mut tail_token, self.producer.borrow_mut());\n                });\n                self.tail = next_tail;\n                return ;\n            }\n        }\n    }\n}\n// ANCHOR_END: impl_producer\n\n// ANCHOR: impl_consumer\nimpl<T> Consumer<T> {\n    fn dequeue(&mut self) -> (t: T)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n    {\n        loop\n            invariant\n                self.wf(),\n        {\n            let queue = &*self.queue;\n            let len = queue.buffer.len();\n            assert(0 <= self.head && self.head < len);\n            let next_head = if self.head + 1 == len {\n                0\n            } else {\n                self.head + 1\n            };\n            let tracked cell_perm: Option<cell::PointsTo<T>>;\n            let tail =\n                atomic_with_ghost!(&queue.tail => load();\n                returning tail;\n                ghost tail_token => {\n                    cell_perm = if self.head as u64 != tail {\n                        let tracked (_, Tracked(cp)) = queue.instance.borrow().consume_start(&tail_token, self.consumer.borrow_mut());\n                        Option::Some(cp)\n                    } else {\n                        Option::None\n                    };\n                }\n            );\n            if self.head as u64 != tail {\n                let tracked mut cell_perm = match cell_perm {\n                    Option::Some(cp) => cp,\n                    Option::None => {\n                        assert(false);\n                        proof_from_false()\n                    },\n                };\n                let t = queue.buffer[self.head].take(Tracked(&mut cell_perm));\n                atomic_with_ghost!(&queue.head => store(next_head as u64); ghost head_token => {\n                    queue.instance.borrow().consume_end(cell_perm,\n                        cell_perm, &mut head_token, self.consumer.borrow_mut());\n                });\n                self.head = next_head;\n                return t;\n            }\n        }\n    }\n}\n\nfn main() {\n    let (mut producer, mut consumer) = new_queue(20);\n\n    // Simple test:\n\n    producer.enqueue(5);\n    producer.enqueue(6);\n    producer.enqueue(7);\n\n    let x = consumer.dequeue();\n    print_u64(x);\n\n    let x = consumer.dequeue();\n    print_u64(x);\n\n    let x = consumer.dequeue();\n    print_u64(x);\n\n    // Multi-threaded test:\n\n    let producer = producer;\n    let _join_handle = vstd::thread::spawn(\n        move ||\n            {\n                let mut producer = producer;\n                let mut i = 0;\n                while i < 100\n                    invariant\n                        producer.wf(),\n                {\n                    producer.enqueue(i);\n                    i = i + 1;\n                }\n            },\n    );\n    let mut i = 0;\n    while i < 100\n        invariant\n            consumer.wf(),\n    {\n        let x = consumer.dequeue();\n        print_u64(x);\n        i = i + 1;\n    }\n}\n\n} // verus!\n// ANCHOR_END: impl_consumer\n// ANCHOR_END: full\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/state_machines/tutorial/fifo.rs", "verified": true, "metadata": {"original_id": "verus_fifo_7d613aff30a4", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_c_missing_decreases_02bc440edcf8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } i += 1 ; } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let element = arr1 [i] ; if contains (arr2 , element) && ! contains (& result , element) { result . push (element) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i , { if arr [i] == key { return true ; } i += 1 ; } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , decreases arr1 . len () - i , { let element = arr1 [i] ; if contains (arr2 , element) && ! contains (& result , element) { result . push (element) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i , { if arr [i] == key { return true ; } i += 1 ; } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , decreases arr1 . len () - i , { let element = arr1 [i] ; if contains (arr2 , element) && ! contains (& result , element) { result . push (element) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "02bc440edcf8", "function_name": "intersection", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_f086a67575eb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32)  ensures k_out >= 0 , { k }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "f086a67575eb", "function_name": "main_method", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_verus_assert_by_compute_a4dde075646d", "task": "task_c", "input_text": "// rust_verify/tests/example.rs no-report-long-running --- Don't report long-running tests\n#![recursion_limit = \"512\"]\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\nfn main() {\n}\n\n/// Different components of this file can be enabled/disabled quickly and easily using\n/// `#[cfg(any())]` which simply turns off a module.\n/// Any module with its `#[cfg(any())]` line commented out is valid to run.\n//#[cfg(any())]\nmod fib {\n    use super::*;\n\n    #[verifier::memoize]\n    spec fn fib(x: nat) -> nat\n        decreases x,\n    {\n        if x == 0 {\n            0\n        } else if x == 1 {\n            1\n        } else {\n            fib((x - 1) as nat) + fib((x - 2) as nat)\n        }\n    }\n\n    fn test() {\n        //assert(fib(10) == 55);  // Fails without more fuel\n        assert(fib(10) == 55) by (compute_only);\n        assert(fib(100) == 354224848179261915075) by (compute_only);\n        assert(fib(101) == 573147844013817084101) by (compute_only);\n        assert(fib(102) == 927372692193078999176);  // Succeeds based on the two results above\n    }\n\n}\n\n//#[cfg(any())]\nmod verititan_example {\n    use super::*;\n\n    // Naive definition of exponentiation\n    spec fn pow(base: nat, exp: nat) -> nat\n        decreases exp,\n    {\n        if exp == 0 {\n            1\n        } else {\n            base * pow(base, (exp - 1) as nat)\n        }\n    }\n\n    spec const Q: nat = 12289;\n\n    spec const L: nat = 11;\n\n    spec const G: nat = 7;\n\n    fn compute_verititan() {\n        // Fails, since Z3 doesn't have nearly enough fuel to calculate this\n        // assert(pow(G, pow(2, L) / 2) % Q == Q - 1);\n        assert(pow(G, pow(2, L) / 2) % Q == Q - 1) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod recursive_data_structures {\n    use super::*;\n\n    enum List<T> {\n        Nil,\n        Cons(T, Box<List<T>>),\n    }\n\n    spec fn len<T>(l: List<T>) -> nat\n        decreases l,\n    {\n        match l {\n            List::Nil => 0,\n            List::Cons(_, tl) => 1 + len(*tl),\n        }\n    }\n\n    spec fn append<T>(l: List<T>, x: T) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Cons(x, Box::new(List::Nil)),\n            List::Cons(hd, tl) => List::Cons(hd, Box::new(append(*tl, x))),\n        }\n    }\n\n    spec fn reverse<T>(l: List<T>) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Nil,\n            List::Cons(hd, tl) => append(reverse(*tl), hd),\n        }\n    }\n\n    spec fn ex1() -> List<nat> {\n        List::Cons(\n            1,\n            Box::new(\n                List::Cons(\n                    2,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(4, Box::new(List::Cons(5, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    spec fn ex1_rev() -> List<nat> {\n        List::Cons(\n            5,\n            Box::new(\n                List::Cons(\n                    4,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(2, Box::new(List::Cons(1, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    proof fn compute_list() {\n        assert(len(ex1()) == 5) by (compute_only);\n        assert(len(append(ex1(), 6)) == 6) by (compute_only);\n        assert(equal(reverse(ex1()), ex1_rev())) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod sequences {\n    use super::*;\n\n    spec fn reverse<T>(s: Seq<T>) -> Seq<T>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    fn compute_seq_symbolic<T>(a: T, b: T, c: T, d: T) {\n        assert(seq![a, b, c, d].len() == 4) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].push(c).push(d)) by (compute_only);\n        assert(seq![a, b, c, d].subrange(1, 3) =~= seq![b].push(c)) by (compute_only);\n        assert(seq![a, b, c, d] =~= reverse(seq![d, c, b, a])) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_original {\n    use super::*;\n\n    // VeriBetrKV example original:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool>\n        decreases l,\n    {\n        if l == 0 {\n            Seq::empty()\n        } else {\n            zeroes((l - 1) as nat).push(false)\n        }\n    }\n\n    proof fn zeroes_len(l: nat)\n\n    {\n        if l == 0 {\n        } else {\n            zeroes_len((l - 1) as nat);\n        }\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            p.len() == q.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            Seq::empty()\n        } else {\n            xor(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1)).push(p.last() ^ q.last())\n        }\n    }\n\n    proof fn xor_len(p: Seq<bool>, q: Seq<bool>)\n        requires\n            p.len() == q.len(),\n\n    {\n        if p.len() == 0 {\n            assert(xor(p, q).len() == p.len());\n        } else {\n            xor_len(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1));\n        }\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    #[verifier::recommends_by]\n    proof fn mod_F2_X_rec(p: Seq<bool>, q: Seq<bool>) {\n        if p.len() > (q.len() - 1) as nat {\n            zeroes_len((p.len() - q.len()) as nat);\n            xor_len(p, shift(q, (p.len() - q.len()) as nat));\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //    0x3da6d0cb39d3b296, 0xddc0152b0715ce53, 0x1c291d0447db8317, 0x9e4addf80d3b6092,\n    //    0x740eef02c96cfdc0, 0x39d3b296878a92a7, 0x083a6eecdaece73e, 0x0715ce53ab7aff2a,\n    //    0xc49f4f672162d385, 0x47db831783348832, 0x2ad91c30299847d5, 0x0d3b6092b9e02b86,\n    //    0x6992cea218b33a4e, 0xc96cfdc0b6dd949b, 0x7e90804878d9ccb7, 0x878a92a7bac2fd7b,\n    //    0x1b3d8f29a60ce07b, 0xdaece73ece7f39f4, 0xf1d0f55e61d82e56, 0xab7aff2ad270f1a2,\n    //    0xa87ab8a8c619809d, 0x2162d3852b3cac5d, 0x8462d80065863b64, 0x833488321b03397f,\n    //    0x71d111a8ebb883bd, 0x299847d5b3e32c28, 0xffd852c6064f7f26, 0xb9e02b86dd7e3b0c,\n    //    0xdcb17aa4f285651c, 0x18b33a4e10746f3c, 0xf37c5aeec7a68855, 0xb6dd949b271d9844,\n    //    0x6051d5a28e766a0c, 0x78d9ccb793a5f730, 0x18b0d4ff6cb08e5c, 0xbac2fd7b6b749fb2,\n    //    0x21f3d99c1393e203, 0xa60ce07bcec3662e, 0x8f15801496c515bb, 0xce7f39f4e6fc4e6a,\n    //    0xa00457f78227bb8a, 0x61d82e56b0cd4768, 0x8d6d2c4339c7ff35, 0xd270f1a2d7a4825c,\n    //    0x00ac29cf0ab3844b, 0xc619809d0167d312, 0xe9adf796f6076544, 0x2b3cac5d26f6a60a,\n    //    0x96638b34a741c1bf, 0x65863b6498d8d9cb, 0xe0e9f35149c3cc9c, 0x1b03397f68bce87a,\n    //    0x9af01f2d57a3d037, 0xebb883bd6956fc3b, 0x2cff42cf42d98888, 0xb3e32c283771e98f,\n    //    0x88f25a3ab42ae3d9, 0x064f7f262178513a, 0x4e36f0b0e0ac139e, 0xdd7e3b0c170076fa,\n    //    0xbd6f81f8444dd413, 0xf285651c6f345e45, 0x91c9bd4b41d17b64, 0x10746f3cff0dba97,\n    //    0x885f087ba2b73df1, 0xc7a68855f872e54c, 0x4c1449321e41e9fc, 0x271d984486d8e4d2,\n    //    0x52148f02651bd98b, 0x8e766a0c5bb8f1bc, 0xa3c6f37aa90fd27a, 0x93a5f730b3af077a,\n    //    0xd7c0557f4984d782, 0x6cb08e5cca6ef3ac, 0x63ded06a234e0b26, 0x6b749fb2dd66cbbb,\n    //    0x4d56973c4597456a, 0x1393e203e9e28eb4, 0x9669c9df7b3ff57a, 0xcec3662ec9c8b782,\n    //    0xe417f38a3f70cc6f, 0x96c515bb93e106a4, 0x4b9e0f7162ec6c6d, 0xe6fc4e6ad813b325,\n    //    0xd104b8fc0df04680, 0x8227bb8a2342001e, 0x5b3977300a2a8d7e, 0xb0cd47686d9a4957,\n    //    0xe78eb416e8b6368b, 0x39c7ff35d2c3ed1a, 0x61ff0e01995a5724, 0xd7a4825c9ef68d35,\n    //    0x8d96551c0c139b31, 0x0ab3844bf2271e60, 0x0bf80dd20b0bf8ca, 0x0167d3122664fd8b,\n    //    0x8821abeded64812d, 0xf607654402ee03b2, 0x6a45d2b28604ae0f, 0x26f6a60a363bd6b3,\n    //    0xd8d26619135c83fd, 0xa741c1bf5fabe670, 0xde87806c35ec3279, 0x98d8d9cb00bcf5f6,\n    //    0x143387548ae00689, 0x49c3cc9c17f27698, 0x5bd2011f58ca5f00, 0x68bce87aaa7c7ad5,\n    //    0xdd07448eb5cfca28, 0x57a3d037ded288f8, 0xdde8f5b959f229bc, 0x6956fc3b6d390dec,\n    //    0xa3e3e02c37170390, 0x42d988886353c1cc, 0xd73c7beac4584f5c, 0x3771e98ff48642e9,\n    //    0: Result<Vec<Exp>, VirErr>x80ff0093531377e2, 0xb42ae3d9dd35bc8d, 0x8fe4c34db25b29f2, 0x2178513a9a5ede41,\n    //    0xdf99fc11a563905d, 0xe0ac139e45cddf4e, 0x6c23e841acfa3103, 0x170076faa51b6135,\n    //    0xfe314258dfd94fb2, 0x444dd41380f2886b, 0x0d8373a067969a6a, 0x6f345e45021ac5ef,\n    //    0x19e3635ee8310afa, 0x41d17b6475451b04, 0x29f268b48e1450f7, 0xff0dba97cbbe4ee1,\n    //    0x1dc0632a3a83de21, 0xa2b73df1e0cdcf86, 0x1614f396453c1679, 0xf872e54cdefba41c,\n    //    0x9e2993d3613eee91, 0x1e41e9fcddaf5114, 0x6bebd73c1f1dd124, 0x86d8e4d2bedc6ba1,\n    //    0x63ae91e6eca08ffe, 0x651bd98b3ae30875, 0xf8c9da7a0cd1526a, 0x5bb8f1bcb1630f04,\n    //    0x945a19c1ff47317b, 0xa90fd27ad6c3a807, 0xee8213b79a7781e0, 0xb3af077a63d097e9,\n    //    0x93781dc71d31175f, 0x4984d78294eb256e, 0xccc4a1b913184649, 0xca6ef3ac4be7fd90,\n    //    0xa2c2d9717d5c1d64, 0x234e0b2680ba859a, 0x1cad44526eeed1c9, 0xdd66cbbb22c3799f,\n    //    0x74922601d8ecc578, 0x4597456ab3a6da94, 0xc55f7eabcaf933fe, 0xe9e28eb450bfaade,\n    //    0xa19623292e7d11a7, 0x7b3ff57a7d14748f, 0x2d37074932d8041c, 0xc9c8b782889774e1,\n    //    0x397d84a16cc8a0ff, 0x3f70cc6f5aa1f3cf, 0x791132708a074012, 0x93e106a433bc58b3,\n    //    0xbc8178039f2b002a, 0x62ec6c6dbd0bb25f, 0x88eb3c0760bf0a6a, 0xd813b3258515c07f,\n    //    0x6e4cb6303be3c09b, 0x0df04680d8440525, 0x71971d5c682d085d, 0x2342001e465a4eee,\n    //    0xf33b8bc628b5de82, 0x0a2a8d7e077d54e0, 0x9fb3bbc02e5f3c8c, 0x6d9a4957c00df280,\n    //    0x6ef22b23d0a37f43, 0xe8b6368ba52f58ec, 0xce2df76800712e86, 0xd2c3ed1ad6748e82,\n    //    0xe53a4fc747972100, 0x995a572451aeef66, 0xbe60a91a71900712, 0x9ef68d35359674f7,\n    //    0x1dfa0a15647fbd15, 0x0c139b311baaa809, 0x8ec52396469aef86, 0xf2271e6086d42d06,\n    //    0x0e766b114aba1470, 0x0b0bf8ca1c2cce0a, 0x475846a4aa0cd2d3, 0x2664fd8bf8448640,\n    //    0xb2a3dfa6ac4fcdec, 0xed64812de81cf154, 0xdc1a160cc2c7385c, 0x02ee03b295ffd7dc,\n    //    0x79afdf1c91de6176, 0x8604ae0f84ee89ac, 0x07ac6e46533e308d, 0x363bd6b35f0e0438,\n    //    0x15f85253604d6e09, 0x135c83fdaeb3e622, 0x1bec24dd4263eb04, 0x5fabe67050c2cb16,\n    //    0x4c36cd5b6667afe7, 0x35ec32791a6889b8, 0xe0a22e29de42c92a, 0x00bcf5f67f47463d,\n    //    0x7c2b6ed9b82b6080, 0x8ae00689828d550b, 0x06ff88fddca2b4da, 0x17f276984ac726eb,\n    //    0xf7317cf0529295e6, 0x58ca5f005e9f28eb, 0x61b6e40b40c14fff, 0xaa7c7ad596a1f19b,\n    //    0xde8a97f8997157e1, 0xb5cfca28b0ed8196, 0x88f61445097e41e6, 0xded288f84ce8bfe5,\n    //    0xd4520e9ee36841ad, 0x59f229bcd1a9427c, 0x0c592bd593f3319c, 0x6d390decb58ac6fe,\n    //    0x38edfaf3e3809241, 0x37170390f22fd3e2, 0x72cbfcdb83c2df88, 0x6353c1ccd6b1825a,\n    //    0x348331a54e4ff232, 0xc4584f5c6664d9c1, 0xc3977c19836b5a6e, 0xf48642e923d5e7e5,\n    //    0xdafaea7c65065343, 0x531377e21495d20d, 0x73db4c04a29c82eb, 0xdd35bc8df370b37f,\n    //    0x72675ce8ea6dd7dc, 0xb25b29f2e9415bce, 0x3ec2ff8396309b0f, 0x9a5ede41c776b648,\n    //    0xe8c7a017c22c52c5, 0xa563905dcecfcd43, 0xcf4bfaefd8311ee7, 0x45cddf4e24e6fe8f,\n    //    0x6bde1ac7d0c6d7c9, 0xacfa310345aa5d4a, 0xae1175c2cf067065, 0xa51b613582f89c77,\n    //    0x0];\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_list_comprehension {\n    use super::*;\n\n    // VeriBetrKV example using sequence comprehension:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool> {\n        Seq::new(l, |i| false)\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool> {\n        recommends(p.len() == q.len());\n        Seq::new(p.len(), |i| p.index(i) ^ q.index(i))\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        //recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod arch_specific {\n    use verus_builtin::SpecShl;\n\n    proof fn test_shift() {\n        assert((1usize << 20usize) != 0usize) by (compute_only);\n        assert((1usize << 100usize) == 0usize) by (compute_only);\n        // But this next assert should not work (at least without size_of usize set), because usize\n        // could be either 32-bit or 64-bit.\n        //\n        // assert((1usize << 40usize) == 0usize) by (compute_only);\n    }\n\n}\n\n} // verus!\n", "target_text": "// rust_verify/tests/example.rs no-report-long-running --- Don't report long-running tests\n#![recursion_limit = \"512\"]\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\nfn main() {\n}\n\n/// Different components of this file can be enabled/disabled quickly and easily using\n/// `#[cfg(any())]` which simply turns off a module.\n/// Any module with its `#[cfg(any())]` line commented out is valid to run.\n//#[cfg(any())]\nmod fib {\n    use super::*;\n\n    #[verifier::memoize]\n    spec fn fib(x: nat) -> nat\n        decreases x,\n    {\n        if x == 0 {\n            0\n        } else if x == 1 {\n            1\n        } else {\n            fib((x - 1) as nat) + fib((x - 2) as nat)\n        }\n    }\n\n    fn test() {\n        //assert(fib(10) == 55);  // Fails without more fuel\n        assert(fib(10) == 55) by (compute_only);\n        assert(fib(100) == 354224848179261915075) by (compute_only);\n        assert(fib(101) == 573147844013817084101) by (compute_only);\n        assert(fib(102) == 927372692193078999176);  // Succeeds based on the two results above\n    }\n\n}\n\n//#[cfg(any())]\nmod verititan_example {\n    use super::*;\n\n    // Naive definition of exponentiation\n    spec fn pow(base: nat, exp: nat) -> nat\n        decreases exp,\n    {\n        if exp == 0 {\n            1\n        } else {\n            base * pow(base, (exp - 1) as nat)\n        }\n    }\n\n    spec const Q: nat = 12289;\n\n    spec const L: nat = 11;\n\n    spec const G: nat = 7;\n\n    fn compute_verititan() {\n        // Fails, since Z3 doesn't have nearly enough fuel to calculate this\n        // assert(pow(G, pow(2, L) / 2) % Q == Q - 1);\n        assert(pow(G, pow(2, L) / 2) % Q == Q - 1) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod recursive_data_structures {\n    use super::*;\n\n    enum List<T> {\n        Nil,\n        Cons(T, Box<List<T>>),\n    }\n\n    spec fn len<T>(l: List<T>) -> nat\n        decreases l,\n    {\n        match l {\n            List::Nil => 0,\n            List::Cons(_, tl) => 1 + len(*tl),\n        }\n    }\n\n    spec fn append<T>(l: List<T>, x: T) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Cons(x, Box::new(List::Nil)),\n            List::Cons(hd, tl) => List::Cons(hd, Box::new(append(*tl, x))),\n        }\n    }\n\n    spec fn reverse<T>(l: List<T>) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Nil,\n            List::Cons(hd, tl) => append(reverse(*tl), hd),\n        }\n    }\n\n    spec fn ex1() -> List<nat> {\n        List::Cons(\n            1,\n            Box::new(\n                List::Cons(\n                    2,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(4, Box::new(List::Cons(5, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    spec fn ex1_rev() -> List<nat> {\n        List::Cons(\n            5,\n            Box::new(\n                List::Cons(\n                    4,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(2, Box::new(List::Cons(1, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    proof fn compute_list() {\n        assert(len(ex1()) == 5) by (compute_only);\n        assert(len(append(ex1(), 6)) == 6) by (compute_only);\n        assert(equal(reverse(ex1()), ex1_rev())) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod sequences {\n    use super::*;\n\n    spec fn reverse<T>(s: Seq<T>) -> Seq<T>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    fn compute_seq_symbolic<T>(a: T, b: T, c: T, d: T) {\n        assert(seq![a, b, c, d].len() == 4) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].push(c).push(d)) by (compute_only);\n        assert(seq![a, b, c, d].subrange(1, 3) =~= seq![b].push(c)) by (compute_only);\n        assert(seq![a, b, c, d] =~= reverse(seq![d, c, b, a])) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_original {\n    use super::*;\n\n    // VeriBetrKV example original:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool>\n        decreases l,\n    {\n        if l == 0 {\n            Seq::empty()\n        } else {\n            zeroes((l - 1) as nat).push(false)\n        }\n    }\n\n    proof fn zeroes_len(l: nat)\n        ensures\n            zeroes(l).len() == l,\n        decreases l,\n    {\n        if l == 0 {\n        } else {\n            zeroes_len((l - 1) as nat);\n        }\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            p.len() == q.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            Seq::empty()\n        } else {\n            xor(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1)).push(p.last() ^ q.last())\n        }\n    }\n\n    proof fn xor_len(p: Seq<bool>, q: Seq<bool>)\n        requires\n            p.len() == q.len(),\n        ensures\n            xor(p, q).len() == p.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            assert(xor(p, q).len() == p.len());\n        } else {\n            xor_len(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1));\n        }\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    #[verifier::recommends_by]\n    proof fn mod_F2_X_rec(p: Seq<bool>, q: Seq<bool>) {\n        if p.len() > (q.len() - 1) as nat {\n            zeroes_len((p.len() - q.len()) as nat);\n            xor_len(p, shift(q, (p.len() - q.len()) as nat));\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //    0x3da6d0cb39d3b296, 0xddc0152b0715ce53, 0x1c291d0447db8317, 0x9e4addf80d3b6092,\n    //    0x740eef02c96cfdc0, 0x39d3b296878a92a7, 0x083a6eecdaece73e, 0x0715ce53ab7aff2a,\n    //    0xc49f4f672162d385, 0x47db831783348832, 0x2ad91c30299847d5, 0x0d3b6092b9e02b86,\n    //    0x6992cea218b33a4e, 0xc96cfdc0b6dd949b, 0x7e90804878d9ccb7, 0x878a92a7bac2fd7b,\n    //    0x1b3d8f29a60ce07b, 0xdaece73ece7f39f4, 0xf1d0f55e61d82e56, 0xab7aff2ad270f1a2,\n    //    0xa87ab8a8c619809d, 0x2162d3852b3cac5d, 0x8462d80065863b64, 0x833488321b03397f,\n    //    0x71d111a8ebb883bd, 0x299847d5b3e32c28, 0xffd852c6064f7f26, 0xb9e02b86dd7e3b0c,\n    //    0xdcb17aa4f285651c, 0x18b33a4e10746f3c, 0xf37c5aeec7a68855, 0xb6dd949b271d9844,\n    //    0x6051d5a28e766a0c, 0x78d9ccb793a5f730, 0x18b0d4ff6cb08e5c, 0xbac2fd7b6b749fb2,\n    //    0x21f3d99c1393e203, 0xa60ce07bcec3662e, 0x8f15801496c515bb, 0xce7f39f4e6fc4e6a,\n    //    0xa00457f78227bb8a, 0x61d82e56b0cd4768, 0x8d6d2c4339c7ff35, 0xd270f1a2d7a4825c,\n    //    0x00ac29cf0ab3844b, 0xc619809d0167d312, 0xe9adf796f6076544, 0x2b3cac5d26f6a60a,\n    //    0x96638b34a741c1bf, 0x65863b6498d8d9cb, 0xe0e9f35149c3cc9c, 0x1b03397f68bce87a,\n    //    0x9af01f2d57a3d037, 0xebb883bd6956fc3b, 0x2cff42cf42d98888, 0xb3e32c283771e98f,\n    //    0x88f25a3ab42ae3d9, 0x064f7f262178513a, 0x4e36f0b0e0ac139e, 0xdd7e3b0c170076fa,\n    //    0xbd6f81f8444dd413, 0xf285651c6f345e45, 0x91c9bd4b41d17b64, 0x10746f3cff0dba97,\n    //    0x885f087ba2b73df1, 0xc7a68855f872e54c, 0x4c1449321e41e9fc, 0x271d984486d8e4d2,\n    //    0x52148f02651bd98b, 0x8e766a0c5bb8f1bc, 0xa3c6f37aa90fd27a, 0x93a5f730b3af077a,\n    //    0xd7c0557f4984d782, 0x6cb08e5cca6ef3ac, 0x63ded06a234e0b26, 0x6b749fb2dd66cbbb,\n    //    0x4d56973c4597456a, 0x1393e203e9e28eb4, 0x9669c9df7b3ff57a, 0xcec3662ec9c8b782,\n    //    0xe417f38a3f70cc6f, 0x96c515bb93e106a4, 0x4b9e0f7162ec6c6d, 0xe6fc4e6ad813b325,\n    //    0xd104b8fc0df04680, 0x8227bb8a2342001e, 0x5b3977300a2a8d7e, 0xb0cd47686d9a4957,\n    //    0xe78eb416e8b6368b, 0x39c7ff35d2c3ed1a, 0x61ff0e01995a5724, 0xd7a4825c9ef68d35,\n    //    0x8d96551c0c139b31, 0x0ab3844bf2271e60, 0x0bf80dd20b0bf8ca, 0x0167d3122664fd8b,\n    //    0x8821abeded64812d, 0xf607654402ee03b2, 0x6a45d2b28604ae0f, 0x26f6a60a363bd6b3,\n    //    0xd8d26619135c83fd, 0xa741c1bf5fabe670, 0xde87806c35ec3279, 0x98d8d9cb00bcf5f6,\n    //    0x143387548ae00689, 0x49c3cc9c17f27698, 0x5bd2011f58ca5f00, 0x68bce87aaa7c7ad5,\n    //    0xdd07448eb5cfca28, 0x57a3d037ded288f8, 0xdde8f5b959f229bc, 0x6956fc3b6d390dec,\n    //    0xa3e3e02c37170390, 0x42d988886353c1cc, 0xd73c7beac4584f5c, 0x3771e98ff48642e9,\n    //    0: Result<Vec<Exp>, VirErr>x80ff0093531377e2, 0xb42ae3d9dd35bc8d, 0x8fe4c34db25b29f2, 0x2178513a9a5ede41,\n    //    0xdf99fc11a563905d, 0xe0ac139e45cddf4e, 0x6c23e841acfa3103, 0x170076faa51b6135,\n    //    0xfe314258dfd94fb2, 0x444dd41380f2886b, 0x0d8373a067969a6a, 0x6f345e45021ac5ef,\n    //    0x19e3635ee8310afa, 0x41d17b6475451b04, 0x29f268b48e1450f7, 0xff0dba97cbbe4ee1,\n    //    0x1dc0632a3a83de21, 0xa2b73df1e0cdcf86, 0x1614f396453c1679, 0xf872e54cdefba41c,\n    //    0x9e2993d3613eee91, 0x1e41e9fcddaf5114, 0x6bebd73c1f1dd124, 0x86d8e4d2bedc6ba1,\n    //    0x63ae91e6eca08ffe, 0x651bd98b3ae30875, 0xf8c9da7a0cd1526a, 0x5bb8f1bcb1630f04,\n    //    0x945a19c1ff47317b, 0xa90fd27ad6c3a807, 0xee8213b79a7781e0, 0xb3af077a63d097e9,\n    //    0x93781dc71d31175f, 0x4984d78294eb256e, 0xccc4a1b913184649, 0xca6ef3ac4be7fd90,\n    //    0xa2c2d9717d5c1d64, 0x234e0b2680ba859a, 0x1cad44526eeed1c9, 0xdd66cbbb22c3799f,\n    //    0x74922601d8ecc578, 0x4597456ab3a6da94, 0xc55f7eabcaf933fe, 0xe9e28eb450bfaade,\n    //    0xa19623292e7d11a7, 0x7b3ff57a7d14748f, 0x2d37074932d8041c, 0xc9c8b782889774e1,\n    //    0x397d84a16cc8a0ff, 0x3f70cc6f5aa1f3cf, 0x791132708a074012, 0x93e106a433bc58b3,\n    //    0xbc8178039f2b002a, 0x62ec6c6dbd0bb25f, 0x88eb3c0760bf0a6a, 0xd813b3258515c07f,\n    //    0x6e4cb6303be3c09b, 0x0df04680d8440525, 0x71971d5c682d085d, 0x2342001e465a4eee,\n    //    0xf33b8bc628b5de82, 0x0a2a8d7e077d54e0, 0x9fb3bbc02e5f3c8c, 0x6d9a4957c00df280,\n    //    0x6ef22b23d0a37f43, 0xe8b6368ba52f58ec, 0xce2df76800712e86, 0xd2c3ed1ad6748e82,\n    //    0xe53a4fc747972100, 0x995a572451aeef66, 0xbe60a91a71900712, 0x9ef68d35359674f7,\n    //    0x1dfa0a15647fbd15, 0x0c139b311baaa809, 0x8ec52396469aef86, 0xf2271e6086d42d06,\n    //    0x0e766b114aba1470, 0x0b0bf8ca1c2cce0a, 0x475846a4aa0cd2d3, 0x2664fd8bf8448640,\n    //    0xb2a3dfa6ac4fcdec, 0xed64812de81cf154, 0xdc1a160cc2c7385c, 0x02ee03b295ffd7dc,\n    //    0x79afdf1c91de6176, 0x8604ae0f84ee89ac, 0x07ac6e46533e308d, 0x363bd6b35f0e0438,\n    //    0x15f85253604d6e09, 0x135c83fdaeb3e622, 0x1bec24dd4263eb04, 0x5fabe67050c2cb16,\n    //    0x4c36cd5b6667afe7, 0x35ec32791a6889b8, 0xe0a22e29de42c92a, 0x00bcf5f67f47463d,\n    //    0x7c2b6ed9b82b6080, 0x8ae00689828d550b, 0x06ff88fddca2b4da, 0x17f276984ac726eb,\n    //    0xf7317cf0529295e6, 0x58ca5f005e9f28eb, 0x61b6e40b40c14fff, 0xaa7c7ad596a1f19b,\n    //    0xde8a97f8997157e1, 0xb5cfca28b0ed8196, 0x88f61445097e41e6, 0xded288f84ce8bfe5,\n    //    0xd4520e9ee36841ad, 0x59f229bcd1a9427c, 0x0c592bd593f3319c, 0x6d390decb58ac6fe,\n    //    0x38edfaf3e3809241, 0x37170390f22fd3e2, 0x72cbfcdb83c2df88, 0x6353c1ccd6b1825a,\n    //    0x348331a54e4ff232, 0xc4584f5c6664d9c1, 0xc3977c19836b5a6e, 0xf48642e923d5e7e5,\n    //    0xdafaea7c65065343, 0x531377e21495d20d, 0x73db4c04a29c82eb, 0xdd35bc8df370b37f,\n    //    0x72675ce8ea6dd7dc, 0xb25b29f2e9415bce, 0x3ec2ff8396309b0f, 0x9a5ede41c776b648,\n    //    0xe8c7a017c22c52c5, 0xa563905dcecfcd43, 0xcf4bfaefd8311ee7, 0x45cddf4e24e6fe8f,\n    //    0x6bde1ac7d0c6d7c9, 0xacfa310345aa5d4a, 0xae1175c2cf067065, 0xa51b613582f89c77,\n    //    0x0];\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_list_comprehension {\n    use super::*;\n\n    // VeriBetrKV example using sequence comprehension:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool> {\n        Seq::new(l, |i| false)\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool> {\n        recommends(p.len() == q.len());\n        Seq::new(p.len(), |i| p.index(i) ^ q.index(i))\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        //recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod arch_specific {\n    use verus_builtin::SpecShl;\n\n    proof fn test_shift() {\n        assert((1usize << 20usize) != 0usize) by (compute_only);\n        assert((1usize << 100usize) == 0usize) by (compute_only);\n        // But this next assert should not work (at least without size_of usize set), because usize\n        // could be either 32-bit or 64-bit.\n        //\n        // assert((1usize << 40usize) == 0usize) by (compute_only);\n    }\n\n}\n\n} // verus!\n", "full_verified_code": "// rust_verify/tests/example.rs no-report-long-running --- Don't report long-running tests\n#![recursion_limit = \"512\"]\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\nfn main() {\n}\n\n/// Different components of this file can be enabled/disabled quickly and easily using\n/// `#[cfg(any())]` which simply turns off a module.\n/// Any module with its `#[cfg(any())]` line commented out is valid to run.\n//#[cfg(any())]\nmod fib {\n    use super::*;\n\n    #[verifier::memoize]\n    spec fn fib(x: nat) -> nat\n        decreases x,\n    {\n        if x == 0 {\n            0\n        } else if x == 1 {\n            1\n        } else {\n            fib((x - 1) as nat) + fib((x - 2) as nat)\n        }\n    }\n\n    fn test() {\n        //assert(fib(10) == 55);  // Fails without more fuel\n        assert(fib(10) == 55) by (compute_only);\n        assert(fib(100) == 354224848179261915075) by (compute_only);\n        assert(fib(101) == 573147844013817084101) by (compute_only);\n        assert(fib(102) == 927372692193078999176);  // Succeeds based on the two results above\n    }\n\n}\n\n//#[cfg(any())]\nmod verititan_example {\n    use super::*;\n\n    // Naive definition of exponentiation\n    spec fn pow(base: nat, exp: nat) -> nat\n        decreases exp,\n    {\n        if exp == 0 {\n            1\n        } else {\n            base * pow(base, (exp - 1) as nat)\n        }\n    }\n\n    spec const Q: nat = 12289;\n\n    spec const L: nat = 11;\n\n    spec const G: nat = 7;\n\n    fn compute_verititan() {\n        // Fails, since Z3 doesn't have nearly enough fuel to calculate this\n        // assert(pow(G, pow(2, L) / 2) % Q == Q - 1);\n        assert(pow(G, pow(2, L) / 2) % Q == Q - 1) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod recursive_data_structures {\n    use super::*;\n\n    enum List<T> {\n        Nil,\n        Cons(T, Box<List<T>>),\n    }\n\n    spec fn len<T>(l: List<T>) -> nat\n        decreases l,\n    {\n        match l {\n            List::Nil => 0,\n            List::Cons(_, tl) => 1 + len(*tl),\n        }\n    }\n\n    spec fn append<T>(l: List<T>, x: T) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Cons(x, Box::new(List::Nil)),\n            List::Cons(hd, tl) => List::Cons(hd, Box::new(append(*tl, x))),\n        }\n    }\n\n    spec fn reverse<T>(l: List<T>) -> List<T>\n        decreases l,\n    {\n        match l {\n            List::Nil => List::Nil,\n            List::Cons(hd, tl) => append(reverse(*tl), hd),\n        }\n    }\n\n    spec fn ex1() -> List<nat> {\n        List::Cons(\n            1,\n            Box::new(\n                List::Cons(\n                    2,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(4, Box::new(List::Cons(5, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    spec fn ex1_rev() -> List<nat> {\n        List::Cons(\n            5,\n            Box::new(\n                List::Cons(\n                    4,\n                    Box::new(\n                        List::Cons(\n                            3,\n                            Box::new(List::Cons(2, Box::new(List::Cons(1, Box::new(List::Nil))))),\n                        ),\n                    ),\n                ),\n            ),\n        )\n    }\n\n    proof fn compute_list() {\n        assert(len(ex1()) == 5) by (compute_only);\n        assert(len(append(ex1(), 6)) == 6) by (compute_only);\n        assert(equal(reverse(ex1()), ex1_rev())) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod sequences {\n    use super::*;\n\n    spec fn reverse<T>(s: Seq<T>) -> Seq<T>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    fn compute_seq_symbolic<T>(a: T, b: T, c: T, d: T) {\n        assert(seq![a, b, c, d].len() == 4) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].add(seq![c, d])) by (compute_only);\n        assert(seq![a, b, c, d] =~= seq![a, b].push(c).push(d)) by (compute_only);\n        assert(seq![a, b, c, d].subrange(1, 3) =~= seq![b].push(c)) by (compute_only);\n        assert(seq![a, b, c, d] =~= reverse(seq![d, c, b, a])) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_original {\n    use super::*;\n\n    // VeriBetrKV example original:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool>\n        decreases l,\n    {\n        if l == 0 {\n            Seq::empty()\n        } else {\n            zeroes((l - 1) as nat).push(false)\n        }\n    }\n\n    proof fn zeroes_len(l: nat)\n        ensures\n            zeroes(l).len() == l,\n        decreases l,\n    {\n        if l == 0 {\n        } else {\n            zeroes_len((l - 1) as nat);\n        }\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            p.len() == q.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            Seq::empty()\n        } else {\n            xor(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1)).push(p.last() ^ q.last())\n        }\n    }\n\n    proof fn xor_len(p: Seq<bool>, q: Seq<bool>)\n        requires\n            p.len() == q.len(),\n        ensures\n            xor(p, q).len() == p.len(),\n        decreases p.len(),\n    {\n        if p.len() == 0 {\n            assert(xor(p, q).len() == p.len());\n        } else {\n            xor_len(p.subrange(0, p.len() - 1), q.subrange(0, q.len() - 1));\n        }\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    #[verifier::recommends_by]\n    proof fn mod_F2_X_rec(p: Seq<bool>, q: Seq<bool>) {\n        if p.len() > (q.len() - 1) as nat {\n            zeroes_len((p.len() - q.len()) as nat);\n            xor_len(p, shift(q, (p.len() - q.len()) as nat));\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //    0x3da6d0cb39d3b296, 0xddc0152b0715ce53, 0x1c291d0447db8317, 0x9e4addf80d3b6092,\n    //    0x740eef02c96cfdc0, 0x39d3b296878a92a7, 0x083a6eecdaece73e, 0x0715ce53ab7aff2a,\n    //    0xc49f4f672162d385, 0x47db831783348832, 0x2ad91c30299847d5, 0x0d3b6092b9e02b86,\n    //    0x6992cea218b33a4e, 0xc96cfdc0b6dd949b, 0x7e90804878d9ccb7, 0x878a92a7bac2fd7b,\n    //    0x1b3d8f29a60ce07b, 0xdaece73ece7f39f4, 0xf1d0f55e61d82e56, 0xab7aff2ad270f1a2,\n    //    0xa87ab8a8c619809d, 0x2162d3852b3cac5d, 0x8462d80065863b64, 0x833488321b03397f,\n    //    0x71d111a8ebb883bd, 0x299847d5b3e32c28, 0xffd852c6064f7f26, 0xb9e02b86dd7e3b0c,\n    //    0xdcb17aa4f285651c, 0x18b33a4e10746f3c, 0xf37c5aeec7a68855, 0xb6dd949b271d9844,\n    //    0x6051d5a28e766a0c, 0x78d9ccb793a5f730, 0x18b0d4ff6cb08e5c, 0xbac2fd7b6b749fb2,\n    //    0x21f3d99c1393e203, 0xa60ce07bcec3662e, 0x8f15801496c515bb, 0xce7f39f4e6fc4e6a,\n    //    0xa00457f78227bb8a, 0x61d82e56b0cd4768, 0x8d6d2c4339c7ff35, 0xd270f1a2d7a4825c,\n    //    0x00ac29cf0ab3844b, 0xc619809d0167d312, 0xe9adf796f6076544, 0x2b3cac5d26f6a60a,\n    //    0x96638b34a741c1bf, 0x65863b6498d8d9cb, 0xe0e9f35149c3cc9c, 0x1b03397f68bce87a,\n    //    0x9af01f2d57a3d037, 0xebb883bd6956fc3b, 0x2cff42cf42d98888, 0xb3e32c283771e98f,\n    //    0x88f25a3ab42ae3d9, 0x064f7f262178513a, 0x4e36f0b0e0ac139e, 0xdd7e3b0c170076fa,\n    //    0xbd6f81f8444dd413, 0xf285651c6f345e45, 0x91c9bd4b41d17b64, 0x10746f3cff0dba97,\n    //    0x885f087ba2b73df1, 0xc7a68855f872e54c, 0x4c1449321e41e9fc, 0x271d984486d8e4d2,\n    //    0x52148f02651bd98b, 0x8e766a0c5bb8f1bc, 0xa3c6f37aa90fd27a, 0x93a5f730b3af077a,\n    //    0xd7c0557f4984d782, 0x6cb08e5cca6ef3ac, 0x63ded06a234e0b26, 0x6b749fb2dd66cbbb,\n    //    0x4d56973c4597456a, 0x1393e203e9e28eb4, 0x9669c9df7b3ff57a, 0xcec3662ec9c8b782,\n    //    0xe417f38a3f70cc6f, 0x96c515bb93e106a4, 0x4b9e0f7162ec6c6d, 0xe6fc4e6ad813b325,\n    //    0xd104b8fc0df04680, 0x8227bb8a2342001e, 0x5b3977300a2a8d7e, 0xb0cd47686d9a4957,\n    //    0xe78eb416e8b6368b, 0x39c7ff35d2c3ed1a, 0x61ff0e01995a5724, 0xd7a4825c9ef68d35,\n    //    0x8d96551c0c139b31, 0x0ab3844bf2271e60, 0x0bf80dd20b0bf8ca, 0x0167d3122664fd8b,\n    //    0x8821abeded64812d, 0xf607654402ee03b2, 0x6a45d2b28604ae0f, 0x26f6a60a363bd6b3,\n    //    0xd8d26619135c83fd, 0xa741c1bf5fabe670, 0xde87806c35ec3279, 0x98d8d9cb00bcf5f6,\n    //    0x143387548ae00689, 0x49c3cc9c17f27698, 0x5bd2011f58ca5f00, 0x68bce87aaa7c7ad5,\n    //    0xdd07448eb5cfca28, 0x57a3d037ded288f8, 0xdde8f5b959f229bc, 0x6956fc3b6d390dec,\n    //    0xa3e3e02c37170390, 0x42d988886353c1cc, 0xd73c7beac4584f5c, 0x3771e98ff48642e9,\n    //    0: Result<Vec<Exp>, VirErr>x80ff0093531377e2, 0xb42ae3d9dd35bc8d, 0x8fe4c34db25b29f2, 0x2178513a9a5ede41,\n    //    0xdf99fc11a563905d, 0xe0ac139e45cddf4e, 0x6c23e841acfa3103, 0x170076faa51b6135,\n    //    0xfe314258dfd94fb2, 0x444dd41380f2886b, 0x0d8373a067969a6a, 0x6f345e45021ac5ef,\n    //    0x19e3635ee8310afa, 0x41d17b6475451b04, 0x29f268b48e1450f7, 0xff0dba97cbbe4ee1,\n    //    0x1dc0632a3a83de21, 0xa2b73df1e0cdcf86, 0x1614f396453c1679, 0xf872e54cdefba41c,\n    //    0x9e2993d3613eee91, 0x1e41e9fcddaf5114, 0x6bebd73c1f1dd124, 0x86d8e4d2bedc6ba1,\n    //    0x63ae91e6eca08ffe, 0x651bd98b3ae30875, 0xf8c9da7a0cd1526a, 0x5bb8f1bcb1630f04,\n    //    0x945a19c1ff47317b, 0xa90fd27ad6c3a807, 0xee8213b79a7781e0, 0xb3af077a63d097e9,\n    //    0x93781dc71d31175f, 0x4984d78294eb256e, 0xccc4a1b913184649, 0xca6ef3ac4be7fd90,\n    //    0xa2c2d9717d5c1d64, 0x234e0b2680ba859a, 0x1cad44526eeed1c9, 0xdd66cbbb22c3799f,\n    //    0x74922601d8ecc578, 0x4597456ab3a6da94, 0xc55f7eabcaf933fe, 0xe9e28eb450bfaade,\n    //    0xa19623292e7d11a7, 0x7b3ff57a7d14748f, 0x2d37074932d8041c, 0xc9c8b782889774e1,\n    //    0x397d84a16cc8a0ff, 0x3f70cc6f5aa1f3cf, 0x791132708a074012, 0x93e106a433bc58b3,\n    //    0xbc8178039f2b002a, 0x62ec6c6dbd0bb25f, 0x88eb3c0760bf0a6a, 0xd813b3258515c07f,\n    //    0x6e4cb6303be3c09b, 0x0df04680d8440525, 0x71971d5c682d085d, 0x2342001e465a4eee,\n    //    0xf33b8bc628b5de82, 0x0a2a8d7e077d54e0, 0x9fb3bbc02e5f3c8c, 0x6d9a4957c00df280,\n    //    0x6ef22b23d0a37f43, 0xe8b6368ba52f58ec, 0xce2df76800712e86, 0xd2c3ed1ad6748e82,\n    //    0xe53a4fc747972100, 0x995a572451aeef66, 0xbe60a91a71900712, 0x9ef68d35359674f7,\n    //    0x1dfa0a15647fbd15, 0x0c139b311baaa809, 0x8ec52396469aef86, 0xf2271e6086d42d06,\n    //    0x0e766b114aba1470, 0x0b0bf8ca1c2cce0a, 0x475846a4aa0cd2d3, 0x2664fd8bf8448640,\n    //    0xb2a3dfa6ac4fcdec, 0xed64812de81cf154, 0xdc1a160cc2c7385c, 0x02ee03b295ffd7dc,\n    //    0x79afdf1c91de6176, 0x8604ae0f84ee89ac, 0x07ac6e46533e308d, 0x363bd6b35f0e0438,\n    //    0x15f85253604d6e09, 0x135c83fdaeb3e622, 0x1bec24dd4263eb04, 0x5fabe67050c2cb16,\n    //    0x4c36cd5b6667afe7, 0x35ec32791a6889b8, 0xe0a22e29de42c92a, 0x00bcf5f67f47463d,\n    //    0x7c2b6ed9b82b6080, 0x8ae00689828d550b, 0x06ff88fddca2b4da, 0x17f276984ac726eb,\n    //    0xf7317cf0529295e6, 0x58ca5f005e9f28eb, 0x61b6e40b40c14fff, 0xaa7c7ad596a1f19b,\n    //    0xde8a97f8997157e1, 0xb5cfca28b0ed8196, 0x88f61445097e41e6, 0xded288f84ce8bfe5,\n    //    0xd4520e9ee36841ad, 0x59f229bcd1a9427c, 0x0c592bd593f3319c, 0x6d390decb58ac6fe,\n    //    0x38edfaf3e3809241, 0x37170390f22fd3e2, 0x72cbfcdb83c2df88, 0x6353c1ccd6b1825a,\n    //    0x348331a54e4ff232, 0xc4584f5c6664d9c1, 0xc3977c19836b5a6e, 0xf48642e923d5e7e5,\n    //    0xdafaea7c65065343, 0x531377e21495d20d, 0x73db4c04a29c82eb, 0xdd35bc8df370b37f,\n    //    0x72675ce8ea6dd7dc, 0xb25b29f2e9415bce, 0x3ec2ff8396309b0f, 0x9a5ede41c776b648,\n    //    0xe8c7a017c22c52c5, 0xa563905dcecfcd43, 0xcf4bfaefd8311ee7, 0x45cddf4e24e6fe8f,\n    //    0x6bde1ac7d0c6d7c9, 0xacfa310345aa5d4a, 0xae1175c2cf067065, 0xa51b613582f89c77,\n    //    0x0];\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute);\n    }\n\n}\n\n//#[cfg(any())]\nmod veribetrkv_example_list_comprehension {\n    use super::*;\n\n    // VeriBetrKV example using sequence comprehension:\n    // https://github.com/vmware-labs/verified-betrfs/blob/ee4b18d553933440bb5ecda037c6a1c411a49a5f/lib/Crypto/CRC32Lut.i.dfy\n    spec fn bits_of_int(n: nat, len: nat) -> Seq<bool>\n        decreases len,\n    {\n        if len == 0 {\n            Seq::empty()\n        } else {\n            seq![n % 2 == 1].add(bits_of_int(n / 2, (len - 1) as nat))\n        }\n    }\n\n    spec fn zeroes(l: nat) -> Seq<bool> {\n        Seq::new(l, |i| false)\n    }\n\n    spec fn shift(p: Seq<bool>, t: nat) -> Seq<bool> {\n        zeroes(t).add(p)\n    }\n\n    spec fn xor(p: Seq<bool>, q: Seq<bool>) -> Seq<bool> {\n        recommends(p.len() == q.len());\n        Seq::new(p.len(), |i| p.index(i) ^ q.index(i))\n    }\n\n    spec fn mod_F2_X(p: Seq<bool>, q: Seq<bool>) -> Seq<bool>\n        recommends\n            q.len() > 0,\n        decreases p.len(),\n    {\n        //recommends_by(mod_F2_X_rec);\n        if p.len() <= (q.len() - 1) as nat {\n            p.add(zeroes((q.len() - 1 - p.len()) as nat))\n        } else {\n            if p.last() {\n                mod_F2_X(xor(p, shift(q, (p.len() - q.len()) as nat)).subrange(0, p.len() - 1), q)\n            } else {\n                mod_F2_X(p.subrange(0, p.len() - 1), q)\n            }\n        }\n    }\n\n    spec fn reverse(s: Seq<bool>) -> Seq<bool>\n        decreases s.len(),\n    {\n        if s.len() == 0 {\n            Seq::empty()\n        } else {\n            reverse(s.subrange(1, s.len() as int)).push(s.index(0))\n        }\n    }\n\n    spec fn pow_mod_crc(n: nat) -> Seq<bool> {\n        reverse(mod_F2_X(zeroes((n - 33) as nat).push(true), bits_of_int(0x1_1EDC_6F41, 33)))\n    }\n\n    // TODO: pops the stack if we use the full lut definition\n    spec const lut: Seq<u64> =\n        seq![0x00000001493c7d27, 0x493c7d27ba4fc28e, 0xf20c0dfeddc0152b, 0xba4fc28e9e4addf8];\n\n    //assert (forall n | 1 <= n <= 256 :: bits_of_int(lut[n-1] as int, 64) == pow_mod_crc(2*64*n) + pow_mod_crc(64*n))\n    //    by(computation);\n    spec const v: int = 1;\n\n    fn crc_compute() {\n        assert(bits_of_int(lut.index(v - 1) as nat, 64) =~= pow_mod_crc(2 * 64 * v as nat).add(\n            pow_mod_crc(64 * v as nat),\n        )) by (compute_only);\n    }\n\n}\n\n//#[cfg(any())]\nmod arch_specific {\n    use verus_builtin::SpecShl;\n\n    proof fn test_shift() {\n        assert((1usize << 20usize) != 0usize) by (compute_only);\n        assert((1usize << 100usize) == 0usize) by (compute_only);\n        // But this next assert should not work (at least without size_of usize set), because usize\n        // could be either 32-bit or 64-bit.\n        //\n        // assert((1usize << 40usize) == 0usize) by (compute_only);\n    }\n\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/assert_by_compute.rs", "verified": true, "metadata": {"original_id": "verus_assert_by_compute_a4dde075646d", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_a_53783bc47f7a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn merge_intervals_precond (intervals : Seq < (int , int) >) -> bool { true }\nfn merge_intervals (intervals : Vec < (int , int) >) -> (result : Vec < (int , int) >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires merge_intervals_precond (intervals @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn merge_intervals_precond (intervals : Seq < (int , int) >) -> bool { true }\nfn merge_intervals (intervals : Vec < (int , int) >) -> (result : Vec < (int , int) >) requires merge_intervals_precond (intervals @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_47/verina_advanced_47.rs", "verified": true, "metadata": {"original_id": "53783bc47f7a", "function_name": "merge_intervals", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_d0c86e33c6fb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key ,  { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_51/verina_basic_51_iter_1_current.rs", "verified": true, "metadata": {"original_id": "d0c86e33c6fb", "function_name": "binary_search_loop", "bug_type": "missing_ensures"}}
{"id": "task_a_72be5eeacf95", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool)  { for i in 0 .. text . len ()  { if text [i] == 'Z' || text [i] == 'z' { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) \ninvariant forall | j : int | 0 <= j < i ==> text [j] != 'Z' && text [j] != 'z'", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) , { for i in 0 .. text . len () invariant forall | j : int | 0 <= j < i ==> text [j] != 'Z' && text [j] != 'z' { if text [i] == 'Z' || text [i] == 'z' { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "72be5eeacf95", "function_name": "contains_z", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_b_4df1a8b50f58", "task": "task_b", "input_text": "fn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >)\nrequires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] \nensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_72/verina_basic_72_iter_1_current.rs", "verified": true, "metadata": {"original_id": "4df1a8b50f58", "function_name": "copy", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_54583889d45b", "task": "task_b", "input_text": "fn nonzero (arr : & [i32]) -> (num : i32)\nrequires arr . len () >= 0 \nensures num >= 0 ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn nonzero (arr : & [i32]) -> (num : i32) requires arr . len () >= 0 , ensures num >= 0 , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn nonzero (arr : & [i32]) -> (num : i32) requires arr . len () >= 0 , ensures num >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/vericoding_dafny_to_verus_specs/numpy_specs/np_countnonzero_iter_0_original.rs", "verified": true, "metadata": {"original_id": "54583889d45b", "function_name": "nonzero", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_1b7c625ce440", "task": "task_b", "input_text": "fn pluck_smallest_even (nodes : & Vec < u32 >) -> (result : Vec < u32 >)\nrequires nodes @ . len () <= MAX \nensures result @ . len () == 0 || result @ . len () == 2 , result @ . len () == 0 ==> forall | i : int | 0 <= i < nodes @ . len () ==> nodes @ [i] % 2 != 0 , result @ . len () == 2 ==>", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pluck_smallest_even (nodes : & Vec < u32 >) -> (result : Vec < u32 >) requires nodes @ . len () <= MAX , ensures result @ . len () == 0 || result @ . len () == 2 , result @ . len () == 0 ==> forall | i : int | 0 <= i < nodes @ . len () ==> nodes @ [i] % 2 != 0 , result @ . len () == 2 ==> { &&& result @ [0] % 2 == 0 &&& 0 <= result @ [1] < nodes @ . len () &&& nodes @ [result @ [1] as int] == result @ [0] &&& forall | i : int | 0 <= i < nodes @ . len () ==> (nodes @ [i] % 2 == 0 ==> result @ [0] <= nodes @ [i]) &&& forall | i : int | 0 <= i < result @ [1] ==> nodes @ [i] % 2 != 0 || nodes @ [i] > result @ [0] } , { let mut smallest_even : Option < u32 > = None ; let mut smallest_index : Option < u32 > = None ; for i in 0 .. nodes . len () invariant 0 <= i <= nodes @ . len () , nodes @ . len () <= MAX , smallest_even . is_none () == smallest_index . is_none () , smallest_index . is_none () ==> forall | j : int | 0 <= j < i ==> nodes @ [j] % 2 != 0 , smallest_index . is_some () ==> { &&& 0 <= smallest_index . unwrap () < i as int &&& nodes @ [smallest_index . unwrap () as int] == smallest_even . unwrap () &&& smallest_even . unwrap () % 2 == 0 &&& forall | j : int | 0 <= j < i ==> (nodes @ [j] % 2 == 0 ==> smallest_even . unwrap () <= nodes @ [j]) &&& forall | j : int | 0 <= j < smallest_index . unwrap () ==> nodes @ [j] % 2 != 0 || nodes @ [j] > smallest_even . unwrap () } , { if nodes [i] % 2 == 0 && (smallest_even . is_none () || nodes [i] < smallest_even . unwrap ()) { smallest_even = Some (nodes [i]) ; smallest_index = Some ((i as u32)) ; } } if smallest_index . is_none () { Vec :: new () } else { vec ! [smallest_even . unwrap () , smallest_index . unwrap ()] } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pluck_smallest_even (nodes : & Vec < u32 >) -> (result : Vec < u32 >) requires nodes @ . len () <= MAX , ensures result @ . len () == 0 || result @ . len () == 2 , result @ . len () == 0 ==> forall | i : int | 0 <= i < nodes @ . len () ==> nodes @ [i] % 2 != 0 , result @ . len () == 2 ==> { &&& result @ [0] % 2 == 0 &&& 0 <= result @ [1] < nodes @ . len () &&& nodes @ [result @ [1] as int] == result @ [0] &&& forall | i : int | 0 <= i < nodes @ . len () ==> (nodes @ [i] % 2 == 0 ==> result @ [0] <= nodes @ [i]) &&& forall | i : int | 0 <= i < result @ [1] ==> nodes @ [i] % 2 != 0 || nodes @ [i] > result @ [0] } , { let mut smallest_even : Option < u32 > = None ; let mut smallest_index : Option < u32 > = None ; for i in 0 .. nodes . len () invariant 0 <= i <= nodes @ . len () , nodes @ . len () <= MAX , smallest_even . is_none () == smallest_index . is_none () , smallest_index . is_none () ==> forall | j : int | 0 <= j < i ==> nodes @ [j] % 2 != 0 , smallest_index . is_some () ==> { &&& 0 <= smallest_index . unwrap () < i as int &&& nodes @ [smallest_index . unwrap () as int] == smallest_even . unwrap () &&& smallest_even . unwrap () % 2 == 0 &&& forall | j : int | 0 <= j < i ==> (nodes @ [j] % 2 == 0 ==> smallest_even . unwrap () <= nodes @ [j]) &&& forall | j : int | 0 <= j < smallest_index . unwrap () ==> nodes @ [j] % 2 != 0 || nodes @ [j] > smallest_even . unwrap () } , { if nodes [i] % 2 == 0 && (smallest_even . is_none () || nodes [i] < smallest_even . unwrap ()) { smallest_even = Some (nodes [i]) ; smallest_index = Some ((i as u32)) ; } } if smallest_index . is_none () { Vec :: new () } else { vec ! [smallest_even . unwrap () , smallest_index . unwrap ()] } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/068-pluck_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1b7c625ce440", "function_name": "pluck_smallest_even", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_assert_verus_getting_started_d3f2ed90531b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n\n}\n\n} // verus!\n", "target_text": "use vstd::prelude::*;\n\nverus! {\n\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    assert(min(10, 20) == 10);\n    assert(min(-10, -20) == -20);\n    assert(forall|i: int, j: int| min(i, j) <= i && min(i, j) <= j);\n    assert(forall|i: int, j: int| min(i, j) == i || min(i, j) == j);\n    assert(forall|i: int, j: int| min(i, j) == min(j, i));\n}\n\n} // verus!\n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\nspec fn min(x: int, y: int) -> int {\n    if x <= y {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    assert(min(10, 20) == 10);\n    assert(min(-10, -20) == -20);\n    assert(forall|i: int, j: int| min(i, j) <= i && min(i, j) <= j);\n    assert(forall|i: int, j: int| min(i, j) == i || min(i, j) == j);\n    assert(forall|i: int, j: int| min(i, j) == min(j, i));\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/getting_started.rs", "verified": true, "metadata": {"original_id": "verus_getting_started_d3f2ed90531b", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_b_7287334c84d4", "task": "task_b", "input_text": "fn triple (x : u32) -> (r : u32)\nrequires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "7287334c84d4", "function_name": "triple", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_78e542bc9dd1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX ,  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant result @ . len () == idx * 3 , idx <= s1 @ . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 @ . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant result @ . len () == idx * 3 , idx <= s1 @ . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 @ . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant result @ . len () == idx * 3 , idx <= s1 @ . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 @ . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_578_impl.rs", "verified": true, "metadata": {"original_id": "78e542bc9dd1", "function_name": "interleave", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_verus_interner_63d8677f4199", "task": "task_c", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine! {InternSystem<T> {\n    fields {\n        #[sharding(variable)]\n        pub auth: Seq<T>,\n\n        #[sharding(persistent_map)]\n        pub frag: Map<int, T>,\n    }\n\n    init!{\n        empty() {\n            init auth = Seq::empty();\n            init frag = Map::empty();\n        }\n    }\n\n    transition!{\n        insert(val: T) {\n            require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);\n            update auth = pre.auth.push(val);\n        }\n    }\n\n    transition!{\n        get_frag(idx: int) {\n            require(0 <= idx && idx < pre.auth.len());\n            let val = pre.auth.index(idx);\n            add frag (union)= [idx => val];\n        }\n    }\n\n    property!{\n        get_value(i: int) {\n            have frag >= [i => let val];\n            assert(i < pre.auth.len() && pre.auth.index(i) === val);\n        }\n    }\n\n    property!{\n        compute_equality(idx1: int, val1: T, idx2: int, val2: T) {\n            have frag >= [idx1 => val1];\n            have frag >= [idx2 => val2];\n            assert((idx1 == idx2) <==> (val1 === val2));\n        }\n    }\n\n    #[invariant]\n    pub fn agreement(&self) -> bool {\n        forall |k| #[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()\n                && self.auth.index(k) === self.frag.index(k)\n    }\n\n    #[invariant]\n    pub fn distinct(&self) -> bool {\n        forall |i: int, j: int|\n            0 <= i && i < self.auth.len() &&\n            0 <= j && j < self.auth.len() &&\n            i != j\n            ==>\n            self.auth.index(i) !== self.auth.index(j)\n    }\n\n    #[inductive(empty)]\n    fn empty_inductive(post: Self) { }\n\n    #[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {\n        /*assert_forall_by(|k| {\n            requires(post.frag.dom().contains(k));\n            ensures(0 <= k && k < post.auth.len()\n                && equal(post.auth.index(k), post.frag.index(k)));\n\n            assert(pre.frag.dom().contains(k));\n            assert(k < pre.auth.len());\n            assert(k < post.auth.len());\n            assert(equal(post.auth.index(k), post.frag.index(k)));\n        })*/\n        /*assert_forall_by(|i: int, j: int| {\n            requires(\n                0 <= i && i < post.auth.len() &&\n                0 <= j && j < post.auth.len() &&\n                i != j\n            );\n            ensures(!equal(post.auth.index(i), post.auth.index(j)));\n\n            if i == post.auth.len() as int - 1 {\n                if j == post.auth.len() as int - 1 {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            } else {\n                if j == post.auth.len() as int - 1 {\n                    assert(equal(post.auth.index(pre.auth.len()), val));\n                    assert(equal(post.auth.index(j), val));\n                    assert(equal(post.auth.index(i), pre.auth.index(i)));\n                    assert(!equal(pre.auth.index(i), val));\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            }\n        })*/\n    }\n\n    #[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) { }\n}}\n\nverus! {\n\n// We want the following properties:\n//\n// There is an `Interner` object. You need access to this object in order to:\n//\n//  - intern a new string and get an ID for it\n//  - look up the original string for a given ID\n//\n// However, WITHOUT access to the object, you should be able to:\n//\n// - use `@` to get the original string (in spec-code)\n//   so that you could reason about the string as if you just had the original\n// - evaluate string equality by comparing the IDs\nstruct Interner<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    auth: Tracked<InternSystem::auth<T>>,\n    store: Vec<T>,\n}\n\nstruct Interned<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    frag: Tracked<InternSystem::frag<T>>,\n    id: usize,\n}\n\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)\n    ensures\n        res <==> (a === b),\n{\n    unimplemented!();\n}\n\nimpl<T> Interner<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.inst@ == inst\n        &&& self.auth@.instance_id() == inst.id()\n        &&& self.auth@.value() === self.store@\n    }\n\n    fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))\n        ensures\n            ({\n                let s = x.0;\n                let inst = x.1@;\n                s.wf(inst)\n            }),\n    {\n        let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();\n        let store = Vec::new();\n        (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))\n    }\n\n    fn insert(&mut self, Ghost(inst): Ghost<InternSystem::Instance<T>>, val: T) -> (st: Interned<T>)\n        requires\n            old(self).wf(inst),\n        ensures\n            self.wf(inst) && st.wf(inst) && st@ === val,\n    {\n        let idx: usize = 0;\n        while idx < self.store.len()\n\n        {\n            let eq = compute_eq(&val, &self.store[idx]);\n            if eq {\n                let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n                return Interned {\n                    inst: Tracked(self.inst.borrow().clone()),\n                    frag: Tracked(frag),\n                    id: idx,\n                };\n            }\n        }\n        let idx: usize = self.store.len();\n        self.store.push(val);\n        proof {\n            self.inst.borrow().insert(val, self.auth.borrow_mut());\n        }\n        let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n        Interned { inst: Tracked(self.inst.borrow().clone()), frag: Tracked(frag), id: idx }\n    }\n\n    fn get<'a>(\n        &'a self,\n        interned: &Interned<T>,\n        Ghost(inst): Ghost<InternSystem::Instance<T>>,\n    ) -> (st: &'a T)\n        requires\n            self.wf(inst) && interned.wf(inst),\n        ensures\n            *st === interned@,\n    {\n        proof {\n            self.inst.borrow().get_value(\n                interned.id as int,\n                self.auth.borrow(),\n                interned.frag.borrow(),\n            );\n        }\n        &self.store[interned.id]\n    }\n}\n\nimpl<T> Interned<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.frag@.instance_id() == inst.id()\n        &&& inst === self.inst@\n        &&& self.id as int == self.frag@.key()\n    }\n\n    spec fn view(&self) -> T {\n        self.frag@.value()\n    }\n\n    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)\n        requires\n            self.wf(inst),\n        ensures\n            s.wf(inst) && s@ === self@,\n    {\n        Interned {\n            inst: Tracked(self.inst.borrow().clone()),\n            frag: Tracked(self.frag.borrow().clone()),\n            id: self.id,\n        }\n    }\n\n    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)\n        requires\n            self.wf(inst) && other.wf(inst),\n        ensures\n            b == (self@ === other@),\n    {\n        proof {\n            self.inst.borrow().compute_equality(\n                self.frag@.key(),\n                self.frag@.value(),\n                other.frag@.key(),\n                other.frag@.value(),\n                self.frag.borrow(),\n                other.frag.borrow(),\n            );\n        }\n        self.id == other.id\n    }\n}\n\nfn main() {\n    let (mut interner, Tracked(inst)) = Interner::<u64>::new();\n    let s1 = interner.insert(Ghost(inst), 1);\n    let s2 = interner.insert(Ghost(inst), 2);\n    let s3 = interner.insert(Ghost(inst), 3);\n    let s1_other = interner.insert(Ghost(inst), 1);\n    let b1 = s1.cmp_eq(&s1_other, Ghost(inst));\n    assert(b1);\n    let b2 = s1.cmp_eq(&s2, Ghost(inst));\n    assert(!b2);\n    let t1 = s1.clone(Ghost(inst));\n    let get1 = *interner.get(&t1, Ghost(inst));\n    assert(get1 == 1);\n    let t2 = s2.clone(Ghost(inst));\n    let get2 = *interner.get(&t2, Ghost(inst));\n    assert(get1 == 1);\n}\n\n} // verus!\n", "target_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine! {InternSystem<T> {\n    fields {\n        #[sharding(variable)]\n        pub auth: Seq<T>,\n\n        #[sharding(persistent_map)]\n        pub frag: Map<int, T>,\n    }\n\n    init!{\n        empty() {\n            init auth = Seq::empty();\n            init frag = Map::empty();\n        }\n    }\n\n    transition!{\n        insert(val: T) {\n            require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);\n            update auth = pre.auth.push(val);\n        }\n    }\n\n    transition!{\n        get_frag(idx: int) {\n            require(0 <= idx && idx < pre.auth.len());\n            let val = pre.auth.index(idx);\n            add frag (union)= [idx => val];\n        }\n    }\n\n    property!{\n        get_value(i: int) {\n            have frag >= [i => let val];\n            assert(i < pre.auth.len() && pre.auth.index(i) === val);\n        }\n    }\n\n    property!{\n        compute_equality(idx1: int, val1: T, idx2: int, val2: T) {\n            have frag >= [idx1 => val1];\n            have frag >= [idx2 => val2];\n            assert((idx1 == idx2) <==> (val1 === val2));\n        }\n    }\n\n    #[invariant]\n    pub fn agreement(&self) -> bool {\n        forall |k| #[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()\n                && self.auth.index(k) === self.frag.index(k)\n    }\n\n    #[invariant]\n    pub fn distinct(&self) -> bool {\n        forall |i: int, j: int|\n            0 <= i && i < self.auth.len() &&\n            0 <= j && j < self.auth.len() &&\n            i != j\n            ==>\n            self.auth.index(i) !== self.auth.index(j)\n    }\n\n    #[inductive(empty)]\n    fn empty_inductive(post: Self) { }\n\n    #[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {\n        /*assert_forall_by(|k| {\n            requires(post.frag.dom().contains(k));\n            ensures(0 <= k && k < post.auth.len()\n                && equal(post.auth.index(k), post.frag.index(k)));\n\n            assert(pre.frag.dom().contains(k));\n            assert(k < pre.auth.len());\n            assert(k < post.auth.len());\n            assert(equal(post.auth.index(k), post.frag.index(k)));\n        })*/\n        /*assert_forall_by(|i: int, j: int| {\n            requires(\n                0 <= i && i < post.auth.len() &&\n                0 <= j && j < post.auth.len() &&\n                i != j\n            );\n            ensures(!equal(post.auth.index(i), post.auth.index(j)));\n\n            if i == post.auth.len() as int - 1 {\n                if j == post.auth.len() as int - 1 {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            } else {\n                if j == post.auth.len() as int - 1 {\n                    assert(equal(post.auth.index(pre.auth.len()), val));\n                    assert(equal(post.auth.index(j), val));\n                    assert(equal(post.auth.index(i), pre.auth.index(i)));\n                    assert(!equal(pre.auth.index(i), val));\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            }\n        })*/\n    }\n\n    #[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) { }\n}}\n\nverus! {\n\n// We want the following properties:\n//\n// There is an `Interner` object. You need access to this object in order to:\n//\n//  - intern a new string and get an ID for it\n//  - look up the original string for a given ID\n//\n// However, WITHOUT access to the object, you should be able to:\n//\n// - use `@` to get the original string (in spec-code)\n//   so that you could reason about the string as if you just had the original\n// - evaluate string equality by comparing the IDs\nstruct Interner<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    auth: Tracked<InternSystem::auth<T>>,\n    store: Vec<T>,\n}\n\nstruct Interned<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    frag: Tracked<InternSystem::frag<T>>,\n    id: usize,\n}\n\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)\n    ensures\n        res <==> (a === b),\n{\n    unimplemented!();\n}\n\nimpl<T> Interner<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.inst@ == inst\n        &&& self.auth@.instance_id() == inst.id()\n        &&& self.auth@.value() === self.store@\n    }\n\n    fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))\n        ensures\n            ({\n                let s = x.0;\n                let inst = x.1@;\n                s.wf(inst)\n            }),\n    {\n        let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();\n        let store = Vec::new();\n        (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))\n    }\n\n    fn insert(&mut self, Ghost(inst): Ghost<InternSystem::Instance<T>>, val: T) -> (st: Interned<T>)\n        requires\n            old(self).wf(inst),\n        ensures\n            self.wf(inst) && st.wf(inst) && st@ === val,\n    {\n        let idx: usize = 0;\n        while idx < self.store.len()\n            invariant\n                0 <= idx && idx <= self.store@.len(),\n                self.wf(inst),\n        {\n            let eq = compute_eq(&val, &self.store[idx]);\n            if eq {\n                let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n                return Interned {\n                    inst: Tracked(self.inst.borrow().clone()),\n                    frag: Tracked(frag),\n                    id: idx,\n                };\n            }\n        }\n        let idx: usize = self.store.len();\n        self.store.push(val);\n        proof {\n            self.inst.borrow().insert(val, self.auth.borrow_mut());\n        }\n        let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n        Interned { inst: Tracked(self.inst.borrow().clone()), frag: Tracked(frag), id: idx }\n    }\n\n    fn get<'a>(\n        &'a self,\n        interned: &Interned<T>,\n        Ghost(inst): Ghost<InternSystem::Instance<T>>,\n    ) -> (st: &'a T)\n        requires\n            self.wf(inst) && interned.wf(inst),\n        ensures\n            *st === interned@,\n    {\n        proof {\n            self.inst.borrow().get_value(\n                interned.id as int,\n                self.auth.borrow(),\n                interned.frag.borrow(),\n            );\n        }\n        &self.store[interned.id]\n    }\n}\n\nimpl<T> Interned<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.frag@.instance_id() == inst.id()\n        &&& inst === self.inst@\n        &&& self.id as int == self.frag@.key()\n    }\n\n    spec fn view(&self) -> T {\n        self.frag@.value()\n    }\n\n    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)\n        requires\n            self.wf(inst),\n        ensures\n            s.wf(inst) && s@ === self@,\n    {\n        Interned {\n            inst: Tracked(self.inst.borrow().clone()),\n            frag: Tracked(self.frag.borrow().clone()),\n            id: self.id,\n        }\n    }\n\n    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)\n        requires\n            self.wf(inst) && other.wf(inst),\n        ensures\n            b == (self@ === other@),\n    {\n        proof {\n            self.inst.borrow().compute_equality(\n                self.frag@.key(),\n                self.frag@.value(),\n                other.frag@.key(),\n                other.frag@.value(),\n                self.frag.borrow(),\n                other.frag.borrow(),\n            );\n        }\n        self.id == other.id\n    }\n}\n\nfn main() {\n    let (mut interner, Tracked(inst)) = Interner::<u64>::new();\n    let s1 = interner.insert(Ghost(inst), 1);\n    let s2 = interner.insert(Ghost(inst), 2);\n    let s3 = interner.insert(Ghost(inst), 3);\n    let s1_other = interner.insert(Ghost(inst), 1);\n    let b1 = s1.cmp_eq(&s1_other, Ghost(inst));\n    assert(b1);\n    let b2 = s1.cmp_eq(&s2, Ghost(inst));\n    assert(!b2);\n    let t1 = s1.clone(Ghost(inst));\n    let get1 = *interner.get(&t1, Ghost(inst));\n    assert(get1 == 1);\n    let t2 = s2.clone(Ghost(inst));\n    let get2 = *interner.get(&t2, Ghost(inst));\n    assert(get1 == 1);\n}\n\n} // verus!\n", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\n\nuse vstd::cell::*;\nuse vstd::invariant::*;\nuse vstd::map::*;\nuse vstd::modes::*;\nuse vstd::multiset::*;\nuse vstd::prelude::*;\nuse vstd::seq::*;\nuse vstd::{pervasive::*, prelude::*, *};\n\nuse verus_state_machines_macros::tokenized_state_machine;\n\ntokenized_state_machine! {InternSystem<T> {\n    fields {\n        #[sharding(variable)]\n        pub auth: Seq<T>,\n\n        #[sharding(persistent_map)]\n        pub frag: Map<int, T>,\n    }\n\n    init!{\n        empty() {\n            init auth = Seq::empty();\n            init frag = Map::empty();\n        }\n    }\n\n    transition!{\n        insert(val: T) {\n            require(forall |i: int| 0 <= i && i < pre.auth.len() ==> pre.auth.index(i) !== val);\n            update auth = pre.auth.push(val);\n        }\n    }\n\n    transition!{\n        get_frag(idx: int) {\n            require(0 <= idx && idx < pre.auth.len());\n            let val = pre.auth.index(idx);\n            add frag (union)= [idx => val];\n        }\n    }\n\n    property!{\n        get_value(i: int) {\n            have frag >= [i => let val];\n            assert(i < pre.auth.len() && pre.auth.index(i) === val);\n        }\n    }\n\n    property!{\n        compute_equality(idx1: int, val1: T, idx2: int, val2: T) {\n            have frag >= [idx1 => val1];\n            have frag >= [idx2 => val2];\n            assert((idx1 == idx2) <==> (val1 === val2));\n        }\n    }\n\n    #[invariant]\n    pub fn agreement(&self) -> bool {\n        forall |k| #[trigger] self.frag.dom().contains(k) ==>\n            0 <= k && k < self.auth.len()\n                && self.auth.index(k) === self.frag.index(k)\n    }\n\n    #[invariant]\n    pub fn distinct(&self) -> bool {\n        forall |i: int, j: int|\n            0 <= i && i < self.auth.len() &&\n            0 <= j && j < self.auth.len() &&\n            i != j\n            ==>\n            self.auth.index(i) !== self.auth.index(j)\n    }\n\n    #[inductive(empty)]\n    fn empty_inductive(post: Self) { }\n\n    #[inductive(insert)]\n    fn insert_inductive(pre: Self, post: Self, val: T) {\n        /*assert_forall_by(|k| {\n            requires(post.frag.dom().contains(k));\n            ensures(0 <= k && k < post.auth.len()\n                && equal(post.auth.index(k), post.frag.index(k)));\n\n            assert(pre.frag.dom().contains(k));\n            assert(k < pre.auth.len());\n            assert(k < post.auth.len());\n            assert(equal(post.auth.index(k), post.frag.index(k)));\n        })*/\n        /*assert_forall_by(|i: int, j: int| {\n            requires(\n                0 <= i && i < post.auth.len() &&\n                0 <= j && j < post.auth.len() &&\n                i != j\n            );\n            ensures(!equal(post.auth.index(i), post.auth.index(j)));\n\n            if i == post.auth.len() as int - 1 {\n                if j == post.auth.len() as int - 1 {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            } else {\n                if j == post.auth.len() as int - 1 {\n                    assert(equal(post.auth.index(pre.auth.len()), val));\n                    assert(equal(post.auth.index(j), val));\n                    assert(equal(post.auth.index(i), pre.auth.index(i)));\n                    assert(!equal(pre.auth.index(i), val));\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                } else {\n                    assert(!equal(post.auth.index(i), post.auth.index(j)));\n                }\n            }\n        })*/\n    }\n\n    #[inductive(get_frag)]\n    fn get_frag_inductive(pre: Self, post: Self, idx: int) { }\n}}\n\nverus! {\n\n// We want the following properties:\n//\n// There is an `Interner` object. You need access to this object in order to:\n//\n//  - intern a new string and get an ID for it\n//  - look up the original string for a given ID\n//\n// However, WITHOUT access to the object, you should be able to:\n//\n// - use `@` to get the original string (in spec-code)\n//   so that you could reason about the string as if you just had the original\n// - evaluate string equality by comparing the IDs\nstruct Interner<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    auth: Tracked<InternSystem::auth<T>>,\n    store: Vec<T>,\n}\n\nstruct Interned<T> {\n    inst: Tracked<InternSystem::Instance<T>>,\n    frag: Tracked<InternSystem::frag<T>>,\n    id: usize,\n}\n\n#[verifier::external_body]\nfn compute_eq<T>(a: &T, b: &T) -> (res: bool)\n    ensures\n        res <==> (a === b),\n{\n    unimplemented!();\n}\n\nimpl<T> Interner<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.inst@ == inst\n        &&& self.auth@.instance_id() == inst.id()\n        &&& self.auth@.value() === self.store@\n    }\n\n    fn new() -> (x: (Self, Tracked<InternSystem::Instance<T>>))\n        ensures\n            ({\n                let s = x.0;\n                let inst = x.1@;\n                s.wf(inst)\n            }),\n    {\n        let tracked (Tracked(inst), Tracked(auth), Tracked(_f)) = InternSystem::Instance::empty();\n        let store = Vec::new();\n        (Interner { inst: Tracked(inst.clone()), auth: Tracked(auth), store }, Tracked(inst))\n    }\n\n    fn insert(&mut self, Ghost(inst): Ghost<InternSystem::Instance<T>>, val: T) -> (st: Interned<T>)\n        requires\n            old(self).wf(inst),\n        ensures\n            self.wf(inst) && st.wf(inst) && st@ === val,\n    {\n        let idx: usize = 0;\n        while idx < self.store.len()\n            invariant\n                0 <= idx && idx <= self.store@.len(),\n                self.wf(inst),\n        {\n            let eq = compute_eq(&val, &self.store[idx]);\n            if eq {\n                let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n                return Interned {\n                    inst: Tracked(self.inst.borrow().clone()),\n                    frag: Tracked(frag),\n                    id: idx,\n                };\n            }\n        }\n        let idx: usize = self.store.len();\n        self.store.push(val);\n        proof {\n            self.inst.borrow().insert(val, self.auth.borrow_mut());\n        }\n        let tracked frag = self.inst.borrow().get_frag(idx as int, self.auth.borrow());\n        Interned { inst: Tracked(self.inst.borrow().clone()), frag: Tracked(frag), id: idx }\n    }\n\n    fn get<'a>(\n        &'a self,\n        interned: &Interned<T>,\n        Ghost(inst): Ghost<InternSystem::Instance<T>>,\n    ) -> (st: &'a T)\n        requires\n            self.wf(inst) && interned.wf(inst),\n        ensures\n            *st === interned@,\n    {\n        proof {\n            self.inst.borrow().get_value(\n                interned.id as int,\n                self.auth.borrow(),\n                interned.frag.borrow(),\n            );\n        }\n        &self.store[interned.id]\n    }\n}\n\nimpl<T> Interned<T> {\n    spec fn wf(&self, inst: InternSystem::Instance<T>) -> bool {\n        &&& self.frag@.instance_id() == inst.id()\n        &&& inst === self.inst@\n        &&& self.id as int == self.frag@.key()\n    }\n\n    spec fn view(&self) -> T {\n        self.frag@.value()\n    }\n\n    fn clone(&self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (s: Self)\n        requires\n            self.wf(inst),\n        ensures\n            s.wf(inst) && s@ === self@,\n    {\n        Interned {\n            inst: Tracked(self.inst.borrow().clone()),\n            frag: Tracked(self.frag.borrow().clone()),\n            id: self.id,\n        }\n    }\n\n    fn cmp_eq(&self, other: &Self, Ghost(inst): Ghost<InternSystem::Instance<T>>) -> (b: bool)\n        requires\n            self.wf(inst) && other.wf(inst),\n        ensures\n            b == (self@ === other@),\n    {\n        proof {\n            self.inst.borrow().compute_equality(\n                self.frag@.key(),\n                self.frag@.value(),\n                other.frag@.key(),\n                other.frag@.value(),\n                self.frag.borrow(),\n                other.frag.borrow(),\n            );\n        }\n        self.id == other.id\n    }\n}\n\nfn main() {\n    let (mut interner, Tracked(inst)) = Interner::<u64>::new();\n    let s1 = interner.insert(Ghost(inst), 1);\n    let s2 = interner.insert(Ghost(inst), 2);\n    let s3 = interner.insert(Ghost(inst), 3);\n    let s1_other = interner.insert(Ghost(inst), 1);\n    let b1 = s1.cmp_eq(&s1_other, Ghost(inst));\n    assert(b1);\n    let b2 = s1.cmp_eq(&s2, Ghost(inst));\n    assert(!b2);\n    let t1 = s1.clone(Ghost(inst));\n    let get1 = *interner.get(&t1, Ghost(inst));\n    assert(get1 == 1);\n    let t2 = s2.clone(Ghost(inst));\n    let get2 = *interner.get(&t2, Ghost(inst));\n    assert(get1 == 1);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/state_machines/interner.rs", "verified": true, "metadata": {"original_id": "verus_interner_63d8677f4199", "function_name": "", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_82327a98dd41", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize)  ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_95_iter_2_current.rs", "verified": true, "metadata": {"original_id": "82327a98dd41", "function_name": "smallest_list_length", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_b26a9355f09c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >)  { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len () invariant 0 <= i <= current_letters . len () { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len () invariant 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len () { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len () invariant 0 <= k <= rest . len () , combination . len () == k + 1 { combination . push (rest [k]) ; } result . push (combination) ; } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >) requires start <= chars . len () decreases chars . len () - start { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len () invariant 0 <= i <= current_letters . len () { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len () invariant 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len () { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len () invariant 0 <= k <= rest . len () , combination . len () == k + 1 { combination . push (rest [k]) ; } result . push (combination) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\nfn go (chars : & Vec < char > , start : usize) -> (result : Vec < Vec < char > >) requires start <= chars . len () decreases chars . len () - start { if start == chars . len () { let mut result = Vec :: new () ; result . push (Vec :: new ()) ; return result ; } let current_letters = digit_to_letters_exec (chars [start]) ; let rest_combinations = go (chars , start + 1) ; let mut result = Vec :: new () ; for i in 0 .. current_letters . len () invariant 0 <= i <= current_letters . len () { let letter = current_letters [i] ; for j in 0 .. rest_combinations . len () invariant 0 <= j <= rest_combinations . len () , 0 <= i < current_letters . len () { let mut combination = Vec :: new () ; combination . push (letter) ; let rest = & rest_combinations [j] ; for k in 0 .. rest . len () invariant 0 <= k <= rest . len () , combination . len () == k + 1 { combination . push (rest [k]) ; } result . push (combination) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_26/verina_advanced_26_impl.rs", "verified": true, "metadata": {"original_id": "b26a9355f09c", "function_name": "go", "bug_type": "missing_requires"}}
{"id": "task_a_f9e413e3d8a7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sum_powers_helper (n : u32 , k : u32 , acc : u32) -> u32 { return 0 ; }\n\n} // verus!", "target_text": "decreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sum_powers_helper (n : u32 , k : u32 , acc : u32) -> u32 decreases n , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_18/verina_advanced_18_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f9e413e3d8a7", "function_name": "sum_powers_helper", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_b_6c061a8c09d1", "task": "task_b", "input_text": "fn is_product_even (arr : & Vec < u32 >) -> (result : bool)\nensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) { if arr [i] % 2 == 0 { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) { if arr [i] % 2 == 0 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_804_iter_2_current.rs", "verified": true, "metadata": {"original_id": "6c061a8c09d1", "function_name": "is_product_even", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_805e9284b8ad", "task": "task_b", "input_text": "fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)\nrequires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 2 * N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s1lif_impl.rs", "verified": true, "metadata": {"original_id": "805e9284b8ad", "function_name": "myfun", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_invariant_442259409fce", "task": "task_c", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len ()  { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 0 < idx <= nums . len () , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < idx && nums @ [i] == max_val , decreases nums . len () - idx { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_max (nums : Vec < i32 >) -> (ret : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums @ . len () ==> nums @ [i] <= ret , exists | i : int | 0 <= i < nums @ . len () ==> nums @ [i] == ret , { let mut max_val = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 0 < idx <= nums . len () , forall | i : int | 0 <= i < idx ==> nums @ [i] <= max_val , exists | i : int | 0 <= i < idx && nums @ [i] == max_val , decreases nums . len () - idx { if nums [idx] > max_val { max_val = nums [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/findmax_impl.rs", "verified": true, "metadata": {"original_id": "442259409fce", "function_name": "find_max", "bug_type": "missing_invariant"}}
{"id": "task_a_1385bd8547cb", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn flip_case_spec (c : char) -> (result : char) { if is_lower_case (c) { shift_minus_32_spec (c) } else if is_upper_case (c) { shift_plus_32_spec (c) } else { c } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn shift_plus_32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nfn flip_case (str : & [char]) -> (flipped_case : Vec < char >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str . len ()  { let c = str [i] ; let flipped_char = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (flipped_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "ensures str @ . len () == flipped_case @ . len () , forall | i : int | 0 <= i < str . len () ==> flipped_case [i] == flip_case_spec (# [trigger] str [i]) \ndecreases str . len () - i\ninvariant i <= str . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == flip_case_spec (str [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn flip_case_spec (c : char) -> (result : char) { if is_lower_case (c) { shift_minus_32_spec (c) } else if is_upper_case (c) { shift_plus_32_spec (c) } else { c } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nspec fn is_upper_case (c : char) -> (result : bool) { c >= 'A' && c <= 'Z' }\nspec fn shift_plus_32_spec (c : char) -> (result : char) { ((c as u8) + 32) as char }\nfn flip_case (str : & [char]) -> (flipped_case : Vec < char >) ensures str @ . len () == flipped_case @ . len () , forall | i : int | 0 <= i < str . len () ==> flipped_case [i] == flip_case_spec (# [trigger] str [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str . len () invariant i <= str . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == flip_case_spec (str [j]) , decreases str . len () - i { let c = str [i] ; let flipped_char = if c >= 'a' && c <= 'z' { ((c as u8) - 32) as char } else if c >= 'A' && c <= 'Z' { ((c as u8) + 32) as char } else { c } ; result . push (flipped_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/027-flip_case_iter_2_current.rs", "verified": true, "metadata": {"original_id": "1385bd8547cb", "function_name": "flip_case", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_ensures_78bd1f99700b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e ,  { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (0 <= j < a . len () as int) && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (i == a . len ()) ; assert (forall | k : int | (0 <= k < i as int) ==> a [k] != e) ; assert (exists | j : int | (0 <= j < a . len () as int) && a [j] == e) ; assert (false) ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (0 <= j < a . len () as int) && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (i == a . len ()) ; assert (forall | k : int | (0 <= k < i as int) ==> a [k] != e) ; assert (exists | j : int | (0 <= j < a . len () as int) && a [j] == e) ; assert (false) ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (0 <= j < a . len () as int) && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (i == a . len ()) ; assert (forall | k : int | (0 <= k < i as int) ==> a [k] != e) ; assert (exists | j : int | (0 <= j < a . len () as int) && a [j] == e) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/linear_search2_impl.rs", "verified": true, "metadata": {"original_id": "78bd1f99700b", "function_name": "linear_search", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_b22aeab90b3a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "b22aeab90b3a", "function_name": "any_value_exists", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_e00903eee137", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 ,  { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/brs2_impl.rs", "verified": true, "metadata": {"original_id": "e00903eee137", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_419b0e2e73f0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len ()  { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] , decreases nums . len () - idx , { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut idx = 1 ; while idx < nums . len () invariant 1 <= idx <= nums . len () , forall | i : int | 0 <= i < idx ==> min <= nums [i] , exists | i : int | 0 <= i < idx && min == nums [i] , decreases nums . len () - idx , { if nums [idx] < min { min = nums [idx] ; } idx += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_62_impl.rs", "verified": true, "metadata": {"original_id": "419b0e2e73f0", "function_name": "smallest_num", "bug_type": "missing_invariant"}}
{"id": "task_a_15316c192ba9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_spec (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "15316c192ba9", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_180b38adcc4b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 ,  { sum . set (0 , 6 * N as i32) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * N as i32) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/unverified/s52if_iter_1_current.rs", "verified": true, "metadata": {"original_id": "180b38adcc4b", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_b_cba32b42d8d3", "task": "task_b", "input_text": "fn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)\nensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_249_iter_2_current.rs", "verified": true, "metadata": {"original_id": "cba32b42d8d3", "function_name": "contains", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_ensures_ec9643a6ca26", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn selection_sort (a : & mut Vec < int >)  { let n = a . len () ; let mut i = 0 ; while i < n invariant a . len () == n , forall | p : int , q : int | 0 <= p < q < i ==> a [p] <= a [q] , forall | p : int , q : int | 0 <= p < i <= q < n ==> a [p] <= a [q] , decreases n - i { let mut min_idx = i ; let mut j = i + 1 ; while j < n invariant a . len () == n , i <= min_idx < n , i < j <= n , forall | k : int | i as int <= k < j as int ==> a [min_idx as int] <= a [k] , forall | p : int , q : int | 0 <= p < q < i ==> a [p] <= a [q] , forall | p : int , q : int | 0 <= p < i <= q < n ==> a [p] <= a [q] , decreases n - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn selection_sort (a : & mut Vec < int >) ensures a . len () == old (a) . len () , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , { let n = a . len () ; let mut i = 0 ; while i < n invariant a . len () == n , forall | p : int , q : int | 0 <= p < q < i ==> a [p] <= a [q] , forall | p : int , q : int | 0 <= p < i <= q < n ==> a [p] <= a [q] , decreases n - i { let mut min_idx = i ; let mut j = i + 1 ; while j < n invariant a . len () == n , i <= min_idx < n , i < j <= n , forall | k : int | i as int <= k < j as int ==> a [min_idx as int] <= a [k] , forall | p : int , q : int | 0 <= p < q < i ==> a [p] <= a [q] , forall | p : int , q : int | 0 <= p < i <= q < n ==> a [p] <= a [q] , decreases n - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn selection_sort (a : & mut Vec < int >) ensures a . len () == old (a) . len () , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , { let n = a . len () ; let mut i = 0 ; while i < n invariant a . len () == n , forall | p : int , q : int | 0 <= p < q < i ==> a [p] <= a [q] , forall | p : int , q : int | 0 <= p < i <= q < n ==> a [p] <= a [q] , decreases n - i { let mut min_idx = i ; let mut j = i + 1 ; while j < n invariant a . len () == n , i <= min_idx < n , i < j <= n , forall | k : int | i as int <= k < j as int ==> a [min_idx as int] <= a [k] , forall | p : int , q : int | 0 <= p < q < i ==> a [p] <= a [q] , forall | p : int , q : int | 0 <= p < i <= q < n ==> a [p] <= a [q] , decreases n - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_selectionsort/verus_code_iter_5_current.rs", "verified": true, "metadata": {"original_id": "ec9643a6ca26", "function_name": "selection_sort", "bug_type": "missing_ensures"}}
{"id": "task_a_6fc6d123b071", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn generate_all_combinations (n : i32 , k : i32) -> Vec < Vec < i32 > >  { return Vec :: new () ; }\n\n} // verus!", "target_text": "requires 0 <= n <= MAX - 1 , 0 <= k <= n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn generate_all_combinations (n : i32 , k : i32) -> Vec < Vec < i32 > > requires 0 <= n <= MAX - 1 , 0 <= k <= n , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/interprocedural/AlgorithmsRust/all_combination_of_size_k_iter_0_original.rs", "verified": true, "metadata": {"original_id": "6fc6d123b071", "function_name": "generate_all_combinations", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_d059178c6f16", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () ,  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , decreases a . len () - idx , { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , decreases a . len () - idx , { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , decreases a . len () - idx , { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_product_impl.rs", "verified": true, "metadata": {"original_id": "d059178c6f16", "function_name": "array_product", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_e611bcbaf723", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , { a . set (i as usize , 0) ; i = i + 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i , { a . set (i as usize , 0) ; i = i + 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i , { a . set (i as usize , 0) ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/condg_impl.rs", "verified": true, "metadata": {"original_id": "e611bcbaf723", "function_name": "myfun", "bug_type": "missing_decreases"}}
{"id": "task_b_9ecf147a7a6c", "task": "task_b", "input_text": "fn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32)\nrequires kth_element_precond (arr @ , k as nat) \nensures kth_element_postcond (arr @ , k as nat , result as int) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) , ensures kth_element_postcond (arr @ , k as nat , result as int) , { let result = arr [k - 1] ; proof { let witness_idx = k as int - 1 ; assert (0 <= witness_idx < arr @ . len ()) by { assert (k >= 1 && k <= arr @ . len ()) ; assert (k as int >= 1) ; assert (k as int - 1 >= 0) ; assert (k as int <= arr @ . len ()) ; assert (k as int - 1 < arr @ . len ()) ; } ; assert (arr @ [witness_idx] == result) ; assert (result as int == arr @ [k as int - 1] as int) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) , ensures kth_element_postcond (arr @ , k as nat , result as int) , { let result = arr [k - 1] ; proof { let witness_idx = k as int - 1 ; assert (0 <= witness_idx < arr @ . len ()) by { assert (k >= 1 && k <= arr @ . len ()) ; assert (k as int >= 1) ; assert (k as int - 1 >= 0) ; assert (k as int <= arr @ . len ()) ; assert (k as int - 1 < arr @ . len ()) ; } ; assert (arr @ [witness_idx] == result) ; assert (result as int == arr @ [k as int - 1] as int) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_4/verina_basic_4_iter_1_current.rs", "verified": true, "metadata": {"original_id": "9ecf147a7a6c", "function_name": "kth_element", "has_invariants": false, "has_asserts": true}}
{"id": "task_c_missing_ensures_f038eb73e65a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive4 (v : & [i32]) -> (b : bool)  { let mut result = true ; for i in 0 .. v . len () invariant result == (forall | u : int | 0 <= u < i ==> v [u] >= 0) { if v [i] < 0 { result = false ; } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive4 (v : & [i32]) -> (b : bool) ensures b == positive (v @) { let mut result = true ; for i in 0 .. v . len () invariant result == (forall | u : int | 0 <= u < i ==> v [u] >= 0) { if v [i] < 0 { result = false ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive4 (v : & [i32]) -> (b : bool) ensures b == positive (v @) { let mut result = true ; for i in 0 .. v . len () invariant result == (forall | u : int | 0 <= u < i ==> v [u] >= 0) { if v [i] < 0 { result = false ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "f038eb73e65a", "function_name": "mpositive4", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_verus_bst_map_62a66282bf35", "task": "task_c", "input_text": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\n// ANCHOR: StructsDef\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n// ANCHOR_END: StructsDef\n\n// ANCHOR: AsMapDef\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n// ANCHOR_END: AsMapDef\n\n// ANCHOR: ViewDef\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n// ANCHOR_END: ViewDef\n\n// ANCHOR: WellFormedDef\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: WellFormedDef\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (tree_map: Self)\n        ensures\n            tree_map.well_formed(),\n            tree_map@ == Map::<u64, V>::empty(),\n// ANCHOR_END: new_signature\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\n// ANCHOR: insert\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        {\n        match node.take() {\n            None => {\n                *node = Some(Box::new(Node::<V> {\n                    key: key,\n                    value: value,\n                    left: None,\n                    right: None,\n                }));\n            }\n            Some(mut boxed_node) => {\n                (&mut *boxed_node).insert(key, value);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        {\n        if key == self.key {\n            self.value = value;\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature\n    {\n        Node::<V>::insert_into_optional(&mut self.root, key, value);\n    }\n}\n// ANCHOR_END: insert\n\n// ANCHOR: delete\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        {\n        if let Some(mut boxed_node) = node.take() {\n\n            if key == boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        {\n        let mut boxed_node = node.take().unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature\n    {\n        Node::<V>::delete_from_optional(&mut self.root, key);\n    }\n}\n// ANCHOR_END: delete\n\n// ANCHOR: get\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n            Self::get_from_optional(&self.left, key)\n        } else {\n            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: test\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n}\n// ANCHOR_END: test\n\n// ANCHOR: test_callee\nfn test2() {\n    let mut tree_map = TreeMap::<bool>::new();\n    test_callee(tree_map);\n}\n\nfn test_callee(tree_map: TreeMap<bool>)\n    requires\n        tree_map.well_formed(),\n{\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: test_callee\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "target_text": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\n// ANCHOR: StructsDef\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n// ANCHOR_END: StructsDef\n\n// ANCHOR: AsMapDef\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        decreases self,\n    {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n// ANCHOR_END: AsMapDef\n\n// ANCHOR: ViewDef\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n// ANCHOR_END: ViewDef\n\n// ANCHOR: WellFormedDef\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        decreases self,\n    {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: WellFormedDef\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (tree_map: Self)\n        ensures\n            tree_map.well_formed(),\n            tree_map@ == Map::<u64, V>::empty(),\n// ANCHOR_END: new_signature\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\n// ANCHOR: insert\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n        match node.take() {\n            None => {\n                *node = Some(Box::new(Node::<V> {\n                    key: key,\n                    value: value,\n                    left: None,\n                    right: None,\n                }));\n            }\n            Some(mut boxed_node) => {\n                (&mut *boxed_node).insert(key, value);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n        if key == self.key {\n            self.value = value;\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature\n    {\n        Node::<V>::insert_into_optional(&mut self.root, key, value);\n    }\n}\n// ANCHOR_END: insert\n\n// ANCHOR: delete\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n        if let Some(mut boxed_node) = node.take() {\n\n            if key == boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node),\n    {\n        let mut boxed_node = node.take().unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature\n    {\n        Node::<V>::delete_from_optional(&mut self.root, key);\n    }\n}\n// ANCHOR_END: delete\n\n// ANCHOR: get\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n            Self::get_from_optional(&self.left, key)\n        } else {\n            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: test\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n}\n// ANCHOR_END: test\n\n// ANCHOR: test_callee\nfn test2() {\n    let mut tree_map = TreeMap::<bool>::new();\n    test_callee(tree_map);\n}\n\nfn test_callee(tree_map: TreeMap<bool>)\n    requires\n        tree_map.well_formed(),\n{\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: test_callee\n\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "full_verified_code": "// ANCHOR: all\nuse vstd::prelude::*;\n\nverus!{\n\n// ANCHOR: StructsDef\nstruct Node<V> {\n    key: u64,\n    value: V,\n    left: Option<Box<Node<V>>>,\n    right: Option<Box<Node<V>>>,\n}\n\npub struct TreeMap<V> {\n    root: Option<Box<Node<V>>>,\n}\n// ANCHOR_END: StructsDef\n\n// ANCHOR: AsMapDef\nimpl<V> Node<V> {\n    spec fn optional_as_map(node_opt: Option<Box<Node<V>>>) -> Map<u64, V>\n        decreases node_opt,\n    {\n        match node_opt {\n            None => Map::empty(),\n            Some(node) => node.as_map(),\n        }\n    }\n\n    spec fn as_map(self) -> Map<u64, V>\n        decreases self,\n    {\n        Node::<V>::optional_as_map(self.left)\n          .union_prefer_right(Node::<V>::optional_as_map(self.right))\n          .insert(self.key, self.value)\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn as_map(self) -> Map<u64, V> {\n        Node::<V>::optional_as_map(self.root)\n    }\n}\n// ANCHOR_END: AsMapDef\n\n// ANCHOR: ViewDef\nimpl<V> View for TreeMap<V> {\n    type V = Map<u64, V>;\n\n    open spec fn view(&self) -> Map<u64, V> {\n        self.as_map()\n    }\n}\n// ANCHOR_END: ViewDef\n\n// ANCHOR: WellFormedDef\nimpl<V> Node<V> {\n    spec fn well_formed(self) -> bool\n        decreases self,\n    {\n        &&& (forall |elem| Node::<V>::optional_as_map(self.left).dom().contains(elem) ==> elem < self.key)\n        &&& (forall |elem| Node::<V>::optional_as_map(self.right).dom().contains(elem) ==> elem > self.key)\n        &&& (match self.left {\n            Some(left_node) => left_node.well_formed(),\n            None => true,\n        })\n        &&& (match self.right {\n            Some(right_node) => right_node.well_formed(),\n            None => true,\n        })\n    }\n}\n\nimpl<V> TreeMap<V> {\n    pub closed spec fn well_formed(self) -> bool {\n        match self.root {\n            Some(node) => node.well_formed(),\n            None => true, // empty tree always well-formed\n        }\n    }\n}\n// ANCHOR_END: WellFormedDef\n\n// ANCHOR: new\nimpl<V> TreeMap<V> {\n// ANCHOR: new_signature\n    pub fn new() -> (tree_map: Self)\n        ensures\n            tree_map.well_formed(),\n            tree_map@ == Map::<u64, V>::empty(),\n// ANCHOR_END: new_signature\n    {\n        TreeMap::<V> { root: None }\n    }\n}\n// ANCHOR_END: new\n\n// ANCHOR: insert\nimpl<V> Node<V> {\n    fn insert_into_optional(node: &mut Option<Box<Node<V>>>, key: u64, value: V)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).insert(key, value),\n        decreases *old(node),\n    {\n        match node.take() {\n            None => {\n                *node = Some(Box::new(Node::<V> {\n                    key: key,\n                    value: value,\n                    left: None,\n                    right: None,\n                }));\n            }\n            Some(mut boxed_node) => {\n                (&mut *boxed_node).insert(key, value);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self.as_map() =~= old(self).as_map().insert(key, value),\n        decreases *old(self),\n    {\n        if key == self.key {\n            self.value = value;\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else if key < self.key {\n            Self::insert_into_optional(&mut self.left, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.right).dom().contains(key));\n        } else {\n            Self::insert_into_optional(&mut self.right, key, value);\n\n            assert(!Node::<V>::optional_as_map(self.left).dom().contains(key));\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: insert_signature\n    pub fn insert(&mut self, key: u64, value: V)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.insert(key, value),\n// ANCHOR_END: insert_signature\n    {\n        Node::<V>::insert_into_optional(&mut self.root, key, value);\n    }\n}\n// ANCHOR_END: insert\n\n// ANCHOR: delete\nimpl<V> Node<V> {\n    fn delete_from_optional(node: &mut Option<Box<Node<V>>>, key: u64)\n        requires\n            old(node).is_some() ==> old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(key),\n        decreases *old(node),\n    {\n        if let Some(mut boxed_node) = node.take() {\n\n            if key == boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n\n                if boxed_node.left.is_none() {\n                    *node = boxed_node.right;\n                } else {\n                    if boxed_node.right.is_none() {\n                        *node = boxed_node.left;\n                    } else {\n                        let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.left);\n                        boxed_node.key = popped_key;\n                        boxed_node.value = popped_value;\n                        *node = Some(boxed_node);\n                    }\n                }\n            } else if key < boxed_node.key {\n                assert(!Node::<V>::optional_as_map(boxed_node.right).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.left, key);\n                *node = Some(boxed_node);\n            } else {\n                assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(key));\n                Node::<V>::delete_from_optional(&mut boxed_node.right, key);\n                *node = Some(boxed_node);\n            }\n        }\n    }\n\n    fn delete_rightmost(node: &mut Option<Box<Node<V>>>) -> (popped: (u64, V))\n        requires\n            old(node).is_some(),\n            old(node).unwrap().well_formed(),\n        ensures\n            node.is_some() ==> node.unwrap().well_formed(),\n            Node::<V>::optional_as_map(*node) =~= Node::<V>::optional_as_map(*old(node)).remove(popped.0),\n            Node::<V>::optional_as_map(*old(node)).dom().contains(popped.0),\n            Node::<V>::optional_as_map(*old(node))[popped.0] == popped.1,\n            forall |elem| Node::<V>::optional_as_map(*old(node)).dom().contains(elem) ==> popped.0 >= elem,\n        decreases *old(node),\n    {\n        let mut boxed_node = node.take().unwrap();\n\n        if boxed_node.right.is_none() {\n            *node = boxed_node.left;\n            assert(Node::<V>::optional_as_map(boxed_node.right) =~= Map::empty());\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(boxed_node.key));\n            return (boxed_node.key, boxed_node.value);\n        } else {\n            let (popped_key, popped_value) = Node::<V>::delete_rightmost(&mut boxed_node.right);\n            assert(!Node::<V>::optional_as_map(boxed_node.left).dom().contains(popped_key));\n            *node = Some(boxed_node);\n            return (popped_key, popped_value);\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: delete_signature\n    pub fn delete(&mut self, key: u64)\n        requires\n            old(self).well_formed(),\n        ensures\n            self.well_formed(),\n            self@ == old(self)@.remove(key),\n// ANCHOR_END: delete_signature\n    {\n        Node::<V>::delete_from_optional(&mut self.root, key);\n    }\n}\n// ANCHOR_END: delete\n\n// ANCHOR: get\nimpl<V> Node<V> {\n    fn get_from_optional(node: &Option<Box<Node<V>>>, key: u64) -> Option<&V>\n        requires\n            node.is_some() ==> node.unwrap().well_formed(),\n        returns\n            (match node {\n                Some(node) => (if node.as_map().dom().contains(key) { Some(&node.as_map()[key]) } else { None }),\n                None => None,\n            }),\n        decreases node,\n    {\n        match node {\n            None => None,\n            Some(node) => {\n                node.get(key)\n            }\n        }\n    }\n\n    fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self.as_map().dom().contains(key) { Some(&self.as_map()[key]) } else { None }),\n        decreases self,\n    {\n        if key == self.key {\n            Some(&self.value)\n        } else if key < self.key {\n            proof { assert(!Node::<V>::optional_as_map(self.right).dom().contains(key)); }\n            Self::get_from_optional(&self.left, key)\n        } else {\n            proof { assert(!Node::<V>::optional_as_map(self.left).dom().contains(key)); }\n            Self::get_from_optional(&self.right, key)\n        }\n    }\n}\n\nimpl<V> TreeMap<V> {\n// ANCHOR: get_signature\n    pub fn get(&self, key: u64) -> Option<&V>\n        requires\n            self.well_formed(),\n        returns\n            (if self@.dom().contains(key) { Some(&self@[key]) } else { None }),\n// ANCHOR_END: get_signature\n    {\n        Node::<V>::get_from_optional(&self.root, key)\n    }\n}\n// ANCHOR_END: get\n\n// ANCHOR: test\nfn test() {\n    let mut tree_map = TreeMap::<bool>::new();\n    tree_map.insert(17, false);\n    tree_map.insert(18, false);\n    tree_map.insert(17, true);\n\n    assert(tree_map@ == map![17u64 => true, 18u64 => false]);\n\n    tree_map.delete(17);\n\n    assert(tree_map@ == map![18u64 => false]);\n\n    let elem17 = tree_map.get(17);\n    let elem18 = tree_map.get(18);\n    assert(elem17.is_none());\n    assert(elem18 == Some(&false));\n}\n// ANCHOR_END: test\n\n// ANCHOR: test_callee\nfn test2() {\n    let mut tree_map = TreeMap::<bool>::new();\n    test_callee(tree_map);\n}\n\nfn test_callee(tree_map: TreeMap<bool>)\n    requires\n        tree_map.well_formed(),\n{\n    let mut tree_map = tree_map;\n    tree_map.insert(25, true);\n    tree_map.insert(100, true);\n}\n// ANCHOR_END: test_callee\n\n\n}\n// ANCHOR_END: all\n\nfn main() { }\n\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/bst_map.rs", "verified": true, "metadata": {"original_id": "verus_bst_map_62a66282bf35", "function_name": "", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_3a261bf6d204", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , { result . push (a [i]) ; i += 1 ; } assert (i == a . len ()) ; result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } assert (i == a . len ()) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } assert (i == a . len ()) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/array_copy_impl.rs", "verified": true, "metadata": {"original_id": "3a261bf6d204", "function_name": "array_copy", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_9bef30898e7f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >)  ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/conditional_average_iter_3_current.rs", "verified": true, "metadata": {"original_id": "9bef30898e7f", "function_name": "conditional_average", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_28fc4eedcec5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_to_int (a : Seq < i32 >) -> Seq < int > { a . map (| _idx : int , x : i32 | x as int) }\nspec fn is_prefix_sum_for (a : Seq < int > , c : Seq < int >) -> bool { &&& a . len () + 1 == c . len () &&& c [0] == 0 &&& forall | i : int | 0 <= i < a . len () ==> c [i + 1] == c [i] + a [i] }\nspec fn sum (a : Seq < int > , i : int , j : int) -> int { if i >= j { 0 } else { a [i] + sum (a , i + 1 , j) } }\nproof fn aux (a : Seq < int > , c : Seq < int > , i : int , j : int) requires 0 <= i <= j <= a . len () , a . len () + 1 == c . len () , c [0] == 0 , is_prefix_sum_for (a , c) ensures sum (a , i , j) == c [j] - c [i] { if i == j { } else { aux (a , c , i + 1 , j) ; } }\nfn query_fast (a : & Vec < i32 > , c : & Vec < i32 > , i : usize , j : usize) -> (r : i32) requires a . len () + 1 == c . len () , c [0] == 0 , i <= j <= a . len () , is_prefix_sum_for (seq_to_int (a @) , seq_to_int (c @)) , forall | k : int | 0 <= k < c @ . len () ==> - 1000000 <= # [trigger] c @ [k] <= 1000000 , ensures r == sum (seq_to_int (a @) , i as int , j as int) { proof { aux (seq_to_int (a @) , seq_to_int (c @) , i as int , j as int) ; } c [j] - c [i] }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_to_int (a : Seq < i32 >) -> Seq < int > { a . map (| _idx : int , x : i32 | x as int) }\nspec fn is_prefix_sum_for (a : Seq < int > , c : Seq < int >) -> bool { &&& a . len () + 1 == c . len () &&& c [0] == 0 &&& forall | i : int | 0 <= i < a . len () ==> c [i + 1] == c [i] + a [i] }\nspec fn sum (a : Seq < int > , i : int , j : int) -> int decreases j - i { if i >= j { 0 } else { a [i] + sum (a , i + 1 , j) } }\nproof fn aux (a : Seq < int > , c : Seq < int > , i : int , j : int) requires 0 <= i <= j <= a . len () , a . len () + 1 == c . len () , c [0] == 0 , is_prefix_sum_for (a , c) ensures sum (a , i , j) == c [j] - c [i] decreases j - i { if i == j { } else { aux (a , c , i + 1 , j) ; } }\nfn query_fast (a : & Vec < i32 > , c : & Vec < i32 > , i : usize , j : usize) -> (r : i32) requires a . len () + 1 == c . len () , c [0] == 0 , i <= j <= a . len () , is_prefix_sum_for (seq_to_int (a @) , seq_to_int (c @)) , forall | k : int | 0 <= k < c @ . len () ==> - 1000000 <= # [trigger] c @ [k] <= 1000000 , ensures r == sum (seq_to_int (a @) , i as int , j as int) { proof { aux (seq_to_int (a @) , seq_to_int (c @) , i as int , j as int) ; } c [j] - c [i] }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_to_int (a : Seq < i32 >) -> Seq < int > { a . map (| _idx : int , x : i32 | x as int) }\nspec fn is_prefix_sum_for (a : Seq < int > , c : Seq < int >) -> bool { &&& a . len () + 1 == c . len () &&& c [0] == 0 &&& forall | i : int | 0 <= i < a . len () ==> c [i + 1] == c [i] + a [i] }\nspec fn sum (a : Seq < int > , i : int , j : int) -> int decreases j - i { if i >= j { 0 } else { a [i] + sum (a , i + 1 , j) } }\nproof fn aux (a : Seq < int > , c : Seq < int > , i : int , j : int) requires 0 <= i <= j <= a . len () , a . len () + 1 == c . len () , c [0] == 0 , is_prefix_sum_for (a , c) ensures sum (a , i , j) == c [j] - c [i] decreases j - i { if i == j { } else { aux (a , c , i + 1 , j) ; } }\nfn query_fast (a : & Vec < i32 > , c : & Vec < i32 > , i : usize , j : usize) -> (r : i32) requires a . len () + 1 == c . len () , c [0] == 0 , i <= j <= a . len () , is_prefix_sum_for (seq_to_int (a @) , seq_to_int (c @)) , forall | k : int | 0 <= k < c @ . len () ==> - 1000000 <= # [trigger] c @ [k] <= 1000000 , ensures r == sum (seq_to_int (a @) , i as int , j as int) { proof { aux (seq_to_int (a @) , seq_to_int (c @) , i as int , j as int) ; } c [j] - c [i] }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/CVS-handout1_tmp_tmptm52no3k_1/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "28fc4eedcec5", "function_name": "query_fast", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_1f681c77b4c7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | j : int | 0 <= j < s . len () ==> s [j] . len () > 0 , { assert (i < s . len ()) ; assert (s [i as int] . len () > 0) ; assert (s [i as int] . len () - 1 < s [i as int] . len ()) ; let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | j : int | 0 <= j < s . len () ==> s [j] . len () > 0 , decreases s . len () - i , { assert (i < s . len ()) ; assert (s [i as int] . len () > 0) ; assert (s [i as int] . len () - 1 < s [i as int] . len ()) ; let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | j : int | 0 <= j < s . len () ==> s [j] . len () > 0 , decreases s . len () - i , { assert (i < s . len ()) ; assert (s [i as int] . len () > 0) ; assert (s [i as int] . len () - 1 < s [i as int] . len ()) ; let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_424_impl.rs", "verified": true, "metadata": {"original_id": "1f681c77b4c7", "function_name": "extract_rear_chars", "bug_type": "missing_decreases"}}
{"id": "task_a_9d1ba670100f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < size  { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1\nensures out . len () == size\ndecreases a . len (), size - i\ninvariant i <= size , result . len () == i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 decreases a . len () { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >) requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1 ensures out . len () == size { let mut result = Vec :: new () ; let mut i = 0 ; while i < size invariant i <= size , result . len () == i decreases size - i { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/703FinalProject_tmp_tmpr_10rn4z_gaussian/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9d1ba670100f", "function_name": "gaussian", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_07c9e6877f8b", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: logarithm :: log ;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_fn_specification] pub fn ex_checked_pow (x : u32 , exp : u32) -> (ret : Option < u32 >)  { x . checked_pow (exp) }\n\n} // verus!", "target_text": "ensures ret . is_some () <==> ret . unwrap () == pow (x as int , exp as nat) , ret . is_none () <==> pow (x as int , exp as nat) > MAX ", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: logarithm :: log ;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_fn_specification] pub fn ex_checked_pow (x : u32 , exp : u32) -> (ret : Option < u32 >) ensures ret . is_some () <==> ret . unwrap () == pow (x as int , exp as nat) , ret . is_none () <==> pow (x as int , exp as nat) > MAX , { x . checked_pow (exp) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/not_finished_proof/076-is_simple_power_impl.rs", "verified": true, "metadata": {"original_id": "07c9e6877f8b", "function_name": "ex_checked_pow", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_f4f15b2539ef", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 ,  { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N + 1 , N + 1 <= MAX , decreases a . len () - i { assert (i < a . len ()) ; assert (N + 1 <= MAX) ; a . set (i , N + 1) ; assert (forall | k : int | 0 <= k < i ==> a [k] == N + 1) ; assert (a [i as int] == N + 1) ; i += 1 ; assert (forall | k : int | 0 <= k < i ==> a [k] == N + 1) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures forall | k : int | 0 <= k < N ==> a [k] == N + 1 , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N + 1 , N + 1 <= MAX , decreases a . len () - i { assert (i < a . len ()) ; assert (N + 1 <= MAX) ; a . set (i , N + 1) ; assert (forall | k : int | 0 <= k < i ==> a [k] == N + 1) ; assert (a [i as int] == N + 1) ; i += 1 ; assert (forall | k : int | 0 <= k < i ==> a [k] == N + 1) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures forall | k : int | 0 <= k < N ==> a [k] == N + 1 , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N + 1 , N + 1 <= MAX , decreases a . len () - i { assert (i < a . len ()) ; assert (N + 1 <= MAX) ; a . set (i , N + 1) ; assert (forall | k : int | 0 <= k < i ==> a [k] == N + 1) ; assert (a [i as int] == N + 1) ; i += 1 ; assert (forall | k : int | 0 <= k < i ==> a [k] == N + 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/sina2_impl.rs", "verified": true, "metadata": {"original_id": "f4f15b2539ef", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_21f1901eedf6", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn helper (n : u32) -> (result : bool) { return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn helper (n : u32) -> (result : bool) decreases n { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn helper (n : u32) -> (result : bool) decreases n { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_14/verina_advanced_14_iter_0_original.rs", "verified": true, "metadata": {"original_id": "21f1901eedf6", "function_name": "helper", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_fa9d0a6c75ee", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool)  { let mut idx = 0 ; while idx < text . len () invariant forall | i : int | 0 <= i < idx ==> is_digit_spec (text [i]) , decreases text . len () - idx , { if ! is_digit (text [idx]) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut idx = 0 ; while idx < text . len () invariant forall | i : int | 0 <= i < idx ==> is_digit_spec (text [i]) , decreases text . len () - idx , { if ! is_digit (text [idx]) { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut idx = 0 ; while idx < text . len () invariant forall | i : int | 0 <= i < idx ==> is_digit_spec (text [i]) , decreases text . len () - idx , { if ! is_digit (text [idx]) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "fa9d0a6c75ee", "function_name": "is_integer", "bug_type": "missing_ensures"}}
{"id": "task_a_52e2f9691e2a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 \nensures sum [0] <= 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/res2o_impl.rs", "verified": true, "metadata": {"original_id": "52e2f9691e2a", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_b_7a561411b753", "task": "task_b", "input_text": "fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)\nrequires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 2 * N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/ms3_impl.rs", "verified": true, "metadata": {"original_id": "7a561411b753", "function_name": "myfun", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_2533c1fbb6be", "task": "task_b", "input_text": "fn myfun1 (x : & Vec < i32 >) -> (max_index : usize)\nrequires x . len () >= 1 \nensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index : usize = 0 ; let mut i : usize = 1 ; while i < x . len () invariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] , decreases x . len () - i { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index : usize = 0 ; let mut i : usize = 1 ; while i < x . len () invariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] , decreases x . len () - i { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/Misc/max_index_impl.rs", "verified": true, "metadata": {"original_id": "2533c1fbb6be", "function_name": "myfun1", "has_invariants": true, "has_asserts": false}}
{"id": "task_a_f8c095391aa0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32)   { let mut i = 0 ; while i < N  { i = i + 1 ; } i }\n\n} // verus!", "target_text": "requires 0 <= N \nensures i == N \ndecreases N - i \ninvariant 0 <= i <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "f8c095391aa0", "function_name": "up_while_less", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_ensures_03e43303cb14", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e ,  { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) ,  { linear_search_aux (a , e , 0) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) , ensures linear_search_postcond (a , e , result) , { linear_search_aux (a , e , 0) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) , ensures linear_search_postcond (a , e , result) , { linear_search_aux (a , e , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_69/verina_basic_69_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "03e43303cb14", "function_name": "linear_search", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_09be92538d29", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN ,  { let mut i = 0 ; while i < nums . len () invariant 0 <= i <= nums . len () , forall | ii : int , jj : int | 0 <= ii < i && ii < jj < nums . len () ==> nums [ii] + nums [jj] != target , decreases nums . len () - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () , i + 1 <= j <= nums . len () , forall | ii : int , jj : int | 0 <= ii < i && ii < jj < nums . len () ==> nums [ii] + nums [jj] != target , forall | jj : int | (i as int) < jj < j ==> nums [i as int] + nums [jj] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN , ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () invariant 0 <= i <= nums . len () , forall | ii : int , jj : int | 0 <= ii < i && ii < jj < nums . len () ==> nums [ii] + nums [jj] != target , decreases nums . len () - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () , i + 1 <= j <= nums . len () , forall | ii : int , jj : int | 0 <= ii < i && ii < jj < nums . len () ==> nums [ii] + nums [jj] != target , forall | jj : int | (i as int) < jj < j ==> nums [i as int] + nums [jj] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN , ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () invariant 0 <= i <= nums . len () , forall | ii : int , jj : int | 0 <= ii < i && ii < jj < nums . len () ==> nums [ii] + nums [jj] != target , decreases nums . len () - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () , i + 1 <= j <= nums . len () , forall | ii : int , jj : int | 0 <= ii < i && ii < jj < nums . len () ==> nums [ii] + nums [jj] != target , forall | jj : int | (i as int) < jj < j ==> nums [i as int] + nums [jj] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/043-pairs-sum-to-zero_impl.rs", "verified": true, "metadata": {"original_id": "09be92538d29", "function_name": "pairs_sum_to_zero", "bug_type": "missing_ensures"}}
{"id": "task_b_1abcb777eff1", "task": "task_b", "input_text": "fn is_digit (c : u8) -> (res : bool)\nensures res == is_digit_spec (c) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "1abcb777eff1", "function_name": "is_digit", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_c598d24e772a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool)  { if a . len () == 0 { return true ; } let first = a [0] ; let mut i = 1 ; while i < a . len () invariant 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first , decreases a . len () - i { if a [i] != first { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; let mut i = 1 ; while i < a . len () invariant 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first , decreases a . len () - i { if a [i] != first { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; let mut i = 1 ; while i < a . len () invariant 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first , decreases a . len () - i { if a [i] != first { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/has_only_one_distinct_element_iter_2_current.rs", "verified": true, "metadata": {"original_id": "c598d24e772a", "function_name": "has_only_one_distinct_element", "bug_type": "missing_ensures"}}
{"id": "task_a_11987890251d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "requires old (v) . len () > 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize) requires old (v) . len () > 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "11987890251d", "function_name": "separate", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_requires_530a59003962", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >)  ensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i] { let n = matrix . len () ; let mut result : Vec < Vec < i32 > > = Vec :: new () ; let mut i = 0 ; while i < n invariant 0 <= i <= n , result . len () == i , forall | k : int | # ! [trigger result [k]] 0 <= k < i ==> result [k] . len () == n , forall | k : int , l : int | # ! [trigger result [k] , matrix [l]] 0 <= k < i && 0 <= l < n ==> result [k] [l] == matrix [l] [k] decreases n - i { let mut row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < n invariant 0 <= j <= n , 0 <= i < n , row . len () == j , forall | l : int | # ! [trigger row [l]] 0 <= l < j ==> row [l] == matrix [l] [i as int] decreases n - j { row . push (matrix [j] [i]) ; j += 1 ; } result . push (row) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >) requires matrix . len () > 0 , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix [0] . len () , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix . len () ensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i] { let n = matrix . len () ; let mut result : Vec < Vec < i32 > > = Vec :: new () ; let mut i = 0 ; while i < n invariant 0 <= i <= n , result . len () == i , forall | k : int | # ! [trigger result [k]] 0 <= k < i ==> result [k] . len () == n , forall | k : int , l : int | # ! [trigger result [k] , matrix [l]] 0 <= k < i && 0 <= l < n ==> result [k] [l] == matrix [l] [k] decreases n - i { let mut row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < n invariant 0 <= j <= n , 0 <= i < n , row . len () == j , forall | l : int | # ! [trigger row [l]] 0 <= l < j ==> row [l] == matrix [l] [i as int] decreases n - j { row . push (matrix [j] [i]) ; j += 1 ; } result . push (row) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn transpose (matrix : Vec < Vec < i32 > >) -> (result : Vec < Vec < i32 > >) requires matrix . len () > 0 , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix [0] . len () , forall | i : int | # ! [trigger matrix [i]] 0 <= i < matrix . len () ==> matrix [i] . len () == matrix . len () ensures result . len () == matrix [0] . len () , forall | i : int | # ! [trigger result [i]] 0 <= i < result . len () ==> result [i] . len () == matrix . len () , forall | i : int , j : int | # ! [trigger result [i] , matrix [j]] 0 <= i < result . len () && 0 <= j < result [i] . len () ==> result [i] [j] == matrix [j] [i] { let n = matrix . len () ; let mut result : Vec < Vec < i32 > > = Vec :: new () ; let mut i = 0 ; while i < n invariant 0 <= i <= n , result . len () == i , forall | k : int | # ! [trigger result [k]] 0 <= k < i ==> result [k] . len () == n , forall | k : int , l : int | # ! [trigger result [k] , matrix [l]] 0 <= k < i && 0 <= l < n ==> result [k] [l] == matrix [l] [k] decreases n - i { let mut row : Vec < i32 > = Vec :: new () ; let mut j = 0 ; while j < n invariant 0 <= j <= n , 0 <= i < n , row . len () == j , forall | l : int | # ! [trigger row [l]] 0 <= l < j ==> row [l] == matrix [l] [i as int] decreases n - j { row . push (matrix [j] [i]) ; j += 1 ; } result . push (row) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/WIP/WIP__transpose_matrix_iter_3_current.rs", "verified": true, "metadata": {"original_id": "530a59003962", "function_name": "transpose", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_verus_rw2022_script_a61a5d4b6b8c", "task": "task_c", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nfn main() {}\n\n// ## 11 -- 10-program.rs\n\n#[allow(unused_imports)]\nuse {verus_builtin::*, verus_builtin_macros::*, prelude::*, seq::*, vstd::*};\n\nverus! {\n\n// ## A -- A-program.rs\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n    if a >= b {\n        a\n    } else {\n        b\n    }\n}\n\nfn max_test2() {\n    let x = 3;\n    let y = 4;\n    let ret = max(x, y);\n    assert(ret == 4);\n}\n\n// ## B -- B-program.rs\nfn main_1() {\n    let x = 3;\n    let y = 4;\n    assert(x != y);\n}\n\n// ## B -- B-program.rs.smt sat\n// ## C -- C-prime.rs\nspec fn divides(factor: nat, candidate: nat) -> bool {\n    candidate % factor == 0\n}\n\nspec fn is_prime(candidate: nat) -> bool {\n    &&& 1 < candidate\n    &&& forall|factor: nat| 1 < factor && factor < candidate ==> !divides(factor, candidate)\n}\n\nfn test_prime(candidate: u64) -> (result: bool)\n    requires\n        1 < candidate,\n    ensures\n        result == is_prime(candidate as nat),\n{\n    let mut factor: u64 = 2;\n    while factor < candidate\n        invariant\n            1 < factor <= candidate,\n            forall|smallerfactor: nat|\n                1 < smallerfactor < factor ==> !divides(smallerfactor, candidate as nat),\n    {\n        if candidate % factor == 0 {\n            assert(divides(factor as nat, candidate as nat));\n            assert(!is_prime(candidate as nat));\n            return false;\n        }\n        factor = factor + 1;\n    }\n    true\n}\n\nfn assertions() {\n    assert(divides(3, 6));\n    assert(divides(12, 24));\n    assert(is_prime(2));\n    assert(is_prime(3));\n    assert(!divides(4, 5));\n    assert(is_prime(5));\n}\n\n// ## D -- D-fibo.rs\nspec fn fibo(n: nat) -> nat\n    {\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    {\n    // ----\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\n// ## D/2 -- D-fibo.rs\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    // ----\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\n// ## E -- E-reverse.rs -- spec variables\n/* See vectors.rs\nfn reverse(v: &mut Vec<u64>) {\n    ensures([\n        v.len() == old(v).len(),\n        forall(|i: int| 0 <= i && i < old(v).len()\n               >>= v.index(i) == old(v).index(old(v).len() - i - 1)),\n    ]);\n\n    let length = v.len();\n    #[verifier::spec] let v1 = *v;\n    let mut n: usize = 0;\n    while n < length / 2 {\n        invariant([\n            length == v.len(),\n            forall(|i: int| n <= i && i + n < length >>= v.index(i) == v1.index(i)),\n            forall(|i: int| 0 <= i && i < n >>= v.index(i) == v1.index(length - i - 1)),\n            forall(|i: int| 0 <= i && i < n >>= v1.index(i) == v.index(length - i - 1)),\n        ]);\n\n        let x = *v.index(n);\n        let y = *v.index(length - 1 - n);\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n\n        n = n + 1;\n    }\n}\n*/\n\n// F -- F-linear-proof\n// cell::RefCell::Cell<X>\n// G -- G-bitvector.rs\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{\n    assert(x & 7 == x % 8) by (bit_vector);\n    x & 7\n}\n\n} // verus!\n", "target_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nfn main() {}\n\n// ## 11 -- 10-program.rs\n\n#[allow(unused_imports)]\nuse {verus_builtin::*, verus_builtin_macros::*, prelude::*, seq::*, vstd::*};\n\nverus! {\n\n// ## A -- A-program.rs\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n    if a >= b {\n        a\n    } else {\n        b\n    }\n}\n\nfn max_test2() {\n    let x = 3;\n    let y = 4;\n    let ret = max(x, y);\n    assert(ret == 4);\n}\n\n// ## B -- B-program.rs\nfn main_1() {\n    let x = 3;\n    let y = 4;\n    assert(x != y);\n}\n\n// ## B -- B-program.rs.smt sat\n// ## C -- C-prime.rs\nspec fn divides(factor: nat, candidate: nat) -> bool {\n    candidate % factor == 0\n}\n\nspec fn is_prime(candidate: nat) -> bool {\n    &&& 1 < candidate\n    &&& forall|factor: nat| 1 < factor && factor < candidate ==> !divides(factor, candidate)\n}\n\nfn test_prime(candidate: u64) -> (result: bool)\n    requires\n        1 < candidate,\n    ensures\n        result == is_prime(candidate as nat),\n{\n    let mut factor: u64 = 2;\n    while factor < candidate\n        invariant\n            1 < factor <= candidate,\n            forall|smallerfactor: nat|\n                1 < smallerfactor < factor ==> !divides(smallerfactor, candidate as nat),\n    {\n        if candidate % factor == 0 {\n            assert(divides(factor as nat, candidate as nat));\n            assert(!is_prime(candidate as nat));\n            return false;\n        }\n        factor = factor + 1;\n    }\n    true\n}\n\nfn assertions() {\n    assert(divides(3, 6));\n    assert(divides(12, 24));\n    assert(is_prime(2));\n    assert(is_prime(3));\n    assert(!divides(4, 5));\n    assert(is_prime(5));\n}\n\n// ## D -- D-fibo.rs\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    // ----\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\n// ## D/2 -- D-fibo.rs\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    // ----\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\n// ## E -- E-reverse.rs -- spec variables\n/* See vectors.rs\nfn reverse(v: &mut Vec<u64>) {\n    ensures([\n        v.len() == old(v).len(),\n        forall(|i: int| 0 <= i && i < old(v).len()\n               >>= v.index(i) == old(v).index(old(v).len() - i - 1)),\n    ]);\n\n    let length = v.len();\n    #[verifier::spec] let v1 = *v;\n    let mut n: usize = 0;\n    while n < length / 2 {\n        invariant([\n            length == v.len(),\n            forall(|i: int| n <= i && i + n < length >>= v.index(i) == v1.index(i)),\n            forall(|i: int| 0 <= i && i < n >>= v.index(i) == v1.index(length - i - 1)),\n            forall(|i: int| 0 <= i && i < n >>= v1.index(i) == v.index(length - i - 1)),\n        ]);\n\n        let x = *v.index(n);\n        let y = *v.index(length - 1 - n);\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n\n        n = n + 1;\n    }\n}\n*/\n\n// F -- F-linear-proof\n// cell::RefCell::Cell<X>\n// G -- G-bitvector.rs\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{\n    assert(x & 7 == x % 8) by (bit_vector);\n    x & 7\n}\n\n} // verus!\n", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\nfn main() {}\n\n// ## 11 -- 10-program.rs\n\n#[allow(unused_imports)]\nuse {verus_builtin::*, verus_builtin_macros::*, prelude::*, seq::*, vstd::*};\n\nverus! {\n\n// ## A -- A-program.rs\nfn max(a: u64, b: u64) -> (ret: u64)\n    ensures\n        ret == a || ret == b,\n        ret >= a && ret >= b,\n{\n    if a >= b {\n        a\n    } else {\n        b\n    }\n}\n\nfn max_test2() {\n    let x = 3;\n    let y = 4;\n    let ret = max(x, y);\n    assert(ret == 4);\n}\n\n// ## B -- B-program.rs\nfn main_1() {\n    let x = 3;\n    let y = 4;\n    assert(x != y);\n}\n\n// ## B -- B-program.rs.smt sat\n// ## C -- C-prime.rs\nspec fn divides(factor: nat, candidate: nat) -> bool {\n    candidate % factor == 0\n}\n\nspec fn is_prime(candidate: nat) -> bool {\n    &&& 1 < candidate\n    &&& forall|factor: nat| 1 < factor && factor < candidate ==> !divides(factor, candidate)\n}\n\nfn test_prime(candidate: u64) -> (result: bool)\n    requires\n        1 < candidate,\n    ensures\n        result == is_prime(candidate as nat),\n{\n    let mut factor: u64 = 2;\n    while factor < candidate\n        invariant\n            1 < factor <= candidate,\n            forall|smallerfactor: nat|\n                1 < smallerfactor < factor ==> !divides(smallerfactor, candidate as nat),\n    {\n        if candidate % factor == 0 {\n            assert(divides(factor as nat, candidate as nat));\n            assert(!is_prime(candidate as nat));\n            return false;\n        }\n        factor = factor + 1;\n    }\n    true\n}\n\nfn assertions() {\n    assert(divides(3, 6));\n    assert(divides(12, 24));\n    assert(is_prime(2));\n    assert(is_prime(3));\n    assert(!divides(4, 5));\n    assert(is_prime(5));\n}\n\n// ## D -- D-fibo.rs\nspec fn fibo(n: nat) -> nat\n    decreases n,\n{\n    if n == 0 {\n        0\n    } else if n == 1 {\n        1\n    } else {\n        fibo((n - 2) as nat) + fibo((n - 1) as nat)\n    }\n}\n\nproof fn lemma_fibo_is_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        fibo(i) <= fibo(j),\n    decreases j - i,\n{\n    // ----\n    if j < 2 {\n    } else if i == j {\n    } else if i == j - 1 {\n    } else {\n        lemma_fibo_is_monotonic(i, (j - 1) as nat);\n        lemma_fibo_is_monotonic(i, (j - 2) as nat);\n    }\n}\n\n// ## D/2 -- D-fibo.rs\nspec fn fibo_fits_u64(n: nat) -> bool {\n    fibo(n) <= 0xffff_ffff_ffff_ffff\n}\n\nexec fn fibo_impl(n: u64) -> (result: u64)\n    requires\n        fibo_fits_u64(n as nat),\n    ensures\n        result == fibo(n as nat),\n{\n    // ----\n    if n == 0 {\n        return 0;\n    }\n    let mut prev: u64 = 0;\n    let mut cur: u64 = 1;\n    let mut i: u64 = 1;\n    while i < n\n        invariant\n            0 < i <= n,\n            fibo_fits_u64(n as nat),\n            fibo_fits_u64(i as nat),\n            cur == fibo(i as nat),\n            prev == fibo((i - 1) as nat),\n    {\n        i = i + 1;\n        proof {\n            lemma_fibo_is_monotonic(i as nat, n as nat);\n        }\n        let new_cur = cur + prev;\n        prev = cur;\n        cur = new_cur;\n    }\n    cur\n}\n\n// ## E -- E-reverse.rs -- spec variables\n/* See vectors.rs\nfn reverse(v: &mut Vec<u64>) {\n    ensures([\n        v.len() == old(v).len(),\n        forall(|i: int| 0 <= i && i < old(v).len()\n               >>= v.index(i) == old(v).index(old(v).len() - i - 1)),\n    ]);\n\n    let length = v.len();\n    #[verifier::spec] let v1 = *v;\n    let mut n: usize = 0;\n    while n < length / 2 {\n        invariant([\n            length == v.len(),\n            forall(|i: int| n <= i && i + n < length >>= v.index(i) == v1.index(i)),\n            forall(|i: int| 0 <= i && i < n >>= v.index(i) == v1.index(length - i - 1)),\n            forall(|i: int| 0 <= i && i < n >>= v1.index(i) == v.index(length - i - 1)),\n        ]);\n\n        let x = *v.index(n);\n        let y = *v.index(length - 1 - n);\n        v.set(n, y);\n        v.set(length - 1 - n, x);\n\n        n = n + 1;\n    }\n}\n*/\n\n// F -- F-linear-proof\n// cell::RefCell::Cell<X>\n// G -- G-bitvector.rs\nfn mod8_bw(x: u32) -> (ret: u32)\n    ensures\n        ret == x % 8,\n{\n    assert(x & 7 == x % 8) by (bit_vector);\n    x & 7\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/rw2022_script.rs", "verified": true, "metadata": {"original_id": "verus_rw2022_script_a61a5d4b6b8c", "function_name": "", "bug_type": "missing_decreases"}}
{"id": "task_b_65b358753fce", "task": "task_b", "input_text": "fn compare_int (a : int , b : int) -> (eq : bool)\nrequires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_compare/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "65b358753fce", "function_name": "compare_int", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_requires_edc096b52552", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)  ensures sum [0] == 6 * N , { sum . set (0 , 6 * N as i32) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * N as i32) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/unverified/s52if_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "edc096b52552", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_verus_recursive_types_c0ef99fd2fbd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\n// TODO: add some of these explanations to the guide\n\nverus! {\n\n// If treated naively, recursive types can lead to nonterminating proofs:\n/*\nstruct R { f: spec_fn(R) -> int }\nproof fn bad()\n\n{\n    let f1 = |r: R| -> int {\n        (r.f)(r) + 1\n    };\n    let r = R { f: f1 };\n    // from r == R { f: f1 }:\n    assert( r.f     == f1   );\n    assert((r.f)(r) == f1(r));\n    // from the definition of f1:\n    assert(f1(r) == (r.f)(r) + 1);\n    // taken together:\n    assert(f1(r) == f1(r) + 1);\n}\n*/// To prevent this, Verus prohibits recursion in \"negative positions\" in a recursive type.\n// Roughly, a negative position is anything on the left-hand side of a function type ->.\n// For example, the \"R\" in spec_fn(R) -> int is in a negative position.\n// Therefore, Verus rejects the definition \"struct R { f: spec_fn(R) -> int }\" with an error.\n// If generics are treated naively, they could encode recursion in negative positions.\n// For example, we could try to wrap the function type in a new type to hide the negative\n// use of R:\n/*\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // error: A not allowed in negative position\nstruct R { f: FnWrapper<R, int> }\n*/// To prevent this, Verus requires that type parameters used in negative positions (like A)\n// be annotated with #[verifier::reject_recursive_types]:\n/*\n#[verifier::reject_recursive_types(A)]\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // ok\nstruct R { f: FnWrapper<R, int> } // error: R not allowed in negative position\n*/// Based on this annotation on A, Verus knows that the recursive R in FnWrapper<R, int> should\n// be rejected, and it reports an error in the definition of R.\n// Recursive types can be used in decreases clauses of recursive specifications and recursive proofs:\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list  // decreases can be used on values of type List<A> ,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\n// To support this, Verus requires that struct and enum datatypes have a well-defined height (rank).\n// For this, Verus requires that struct and enum datatypes have a non-recursive\n// \"ground\" variant that can be used as a base case for defining the height.\n// For example, the Nil variant in List can be used to construct List values of height 0,\n// and then the Cons variant can be repeatedly applied to construct bigger and bigger values\n// with height > 0.\n// Attempting to declare a datatype with no ground variant will cause an error:\n/*\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which recursively uses UngroundedList\n    Cons(A, Box<UngroundedList<A>>),\n}\n*/\n\n// If generics are treated naively, they could encode datatypes with no ground variant:\n/*\nstruct DataWrapper<A> { a: A }\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which still recursively uses UngroundedList\n    Cons(A, Box<DataWrapper<UngroundedList<A>>>),\n}\n*/\n\n// To prevent this, Verus rejects a recursive type definition's ground variant\n// from instantiating a type parameter A with the recursive type (UngroundedList)\n// unless the type parameter A is marked #[verifier::accept_recursive_types].\n// However, if DataWrapper marks A accept_recursive_types,\n// then DataWrapper must have a ground variant that is not built from A.\n// Because of this, Verus rejects the following:\n/*\n#[verifier::accept_recursive_types(A)]\nstruct DataWrapper<A> { a: A } // error: no ground variant without A\n*/\n\n// However, by adding a ground variant, we can provide a correct wrapper,\n// making both DataOption and GroundedList properly grounded:\n#[verifier::accept_recursive_types(A)]\nenum DataOption<A> {\n    None,\n    Some(A),\n}\n  // ok\nenum GroundedList<A> {\n    Cons(A, Box<DataOption<GroundedList<A>>>),  // ok\n}\n\n// Overall, Verus parameters have one of three levels of acceptance of recursive types:\n// - #[verifier::reject_recursive_types]\n// - #[verifier::reject_recursive_types_in_ground_variants]\n// - #[verifier::accept_recursive_types]\n// reject_recursive_types is added to types that use the type parameter negatively,\n// and accept_recursive_types may (optionally) be added to types that have a ground variant\n// that doesn't use the type parameter.\n// Typical example of reject_recursive_types:\n#[verifier::reject_recursive_types(A)]\nstruct Set<A> {\n    f: spec_fn(A) -> bool,\n}\n\n// Typical example of reject_recursive_types_in_ground_variants (which is the default):\nstruct Pair<A, B> {\n    first: A,\n    second: B,\n}\n\n// Typical example of accept_recursive_types:\n#[verifier::accept_recursive_types(A)]\nenum Option<A> {\n    None,\n    Some(A),\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "use vstd::prelude::*;\n\n// TODO: add some of these explanations to the guide\n\nverus! {\n\n// If treated naively, recursive types can lead to nonterminating proofs:\n/*\nstruct R { f: spec_fn(R) -> int }\nproof fn bad()\n    ensures false\n{\n    let f1 = |r: R| -> int {\n        (r.f)(r) + 1\n    };\n    let r = R { f: f1 };\n    // from r == R { f: f1 }:\n    assert( r.f     == f1   );\n    assert((r.f)(r) == f1(r));\n    // from the definition of f1:\n    assert(f1(r) == (r.f)(r) + 1);\n    // taken together:\n    assert(f1(r) == f1(r) + 1);\n}\n*/// To prevent this, Verus prohibits recursion in \"negative positions\" in a recursive type.\n// Roughly, a negative position is anything on the left-hand side of a function type ->.\n// For example, the \"R\" in spec_fn(R) -> int is in a negative position.\n// Therefore, Verus rejects the definition \"struct R { f: spec_fn(R) -> int }\" with an error.\n// If generics are treated naively, they could encode recursion in negative positions.\n// For example, we could try to wrap the function type in a new type to hide the negative\n// use of R:\n/*\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // error: A not allowed in negative position\nstruct R { f: FnWrapper<R, int> }\n*/// To prevent this, Verus requires that type parameters used in negative positions (like A)\n// be annotated with #[verifier::reject_recursive_types]:\n/*\n#[verifier::reject_recursive_types(A)]\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // ok\nstruct R { f: FnWrapper<R, int> } // error: R not allowed in negative position\n*/// Based on this annotation on A, Verus knows that the recursive R in FnWrapper<R, int> should\n// be rejected, and it reports an error in the definition of R.\n// Recursive types can be used in decreases clauses of recursive specifications and recursive proofs:\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list  // decreases can be used on values of type List<A> ,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\n// To support this, Verus requires that struct and enum datatypes have a well-defined height (rank).\n// For this, Verus requires that struct and enum datatypes have a non-recursive\n// \"ground\" variant that can be used as a base case for defining the height.\n// For example, the Nil variant in List can be used to construct List values of height 0,\n// and then the Cons variant can be repeatedly applied to construct bigger and bigger values\n// with height > 0.\n// Attempting to declare a datatype with no ground variant will cause an error:\n/*\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which recursively uses UngroundedList\n    Cons(A, Box<UngroundedList<A>>),\n}\n*/\n\n// If generics are treated naively, they could encode datatypes with no ground variant:\n/*\nstruct DataWrapper<A> { a: A }\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which still recursively uses UngroundedList\n    Cons(A, Box<DataWrapper<UngroundedList<A>>>),\n}\n*/\n\n// To prevent this, Verus rejects a recursive type definition's ground variant\n// from instantiating a type parameter A with the recursive type (UngroundedList)\n// unless the type parameter A is marked #[verifier::accept_recursive_types].\n// However, if DataWrapper marks A accept_recursive_types,\n// then DataWrapper must have a ground variant that is not built from A.\n// Because of this, Verus rejects the following:\n/*\n#[verifier::accept_recursive_types(A)]\nstruct DataWrapper<A> { a: A } // error: no ground variant without A\n*/\n\n// However, by adding a ground variant, we can provide a correct wrapper,\n// making both DataOption and GroundedList properly grounded:\n#[verifier::accept_recursive_types(A)]\nenum DataOption<A> {\n    None,\n    Some(A),\n}\n  // ok\nenum GroundedList<A> {\n    Cons(A, Box<DataOption<GroundedList<A>>>),  // ok\n}\n\n// Overall, Verus parameters have one of three levels of acceptance of recursive types:\n// - #[verifier::reject_recursive_types]\n// - #[verifier::reject_recursive_types_in_ground_variants]\n// - #[verifier::accept_recursive_types]\n// reject_recursive_types is added to types that use the type parameter negatively,\n// and accept_recursive_types may (optionally) be added to types that have a ground variant\n// that doesn't use the type parameter.\n// Typical example of reject_recursive_types:\n#[verifier::reject_recursive_types(A)]\nstruct Set<A> {\n    f: spec_fn(A) -> bool,\n}\n\n// Typical example of reject_recursive_types_in_ground_variants (which is the default):\nstruct Pair<A, B> {\n    first: A,\n    second: B,\n}\n\n// Typical example of accept_recursive_types:\n#[verifier::accept_recursive_types(A)]\nenum Option<A> {\n    None,\n    Some(A),\n}\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "use vstd::prelude::*;\n\n// TODO: add some of these explanations to the guide\n\nverus! {\n\n// If treated naively, recursive types can lead to nonterminating proofs:\n/*\nstruct R { f: spec_fn(R) -> int }\nproof fn bad()\n    ensures false\n{\n    let f1 = |r: R| -> int {\n        (r.f)(r) + 1\n    };\n    let r = R { f: f1 };\n    // from r == R { f: f1 }:\n    assert( r.f     == f1   );\n    assert((r.f)(r) == f1(r));\n    // from the definition of f1:\n    assert(f1(r) == (r.f)(r) + 1);\n    // taken together:\n    assert(f1(r) == f1(r) + 1);\n}\n*/// To prevent this, Verus prohibits recursion in \"negative positions\" in a recursive type.\n// Roughly, a negative position is anything on the left-hand side of a function type ->.\n// For example, the \"R\" in spec_fn(R) -> int is in a negative position.\n// Therefore, Verus rejects the definition \"struct R { f: spec_fn(R) -> int }\" with an error.\n// If generics are treated naively, they could encode recursion in negative positions.\n// For example, we could try to wrap the function type in a new type to hide the negative\n// use of R:\n/*\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // error: A not allowed in negative position\nstruct R { f: FnWrapper<R, int> }\n*/// To prevent this, Verus requires that type parameters used in negative positions (like A)\n// be annotated with #[verifier::reject_recursive_types]:\n/*\n#[verifier::reject_recursive_types(A)]\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // ok\nstruct R { f: FnWrapper<R, int> } // error: R not allowed in negative position\n*/// Based on this annotation on A, Verus knows that the recursive R in FnWrapper<R, int> should\n// be rejected, and it reports an error in the definition of R.\n// Recursive types can be used in decreases clauses of recursive specifications and recursive proofs:\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list  // decreases can be used on values of type List<A> ,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\n// To support this, Verus requires that struct and enum datatypes have a well-defined height (rank).\n// For this, Verus requires that struct and enum datatypes have a non-recursive\n// \"ground\" variant that can be used as a base case for defining the height.\n// For example, the Nil variant in List can be used to construct List values of height 0,\n// and then the Cons variant can be repeatedly applied to construct bigger and bigger values\n// with height > 0.\n// Attempting to declare a datatype with no ground variant will cause an error:\n/*\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which recursively uses UngroundedList\n    Cons(A, Box<UngroundedList<A>>),\n}\n*/\n\n// If generics are treated naively, they could encode datatypes with no ground variant:\n/*\nstruct DataWrapper<A> { a: A }\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which still recursively uses UngroundedList\n    Cons(A, Box<DataWrapper<UngroundedList<A>>>),\n}\n*/\n\n// To prevent this, Verus rejects a recursive type definition's ground variant\n// from instantiating a type parameter A with the recursive type (UngroundedList)\n// unless the type parameter A is marked #[verifier::accept_recursive_types].\n// However, if DataWrapper marks A accept_recursive_types,\n// then DataWrapper must have a ground variant that is not built from A.\n// Because of this, Verus rejects the following:\n/*\n#[verifier::accept_recursive_types(A)]\nstruct DataWrapper<A> { a: A } // error: no ground variant without A\n*/\n\n// However, by adding a ground variant, we can provide a correct wrapper,\n// making both DataOption and GroundedList properly grounded:\n#[verifier::accept_recursive_types(A)]\nenum DataOption<A> {\n    None,\n    Some(A),\n}\n  // ok\nenum GroundedList<A> {\n    Cons(A, Box<DataOption<GroundedList<A>>>),  // ok\n}\n\n// Overall, Verus parameters have one of three levels of acceptance of recursive types:\n// - #[verifier::reject_recursive_types]\n// - #[verifier::reject_recursive_types_in_ground_variants]\n// - #[verifier::accept_recursive_types]\n// reject_recursive_types is added to types that use the type parameter negatively,\n// and accept_recursive_types may (optionally) be added to types that have a ground variant\n// that doesn't use the type parameter.\n// Typical example of reject_recursive_types:\n#[verifier::reject_recursive_types(A)]\nstruct Set<A> {\n    f: spec_fn(A) -> bool,\n}\n\n// Typical example of reject_recursive_types_in_ground_variants (which is the default):\nstruct Pair<A, B> {\n    first: A,\n    second: B,\n}\n\n// Typical example of accept_recursive_types:\n#[verifier::accept_recursive_types(A)]\nenum Option<A> {\n    None,\n    Some(A),\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/recursive_types.rs", "verified": true, "metadata": {"original_id": "verus_recursive_types_c0ef99fd2fbd", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_a_db8eba61e4e5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = a ; let old_value = result [4] ; result . set (4 , old_value + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "target_text": "requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN\nensures update_elements_postcond (& a , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >) requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN ensures update_elements_postcond (& a , & result) { let mut result = a ; let old_value = result [4] ; result . set (4 , old_value + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_103/verina_basic_103_iter_2_current.rs", "verified": true, "metadata": {"original_id": "db8eba61e4e5", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_b_2f8692a729d3", "task": "task_b", "input_text": "pub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)\nrequires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures forall | k : int | 0 <= k < N ==> a [k] == N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases N - i , { a . set (i as usize , N) ; i = i + 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases N - i , { a . set (i as usize , N) ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/sina1_impl.rs", "verified": true, "metadata": {"original_id": "2f8692a729d3", "function_name": "myfun", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_ensures_ccfb57f4fcbc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn concat_precond (a : & Vec < i32 > , b : & Vec < i32 >) -> bool { true }\nspec fn concat_postcond (a : & Vec < i32 > , b : & Vec < i32 > , result : & Vec < i32 >) -> bool { result . len () == a . len () + b . len () && (forall | k : int | 0 <= k < a . len () ==> result [k] == a [k]) && (forall | k : int | 0 <= k < b . len () ==> result [k + a . len ()] == b [k]) }\nfn concat (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : Vec < i32 >) requires concat_precond (a , b) , a . len () + b . len () <= MAX ,  { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == a [k] , decreases a . len () - i { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k < j ==> result [k + a . len ()] == b [k] , decreases b . len () - j { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn concat_precond (a : & Vec < i32 > , b : & Vec < i32 >) -> bool { true }\nspec fn concat_postcond (a : & Vec < i32 > , b : & Vec < i32 > , result : & Vec < i32 >) -> bool { result . len () == a . len () + b . len () && (forall | k : int | 0 <= k < a . len () ==> result [k] == a [k]) && (forall | k : int | 0 <= k < b . len () ==> result [k + a . len ()] == b [k]) }\nfn concat (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : Vec < i32 >) requires concat_precond (a , b) , a . len () + b . len () <= MAX , ensures concat_postcond (a , b , & result) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == a [k] , decreases a . len () - i { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k < j ==> result [k + a . len ()] == b [k] , decreases b . len () - j { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn concat_precond (a : & Vec < i32 > , b : & Vec < i32 >) -> bool { true }\nspec fn concat_postcond (a : & Vec < i32 > , b : & Vec < i32 > , result : & Vec < i32 >) -> bool { result . len () == a . len () + b . len () && (forall | k : int | 0 <= k < a . len () ==> result [k] == a [k]) && (forall | k : int | 0 <= k < b . len () ==> result [k + a . len ()] == b [k]) }\nfn concat (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : Vec < i32 >) requires concat_precond (a , b) , a . len () + b . len () <= MAX , ensures concat_postcond (a , b , & result) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == a [k] , decreases a . len () - i { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k < j ==> result [k + a . len ()] == b [k] , decreases b . len () - j { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_83/verina_basic_83_impl.rs", "verified": true, "metadata": {"original_id": "ccfb57f4fcbc", "function_name": "concat", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_16311594898c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)  ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/is_non_prime_iter_2_current.rs", "verified": true, "metadata": {"original_id": "16311594898c", "function_name": "is_non_prime", "bug_type": "missing_requires"}}
{"id": "task_b_000452c4f641", "task": "task_b", "input_text": "fn is_product_even (arr : & Vec < u32 >) -> (result : bool)\nensures result == is_even (n), result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool) ensures result == is_even (n) { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (# [trigger] arr [k]) , { if is_even_exec (arr [i]) { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool) ensures result == is_even (n) { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (# [trigger] arr [k]) , { if is_even_exec (arr [i]) { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "000452c4f641", "function_name": "is_product_even", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_8c528113aee7", "task": "task_b", "input_text": "fn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)\nensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/code_from_spec_on_17-07_17h24/task_id_2_impl_impl.rs", "verified": true, "metadata": {"original_id": "8c528113aee7", "function_name": "contains", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_ensures_ea5380f02e6b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000  { (a + b) / 2 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_avg/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "ea5380f02e6b", "function_name": "compute_avg", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_79e4faecada6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true ,  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "79e4faecada6", "function_name": "binary_search", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_f18dbd825d99", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize)  ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx : usize = 0 ; let mut j : usize = 1 ; while j < nums . len () invariant 0 <= max_idx && max_idx < nums . len () , 1 <= j && j <= nums . len () , forall | i : int | 0 <= i && i < j ==> nums [i] <= nums [max_idx as int] , decreases nums . len () - j { if nums [j] > nums [max_idx] { max_idx = j ; } j += 1 ; } max_idx }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx : usize = 0 ; let mut j : usize = 1 ; while j < nums . len () invariant 0 <= max_idx && max_idx < nums . len () , 1 <= j && j <= nums . len () , forall | i : int | 0 <= i && i < j ==> nums [i] <= nums [max_idx as int] , decreases nums . len () - j { if nums [j] > nums [max_idx] { max_idx = j ; } j += 1 ; } max_idx }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx : usize = 0 ; let mut j : usize = 1 ; while j < nums . len () invariant 0 <= max_idx && max_idx < nums . len () , 1 <= j && j <= nums . len () , forall | i : int | 0 <= i && i < j ==> nums [i] <= nums [max_idx as int] , decreases nums . len () - j { if nums [j] > nums [max_idx] { max_idx = j ; } j += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/max_array_impl.rs", "verified": true, "metadata": {"original_id": "f18dbd825d99", "function_name": "max_array", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_e4abb7af8d6a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >)  { x . checked_add (y) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >) ensures res . is_some () ==> res . unwrap () == x + y , { x . checked_add (y) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >) ensures res . is_some () ==> res . unwrap () == x + y , { x . checked_add (y) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/053-add_iter_1_current.rs", "verified": true, "metadata": {"original_id": "e4abb7af8d6a", "function_name": "add", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_314920209f24", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len ()  { if arr [i] >= number { return false ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] , { if arr [i] >= number { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] , { if arr [i] >= number { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_433_iter_1_current.rs", "verified": true, "metadata": {"original_id": "314920209f24", "function_name": "is_greater", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_assert_verus_recursive_types_c0ef99fd2fbd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\n// TODO: add some of these explanations to the guide\n\nverus! {\n\n// If treated naively, recursive types can lead to nonterminating proofs:\n/*\nstruct R { f: spec_fn(R) -> int }\nproof fn bad()\n    ensures false\n{\n    let f1 = |r: R| -> int {\n        (r.f)(r) + 1\n    };\n    let r = R { f: f1 };\n    // from r == R { f: f1 }:\n\n    // from the definition of f1:\n\n    // taken together:\n\n}\n*/// To prevent this, Verus prohibits recursion in \"negative positions\" in a recursive type.\n// Roughly, a negative position is anything on the left-hand side of a function type ->.\n// For example, the \"R\" in spec_fn(R) -> int is in a negative position.\n// Therefore, Verus rejects the definition \"struct R { f: spec_fn(R) -> int }\" with an error.\n// If generics are treated naively, they could encode recursion in negative positions.\n// For example, we could try to wrap the function type in a new type to hide the negative\n// use of R:\n/*\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // error: A not allowed in negative position\nstruct R { f: FnWrapper<R, int> }\n*/// To prevent this, Verus requires that type parameters used in negative positions (like A)\n// be annotated with #[verifier::reject_recursive_types]:\n/*\n#[verifier::reject_recursive_types(A)]\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // ok\nstruct R { f: FnWrapper<R, int> } // error: R not allowed in negative position\n*/// Based on this annotation on A, Verus knows that the recursive R in FnWrapper<R, int> should\n// be rejected, and it reports an error in the definition of R.\n// Recursive types can be used in decreases clauses of recursive specifications and recursive proofs:\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list  // decreases can be used on values of type List<A> ,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\n// To support this, Verus requires that struct and enum datatypes have a well-defined height (rank).\n// For this, Verus requires that struct and enum datatypes have a non-recursive\n// \"ground\" variant that can be used as a base case for defining the height.\n// For example, the Nil variant in List can be used to construct List values of height 0,\n// and then the Cons variant can be repeatedly applied to construct bigger and bigger values\n// with height > 0.\n// Attempting to declare a datatype with no ground variant will cause an error:\n/*\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which recursively uses UngroundedList\n    Cons(A, Box<UngroundedList<A>>),\n}\n*/\n\n// If generics are treated naively, they could encode datatypes with no ground variant:\n/*\nstruct DataWrapper<A> { a: A }\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which still recursively uses UngroundedList\n    Cons(A, Box<DataWrapper<UngroundedList<A>>>),\n}\n*/\n\n// To prevent this, Verus rejects a recursive type definition's ground variant\n// from instantiating a type parameter A with the recursive type (UngroundedList)\n// unless the type parameter A is marked #[verifier::accept_recursive_types].\n// However, if DataWrapper marks A accept_recursive_types,\n// then DataWrapper must have a ground variant that is not built from A.\n// Because of this, Verus rejects the following:\n/*\n#[verifier::accept_recursive_types(A)]\nstruct DataWrapper<A> { a: A } // error: no ground variant without A\n*/\n\n// However, by adding a ground variant, we can provide a correct wrapper,\n// making both DataOption and GroundedList properly grounded:\n#[verifier::accept_recursive_types(A)]\nenum DataOption<A> {\n    None,\n    Some(A),\n}\n  // ok\nenum GroundedList<A> {\n    Cons(A, Box<DataOption<GroundedList<A>>>),  // ok\n}\n\n// Overall, Verus parameters have one of three levels of acceptance of recursive types:\n// - #[verifier::reject_recursive_types]\n// - #[verifier::reject_recursive_types_in_ground_variants]\n// - #[verifier::accept_recursive_types]\n// reject_recursive_types is added to types that use the type parameter negatively,\n// and accept_recursive_types may (optionally) be added to types that have a ground variant\n// that doesn't use the type parameter.\n// Typical example of reject_recursive_types:\n#[verifier::reject_recursive_types(A)]\nstruct Set<A> {\n    f: spec_fn(A) -> bool,\n}\n\n// Typical example of reject_recursive_types_in_ground_variants (which is the default):\nstruct Pair<A, B> {\n    first: A,\n    second: B,\n}\n\n// Typical example of accept_recursive_types:\n#[verifier::accept_recursive_types(A)]\nenum Option<A> {\n    None,\n    Some(A),\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "use vstd::prelude::*;\n\n// TODO: add some of these explanations to the guide\n\nverus! {\n\n// If treated naively, recursive types can lead to nonterminating proofs:\n/*\nstruct R { f: spec_fn(R) -> int }\nproof fn bad()\n    ensures false\n{\n    let f1 = |r: R| -> int {\n        (r.f)(r) + 1\n    };\n    let r = R { f: f1 };\n    // from r == R { f: f1 }:\n    assert( r.f     == f1   );\n    assert((r.f)(r) == f1(r));\n    // from the definition of f1:\n    assert(f1(r) == (r.f)(r) + 1);\n    // taken together:\n    assert(f1(r) == f1(r) + 1);\n}\n*/// To prevent this, Verus prohibits recursion in \"negative positions\" in a recursive type.\n// Roughly, a negative position is anything on the left-hand side of a function type ->.\n// For example, the \"R\" in spec_fn(R) -> int is in a negative position.\n// Therefore, Verus rejects the definition \"struct R { f: spec_fn(R) -> int }\" with an error.\n// If generics are treated naively, they could encode recursion in negative positions.\n// For example, we could try to wrap the function type in a new type to hide the negative\n// use of R:\n/*\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // error: A not allowed in negative position\nstruct R { f: FnWrapper<R, int> }\n*/// To prevent this, Verus requires that type parameters used in negative positions (like A)\n// be annotated with #[verifier::reject_recursive_types]:\n/*\n#[verifier::reject_recursive_types(A)]\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // ok\nstruct R { f: FnWrapper<R, int> } // error: R not allowed in negative position\n*/// Based on this annotation on A, Verus knows that the recursive R in FnWrapper<R, int> should\n// be rejected, and it reports an error in the definition of R.\n// Recursive types can be used in decreases clauses of recursive specifications and recursive proofs:\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list  // decreases can be used on values of type List<A> ,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\n// To support this, Verus requires that struct and enum datatypes have a well-defined height (rank).\n// For this, Verus requires that struct and enum datatypes have a non-recursive\n// \"ground\" variant that can be used as a base case for defining the height.\n// For example, the Nil variant in List can be used to construct List values of height 0,\n// and then the Cons variant can be repeatedly applied to construct bigger and bigger values\n// with height > 0.\n// Attempting to declare a datatype with no ground variant will cause an error:\n/*\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which recursively uses UngroundedList\n    Cons(A, Box<UngroundedList<A>>),\n}\n*/\n\n// If generics are treated naively, they could encode datatypes with no ground variant:\n/*\nstruct DataWrapper<A> { a: A }\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which still recursively uses UngroundedList\n    Cons(A, Box<DataWrapper<UngroundedList<A>>>),\n}\n*/\n\n// To prevent this, Verus rejects a recursive type definition's ground variant\n// from instantiating a type parameter A with the recursive type (UngroundedList)\n// unless the type parameter A is marked #[verifier::accept_recursive_types].\n// However, if DataWrapper marks A accept_recursive_types,\n// then DataWrapper must have a ground variant that is not built from A.\n// Because of this, Verus rejects the following:\n/*\n#[verifier::accept_recursive_types(A)]\nstruct DataWrapper<A> { a: A } // error: no ground variant without A\n*/\n\n// However, by adding a ground variant, we can provide a correct wrapper,\n// making both DataOption and GroundedList properly grounded:\n#[verifier::accept_recursive_types(A)]\nenum DataOption<A> {\n    None,\n    Some(A),\n}\n  // ok\nenum GroundedList<A> {\n    Cons(A, Box<DataOption<GroundedList<A>>>),  // ok\n}\n\n// Overall, Verus parameters have one of three levels of acceptance of recursive types:\n// - #[verifier::reject_recursive_types]\n// - #[verifier::reject_recursive_types_in_ground_variants]\n// - #[verifier::accept_recursive_types]\n// reject_recursive_types is added to types that use the type parameter negatively,\n// and accept_recursive_types may (optionally) be added to types that have a ground variant\n// that doesn't use the type parameter.\n// Typical example of reject_recursive_types:\n#[verifier::reject_recursive_types(A)]\nstruct Set<A> {\n    f: spec_fn(A) -> bool,\n}\n\n// Typical example of reject_recursive_types_in_ground_variants (which is the default):\nstruct Pair<A, B> {\n    first: A,\n    second: B,\n}\n\n// Typical example of accept_recursive_types:\n#[verifier::accept_recursive_types(A)]\nenum Option<A> {\n    None,\n    Some(A),\n}\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "use vstd::prelude::*;\n\n// TODO: add some of these explanations to the guide\n\nverus! {\n\n// If treated naively, recursive types can lead to nonterminating proofs:\n/*\nstruct R { f: spec_fn(R) -> int }\nproof fn bad()\n    ensures false\n{\n    let f1 = |r: R| -> int {\n        (r.f)(r) + 1\n    };\n    let r = R { f: f1 };\n    // from r == R { f: f1 }:\n    assert( r.f     == f1   );\n    assert((r.f)(r) == f1(r));\n    // from the definition of f1:\n    assert(f1(r) == (r.f)(r) + 1);\n    // taken together:\n    assert(f1(r) == f1(r) + 1);\n}\n*/// To prevent this, Verus prohibits recursion in \"negative positions\" in a recursive type.\n// Roughly, a negative position is anything on the left-hand side of a function type ->.\n// For example, the \"R\" in spec_fn(R) -> int is in a negative position.\n// Therefore, Verus rejects the definition \"struct R { f: spec_fn(R) -> int }\" with an error.\n// If generics are treated naively, they could encode recursion in negative positions.\n// For example, we could try to wrap the function type in a new type to hide the negative\n// use of R:\n/*\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // error: A not allowed in negative position\nstruct R { f: FnWrapper<R, int> }\n*/// To prevent this, Verus requires that type parameters used in negative positions (like A)\n// be annotated with #[verifier::reject_recursive_types]:\n/*\n#[verifier::reject_recursive_types(A)]\nstruct FnWrapper<A, B> { f: spec_fn(A) -> B } // ok\nstruct R { f: FnWrapper<R, int> } // error: R not allowed in negative position\n*/// Based on this annotation on A, Verus knows that the recursive R in FnWrapper<R, int> should\n// be rejected, and it reports an error in the definition of R.\n// Recursive types can be used in decreases clauses of recursive specifications and recursive proofs:\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list  // decreases can be used on values of type List<A> ,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\n// To support this, Verus requires that struct and enum datatypes have a well-defined height (rank).\n// For this, Verus requires that struct and enum datatypes have a non-recursive\n// \"ground\" variant that can be used as a base case for defining the height.\n// For example, the Nil variant in List can be used to construct List values of height 0,\n// and then the Cons variant can be repeatedly applied to construct bigger and bigger values\n// with height > 0.\n// Attempting to declare a datatype with no ground variant will cause an error:\n/*\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which recursively uses UngroundedList\n    Cons(A, Box<UngroundedList<A>>),\n}\n*/\n\n// If generics are treated naively, they could encode datatypes with no ground variant:\n/*\nstruct DataWrapper<A> { a: A }\nenum UngroundedList<A> {\n    // error: no ground variant; the only variant is Cons, which still recursively uses UngroundedList\n    Cons(A, Box<DataWrapper<UngroundedList<A>>>),\n}\n*/\n\n// To prevent this, Verus rejects a recursive type definition's ground variant\n// from instantiating a type parameter A with the recursive type (UngroundedList)\n// unless the type parameter A is marked #[verifier::accept_recursive_types].\n// However, if DataWrapper marks A accept_recursive_types,\n// then DataWrapper must have a ground variant that is not built from A.\n// Because of this, Verus rejects the following:\n/*\n#[verifier::accept_recursive_types(A)]\nstruct DataWrapper<A> { a: A } // error: no ground variant without A\n*/\n\n// However, by adding a ground variant, we can provide a correct wrapper,\n// making both DataOption and GroundedList properly grounded:\n#[verifier::accept_recursive_types(A)]\nenum DataOption<A> {\n    None,\n    Some(A),\n}\n  // ok\nenum GroundedList<A> {\n    Cons(A, Box<DataOption<GroundedList<A>>>),  // ok\n}\n\n// Overall, Verus parameters have one of three levels of acceptance of recursive types:\n// - #[verifier::reject_recursive_types]\n// - #[verifier::reject_recursive_types_in_ground_variants]\n// - #[verifier::accept_recursive_types]\n// reject_recursive_types is added to types that use the type parameter negatively,\n// and accept_recursive_types may (optionally) be added to types that have a ground variant\n// that doesn't use the type parameter.\n// Typical example of reject_recursive_types:\n#[verifier::reject_recursive_types(A)]\nstruct Set<A> {\n    f: spec_fn(A) -> bool,\n}\n\n// Typical example of reject_recursive_types_in_ground_variants (which is the default):\nstruct Pair<A, B> {\n    first: A,\n    second: B,\n}\n\n// Typical example of accept_recursive_types:\n#[verifier::accept_recursive_types(A)]\nenum Option<A> {\n    None,\n    Some(A),\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/recursive_types.rs", "verified": true, "metadata": {"original_id": "verus_recursive_types_c0ef99fd2fbd", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_a_6d83f1c8cca4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) \ndecreases arr1 . len () - i\ninvariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] % arr2 [j] , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] % arr2 [j]) <= MAX) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] % arr2 [j] , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] % arr2 [j]) <= MAX) , decreases arr1 . len () - i { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_616_iter_3_current.rs", "verified": true, "metadata": {"original_id": "6d83f1c8cca4", "function_name": "element_wise_module", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_eacdf445eec3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) \ndecreases arr . len () - idx \ninvariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_790_impl.rs", "verified": true, "metadata": {"original_id": "eacdf445eec3", "function_name": "is_even_at_even_index", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_dc2d76ce2db1", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn helper (n : u32) -> (result : bool) { return false ; }\n\n} // verus!", "target_text": "decreases n", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: power :: pow ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn helper (n : u32) -> (result : bool) decreases n { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_14/verina_advanced_14_iter_0_original.rs", "verified": true, "metadata": {"original_id": "dc2d76ce2db1", "function_name": "helper", "has_requires": false, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_c_missing_invariant_af1a74651a1a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) , { for i in 0 .. arr . len ()  { if arr [i] != element { return false ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] == element { if arr [i] != element { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_elements_equals (arr : & Vec < i32 > , element : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> (arr [i] == element)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] == element { if arr [i] != element { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_284_impl.rs", "verified": true, "metadata": {"original_id": "af1a74651a1a", "function_name": "all_elements_equals", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_734530d2ece4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn increasing_triplet_precond (nums : Seq < i32 >) -> bool { true }\nfn increasing_triplet (nums : Vec < i32 >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn increasing_triplet_precond (nums : Seq < i32 >) -> bool { true }\nfn increasing_triplet (nums : Vec < i32 >) -> (result : bool) requires increasing_triplet_precond (nums @) { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn increasing_triplet_precond (nums : Seq < i32 >) -> bool { true }\nfn increasing_triplet (nums : Vec < i32 >) -> (result : bool) requires increasing_triplet_precond (nums @) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_15/verina_advanced_15_iter_0_original.rs", "verified": true, "metadata": {"original_id": "734530d2ece4", "function_name": "increasing_triplet", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_verus_datatypes_1d964de00785", "task": "task_c", "input_text": "#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\nfn get_len<A>(list: &List<A>) -> (r: u64)\n    requires\n        len(list) <= 0xffffffffffffffff,\n    ensures\n        r == len(list),\n{\n    let mut n: u64 = 0;\n    let mut iter = list;\n    loop\n\n    {\n        match iter {\n            List::Nil => {\n                break;\n            },\n            List::Cons(_, tl) => {\n                iter = tl;\n                proof {\n                    reveal_with_fuel(len, 2);\n                }\n                n = n + 1;\n            },\n        }\n    }\n    n\n}\n\nfn mk_range(start: u32, length: u32) -> (r: List<u32>)\n    requires\n        start + length <= 0xffff_ffff,\n    ensures\n        len::<u32>(&r) == length,\n    decreases length,\n{\n    if length == 0 {\n        List::Nil\n    } else {\n        List::Cons(start, Box::new(mk_range(start + 1, length - 1)))\n    }\n}\n\nfn main() {\n    let x = List::Cons(100u64, Box::new(List::Nil));\n    let i = match x {\n        List::Nil => 1,\n        List::Cons(n, _) if n < 10 => n + 2,\n        List::Cons(n, _) if n < 100 => n + 3,\n        List::Cons(n, _) if n < 200 => n + 4,\n        List::Cons(n, _) => n + 5,\n    };\n    assert(i == 104);\n    let mut j: u64 = 0;\n    match x {\n        List::Nil => {\n            j = 1;\n        },\n        List::Cons(n, _) => {\n            j = n;\n        },\n    }\n    assert(j == 100);\n    let k: u32 = match List::Cons(100u64, Box::new(List::Nil)) {\n        List::Nil => {\n            j = 11;\n            6\n        },\n        List::Cons(n, _) => {\n            j = n + 1;\n            7\n        },\n    };\n    assert(j == 101);\n    assert(k == 7);\n}\n\n} // verus!\n", "target_text": "#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\nfn get_len<A>(list: &List<A>) -> (r: u64)\n    requires\n        len(list) <= 0xffffffffffffffff,\n    ensures\n        r == len(list),\n{\n    let mut n: u64 = 0;\n    let mut iter = list;\n    loop\n        invariant\n            len(list) <= 0xffffffffffffffff,\n            n + len(iter) == len(list),\n        ensures\n            n == len(list),\n        decreases len(iter),\n    {\n        match iter {\n            List::Nil => {\n                break;\n            },\n            List::Cons(_, tl) => {\n                iter = tl;\n                proof {\n                    reveal_with_fuel(len, 2);\n                }\n                n = n + 1;\n            },\n        }\n    }\n    n\n}\n\nfn mk_range(start: u32, length: u32) -> (r: List<u32>)\n    requires\n        start + length <= 0xffff_ffff,\n    ensures\n        len::<u32>(&r) == length,\n    decreases length,\n{\n    if length == 0 {\n        List::Nil\n    } else {\n        List::Cons(start, Box::new(mk_range(start + 1, length - 1)))\n    }\n}\n\nfn main() {\n    let x = List::Cons(100u64, Box::new(List::Nil));\n    let i = match x {\n        List::Nil => 1,\n        List::Cons(n, _) if n < 10 => n + 2,\n        List::Cons(n, _) if n < 100 => n + 3,\n        List::Cons(n, _) if n < 200 => n + 4,\n        List::Cons(n, _) => n + 5,\n    };\n    assert(i == 104);\n    let mut j: u64 = 0;\n    match x {\n        List::Nil => {\n            j = 1;\n        },\n        List::Cons(n, _) => {\n            j = n;\n        },\n    }\n    assert(j == 100);\n    let k: u32 = match List::Cons(100u64, Box::new(List::Nil)) {\n        List::Nil => {\n            j = 11;\n            6\n        },\n        List::Cons(n, _) => {\n            j = n + 1;\n            7\n        },\n    };\n    assert(j == 101);\n    assert(k == 7);\n}\n\n} // verus!\n", "full_verified_code": "#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nenum List<A> {\n    Nil,\n    Cons(A, Box<List<A>>),\n}\n\nspec fn len<A>(list: &List<A>) -> nat\n    decreases list,\n{\n    match list {\n        List::Nil => 0,\n        List::Cons(_, tl) => 1 + len(tl),\n    }\n}\n\nfn get_len<A>(list: &List<A>) -> (r: u64)\n    requires\n        len(list) <= 0xffffffffffffffff,\n    ensures\n        r == len(list),\n{\n    let mut n: u64 = 0;\n    let mut iter = list;\n    loop\n        invariant\n            len(list) <= 0xffffffffffffffff,\n            n + len(iter) == len(list),\n        ensures\n            n == len(list),\n        decreases len(iter),\n    {\n        match iter {\n            List::Nil => {\n                break;\n            },\n            List::Cons(_, tl) => {\n                iter = tl;\n                proof {\n                    reveal_with_fuel(len, 2);\n                }\n                n = n + 1;\n            },\n        }\n    }\n    n\n}\n\nfn mk_range(start: u32, length: u32) -> (r: List<u32>)\n    requires\n        start + length <= 0xffff_ffff,\n    ensures\n        len::<u32>(&r) == length,\n    decreases length,\n{\n    if length == 0 {\n        List::Nil\n    } else {\n        List::Cons(start, Box::new(mk_range(start + 1, length - 1)))\n    }\n}\n\nfn main() {\n    let x = List::Cons(100u64, Box::new(List::Nil));\n    let i = match x {\n        List::Nil => 1,\n        List::Cons(n, _) if n < 10 => n + 2,\n        List::Cons(n, _) if n < 100 => n + 3,\n        List::Cons(n, _) if n < 200 => n + 4,\n        List::Cons(n, _) => n + 5,\n    };\n    assert(i == 104);\n    let mut j: u64 = 0;\n    match x {\n        List::Nil => {\n            j = 1;\n        },\n        List::Cons(n, _) => {\n            j = n;\n        },\n    }\n    assert(j == 100);\n    let k: u32 = match List::Cons(100u64, Box::new(List::Nil)) {\n        List::Nil => {\n            j = 11;\n            6\n        },\n        List::Cons(n, _) => {\n            j = n + 1;\n            7\n        },\n    };\n    assert(j == 101);\n    assert(k == 7);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/datatypes.rs", "verified": true, "metadata": {"original_id": "verus_datatypes_1d964de00785", "function_name": "", "bug_type": "missing_invariant"}}
{"id": "task_a_51e5c6e21309", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith)   { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith)   { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n  { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "requires p > 0 , p > 0 \nensures mul == ((a as int) * (b as int)) % (p as int) , r == modp_rec (n as nat , p as nat) \ndecreases n , n - i \ninvariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) decreases n , { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith) requires p > 0 , ensures r == modp_rec (n as nat , p as nat) , { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n invariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) , decreases n - i , { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/049-modp_iter_2_current.rs", "verified": true, "metadata": {"original_id": "51e5c6e21309", "function_name": "modp", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_b_ea4aa97c6d20", "task": "task_b", "input_text": "pub fn generate_all_combinations (n : i32 , k : i32)\nrequires 0 <= n <= MAX - 1 , 0 <= k <= n ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn generate_all_combinations (n : i32 , k : i32) -> Vec < Vec < i32 > > requires 0 <= n <= MAX - 1 , 0 <= k <= n , { return Vec :: new () ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn generate_all_combinations (n : i32 , k : i32) -> Vec < Vec < i32 > > requires 0 <= n <= MAX - 1 , 0 <= k <= n , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/interprocedural/AlgorithmsRust/all_combination_of_size_k_iter_0_original.rs", "verified": true, "metadata": {"original_id": "ea4aa97c6d20", "function_name": "generate_all_combinations", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_df8542f593af", "task": "task_b", "input_text": "fn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >)\nrequires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX \nensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >) requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX , ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >) requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX , ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_82/verina_basic_82_impl.rs", "verified": true, "metadata": {"original_id": "df8542f593af", "function_name": "copy_from", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_6b9009807334", "task": "task_b", "input_text": "fn set_to_seq (s : Vec < int >) -> (result : Vec < int >)\nrequires set_to_seq_precond (s @)", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn set_to_seq_precond (s : Seq < int >) -> bool { true }\nfn set_to_seq (s : Vec < int >) -> (result : Vec < int >) requires set_to_seq_precond (s @) { return Vec :: new () ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn set_to_seq_precond (s : Seq < int >) -> bool { true }\nfn set_to_seq (s : Vec < int >) -> (result : Vec < int >) requires set_to_seq_precond (s @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_89/verina_basic_89_iter_0_original.rs", "verified": true, "metadata": {"original_id": "6b9009807334", "function_name": "set_to_seq", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_requires_cf96657aad73", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >)  ensures find_smallest_postcond (s @ , result) , { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] , decreases s . len () - i , { if s [i] < min { min = s [i] ; } i = i + 1 ; } Some (min) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) , ensures find_smallest_postcond (s @ , result) , { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] , decreases s . len () - i , { if s [i] < min { min = s [i] ; } i = i + 1 ; } Some (min) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) , ensures find_smallest_postcond (s @ , result) , { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] , decreases s . len () - i , { if s [i] < min { min = s [i] ; } i = i + 1 ; } Some (min) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_2/verina_basic_2_iter_2_current.rs", "verified": true, "metadata": {"original_id": "cf96657aad73", "function_name": "find_smallest", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_ccc4e7907856", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_414_iter_3_current.rs", "verified": true, "metadata": {"original_id": "ccc4e7907856", "function_name": "contains", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_fea20d875003", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e , { if a [i] == e { return i ; } i += 1 ; } assert (false) ; 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e , decreases a . len () - i , { if a [i] == e { return i ; } i += 1 ; } assert (false) ; 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e , decreases a . len () - i , { if a [i] == e { return i ; } i += 1 ; } assert (false) ; 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/unverified/linear_search2_impl.rs", "verified": true, "metadata": {"original_id": "fea20d875003", "function_name": "linear_search", "bug_type": "missing_decreases"}}
{"id": "task_a_dfd8fc138793", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool)  { n % 2 == 1 }\nfn partition_odd_even (a : & mut Vec < u32 >)   { let mut left = 0 ; let mut right = a . len () ; while left < right  { if odd_exec (a [left]) { left += 1 ; } else { right -= 1 ; let temp = a [left] ; let right_val = a [right] ; a . set (left , right_val) ; a . set (right , temp) ; } } }\n\n} // verus!", "target_text": "requires old (a) . len () > 0 \nensures result == odd (n as int), a @ . len () == old (a) @ . len () \ndecreases right - left\ninvariant left <= right , right <= a . len () , a @ . len () == old (a) @ . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool) ensures result == odd (n as int) { n % 2 == 1 }\nfn partition_odd_even (a : & mut Vec < u32 >) requires old (a) . len () > 0 , ensures a @ . len () == old (a) @ . len () , { let mut left = 0 ; let mut right = a . len () ; while left < right invariant left <= right , right <= a . len () , a @ . len () == old (a) @ . len () , decreases right - left { if odd_exec (a [left]) { left += 1 ; } else { right -= 1 ; let temp = a [left] ; let right_val = a [right] ; a . set (left , right_val) ; a . set (right , temp) ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "dfd8fc138793", "function_name": "partition_odd_even", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_675cd954685d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_spec (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "675cd954685d", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_assert_verus_strings_a9ecfdea6bcc", "task": "task_c", "input_text": "// rust_verify/tests/example.rs\nuse vstd::prelude::*;\n\nverus! {\n\n// ANCHOR: initial\nfn get_char() {\n    let x = \"hello world\";\n    proof {\n        reveal_strlit(\"hello world\");\n    }\n\n    let val = x.get_char(0);\n\n}\n// ANCHOR_END: initial\n\n// ANCHOR: literal_eq\nfn literal_eq() {\n    let x = \"hello world\";\n    let y = \"hello world\";\n\n}\n// ANCHOR_END: literal_eq\n//\n// ANCHOR: literal_view\nfn str_view() {\n    let x = \"hello world\";\n    let ghost y: Seq<char> = x@;\n}\n// ANCHOR_END: literal_view\n\n// ANCHOR: pre_substring\nfn subrange<'a>(s: &str)\n    requires s@ =~= \"Hello\"@,\n{\n    proof {\n        reveal_strlit(\"Hello\");\n        reveal_strlit(\"H\");\n    }\n\n}\n// ANCHOR_END: pre_substring\n\n// ANCHOR: substring_ascii\nfn test() {\n    let a = String::from_str((\"ABC\"));\n    proof {\n        reveal_strlit(\"ABC\");\n    }\n\n    let b = a.as_str().substring_ascii(2, 3);\n    proof {\n        reveal_strlit(\"C\");\n    }\n\n}\n// ANCHOR_END: substring_ascii\n\n} // verus!", "target_text": "// rust_verify/tests/example.rs\nuse vstd::prelude::*;\n\nverus! {\n\n// ANCHOR: initial\nfn get_char() {\n    let x = \"hello world\";\n    proof {\n        reveal_strlit(\"hello world\");\n    }\n    assert(x@.len() == 11);\n    let val = x.get_char(0);\n    assert('h' === val);\n}\n// ANCHOR_END: initial\n\n// ANCHOR: literal_eq\nfn literal_eq() {\n    let x = \"hello world\";\n    let y = \"hello world\";\n    assert(x@ == y@);\n}\n// ANCHOR_END: literal_eq\n//\n// ANCHOR: literal_view\nfn str_view() {\n    let x = \"hello world\";\n    let ghost y: Seq<char> = x@;\n}\n// ANCHOR_END: literal_view\n\n// ANCHOR: pre_substring\nfn subrange<'a>(s: &str)\n    requires s@ =~= \"Hello\"@,\n{\n    proof {\n        reveal_strlit(\"Hello\");\n        reveal_strlit(\"H\");\n    }\n    assert(s@.subrange(0, 1) =~= \"H\"@);\n}\n// ANCHOR_END: pre_substring\n\n// ANCHOR: substring_ascii\nfn test() {\n    let a = String::from_str((\"ABC\"));\n    proof {\n        reveal_strlit(\"ABC\");\n    }\n    assert(a.is_ascii());\n    let b = a.as_str().substring_ascii(2, 3);\n    proof {\n        reveal_strlit(\"C\");\n    }\n    assert(b@ =~= (\"C\")@);\n}\n// ANCHOR_END: substring_ascii\n\n} // verus!", "full_verified_code": "// rust_verify/tests/example.rs\nuse vstd::prelude::*;\n\nverus! {\n\n// ANCHOR: initial\nfn get_char() {\n    let x = \"hello world\";\n    proof {\n        reveal_strlit(\"hello world\");\n    }\n    assert(x@.len() == 11);\n    let val = x.get_char(0);\n    assert('h' === val);\n}\n// ANCHOR_END: initial\n\n// ANCHOR: literal_eq\nfn literal_eq() {\n    let x = \"hello world\";\n    let y = \"hello world\";\n    assert(x@ == y@);\n}\n// ANCHOR_END: literal_eq\n//\n// ANCHOR: literal_view\nfn str_view() {\n    let x = \"hello world\";\n    let ghost y: Seq<char> = x@;\n}\n// ANCHOR_END: literal_view\n\n// ANCHOR: pre_substring\nfn subrange<'a>(s: &str)\n    requires s@ =~= \"Hello\"@,\n{\n    proof {\n        reveal_strlit(\"Hello\");\n        reveal_strlit(\"H\");\n    }\n    assert(s@.subrange(0, 1) =~= \"H\"@);\n}\n// ANCHOR_END: pre_substring\n\n// ANCHOR: substring_ascii\nfn test() {\n    let a = String::from_str((\"ABC\"));\n    proof {\n        reveal_strlit(\"ABC\");\n    }\n    assert(a.is_ascii());\n    let b = a.as_str().substring_ascii(2, 3);\n    proof {\n        reveal_strlit(\"C\");\n    }\n    assert(b@ =~= (\"C\")@);\n}\n// ANCHOR_END: substring_ascii\n\n} // verus!", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/strings.rs", "verified": true, "metadata": {"original_id": "verus_strings_a9ecfdea6bcc", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_b_f7de326d8817", "task": "task_b", "input_text": "fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >)\nensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/array_copy_impl.rs", "verified": true, "metadata": {"original_id": "f7de326d8817", "function_name": "array_copy", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_09faa3d174a3", "task": "task_b", "input_text": "fn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize)\nrequires true \nensures 0 <= n <= a . len () ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high invariant 0 <= low <= high <= a . len () , decreases high - low , { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high invariant 0 <= low <= high <= a . len () , decreases high - low , { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "09faa3d174a3", "function_name": "binary_search", "has_invariants": true, "has_asserts": false}}
{"id": "task_a_c5475d6423de", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ninvariant forall | j : int | 0 <= j < i ==> number > arr [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_433_impl.rs", "verified": true, "metadata": {"original_id": "c5475d6423de", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_c_missing_ensures_42262fbd4b9c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,) requires nums . len () == old (used) . len () ,  { }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,) requires nums . len () == old (used) . len () , ensures used . len () == old (used) . len () , { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,) requires nums . len () == old (used) . len () , ensures used . len () == old (used) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/interprocedural/AlgorithmsRust/permutations_iter_0_original.rs", "verified": true, "metadata": {"original_id": "42262fbd4b9c", "function_name": "backtrack", "bug_type": "missing_ensures"}}
{"id": "task_b_2745f0d713b9", "task": "task_b", "input_text": "fn abs_diff (a : i32 , b : i32) -> (result : i32)\nrequires a >= - 1000000 && a <= 1000000 , b >= - 1000000 && b <= 1000000 \nensures result >= 0 ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs_diff (a : i32 , b : i32) -> (result : i32) requires a >= - 1000000 && a <= 1000000 , b >= - 1000000 && b <= 1000000 , ensures result >= 0 , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs_diff (a : i32 , b : i32) -> (result : i32) requires a >= - 1000000 && a <= 1000000 , b >= - 1000000 && b <= 1000000 , ensures result >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_63/verina_basic_63_iter_0_original.rs", "verified": true, "metadata": {"original_id": "2745f0d713b9", "function_name": "abs_diff", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_invariant_db82da583b3b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn xor_strings (a : Vec < char > , b : Vec < char >) -> (result : Vec < char >) requires a . len () == b . len () , forall | i : int | 0 <= i && i < a . len () ==> (a [i] == '0' || a [i] == '1') , forall | i : int | 0 <= i && i < b . len () ==> (b [i] == '0' || b [i] == '1') ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == (if a [i] == b [i] { '0' } else { '1' }) { let mut result : Vec < char > = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { '0' } else { '1' }) decreases a . len () - i { let bit = if a [i] == b [i] { '0' } else { '1' } ; result . push (bit) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn xor_strings (a : Vec < char > , b : Vec < char >) -> (result : Vec < char >) requires a . len () == b . len () , forall | i : int | 0 <= i && i < a . len () ==> (a [i] == '0' || a [i] == '1') , forall | i : int | 0 <= i && i < b . len () ==> (b [i] == '0' || b [i] == '1') ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == (if a [i] == b [i] { '0' } else { '1' }) { let mut result : Vec < char > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == (if a [j] == b [j] { '0' } else { '1' }) decreases a . len () - i { let bit = if a [i] == b [i] { '0' } else { '1' } ; result . push (bit) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn xor_strings (a : Vec < char > , b : Vec < char >) -> (result : Vec < char >) requires a . len () == b . len () , forall | i : int | 0 <= i && i < a . len () ==> (a [i] == '0' || a [i] == '1') , forall | i : int | 0 <= i && i < b . len () ==> (b [i] == '0' || b [i] == '1') ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == (if a [i] == b [i] { '0' } else { '1' }) { let mut result : Vec < char > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == (if a [j] == b [j] { '0' } else { '1' }) decreases a . len () - i { let bit = if a [i] == b [i] { '0' } else { '1' } ; result . push (bit) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/string_xor_impl.rs", "verified": true, "metadata": {"original_id": "db82da583b3b", "function_name": "xor_strings", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_553a4b7e9bf1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32)  { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/replace_iter_2_current.rs", "verified": true, "metadata": {"original_id": "553a4b7e9bf1", "function_name": "replace", "bug_type": "missing_ensures"}}
{"id": "task_a_8f26ff6b2328", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32)   { let mut i = 0 ; while i < N  { i = i + 1 ; } i }\n\n} // verus!", "target_text": "requires 0 <= N \nensures i == N \ndecreases N - i \ninvariant 0 <= i <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "8f26ff6b2328", "function_name": "up_while_less", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_54831fba50a1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len ()  { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires a . len () <= 100 && b . len () <= 100 \nensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] \ndecreases a . len () - i , b . len () - j \ninvariant 0 <= i <= a . len () , result . len () == i , forall | j : int | (0 <= j && j < i) ==> result [j] == a [j] , 0 <= j <= b . len () , result . len () == a . len () + j , forall | k : int | (0 <= k && k < a . len ()) ==> result [k] == a [k] , forall | k : int | (a . len () <= k && k < result . len ()) ==> result [k] == b [k - a . len ()] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >) requires a . len () <= 100 && b . len () <= 100 , ensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | (0 <= j && j < i) ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant 0 <= j <= b . len () , result . len () == a . len () + j , forall | k : int | (0 <= k && k < a . len ()) ==> result [k] == a [k] , forall | k : int | (a . len () <= k && k < result . len ()) ==> result [k] == b [k - a . len ()] , decreases b . len () - j , { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/unverified/array_concat_strong_impl.rs", "verified": true, "metadata": {"original_id": "54831fba50a1", "function_name": "concat", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_b_555370735660", "task": "task_b", "input_text": "fn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize)\nrequires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () \nensures result as nat == spec_nat_abs_diff (x , y), result <= d , result <= d , decreases a . len () + b . len () - m - n", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize) requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , ensures result <= d , decreases a . len () + b . len () - m - n { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize) requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , ensures result <= d , decreases a . len () + b . len () - m - n { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_54/verina_basic_54_impl.rs", "verified": true, "metadata": {"original_id": "555370735660", "function_name": "canyon_search_aux", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_decreases_a33d41e9a24e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/barrier_iter_3_current.rs", "verified": true, "metadata": {"original_id": "a33d41e9a24e", "function_name": "barrier", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_43c70428af29", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >) requires swap_precond (arr @ , i , j) ,  { let mut result = arr ; let temp = result [i as usize] ; result . set (i as usize , result [j as usize]) ; result . set (j as usize , temp) ; result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >) requires swap_precond (arr @ , i , j) , ensures swap_postcond (arr @ , i , j , result @) , { let mut result = arr ; let temp = result [i as usize] ; result . set (i as usize , result [j as usize]) ; result . set (j as usize , temp) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >) requires swap_precond (arr @ , i , j) , ensures swap_postcond (arr @ , i , j , result @) , { let mut result = arr ; let temp = result [i as usize] ; result . set (i as usize , result [j as usize]) ; result . set (j as usize , temp) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_95/verina_basic_95_iter_2_current.rs", "verified": true, "metadata": {"original_id": "43c70428af29", "function_name": "swap", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_49dcd78eab5e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >) requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p ,  { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos invariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , decreases at_pos - i { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p invariant j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , decreases p - j { result . push (nl [j]) ; j += 1 ; } let mut k = at_pos ; while k < l invariant at_pos <= k <= l , result . len () == at_pos + p + (k - at_pos) , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k - at_pos ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] , decreases l - k { result . push (oline [k]) ; k += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >) requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p , ensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) , { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos invariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , decreases at_pos - i { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p invariant j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , decreases p - j { result . push (nl [j]) ; j += 1 ; } let mut k = at_pos ; while k < l invariant at_pos <= k <= l , result . len () == at_pos + p + (k - at_pos) , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k - at_pos ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] , decreases l - k { result . push (oline [k]) ; k += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn insert_postcond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat , result : Seq < char >) -> bool { result . len () == l + p && (forall | i : int | 0 <= i < p ==> # [trigger] result [at_pos + i] == nl [i]) && (forall | i : int | 0 <= i < at_pos ==> # [trigger] result [i] == oline [i]) && (forall | i : int | 0 <= i < l - at_pos ==> # [trigger] result [at_pos + p + i] == oline [at_pos + i]) }\nspec fn insert_precond (oline : Seq < char > , l : nat , nl : Seq < char > , p : nat , at_pos : nat) -> bool { l <= oline . len () && p <= nl . len () && at_pos <= l }\n# [verifier :: loop_isolation (false)] fn insert (oline : & Vec < char > , l : usize , nl : & Vec < char > , p : usize , at_pos : usize) -> (result : Vec < char >) requires insert_precond (oline @ , l as nat , nl @ , p as nat , at_pos as nat) , l <= MAX - p , ensures insert_postcond (oline @ , l as nat , nl @ , p as nat , at_pos as nat , result @) , { let mut result = Vec :: with_capacity (l + p) ; let mut i = 0 ; while i < at_pos invariant i <= at_pos , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result @ [j] == oline @ [j] , decreases at_pos - i { result . push (oline [i]) ; i += 1 ; } let mut j = 0 ; while j < p invariant j <= p , result . len () == at_pos + j , forall | k : int | 0 <= k < at_pos ==> # [trigger] result @ [k] == oline @ [k] , forall | k : int | 0 <= k < j ==> # [trigger] result @ [at_pos + k] == nl @ [k] , decreases p - j { result . push (nl [j]) ; j += 1 ; } let mut k = at_pos ; while k < l invariant at_pos <= k <= l , result . len () == at_pos + p + (k - at_pos) , forall | m : int | 0 <= m < at_pos ==> # [trigger] result @ [m] == oline @ [m] , forall | m : int | 0 <= m < p ==> # [trigger] result @ [at_pos + m] == nl @ [m] , forall | m : int | 0 <= m < k - at_pos ==> # [trigger] result @ [at_pos + p + m] == oline @ [at_pos + m] , decreases l - k { result . push (oline [k]) ; k += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_64/verina_basic_64_impl.rs", "verified": true, "metadata": {"original_id": "49dcd78eab5e", "function_name": "insert", "bug_type": "missing_ensures"}}
{"id": "task_a_f4cde1453d44", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_75/verina_basic_75_iter_1_current.rs", "verified": true, "metadata": {"original_id": "f4cde1453d44", "function_name": "find_min_loop", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_c_missing_decreases_7df986bba7c9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_prime_check (n : u32 , i : u32 , fuel : u32) -> (result : bool) requires n >= 2 , n <= 0xFFFF , i >= 2 , fuel <= n , { return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_prime_check (n : u32 , i : u32 , fuel : u32) -> (result : bool) requires n >= 2 , n <= 0xFFFF , i >= 2 , fuel <= n , decreases fuel , { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_prime_check (n : u32 , i : u32 , fuel : u32) -> (result : bool) requires n >= 2 , n <= 0xFFFF , i >= 2 , fuel <= n , decreases fuel , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_28/verina_basic_28_iter_0_original.rs", "verified": true, "metadata": {"original_id": "7df986bba7c9", "function_name": "is_prime_check", "bug_type": "missing_decreases"}}
{"id": "task_b_385ba17c20ec", "task": "task_b", "input_text": "fn seq_to_vec (Ghost (s)\nensures result . deep_view () == s", "target_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] # [cfg (verus_keep_ghost)] exec fn seq_to_vec (Ghost (s) : Ghost < Seq < Seq < bool > > >) -> (result : Vec < Vec < bool > >) ensures result . deep_view () == s { arbitrary () }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] # [cfg (verus_keep_ghost)] exec fn seq_to_vec (Ghost (s) : Ghost < Seq < Seq < bool > > >) -> (result : Vec < Vec < bool > >) ensures result . deep_view () == s { arbitrary () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "capybarakv_inlined.rs", "verified": true, "metadata": {"original_id": "385ba17c20ec", "function_name": "seq_to_vec", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_requires_bb646573475a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >)  ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut c = v . clone () ; c . push (elem) ; c }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut c = v . clone () ; c . push (elem) ; c }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut c = v . clone () ; c . push (elem) ; c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/array_append_strong_impl.rs", "verified": true, "metadata": {"original_id": "bb646573475a", "function_name": "append", "bug_type": "missing_requires"}}
{"id": "task_b_e6a4215bddf9", "task": "task_b", "input_text": "fn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >)\nrequires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX \nensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant idx <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == idx * 3 , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant idx <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == idx * 3 , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_578_impl.rs", "verified": true, "metadata": {"original_id": "e6a4215bddf9", "function_name": "interleave", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_7173535ee445", "task": "task_b", "input_text": "fn is_product_even (arr : & Vec < u32 >) -> (result : bool)\nensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) , { if arr [i] % 2 == 0 { proof { assert (is_even (arr [i as int])) ; assert (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) ; } return true ; } } proof { assert (forall | k : int | 0 <= k < arr . len () ==> ! is_even (arr [k])) ; assert (! (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k]))) ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) , { if arr [i] % 2 == 0 { proof { assert (is_even (arr [i as int])) ; assert (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) ; } return true ; } } proof { assert (forall | k : int | 0 <= k < arr . len () ==> ! is_even (arr [k])) ; assert (! (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k]))) ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "7173535ee445", "function_name": "is_product_even", "has_invariants": true, "has_asserts": true}}
{"id": "task_a_39c433ef84d5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)   { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize)   { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "target_text": "requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , binary_search_precond (a @ , key) \nensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo\ndecreases hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize) requires binary_search_precond (a @ , key) , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_51/verina_basic_51_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "39c433ef84d5", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_45948c0dcced", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_elements_iter_1_current.rs", "verified": true, "metadata": {"original_id": "45948c0dcced", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_b_3815f6d0de6e", "task": "task_b", "input_text": "pub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)\nrequires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 3 * N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s3if_impl.rs", "verified": true, "metadata": {"original_id": "3815f6d0de6e", "function_name": "myfun", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_43adf6cc9347", "task": "task_b", "input_text": "fn reverse (a : & [i32]) -> (result : Vec < i32 >)\nensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut i = a . len () ; while i > 0 invariant result . len () == a . len () - i , forall | j : int | 0 <= j && j < result . len () ==> result [j] == a [a . len () - 1 - j] , decreases i { i = i - 1 ; result . push (a [i]) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut i = a . len () ; while i > 0 invariant result . len () == a . len () - i , forall | j : int | 0 <= j && j < result . len () ==> result [j] == a [a . len () - 1 - j] , decreases i { i = i - 1 ; result . push (a [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/reverse_impl.rs", "verified": true, "metadata": {"original_id": "43adf6cc9347", "function_name": "reverse", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_11e4c10a27d3", "task": "task_b", "input_text": "fn last_digit (n : u32) -> (result : u32)\nrequires last_digit_precond (n as nat) \nensures 0 <= result < 10 , result == last_digit_spec (n as nat) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32) requires last_digit_precond (n as nat) , ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32) requires last_digit_precond (n as nat) , ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_11/verina_basic_11_iter_1_current.rs", "verified": true, "metadata": {"original_id": "11e4c10a27d3", "function_name": "last_digit", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_c9dce987a094", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 ,  { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/invariants_removed/is_non_prime_iter_3_current.rs", "verified": true, "metadata": {"original_id": "c9dce987a094", "function_name": "is_non_prime", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_11233d03a03e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn mul_div_lemma (x : int) ensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3 { }\nfn triple (x : i32) -> (result : i32)  ensures triple_postcond (x as int , result as int) { proof { mul_div_lemma (x as int) ; } x * 3 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn mul_div_lemma (x : int) ensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3 { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 700000000 <= x <= 700000000 ensures triple_postcond (x as int , result as int) { proof { mul_div_lemma (x as int) ; } x * 3 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn mul_div_lemma (x : int) ensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3 { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 700000000 <= x <= 700000000 ensures triple_postcond (x as int , result as int) { proof { mul_div_lemma (x as int) ; } x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_98/verina_basic_98_impl.rs", "verified": true, "metadata": {"original_id": "11233d03a03e", "function_name": "triple", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_896a3b8e6bc9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] ,  { let mut left : usize = 0 ; let mut right : usize = v . len () ; while left < right invariant left <= right <= v . len () , exists | i : int | left <= i < right && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases right - left , { let mid = left + (right - left) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { left = mid + 1 ; } else { right = mid ; } } proof { assert (left == right) ; assert (exists | i : int | left <= i < right && k == v [i]) ; assert (left <= left < right) ; assert (false) ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut left : usize = 0 ; let mut right : usize = v . len () ; while left < right invariant left <= right <= v . len () , exists | i : int | left <= i < right && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases right - left , { let mid = left + (right - left) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { left = mid + 1 ; } else { right = mid ; } } proof { assert (left == right) ; assert (exists | i : int | left <= i < right && k == v [i]) ; assert (left <= left < right) ; assert (false) ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut left : usize = 0 ; let mut right : usize = v . len () ; while left < right invariant left <= right <= v . len () , exists | i : int | left <= i < right && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases right - left , { let mid = left + (right - left) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { left = mid + 1 ; } else { right = mid ; } } proof { assert (left == right) ; assert (exists | i : int | left <= i < right && k == v [i]) ; assert (left <= left < right) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/binary_search_iter_2_current.rs", "verified": true, "metadata": {"original_id": "896a3b8e6bc9", "function_name": "binary_search", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_eec342cc46a7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len ()  { if arr [i] == key { return true ; } i += 1 ; } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < list1 . len ()  { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , decreases list1 . len () - i { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , decreases list1 . len () - i { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "eec342cc46a7", "function_name": "shared_elements", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_d917e3667e09", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len ()  { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant idx <= s1 @ . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == idx * 3 , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 @ . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant idx <= s1 @ . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == idx * 3 , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 @ . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_578_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d917e3667e09", "function_name": "interleave", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_d2b21a9d851b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 ,  { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/verified/res2o_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "d2b21a9d851b", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_b_0d26dfca2cb9", "task": "task_b", "input_text": "fn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)\nensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_251_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "0d26dfca2cb9", "function_name": "insert_before_each", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_invariant_ec65c331810f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len ()  { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_433_impl.rs", "verified": true, "metadata": {"original_id": "ec65c331810f", "function_name": "is_greater", "bug_type": "missing_invariant"}}
{"id": "task_a_7fec2997bd0b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = n ; while i > 0  { i = i - 1 ;    result . push (list [i]) ; } let mut j = n ; while j < list . len ()  { result . push (list [j]) ; j = j + 1 ; } result }\n\n} // verus!", "target_text": "requires list @ . len () > 0 , 0 < n < list @ . len () \nensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) \ndecreases i , list . len () - j \ninvariant i <= n , n < list @ . len () , result @ . len () == (n - i) as int , result @ == list @ . subrange (i as int , n as int) . reverse () , n <= j <= list . len () , result @ . len () == (n + (j - n)) as int , result @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) , { let mut result = Vec :: new () ; let mut i = n ; while i > 0 invariant i <= n , n < list @ . len () , result @ . len () == (n - i) as int , result @ == list @ . subrange (i as int , n as int) . reverse () , decreases i , { i = i - 1 ; assert (i < n) ; assert (n < list @ . len ()) ; assert (i < list @ . len ()) ; result . push (list [i]) ; } let mut j = n ; while j < list . len () invariant n <= j <= list . len () , result @ . len () == (n + (j - n)) as int , result @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , j as int)) , decreases list . len () - j , { result . push (list [j]) ; j = j + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_644_impl.rs", "verified": true, "metadata": {"original_id": "7fec2997bd0b", "function_name": "reverse_to_k", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_requires_9785a44c8e1b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)  ensures odd_index < v . len () { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/choose_odd_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9785a44c8e1b", "function_name": "choose_odd", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_verus_references_6ea52b24da6a", "task": "task_c", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n// ANCHOR: immut\nfn immutable_references_example() {\n    let x: u32 = 0;\n    let y: u32 = 0;\n\n    let immut_ref_x = &x;\n    let immut_ref_y = &y;\n\n    assert(x == 0);\n    assert(*immut_ref_x == 0);\n\n    // These point to different stack variables, but they compare equal.\n    assert(immut_ref_x == immut_ref_y);\n}\n// ANCHOR_END: immut\n\n// ANCHOR: mut\nfn modify_y(a: &mut u32)\n    ensures *a == 2\n{\n    *a = 2;\n}\n\nfn mutable_example()\n{\n    let mut y: u32 = 1;\n    assert(y == 1);\n    modify_y(&mut y);\n    assert(y == 2);\n}\n// ANCHOR_END: mut\n\n// ANCHOR: requires\nfn increment(a: &mut u32)\n    requires *old(a) < u32::MAX,\n    ensures *a == *old(a) + 1,\n{\n    *a = *a + 1;\n}\n\nfn caller()\n{\n    let mut z: u32 = 0;\n    increment(&mut z);\n    assert(z == 1);\n}\n// ANCHOR_END: requires\n\n// ANCHOR: asserts\nfn check_and_assert(a: &mut u32)\n    requires *old(a) == 0\n{\n    assert(*old(a) == 0);\n    *a = *a + 1;\n    assert(*a == 1);\n    *a = *a + 1;\n    assert(*a == 2);\n    assert(*old(a) == 0);\n}\n\nfn asserts()\n{\n    let mut x: u32 = 0;\n    check_and_assert(&mut x);\n}\n// ANCHOR_END: asserts\n\n// ANCHOR: complex\nfn decrease(b: &mut u32)\n    requires\n        *old(b) == 10,\n    ensures\n        *b == 0,\n{\n    let mut i: u32 = 0;\n    while (*b > 0)\n\n    {\n        *b = *b - 1;\n        i = i + 1;\n        assert(*b == (10 - i));\n    }\n    assert(*b == 0);\n    assert(*old(b) == 10);\n}\n\nfn complex_example()\n{\n    let mut d: u32 = 10;\n    decrease(&mut d);\n    assert(d == 0);\n}\n// ANCHOR_END: complex\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n\n// ANCHOR: immut\nfn immutable_references_example() {\n    let x: u32 = 0;\n    let y: u32 = 0;\n\n    let immut_ref_x = &x;\n    let immut_ref_y = &y;\n\n    assert(x == 0);\n    assert(*immut_ref_x == 0);\n\n    // These point to different stack variables, but they compare equal.\n    assert(immut_ref_x == immut_ref_y);\n}\n// ANCHOR_END: immut\n\n// ANCHOR: mut\nfn modify_y(a: &mut u32)\n    ensures *a == 2\n{\n    *a = 2;\n}\n\nfn mutable_example()\n{\n    let mut y: u32 = 1;\n    assert(y == 1);\n    modify_y(&mut y);\n    assert(y == 2);\n}\n// ANCHOR_END: mut\n\n// ANCHOR: requires\nfn increment(a: &mut u32)\n    requires *old(a) < u32::MAX,\n    ensures *a == *old(a) + 1,\n{\n    *a = *a + 1;\n}\n\nfn caller()\n{\n    let mut z: u32 = 0;\n    increment(&mut z);\n    assert(z == 1);\n}\n// ANCHOR_END: requires\n\n// ANCHOR: asserts\nfn check_and_assert(a: &mut u32)\n    requires *old(a) == 0\n{\n    assert(*old(a) == 0);\n    *a = *a + 1;\n    assert(*a == 1);\n    *a = *a + 1;\n    assert(*a == 2);\n    assert(*old(a) == 0);\n}\n\nfn asserts() \n{\n    let mut x: u32 = 0;\n    check_and_assert(&mut x);\n}\n// ANCHOR_END: asserts\n\n// ANCHOR: complex\nfn decrease(b: &mut u32)\n    requires\n        *old(b) == 10,\n    ensures\n        *b == 0,\n{\n    let mut i: u32 = 0;\n    while (*b > 0) \n        invariant\n            *b == (10 - i),\n        decreases *b,\n    {\n        *b = *b - 1;\n        i = i + 1;\n        assert(*b == (10 - i));\n    }\n    assert(*b == 0);\n    assert(*old(b) == 10);\n}\n\nfn complex_example()\n{\n    let mut d: u32 = 10;\n    decrease(&mut d);\n    assert(d == 0);\n}\n// ANCHOR_END: complex\n\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::prelude::*;\n\nverus! {\n\n\n// ANCHOR: immut\nfn immutable_references_example() {\n    let x: u32 = 0;\n    let y: u32 = 0;\n\n    let immut_ref_x = &x;\n    let immut_ref_y = &y;\n\n    assert(x == 0);\n    assert(*immut_ref_x == 0);\n\n    // These point to different stack variables, but they compare equal.\n    assert(immut_ref_x == immut_ref_y);\n}\n// ANCHOR_END: immut\n\n// ANCHOR: mut\nfn modify_y(a: &mut u32)\n    ensures *a == 2\n{\n    *a = 2;\n}\n\nfn mutable_example()\n{\n    let mut y: u32 = 1;\n    assert(y == 1);\n    modify_y(&mut y);\n    assert(y == 2);\n}\n// ANCHOR_END: mut\n\n// ANCHOR: requires\nfn increment(a: &mut u32)\n    requires *old(a) < u32::MAX,\n    ensures *a == *old(a) + 1,\n{\n    *a = *a + 1;\n}\n\nfn caller()\n{\n    let mut z: u32 = 0;\n    increment(&mut z);\n    assert(z == 1);\n}\n// ANCHOR_END: requires\n\n// ANCHOR: asserts\nfn check_and_assert(a: &mut u32)\n    requires *old(a) == 0\n{\n    assert(*old(a) == 0);\n    *a = *a + 1;\n    assert(*a == 1);\n    *a = *a + 1;\n    assert(*a == 2);\n    assert(*old(a) == 0);\n}\n\nfn asserts() \n{\n    let mut x: u32 = 0;\n    check_and_assert(&mut x);\n}\n// ANCHOR_END: asserts\n\n// ANCHOR: complex\nfn decrease(b: &mut u32)\n    requires\n        *old(b) == 10,\n    ensures\n        *b == 0,\n{\n    let mut i: u32 = 0;\n    while (*b > 0) \n        invariant\n            *b == (10 - i),\n        decreases *b,\n    {\n        *b = *b - 1;\n        i = i + 1;\n        assert(*b == (10 - i));\n    }\n    assert(*b == 0);\n    assert(*old(b) == 10);\n}\n\nfn complex_example()\n{\n    let mut d: u32 = 10;\n    decrease(&mut d);\n    assert(d == 0);\n}\n// ANCHOR_END: complex\n\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/references.rs", "verified": true, "metadata": {"original_id": "verus_references_6ea52b24da6a", "function_name": "", "bug_type": "missing_invariant"}}
{"id": "task_b_69c92090d0b3", "task": "task_b", "input_text": "fn main_method (x_init : u32 , y : u32) -> (z : u32)\nrequires (x_init as int) * (y as int) <= MAX as int \nensures z == 0", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "69c92090d0b3", "function_name": "main_method", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_requires_9a7e15a407f2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32)  ensures r as int == 3 * (x as int) { let doubled = x + x ; doubled + x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { let doubled = x + x ; doubled + x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { let doubled = x + x ; doubled + x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9a7e15a407f2", "function_name": "triple_over", "bug_type": "missing_requires"}}
{"id": "task_b_d5eae418e192", "task": "task_b", "input_text": "fn digit_to_letters_exec (c : char) -> (result : Vec < char >)\nensures result @ == digit_to_letters (c)", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_26/verina_advanced_26_iter_5_current.rs", "verified": true, "metadata": {"original_id": "d5eae418e192", "function_name": "digit_to_letters_exec", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_requires_816a9baf89c3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize)  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize) requires old (v) . len () > 0 { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn separate (v : & mut Vec < i32 >) -> (result : usize) requires old (v) . len () > 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSeparate/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "816a9baf89c3", "function_name": "separate", "bug_type": "missing_requires"}}
{"id": "task_b_ac7d8f2e369b", "task": "task_b", "input_text": "fn containsSubString (a : & [char] , b : & [char]) -> (pos : isize)\nrequires b . len () <= a . len () \nensures true ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn containsSubString (a : & [char] , b : & [char]) -> (pos : isize) requires b . len () <= a . len () , ensures true , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn containsSubString (a : & [char] , b : & [char]) -> (pos : isize) requires b . len () <= a . len () , ensures true , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_searchSort/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "ac7d8f2e369b", "function_name": "containsSubString", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_53f6e2e66b6e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 ,  { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 4 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 4 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/ms5_impl.rs", "verified": true, "metadata": {"original_id": "53f6e2e66b6e", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_a1ca01cbe16a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () ,  { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_52/verina_basic_52_iter_3_current.rs", "verified": true, "metadata": {"original_id": "a1ca01cbe16a", "function_name": "swap", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_e6b58a67275b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i as int] > arr2 [i as int] , decreases arr1 . len () - idx , {    if arr1 [idx] <= arr2 [idx] {   return false ; } idx += 1 ; }  true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i as int] > arr2 [i as int] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { assert (! (arr1 [idx as int] > arr2 [idx as int])) ; assert (exists | i : int | 0 <= i < arr1 . len () && ! (arr1 [i] > arr2 [i])) ; return false ; } idx += 1 ; } assert (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) ; true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i as int] > arr2 [i as int] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { assert (! (arr1 [idx as int] > arr2 [idx as int])) ; assert (exists | i : int | 0 <= i < arr1 . len () && ! (arr1 [i] > arr2 [i])) ; return false ; } idx += 1 ; } assert (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_809_impl.rs", "verified": true, "metadata": {"original_id": "e6b58a67275b", "function_name": "is_smaller", "bug_type": "missing_assert"}}
{"id": "task_c_missing_invariant_ac591ad72f9a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len ()  { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "ac591ad72f9a", "function_name": "is_integer", "bug_type": "missing_invariant"}}
{"id": "task_b_ba3b88d6691c", "task": "task_b", "input_text": "fn abs (i : i32) -> (res : i32)\nrequires i != MIN \nensures i < 0 ==> res == - i , i >= 0 ==> res == i", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/has_close_elements_impl.rs", "verified": true, "metadata": {"original_id": "ba3b88d6691c", "function_name": "abs", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_17101b6af3eb", "task": "task_b", "input_text": "fn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >)\nrequires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN\nensures update_elements_postcond (& a , & result)", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >) requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN ensures update_elements_postcond (& a , & result) { let mut result = a ; result . set (4 , result [4] + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >) requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN ensures update_elements_postcond (& a , & result) { let mut result = a ; result . set (4 , result [4] + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_103/verina_basic_103_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "17101b6af3eb", "function_name": "update_elements", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_ef181f52950f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isSublist_precond (sub : Seq < i32 > , main : Seq < i32 >) -> bool { true }\nfn main () { }\nfn isSublist (sub : Vec < i32 > , main : Vec < i32 >) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires isSublist_precond (sub @ , main @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn isSublist_precond (sub : Seq < i32 > , main : Seq < i32 >) -> bool { true }\nfn main () { }\nfn isSublist (sub : Vec < i32 > , main : Vec < i32 >) -> (result : bool) requires isSublist_precond (sub @ , main @) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_21/verina_basic_21.rs", "verified": true, "metadata": {"original_id": "ef181f52950f", "function_name": "isSublist", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_invariant_0c10f306fe6d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_424_iter_2_current.rs", "verified": true, "metadata": {"original_id": "0c10f306fe6d", "function_name": "extract_rear_chars", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_f39ac4f002ec", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { for i in 0 .. arr . len ()  { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2)) , { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2)) , { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_790_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "f39ac4f002ec", "function_name": "is_even_at_even_index", "bug_type": "missing_invariant"}}
{"id": "task_a_vostd_seq_extra_344700480285", "task": "task_a", "input_text": "use vstd::prelude::*;\nuse vstd::seq::*;\n\nverus! {\n\n#[verifier::external_body]\npub proof fn seq_tracked_new<T>(len: nat, f: impl Fn(int) -> T) -> (tracked res: Seq<T>)\n\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn seq_tracked_update<T>(s: Seq<T>, idx: int, x: T) -> (tracked res: Seq<T>)\n\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn seq_tracked_add<T>(s1: Seq<T>, s2: Seq<T>) -> (tracked res: Seq<T>)\n\n{\n    unimplemented!();\n}\n\npub proof fn lemma_seq_add_head_back<T>(s: Seq<T>)\n\n{\n}\n\npub proof fn lemma_seq_push_head<T>(s: Seq<T>, hd: T)\n\n{\n}\n\npub proof fn lemma_seq_drop_pushed_head<T>(s: Seq<T>, hd: T)\n\n{\n}\n\npub proof fn lemma_seq_push_head_take_head<T>(s: Seq<T>, hd: T)\n\n{\n}\n\n} // verus!\nverus! {\n\n/// The result of pushing elemrnt 'needle' into the sequence 's' contains 'needle'.\npub proof fn lemma_push_contains_same<T>(s: Seq<T>, needle: T)\n\n{\n\n}\n\n/// If element 'needle' is different from 'new_elem', then whether the sequence 's' contains 'needle'\n/// after pushing 'new_elem' depends on whether 's' contains 'needle' before the push.\npub proof fn lemma_push_contains_different<T>(s: Seq<T>, new_elem: T, needle: T)\n\n{\n    if (s.contains(needle)) {\n        let i = choose|i: int| 0 <= i < s.len() && s[i] == needle;\n        axiom_seq_push_index_different(s, needle, i);\n\n    }\n}\n\n/// If the last element of the sequence 's' is different from 'needle', then whether the sequence\n/// 's' contains 'needle' after dropping the last element depends on whether 's' contains 'needle'\n/// before the drop.\npub proof fn lemma_drop_last_contains_different<T>(s: Seq<T>, needle: T)\n\n{\n    if (s.contains(needle)) {\n        let i = choose|i: int| 0 <= i < s.len() && s[i] == needle;\n\n    }\n}\n\n} // verus!\nverus! {\n\n/// Returns true if predicate `f(i,seq[i])` holds for all indices 'i'.\npub open spec fn forall_seq<T>(seq: Seq<T>, f: spec_fn(int, T) -> bool) -> bool {\n    forall|i| #![trigger seq[i]] 0 <= i < seq.len() ==> f(i, seq[i])\n}\n\npub broadcast group group_forall_seq_lemmas {\n    lemma_forall_seq_push,\n    lemma_seq_all_push,\n    lemma_forall_seq_drop_last,\n    lemma_seq_all_drop_last,\n    lemma_seq_all_add,\n    lemma_seq_all_index,\n}\n\n/// Index `i` of the sequence `s` satisfies `f(i,s[i])` if `forall_seq(s,f)` holds.\npub proof fn lemma_forall_seq_index<T>(s: Seq<T>, f: spec_fn(int, T) -> bool, i: int)\n\n{\n}\n\n/// Index `i` of the sequence `s` satisfies `f(s[i])` if `s.all(f)` holds.\n/// This proof is required due to the change of trigger by replacing the original `forall_seq_values` with `Seq::all`.\npub broadcast proof fn lemma_seq_all_index<T>(s: Seq<T>, f: spec_fn(T) -> bool, i: int)\n\n{\n}\n\n/// `forall_seq(s.push(v),f)` is equivalent to `forall_seq(s,f)` and `f(s.len(),v)`.\npub broadcast proof fn lemma_forall_seq_push<T>(s: Seq<T>, f: spec_fn(int, T) -> bool, v: T)\n\n{\n    if (forall_seq(s.push(v), f)) {\n        }\n}\n\n/// s.push(v).all(f)` is equivalent to `s.all(f)` and `f(v)`.\npub broadcast proof fn lemma_seq_all_push<T>(s: Seq<T>, f: spec_fn(T) -> bool, v: T)\n\n{\n    if (s.push(v).all(f)) {\n        }\n}\n\n/// `forall_seq(s,f)` is equivalent to `forall_seq(s.drop_last(),f)` and `f(s.len() as int - 1, s.last())`.\npub broadcast proof fn lemma_forall_seq_drop_last<T>(s: Seq<T>, f: spec_fn(int, T) -> bool)\n\n{\n\n}\n\n/// `s.all(f)` is equivalent to `s.drop_last().all(f)` and `f(s.last())`.\npub broadcast proof fn lemma_seq_all_drop_last<T>(s: Seq<T>, f: spec_fn(T) -> bool)\n\n{\n\n}\n\npub broadcast proof fn lemma_seq_all_add<T>(s1: Seq<T>, s2: Seq<T>, f: spec_fn(T) -> bool)\n\n    {\n    if s2.len() == 0 {\n\n    } else {\n        // Induction step: assume the lemma holds for s2.drop_last() and show that s2==s2.drop_last().push(s2.last()).\n        lemma_seq_all_add(s1, s2.drop_last(), f);\n        if s1.all(f) && s2.all(f) {\n\n        }\n        if (s1 + s2).all(f) {\n\n        }\n    }\n}\n\n/// If `source1` and `source2` are prefixes of `child`, then either `source1` is equal to `source2` or\n/// one of them is a prefix of the other.\npub proof fn lemma_prefix_of_common_sequence(source1: Seq<nat>, source2: Seq<nat>, child: Seq<nat>)\n\n{\n}\n\n} // verus!\n", "target_text": "requires 0 <= idx < s.len(), s.len() > 0, new_elem != needle, s.len() > 0,\n        s.last() != needle, forall_seq(s, f),\n        0 <= i < s.len(), 0 <= i < s.len(),\n        #[trigger] s.all(f), s.len() > 0, s.len() > 0, source1.is_prefix_of(child),\n        source2.is_prefix_of(child)\nensures res == Seq::<T>::new(len, f), res == s.update(idx, x), res == s1.add(s2), s =~= seq![s[0]].add(s.drop_first()), seq![hd].add(s) =~= s.reverse().push(hd).reverse(), seq![hd].add(s).drop_first() =~= s, seq![hd].add(s)[0] == hd, #[trigger] s.push(needle).contains(needle), #[trigger] s.push(new_elem).contains(needle) == s.contains(needle), #[trigger] s.drop_last().contains(needle) == s.contains(needle), f(i, s[i]), f(#[trigger] (s[i])), forall_seq(s, f) && f(s.len() as int, v) <==> #[trigger] forall_seq(s.push(v), f), #[trigger] s.push(v).all(f) <==> s.all(f) && f(v), forall_seq(s, f) <==> #[trigger] forall_seq(s.drop_last(), f) && f(\n            s.len() as int - 1,\n            s.last(),\n        ), s.all(f) <==> #[trigger] s.drop_last().all(f) && f(s.last()), s1.all(f) && s2.all(f) <==> #[trigger] (s1 + s2).all(f), source1 == source2 || source1.len() < source2.len() && source1.is_prefix_of(source2)\n            || source2.len() < source1.len() && source2.is_prefix_of(source1), s1.all(f) && s2.all(f) <==> #[trigger] (s1 + s2).all(f),\n    decreases s2.len(),\n// Induction proof on the length of s2\ndecreases s2.len(),\n// Induction proof on the length of s2", "full_verified_code": "use vstd::prelude::*;\nuse vstd::seq::*;\n\nverus! {\n\n#[verifier::external_body]\npub proof fn seq_tracked_new<T>(len: nat, f: impl Fn(int) -> T) -> (tracked res: Seq<T>)\n    ensures\n        res == Seq::<T>::new(len, f),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn seq_tracked_update<T>(s: Seq<T>, idx: int, x: T) -> (tracked res: Seq<T>)\n    requires\n        0 <= idx < s.len(),\n    ensures\n        res == s.update(idx, x),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn seq_tracked_add<T>(s1: Seq<T>, s2: Seq<T>) -> (tracked res: Seq<T>)\n    ensures\n        res == s1.add(s2),\n{\n    unimplemented!();\n}\n\npub proof fn lemma_seq_add_head_back<T>(s: Seq<T>)\n    requires\n        s.len() > 0,\n    ensures\n        s =~= seq![s[0]].add(s.drop_first()),\n{\n}\n\npub proof fn lemma_seq_push_head<T>(s: Seq<T>, hd: T)\n    ensures\n        seq![hd].add(s) =~= s.reverse().push(hd).reverse(),\n{\n}\n\npub proof fn lemma_seq_drop_pushed_head<T>(s: Seq<T>, hd: T)\n    ensures\n        seq![hd].add(s).drop_first() =~= s,\n{\n}\n\npub proof fn lemma_seq_push_head_take_head<T>(s: Seq<T>, hd: T)\n    ensures\n        seq![hd].add(s)[0] == hd,\n{\n}\n\n} // verus!\nverus! {\n\n/// The result of pushing elemrnt 'needle' into the sequence 's' contains 'needle'.\npub proof fn lemma_push_contains_same<T>(s: Seq<T>, needle: T)\n    ensures\n        #[trigger] s.push(needle).contains(needle),\n{\n    assert(s.push(needle).last() == needle);\n}\n\n/// If element 'needle' is different from 'new_elem', then whether the sequence 's' contains 'needle'\n/// after pushing 'new_elem' depends on whether 's' contains 'needle' before the push.\npub proof fn lemma_push_contains_different<T>(s: Seq<T>, new_elem: T, needle: T)\n    requires\n        new_elem != needle,\n    ensures\n        #[trigger] s.push(new_elem).contains(needle) == s.contains(needle),\n{\n    if (s.contains(needle)) {\n        let i = choose|i: int| 0 <= i < s.len() && s[i] == needle;\n        axiom_seq_push_index_different(s, needle, i);\n        assert(0 <= i < s.push(new_elem).len() && s.push(new_elem)[i] == needle);\n    }\n}\n\n/// If the last element of the sequence 's' is different from 'needle', then whether the sequence\n/// 's' contains 'needle' after dropping the last element depends on whether 's' contains 'needle'\n/// before the drop.\npub proof fn lemma_drop_last_contains_different<T>(s: Seq<T>, needle: T)\n    requires\n        s.len() > 0,\n        s.last() != needle,\n    ensures\n        #[trigger] s.drop_last().contains(needle) == s.contains(needle),\n{\n    if (s.contains(needle)) {\n        let i = choose|i: int| 0 <= i < s.len() && s[i] == needle;\n        assert(0 <= i < s.drop_last().len() && s.drop_last()[i] == needle);\n    }\n}\n\n} // verus!\nverus! {\n\n/// Returns true if predicate `f(i,seq[i])` holds for all indices 'i'.\npub open spec fn forall_seq<T>(seq: Seq<T>, f: spec_fn(int, T) -> bool) -> bool {\n    forall|i| #![trigger seq[i]] 0 <= i < seq.len() ==> f(i, seq[i])\n}\n\npub broadcast group group_forall_seq_lemmas {\n    lemma_forall_seq_push,\n    lemma_seq_all_push,\n    lemma_forall_seq_drop_last,\n    lemma_seq_all_drop_last,\n    lemma_seq_all_add,\n    lemma_seq_all_index,\n}\n\n/// Index `i` of the sequence `s` satisfies `f(i,s[i])` if `forall_seq(s,f)` holds.\npub proof fn lemma_forall_seq_index<T>(s: Seq<T>, f: spec_fn(int, T) -> bool, i: int)\n    requires\n        forall_seq(s, f),\n        0 <= i < s.len(),\n    ensures\n        f(i, s[i]),\n{\n}\n\n/// Index `i` of the sequence `s` satisfies `f(s[i])` if `s.all(f)` holds.\n/// This proof is required due to the change of trigger by replacing the original `forall_seq_values` with `Seq::all`.\npub broadcast proof fn lemma_seq_all_index<T>(s: Seq<T>, f: spec_fn(T) -> bool, i: int)\n    requires\n        0 <= i < s.len(),\n        #[trigger] s.all(f),\n    ensures\n        f(#[trigger] (s[i])),\n{\n}\n\n/// `forall_seq(s.push(v),f)` is equivalent to `forall_seq(s,f)` and `f(s.len(),v)`.\npub broadcast proof fn lemma_forall_seq_push<T>(s: Seq<T>, f: spec_fn(int, T) -> bool, v: T)\n    ensures\n        forall_seq(s, f) && f(s.len() as int, v) <==> #[trigger] forall_seq(s.push(v), f),\n{\n    if (forall_seq(s.push(v), f)) {\n        assert forall|i| 0 <= i < s.len() implies f(i, s[i]) by {\n            assert(s[i] === s.push(v)[i]);\n        }\n        assert(s.push(v)[s.len() as int] == v);\n    }\n}\n\n/// s.push(v).all(f)` is equivalent to `s.all(f)` and `f(v)`.\npub broadcast proof fn lemma_seq_all_push<T>(s: Seq<T>, f: spec_fn(T) -> bool, v: T)\n    ensures\n        #[trigger] s.push(v).all(f) <==> s.all(f) && f(v),\n{\n    if (s.push(v).all(f)) {\n        assert forall|i| 0 <= i < s.len() implies f(s[i]) by {\n            assert(s[i] === s.push(v)[i]);\n        }\n        assert(s.push(v)[s.len() as int] == v);\n    }\n}\n\n/// `forall_seq(s,f)` is equivalent to `forall_seq(s.drop_last(),f)` and `f(s.len() as int - 1, s.last())`.\npub broadcast proof fn lemma_forall_seq_drop_last<T>(s: Seq<T>, f: spec_fn(int, T) -> bool)\n    requires\n        s.len() > 0,\n    ensures\n        forall_seq(s, f) <==> #[trigger] forall_seq(s.drop_last(), f) && f(\n            s.len() as int - 1,\n            s.last(),\n        ),\n{\n    assert(s == s.drop_last().push(s.last()));\n}\n\n/// `s.all(f)` is equivalent to `s.drop_last().all(f)` and `f(s.last())`.\npub broadcast proof fn lemma_seq_all_drop_last<T>(s: Seq<T>, f: spec_fn(T) -> bool)\n    requires\n        s.len() > 0,\n    ensures\n        s.all(f) <==> #[trigger] s.drop_last().all(f) && f(s.last()),\n{\n    assert(s == s.drop_last().push(s.last()));\n}\n\npub broadcast proof fn lemma_seq_all_add<T>(s1: Seq<T>, s2: Seq<T>, f: spec_fn(T) -> bool)\n    ensures\n        s1.all(f) && s2.all(f) <==> #[trigger] (s1 + s2).all(f),\n    decreases s2.len(),\n// Induction proof on the length of s2\n\n{\n    if s2.len() == 0 {\n        assert(s1 + s2 == s1);\n    } else {\n        // Induction step: assume the lemma holds for s2.drop_last() and show that s2==s2.drop_last().push(s2.last()).\n        lemma_seq_all_add(s1, s2.drop_last(), f);\n        if s1.all(f) && s2.all(f) {\n            assert((s1 + s2).all(f));\n        }\n        if (s1 + s2).all(f) {\n            assert((s1 + s2).drop_last() == s1 + s2.drop_last());\n            assert(s2 == s2.drop_last().push(s2.last()));\n            assert((s1 + s2).last() == s2.last());\n        }\n    }\n}\n\n/// If `source1` and `source2` are prefixes of `child`, then either `source1` is equal to `source2` or\n/// one of them is a prefix of the other.\npub proof fn lemma_prefix_of_common_sequence(source1: Seq<nat>, source2: Seq<nat>, child: Seq<nat>)\n    requires\n        source1.is_prefix_of(child),\n        source2.is_prefix_of(child),\n    ensures\n        source1 == source2 || source1.len() < source2.len() && source1.is_prefix_of(source2)\n            || source2.len() < source1.len() && source2.is_prefix_of(source1),\n{\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/vstd_extra/src/seq_extra.rs", "verified": true, "metadata": {"original_id": "vostd_seq_extra_344700480285", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_c_missing_ensures_b4c39b7bd616", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , decreases arr . len () - i { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , decreases arr . len () - i { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , decreases arr . len () - i { result . push (elem) ; result . push (arr [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_251_impl.rs", "verified": true, "metadata": {"original_id": "b4c39b7bd616", "function_name": "insert_before_each", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_e2985cfa789b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] == 4 * N , { sum . set (0 , 4 * N) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , N <= MAX / 4 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , N <= MAX / 4 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/s32if_impl.rs", "verified": true, "metadata": {"original_id": "e2985cfa789b", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_b_37da678db317", "task": "task_b", "input_text": "fn abs (x : i32) -> (result : i32)\nrequires x != MIN \nensures result >= 0 , result == x || result == - x ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x < 0 { - x } else { x } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x < 0 { - x } else { x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/abs_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "37da678db317", "function_name": "abs", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_b85d5c2c824e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn F () -> (r : i32)  { 29 }\n\n} // verus!", "target_text": "ensures r == 29", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn F () -> (r : i32) ensures r == 29 { 29 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Ghost/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "b85d5c2c824e", "function_name": "F", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_verismo_subseq_500b64c32e59", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier(inline)]\npub open spec fn sub_element<T>(subs: Seq<T>, s: Seq<T>, idx: Seq<int>, k: int) -> bool {\n    &&& (0 <= #[trigger] idx[k] < s.len())\n    &&& (subs[k] === s[idx[k]])\n}\n\npub open spec fn is_subseq_via_index<T>(subs: Seq<T>, s: Seq<T>, idx: Seq<int>) -> bool {\n    &&& (forall|k: int| (0 <= k < idx.len()) ==> sub_element(subs, s, idx, k))\n    &&& subs.len() == idx.len()\n    &&& subs.len() <= s.len()\n}\n\npub proof fn proof_empty_is_subs<T>(s: Seq<T>)\n\n{\n}\n\npub proof fn proof_subs_remove<T>(s: Seq<T>, subs: Seq<T>, subs_idx: Seq<int>, i: int)\n    requires\n        is_subseq_via_index(subs, s, subs_idx),\n        0 <= i < subs_idx.len(),\n\n{\n    let (subs0, subs_idx0) = (subs, subs_idx);\n    let subs1 = subs0.remove(i);\n    let subs_idx1 = subs_idx0.remove(i);\n    assert forall|k: int| (0 <= k < subs_idx1.len()) implies sub_element(\n        subs1,\n        s,\n        subs_idx1,\n        k,\n    ) by {\n        assert(subs_idx1.len() == subs_idx0.len() - 1);\n        assert(0 <= k < subs_idx0.len());\n        assert(0 <= k < subs0.len());\n        assert(0 <= k < subs1.len());\n        if k < i {\n            assert(sub_element(subs0, s, subs_idx0, k));\n            assert(subs_idx0[k] == subs_idx1[k]);\n            assert(subs0[k] === subs1[k]);\n            assert(sub_element(subs1, s, subs_idx1, k));\n        } else {\n            assert(subs_idx0[k + 1] == subs_idx1[k]);\n            assert(subs0[k + 1] === subs1[k]);\n            assert(sub_element(subs0, s, subs_idx0, k + 1));\n            assert(sub_element(subs1, s, subs_idx1, k));\n        }\n    }\n    assert(subs1.len() == subs_idx1.len());\n    assert(subs1.len() <= s.len());\n}\n\npub proof fn proof_subs_push<T>(s: Seq<T>, subs: Seq<T>, subs_idx: Seq<int>, i: int)\n    requires\n        is_subseq_via_index(subs, s, subs_idx),\n        0 <= i < s.len(),\n        subs.len() < s.len(),\n\n{\n    let (subs0, subs_idx0) = (subs, subs_idx);\n    let subs1 = subs.push(s[i]);\n    let subs_idx1 = subs_idx.push(i);\n    assert(subs_idx1.len() == subs_idx0.len() + 1);\n    assert forall|k: int| (0 <= k < subs_idx1.len()) implies sub_element(\n        subs1,\n        s,\n        subs_idx1,\n        k,\n    ) by {\n        assert(subs_idx1.len() == subs_idx0.len() + 1);\n        if (0 <= k < subs_idx0.len()) {\n            assert(0 <= k < subs0.len());\n            assert(0 <= k < subs1.len());\n            assert(sub_element(subs0, s, subs_idx0, k));\n            assert(subs_idx0[k] == subs_idx1[k]);\n            assert(subs0[k] === subs1[k]);\n            assert(sub_element(subs1, s, subs_idx1, k));\n        } else {\n            assert(k == subs_idx0.len());\n            assert(i == subs_idx1[k]);\n            assert(s[i] === subs1[k]);\n            assert(sub_element(subs1, s, subs_idx1, k));\n        }\n    }\n    assert(subs1.len() == subs_idx1.len());\n    assert(subs1.len() <= s.len());\n    assert(is_subseq_via_index(subs1, s, subs_idx1));\n}\n\npub proof fn lemma_remove_keep<T>(\n    s: Seq<T>,\n    keep: Seq<T>,\n    removed: Seq<T>,\n    keep_idx: Seq<int>,\n    removed_idx: Seq<int>,\n    i: int,\n)  //-> (ret: (Seq<T>, Seq<T>, Seq<int>, Seq<int>))\n    requires\n        is_subseq_via_index(keep, s, keep_idx),\n        is_subseq_via_index(removed, s, removed_idx),\n        0 <= i < keep_idx.len(),\n        keep.len() + removed.len() == s.len(),\n\n{\n    let keep0 = keep;\n    let keep_idx0 = keep_idx;\n    let (removed0, removed_idx0) = (removed, removed_idx);\n    assert(sub_element(keep0, s, keep_idx0, i));\n    assert(0 <= keep_idx0[i] < s.len());\n    let removed1 = removed0.push(s[keep_idx0[i]]);\n    let removed_idx1 = removed_idx0.push(keep_idx0[i]);\n    let keep1 = keep0.remove(i);\n    let keep_idx1 = keep_idx0.remove(i);\n    proof_subs_remove(s, keep0, keep_idx0, i);\n    proof_subs_push(s, removed0, removed_idx0, keep_idx0[i]);\n}\n\npub proof fn proof_remove_keep<T>(\n    s: Seq<T>,\n    keep: Seq<T>,\n    removed: Seq<T>,\n    keep_idx: &mut Seq<int>,\n    removed_idx: &mut Seq<int>,\n    i: int,\n)\n    requires\n        is_subseq_via_index(keep, s, *old(keep_idx)),\n        is_subseq_via_index(removed, s, *old(removed_idx)),\n        0 <= i < old(keep_idx).len(),\n        keep.len() + removed.len() == s.len(),\n\n{\n    let (keep0, keep_idx0) = (keep, *keep_idx);\n    let (removed0, removed_idx0) = (removed, *removed_idx);\n    assert(sub_element(keep0, s, keep_idx0, i));\n    assert(0 <= keep_idx0[i] < s.len());\n    let removed1 = removed0.push(s[keep_idx0[i]]);\n    let removed_idx1 = removed_idx0.push(keep_idx0[i]);\n    let keep1 = keep0.remove(i);\n    let keep_idx1 = keep_idx0.remove(i);\n    proof_subs_remove(s, keep0, keep_idx0, i);\n    proof_subs_push(s, removed0, removed_idx0, keep_idx0[i]);\n    *keep_idx = keep_idx1;\n    *removed_idx = removed_idx1;\n}\n\n} // verus!\n", "target_text": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier(inline)]\npub open spec fn sub_element<T>(subs: Seq<T>, s: Seq<T>, idx: Seq<int>, k: int) -> bool {\n    &&& (0 <= #[trigger] idx[k] < s.len())\n    &&& (subs[k] === s[idx[k]])\n}\n\npub open spec fn is_subseq_via_index<T>(subs: Seq<T>, s: Seq<T>, idx: Seq<int>) -> bool {\n    &&& (forall|k: int| (0 <= k < idx.len()) ==> sub_element(subs, s, idx, k))\n    &&& subs.len() == idx.len()\n    &&& subs.len() <= s.len()\n}\n\npub proof fn proof_empty_is_subs<T>(s: Seq<T>)\n    ensures\n        is_subseq_via_index(Seq::empty(), s, Seq::empty()),\n{\n}\n\npub proof fn proof_subs_remove<T>(s: Seq<T>, subs: Seq<T>, subs_idx: Seq<int>, i: int)\n    requires\n        is_subseq_via_index(subs, s, subs_idx),\n        0 <= i < subs_idx.len(),\n    ensures\n        is_subseq_via_index(subs.remove(i), s, subs_idx.remove(i)),\n        subs.remove(i).len() == subs.len() - 1,\n{\n    let (subs0, subs_idx0) = (subs, subs_idx);\n    let subs1 = subs0.remove(i);\n    let subs_idx1 = subs_idx0.remove(i);\n    assert forall|k: int| (0 <= k < subs_idx1.len()) implies sub_element(\n        subs1,\n        s,\n        subs_idx1,\n        k,\n    ) by {\n        assert(subs_idx1.len() == subs_idx0.len() - 1);\n        assert(0 <= k < subs_idx0.len());\n        assert(0 <= k < subs0.len());\n        assert(0 <= k < subs1.len());\n        if k < i {\n            assert(sub_element(subs0, s, subs_idx0, k));\n            assert(subs_idx0[k] == subs_idx1[k]);\n            assert(subs0[k] === subs1[k]);\n            assert(sub_element(subs1, s, subs_idx1, k));\n        } else {\n            assert(subs_idx0[k + 1] == subs_idx1[k]);\n            assert(subs0[k + 1] === subs1[k]);\n            assert(sub_element(subs0, s, subs_idx0, k + 1));\n            assert(sub_element(subs1, s, subs_idx1, k));\n        }\n    }\n    assert(subs1.len() == subs_idx1.len());\n    assert(subs1.len() <= s.len());\n}\n\npub proof fn proof_subs_push<T>(s: Seq<T>, subs: Seq<T>, subs_idx: Seq<int>, i: int)\n    requires\n        is_subseq_via_index(subs, s, subs_idx),\n        0 <= i < s.len(),\n        subs.len() < s.len(),\n    ensures\n        is_subseq_via_index(subs.push(s[i]), s, subs_idx.push(i)),\n        subs.push(s[i]).len() == subs.len() + 1,\n        subs_idx.push(i).len() == subs_idx.len() + 1,\n{\n    let (subs0, subs_idx0) = (subs, subs_idx);\n    let subs1 = subs.push(s[i]);\n    let subs_idx1 = subs_idx.push(i);\n    assert(subs_idx1.len() == subs_idx0.len() + 1);\n    assert forall|k: int| (0 <= k < subs_idx1.len()) implies sub_element(\n        subs1,\n        s,\n        subs_idx1,\n        k,\n    ) by {\n        assert(subs_idx1.len() == subs_idx0.len() + 1);\n        if (0 <= k < subs_idx0.len()) {\n            assert(0 <= k < subs0.len());\n            assert(0 <= k < subs1.len());\n            assert(sub_element(subs0, s, subs_idx0, k));\n            assert(subs_idx0[k] == subs_idx1[k]);\n            assert(subs0[k] === subs1[k]);\n            assert(sub_element(subs1, s, subs_idx1, k));\n        } else {\n            assert(k == subs_idx0.len());\n            assert(i == subs_idx1[k]);\n            assert(s[i] === subs1[k]);\n            assert(sub_element(subs1, s, subs_idx1, k));\n        }\n    }\n    assert(subs1.len() == subs_idx1.len());\n    assert(subs1.len() <= s.len());\n    assert(is_subseq_via_index(subs1, s, subs_idx1));\n}\n\npub proof fn lemma_remove_keep<T>(\n    s: Seq<T>,\n    keep: Seq<T>,\n    removed: Seq<T>,\n    keep_idx: Seq<int>,\n    removed_idx: Seq<int>,\n    i: int,\n)  //-> (ret: (Seq<T>, Seq<T>, Seq<int>, Seq<int>))\n    requires\n        is_subseq_via_index(keep, s, keep_idx),\n        is_subseq_via_index(removed, s, removed_idx),\n        0 <= i < keep_idx.len(),\n        keep.len() + removed.len() == s.len(),\n    ensures\n        is_subseq_via_index(keep.remove(i), s, keep_idx.remove(i)),\n        is_subseq_via_index(\n            removed.push(s[keep_idx[i]]),\n            s,\n            removed_idx.push(keep_idx[i]),\n        ),\n//ret === (keep.remove(i), removed.push(s[keep_idx[i]]), keep_idx.remove(i), removed_idx.push(keep_idx[i])),\n\n{\n    let keep0 = keep;\n    let keep_idx0 = keep_idx;\n    let (removed0, removed_idx0) = (removed, removed_idx);\n    assert(sub_element(keep0, s, keep_idx0, i));\n    assert(0 <= keep_idx0[i] < s.len());\n    let removed1 = removed0.push(s[keep_idx0[i]]);\n    let removed_idx1 = removed_idx0.push(keep_idx0[i]);\n    let keep1 = keep0.remove(i);\n    let keep_idx1 = keep_idx0.remove(i);\n    proof_subs_remove(s, keep0, keep_idx0, i);\n    proof_subs_push(s, removed0, removed_idx0, keep_idx0[i]);\n}\n\npub proof fn proof_remove_keep<T>(\n    s: Seq<T>,\n    keep: Seq<T>,\n    removed: Seq<T>,\n    keep_idx: &mut Seq<int>,\n    removed_idx: &mut Seq<int>,\n    i: int,\n)\n    requires\n        is_subseq_via_index(keep, s, *old(keep_idx)),\n        is_subseq_via_index(removed, s, *old(removed_idx)),\n        0 <= i < old(keep_idx).len(),\n        keep.len() + removed.len() == s.len(),\n    ensures\n        is_subseq_via_index(keep.remove(i), s, *keep_idx),\n        is_subseq_via_index(removed.push(s[old(keep_idx)[i]]), s, *removed_idx),\n        *keep_idx === (old(keep_idx).remove(i)),\n        *removed_idx === old(removed_idx).push(old(keep_idx)[i]),\n{\n    let (keep0, keep_idx0) = (keep, *keep_idx);\n    let (removed0, removed_idx0) = (removed, *removed_idx);\n    assert(sub_element(keep0, s, keep_idx0, i));\n    assert(0 <= keep_idx0[i] < s.len());\n    let removed1 = removed0.push(s[keep_idx0[i]]);\n    let removed_idx1 = removed_idx0.push(keep_idx0[i]);\n    let keep1 = keep0.remove(i);\n    let keep_idx1 = keep_idx0.remove(i);\n    proof_subs_remove(s, keep0, keep_idx0, i);\n    proof_subs_push(s, removed0, removed_idx0, keep_idx0[i]);\n    *keep_idx = keep_idx1;\n    *removed_idx = removed_idx1;\n}\n\n} // verus!\n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier(inline)]\npub open spec fn sub_element<T>(subs: Seq<T>, s: Seq<T>, idx: Seq<int>, k: int) -> bool {\n    &&& (0 <= #[trigger] idx[k] < s.len())\n    &&& (subs[k] === s[idx[k]])\n}\n\npub open spec fn is_subseq_via_index<T>(subs: Seq<T>, s: Seq<T>, idx: Seq<int>) -> bool {\n    &&& (forall|k: int| (0 <= k < idx.len()) ==> sub_element(subs, s, idx, k))\n    &&& subs.len() == idx.len()\n    &&& subs.len() <= s.len()\n}\n\npub proof fn proof_empty_is_subs<T>(s: Seq<T>)\n    ensures\n        is_subseq_via_index(Seq::empty(), s, Seq::empty()),\n{\n}\n\npub proof fn proof_subs_remove<T>(s: Seq<T>, subs: Seq<T>, subs_idx: Seq<int>, i: int)\n    requires\n        is_subseq_via_index(subs, s, subs_idx),\n        0 <= i < subs_idx.len(),\n    ensures\n        is_subseq_via_index(subs.remove(i), s, subs_idx.remove(i)),\n        subs.remove(i).len() == subs.len() - 1,\n{\n    let (subs0, subs_idx0) = (subs, subs_idx);\n    let subs1 = subs0.remove(i);\n    let subs_idx1 = subs_idx0.remove(i);\n    assert forall|k: int| (0 <= k < subs_idx1.len()) implies sub_element(\n        subs1,\n        s,\n        subs_idx1,\n        k,\n    ) by {\n        assert(subs_idx1.len() == subs_idx0.len() - 1);\n        assert(0 <= k < subs_idx0.len());\n        assert(0 <= k < subs0.len());\n        assert(0 <= k < subs1.len());\n        if k < i {\n            assert(sub_element(subs0, s, subs_idx0, k));\n            assert(subs_idx0[k] == subs_idx1[k]);\n            assert(subs0[k] === subs1[k]);\n            assert(sub_element(subs1, s, subs_idx1, k));\n        } else {\n            assert(subs_idx0[k + 1] == subs_idx1[k]);\n            assert(subs0[k + 1] === subs1[k]);\n            assert(sub_element(subs0, s, subs_idx0, k + 1));\n            assert(sub_element(subs1, s, subs_idx1, k));\n        }\n    }\n    assert(subs1.len() == subs_idx1.len());\n    assert(subs1.len() <= s.len());\n}\n\npub proof fn proof_subs_push<T>(s: Seq<T>, subs: Seq<T>, subs_idx: Seq<int>, i: int)\n    requires\n        is_subseq_via_index(subs, s, subs_idx),\n        0 <= i < s.len(),\n        subs.len() < s.len(),\n    ensures\n        is_subseq_via_index(subs.push(s[i]), s, subs_idx.push(i)),\n        subs.push(s[i]).len() == subs.len() + 1,\n        subs_idx.push(i).len() == subs_idx.len() + 1,\n{\n    let (subs0, subs_idx0) = (subs, subs_idx);\n    let subs1 = subs.push(s[i]);\n    let subs_idx1 = subs_idx.push(i);\n    assert(subs_idx1.len() == subs_idx0.len() + 1);\n    assert forall|k: int| (0 <= k < subs_idx1.len()) implies sub_element(\n        subs1,\n        s,\n        subs_idx1,\n        k,\n    ) by {\n        assert(subs_idx1.len() == subs_idx0.len() + 1);\n        if (0 <= k < subs_idx0.len()) {\n            assert(0 <= k < subs0.len());\n            assert(0 <= k < subs1.len());\n            assert(sub_element(subs0, s, subs_idx0, k));\n            assert(subs_idx0[k] == subs_idx1[k]);\n            assert(subs0[k] === subs1[k]);\n            assert(sub_element(subs1, s, subs_idx1, k));\n        } else {\n            assert(k == subs_idx0.len());\n            assert(i == subs_idx1[k]);\n            assert(s[i] === subs1[k]);\n            assert(sub_element(subs1, s, subs_idx1, k));\n        }\n    }\n    assert(subs1.len() == subs_idx1.len());\n    assert(subs1.len() <= s.len());\n    assert(is_subseq_via_index(subs1, s, subs_idx1));\n}\n\npub proof fn lemma_remove_keep<T>(\n    s: Seq<T>,\n    keep: Seq<T>,\n    removed: Seq<T>,\n    keep_idx: Seq<int>,\n    removed_idx: Seq<int>,\n    i: int,\n)  //-> (ret: (Seq<T>, Seq<T>, Seq<int>, Seq<int>))\n    requires\n        is_subseq_via_index(keep, s, keep_idx),\n        is_subseq_via_index(removed, s, removed_idx),\n        0 <= i < keep_idx.len(),\n        keep.len() + removed.len() == s.len(),\n    ensures\n        is_subseq_via_index(keep.remove(i), s, keep_idx.remove(i)),\n        is_subseq_via_index(\n            removed.push(s[keep_idx[i]]),\n            s,\n            removed_idx.push(keep_idx[i]),\n        ),\n//ret === (keep.remove(i), removed.push(s[keep_idx[i]]), keep_idx.remove(i), removed_idx.push(keep_idx[i])),\n\n{\n    let keep0 = keep;\n    let keep_idx0 = keep_idx;\n    let (removed0, removed_idx0) = (removed, removed_idx);\n    assert(sub_element(keep0, s, keep_idx0, i));\n    assert(0 <= keep_idx0[i] < s.len());\n    let removed1 = removed0.push(s[keep_idx0[i]]);\n    let removed_idx1 = removed_idx0.push(keep_idx0[i]);\n    let keep1 = keep0.remove(i);\n    let keep_idx1 = keep_idx0.remove(i);\n    proof_subs_remove(s, keep0, keep_idx0, i);\n    proof_subs_push(s, removed0, removed_idx0, keep_idx0[i]);\n}\n\npub proof fn proof_remove_keep<T>(\n    s: Seq<T>,\n    keep: Seq<T>,\n    removed: Seq<T>,\n    keep_idx: &mut Seq<int>,\n    removed_idx: &mut Seq<int>,\n    i: int,\n)\n    requires\n        is_subseq_via_index(keep, s, *old(keep_idx)),\n        is_subseq_via_index(removed, s, *old(removed_idx)),\n        0 <= i < old(keep_idx).len(),\n        keep.len() + removed.len() == s.len(),\n    ensures\n        is_subseq_via_index(keep.remove(i), s, *keep_idx),\n        is_subseq_via_index(removed.push(s[old(keep_idx)[i]]), s, *removed_idx),\n        *keep_idx === (old(keep_idx).remove(i)),\n        *removed_idx === old(removed_idx).push(old(keep_idx)[i]),\n{\n    let (keep0, keep_idx0) = (keep, *keep_idx);\n    let (removed0, removed_idx0) = (removed, *removed_idx);\n    assert(sub_element(keep0, s, keep_idx0, i));\n    assert(0 <= keep_idx0[i] < s.len());\n    let removed1 = removed0.push(s[keep_idx0[i]]);\n    let removed_idx1 = removed_idx0.push(keep_idx0[i]);\n    let keep1 = keep0.remove(i);\n    let keep_idx1 = keep_idx0.remove(i);\n    proof_subs_remove(s, keep0, keep_idx0, i);\n    proof_subs_push(s, removed0, removed_idx0, keep_idx0[i]);\n    *keep_idx = keep_idx1;\n    *removed_idx = removed_idx1;\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verismo/source/verismo/src/tspec/seqlib/subseq.rs", "verified": true, "metadata": {"original_id": "verismo_subseq_500b64c32e59", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_a_023f08f3b9d9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32)   { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "target_text": "requires a . len () > 0\nensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] \ndecreases a . len () - i\ninvariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> min_val <= a [k] , exists | k : int | 0 <= k < i && min_val == a [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0 ensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] , { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> min_val <= a [k] , exists | k : int | 0 <= k < i && min_val == a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "023f08f3b9d9", "function_name": "minArray", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_verus_strings_a9ecfdea6bcc", "task": "task_a", "input_text": "// rust_verify/tests/example.rs\nuse vstd::prelude::*;\n\nverus! {\n\n// ANCHOR: initial\nfn get_char() {\n    let x = \"hello world\";\n\n    let val = x.get_char(0);\n\n}\n// ANCHOR_END: initial\n\n// ANCHOR: literal_eq\nfn literal_eq() {\n    let x = \"hello world\";\n    let y = \"hello world\";\n\n}\n// ANCHOR_END: literal_eq\n//\n// ANCHOR: literal_view\nfn str_view() {\n    let x = \"hello world\";\n    let ghost y: Seq<char> = x@;\n}\n// ANCHOR_END: literal_view\n\n// ANCHOR: pre_substring\nfn subrange<'a>(s: &str)\n\n{\n\n}\n// ANCHOR_END: pre_substring\n\n// ANCHOR: substring_ascii\nfn test() {\n    let a = String::from_str((\"ABC\"));\n\n    let b = a.as_str().substring_ascii(2, 3);\n\n}\n// ANCHOR_END: substring_ascii\n\n} // verus!", "target_text": "requires s@ =~= \"Hello\"@", "full_verified_code": "// rust_verify/tests/example.rs\nuse vstd::prelude::*;\n\nverus! {\n\n// ANCHOR: initial\nfn get_char() {\n    let x = \"hello world\";\n    proof {\n        reveal_strlit(\"hello world\");\n    }\n    assert(x@.len() == 11);\n    let val = x.get_char(0);\n    assert('h' === val);\n}\n// ANCHOR_END: initial\n\n// ANCHOR: literal_eq\nfn literal_eq() {\n    let x = \"hello world\";\n    let y = \"hello world\";\n    assert(x@ == y@);\n}\n// ANCHOR_END: literal_eq\n//\n// ANCHOR: literal_view\nfn str_view() {\n    let x = \"hello world\";\n    let ghost y: Seq<char> = x@;\n}\n// ANCHOR_END: literal_view\n\n// ANCHOR: pre_substring\nfn subrange<'a>(s: &str)\n    requires s@ =~= \"Hello\"@,\n{\n    proof {\n        reveal_strlit(\"Hello\");\n        reveal_strlit(\"H\");\n    }\n    assert(s@.subrange(0, 1) =~= \"H\"@);\n}\n// ANCHOR_END: pre_substring\n\n// ANCHOR: substring_ascii\nfn test() {\n    let a = String::from_str((\"ABC\"));\n    proof {\n        reveal_strlit(\"ABC\");\n    }\n    assert(a.is_ascii());\n    let b = a.as_str().substring_ascii(2, 3);\n    proof {\n        reveal_strlit(\"C\");\n    }\n    assert(b@ =~= (\"C\")@);\n}\n// ANCHOR_END: substring_ascii\n\n} // verus!", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/strings.rs", "verified": true, "metadata": {"original_id": "verus_strings_a9ecfdea6bcc", "function_name": "", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_b_622cdb8d2163", "task": "task_b", "input_text": "pub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)\nrequires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 2 * N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 2 * N , { let mut total : i32 = 0 ; let mut i : usize = 0 ; while i < N as usize invariant i <= N as usize , total <= 2 * (i as i32) , a . len () == N , b . len () == N , sum . len () == 1 , N > 0 , N < 1000 , decreases N as usize - i { if i < a . len () && i < b . len () { let val_a = if a [i] > 1 { 1 } else if a [i] < 0 { 0 } else { a [i] } ; let val_b = if b [i] > 1 { 1 } else if b [i] < 0 { 0 } else { b [i] } ; total = total + val_a + val_b ; } i = i + 1 ; } sum . set (0 , total) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 2 * N , { let mut total : i32 = 0 ; let mut i : usize = 0 ; while i < N as usize invariant i <= N as usize , total <= 2 * (i as i32) , a . len () == N , b . len () == N , sum . len () == 1 , N > 0 , N < 1000 , decreases N as usize - i { if i < a . len () && i < b . len () { let val_a = if a [i] > 1 { 1 } else if a [i] < 0 { 0 } else { a [i] } ; let val_b = if b [i] > 1 { 1 } else if b [i] < 0 { 0 } else { b [i] } ; total = total + val_a + val_b ; } i = i + 1 ; } sum . set (0 , total) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/res1_impl.rs", "verified": true, "metadata": {"original_id": "622cdb8d2163", "function_name": "myfun", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_58d1bb28c3cb", "task": "task_b", "input_text": "fn compare_nat (a : nat , b : nat) -> (eq : bool)\nrequires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_compare/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "58d1bb28c3cb", "function_name": "compare_nat", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_requires_990bbedc39eb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >)  ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >)  ensures double_array_elements_postcond (s , result) , { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >) requires double_array_elements_precond (s) , ensures double_array_elements_postcond (s , result) , { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >) requires double_array_elements_precond (s) , ensures double_array_elements_postcond (s , result) , { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_58/verina_basic_58_impl.rs", "verified": true, "metadata": {"original_id": "990bbedc39eb", "function_name": "double_array_elements", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_3af55780098f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 ,  { k }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "3af55780098f", "function_name": "main_method", "bug_type": "missing_ensures"}}
{"id": "task_a_6a1924bcbe6f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)   { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize)   { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "target_text": "requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , binary_search_precond (a @ , key) \nensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo\ndecreases hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\nfn binary_search (a : & Vec < i32 > , key : i32) -> (result : usize) requires binary_search_precond (a @ , key) , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , { binary_search_loop (a , key , 0 , a . len ()) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_51/verina_basic_51_impl.rs", "verified": true, "metadata": {"original_id": "6a1924bcbe6f", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_b39f2ab4789c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >)   { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "target_text": "requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX \nensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX , ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_update_array/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "b39f2ab4789c", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_b_5bad090f8fd5", "task": "task_b", "input_text": "fn rain (heights : Vec < i32 >) -> (result : i32)\nrequires rain_precond (heights @) \nensures rain_postcond (heights @ , result as int) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn rain_postcond (heights : Seq < i32 > , result : int) -> bool { result >= 0 && if heights . len () < 3 { result == 0 } else { true } }\nspec fn rain_precond (heights : Seq < i32 >) -> bool { forall | i : int | 0 <= i < heights . len () ==> # [trigger] heights [i] >= 0 }\nfn rain (heights : Vec < i32 >) -> (result : i32) requires rain_precond (heights @) , ensures rain_postcond (heights @ , result as int) , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn rain_postcond (heights : Seq < i32 > , result : int) -> bool { result >= 0 && if heights . len () < 3 { result == 0 } else { true } }\nspec fn rain_precond (heights : Seq < i32 >) -> bool { forall | i : int | 0 <= i < heights . len () ==> # [trigger] heights [i] >= 0 }\nfn rain (heights : Vec < i32 >) -> (result : i32) requires rain_precond (heights @) , ensures rain_postcond (heights @ , result as int) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_62/verina_advanced_62_iter_0_original.rs", "verified": true, "metadata": {"original_id": "5bad090f8fd5", "function_name": "rain", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_2da8c3330c3c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >)   { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ;  double_array_elements_aux (s_old , s_next , i + 1) } }\n\n} // verus!", "target_text": "requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] \nensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i\ndecreases s . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_58/verina_basic_58_iter_1_current.rs", "verified": true, "metadata": {"original_id": "2da8c3330c3c", "function_name": "double_array_elements_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_c_missing_ensures_verified-nrkernel_extra_c92552ed5a7d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus!{\n\npub open spec fn inj_on<A, B>(f: spec_fn(A) -> B, da: Set<A>) -> bool {\n    forall|x:A,y:A| da.contains(x) && da.contains(y) && f(x) == f(y) ==> x == y\n}\n\npub proof fn lemma_filter_len_le<A>(f: spec_fn(A) -> bool, da: Set<A>)\n    requires da.finite(), // TODO: necessary?\n\n{\n    if da.is_empty() {\n        assert(da.filter(f) =~= Set::empty());\n    } else {\n        let x = da.choose();\n        lemma_filter_len_le(f, da.remove(x));\n        if f(x) {\n            assert(da.remove(x).filter(f).insert(x) =~= da.filter(f));\n        } else {\n            assert(da.remove(x).filter(f) =~= da.filter(f));\n        }\n    }\n}\n\npub proof fn lemma_map_len_le<A,B>(f: spec_fn(A) -> B, da: Set<A>)\n    requires da.finite()\n\n{\n    if da.is_empty() {\n        assert(da.map(f) =~= Set::empty());\n    } else {\n        let x = da.choose();\n        lemma_map_len_le(f, da.remove(x));\n        assert(da.remove(x).map(f).insert(f(x)) =~= da.map(f));\n    }\n}\n\npub proof fn lemma_map_len_eq<A,B>(f: spec_fn(A) -> B, da: Set<A>)\n    requires\n        da.finite(),\n        inj_on(f, da)\n\n{\n    if da.is_empty() {\n        assert(da.map(f) =~= Set::empty());\n    } else {\n        let x = da.choose();\n        lemma_map_len_eq(f, da.remove(x));\n        assert(da.remove(x).map(f).insert(f(x)) =~= da.map(f));\n    }\n}\n\n/// Creates a finite set of natural numbers in the range [lo, hi).\npub open spec fn set_nat_range(lo: nat, hi: nat) -> Set<nat> {\n    Set::new(|i: nat| lo <= i && i < hi)\n}\n\n/// If a set solely contains numbers in the range [a, b), then its size is\n/// bounded by b - a.\npub proof fn lemma_nat_range(lo: nat, hi: nat)\n    requires\n        lo <= hi,\n\n{\n    if lo == hi {\n        assert(set_nat_range(lo, hi) =~= Set::empty());\n    } else {\n        lemma_nat_range(lo, sub(hi, 1));\n        assert(set_nat_range(lo, sub(hi, 1)).insert(sub(hi, 1)) =~= set_nat_range(lo, hi));\n    }\n}\n\n//spec fn inj<A, B>(f: spec_fn(A) -> B) -> bool {\n//    inj_on(f, univ())\n//}\n//\n//spec fn bij_betw<A, B>(f: spec_fn(A) -> B) -> bool {\n//    inj(f) && univ::<A>.map(f) ==\n//}\n\n//spec fn univ<A>() -> Set<A> {\n//    Set::new(|a:A| true)\n//}\n\n}\n", "target_text": "use vstd::prelude::*;\n\nverus!{\n\npub open spec fn inj_on<A, B>(f: spec_fn(A) -> B, da: Set<A>) -> bool {\n    forall|x:A,y:A| da.contains(x) && da.contains(y) && f(x) == f(y) ==> x == y\n}\n\npub proof fn lemma_filter_len_le<A>(f: spec_fn(A) -> bool, da: Set<A>)\n    requires da.finite(), // TODO: necessary?\n    ensures\n        da.filter(f).finite(),\n        da.filter(f).len() <= da.len(),\n    decreases da.len()\n{\n    if da.is_empty() {\n        assert(da.filter(f) =~= Set::empty());\n    } else {\n        let x = da.choose();\n        lemma_filter_len_le(f, da.remove(x));\n        if f(x) {\n            assert(da.remove(x).filter(f).insert(x) =~= da.filter(f));\n        } else {\n            assert(da.remove(x).filter(f) =~= da.filter(f));\n        }\n    }\n}\n\npub proof fn lemma_map_len_le<A,B>(f: spec_fn(A) -> B, da: Set<A>)\n    requires da.finite()\n    ensures\n        da.map(f).finite(),\n        da.map(f).len() <= da.len(),\n    decreases da.len()\n{\n    if da.is_empty() {\n        assert(da.map(f) =~= Set::empty());\n    } else {\n        let x = da.choose();\n        lemma_map_len_le(f, da.remove(x));\n        assert(da.remove(x).map(f).insert(f(x)) =~= da.map(f));\n    }\n}\n\npub proof fn lemma_map_len_eq<A,B>(f: spec_fn(A) -> B, da: Set<A>)\n    requires\n        da.finite(),\n        inj_on(f, da)\n    ensures\n        da.map(f).finite(),\n        da.map(f).len() == da.len(),\n    decreases da.len()\n{\n    if da.is_empty() {\n        assert(da.map(f) =~= Set::empty());\n    } else {\n        let x = da.choose();\n        lemma_map_len_eq(f, da.remove(x));\n        assert(da.remove(x).map(f).insert(f(x)) =~= da.map(f));\n    }\n}\n\n/// Creates a finite set of natural numbers in the range [lo, hi).\npub open spec fn set_nat_range(lo: nat, hi: nat) -> Set<nat> {\n    Set::new(|i: nat| lo <= i && i < hi)\n}\n\n/// If a set solely contains numbers in the range [a, b), then its size is\n/// bounded by b - a.\npub proof fn lemma_nat_range(lo: nat, hi: nat)\n    requires\n        lo <= hi,\n    ensures\n        set_nat_range(lo, hi).finite(),\n        set_nat_range(lo, hi).len() == hi - lo,\n    decreases hi - lo,\n{\n    if lo == hi {\n        assert(set_nat_range(lo, hi) =~= Set::empty());\n    } else {\n        lemma_nat_range(lo, sub(hi, 1));\n        assert(set_nat_range(lo, sub(hi, 1)).insert(sub(hi, 1)) =~= set_nat_range(lo, hi));\n    }\n}\n\n//spec fn inj<A, B>(f: spec_fn(A) -> B) -> bool {\n//    inj_on(f, univ())\n//}\n//\n//spec fn bij_betw<A, B>(f: spec_fn(A) -> B) -> bool {\n//    inj(f) && univ::<A>.map(f) ==\n//}\n\n//spec fn univ<A>() -> Set<A> {\n//    Set::new(|a:A| true)\n//}\n\n}\n", "full_verified_code": "use vstd::prelude::*;\n\nverus!{\n\npub open spec fn inj_on<A, B>(f: spec_fn(A) -> B, da: Set<A>) -> bool {\n    forall|x:A,y:A| da.contains(x) && da.contains(y) && f(x) == f(y) ==> x == y\n}\n\npub proof fn lemma_filter_len_le<A>(f: spec_fn(A) -> bool, da: Set<A>)\n    requires da.finite(), // TODO: necessary?\n    ensures\n        da.filter(f).finite(),\n        da.filter(f).len() <= da.len(),\n    decreases da.len()\n{\n    if da.is_empty() {\n        assert(da.filter(f) =~= Set::empty());\n    } else {\n        let x = da.choose();\n        lemma_filter_len_le(f, da.remove(x));\n        if f(x) {\n            assert(da.remove(x).filter(f).insert(x) =~= da.filter(f));\n        } else {\n            assert(da.remove(x).filter(f) =~= da.filter(f));\n        }\n    }\n}\n\npub proof fn lemma_map_len_le<A,B>(f: spec_fn(A) -> B, da: Set<A>)\n    requires da.finite()\n    ensures\n        da.map(f).finite(),\n        da.map(f).len() <= da.len(),\n    decreases da.len()\n{\n    if da.is_empty() {\n        assert(da.map(f) =~= Set::empty());\n    } else {\n        let x = da.choose();\n        lemma_map_len_le(f, da.remove(x));\n        assert(da.remove(x).map(f).insert(f(x)) =~= da.map(f));\n    }\n}\n\npub proof fn lemma_map_len_eq<A,B>(f: spec_fn(A) -> B, da: Set<A>)\n    requires\n        da.finite(),\n        inj_on(f, da)\n    ensures\n        da.map(f).finite(),\n        da.map(f).len() == da.len(),\n    decreases da.len()\n{\n    if da.is_empty() {\n        assert(da.map(f) =~= Set::empty());\n    } else {\n        let x = da.choose();\n        lemma_map_len_eq(f, da.remove(x));\n        assert(da.remove(x).map(f).insert(f(x)) =~= da.map(f));\n    }\n}\n\n/// Creates a finite set of natural numbers in the range [lo, hi).\npub open spec fn set_nat_range(lo: nat, hi: nat) -> Set<nat> {\n    Set::new(|i: nat| lo <= i && i < hi)\n}\n\n/// If a set solely contains numbers in the range [a, b), then its size is\n/// bounded by b - a.\npub proof fn lemma_nat_range(lo: nat, hi: nat)\n    requires\n        lo <= hi,\n    ensures\n        set_nat_range(lo, hi).finite(),\n        set_nat_range(lo, hi).len() == hi - lo,\n    decreases hi - lo,\n{\n    if lo == hi {\n        assert(set_nat_range(lo, hi) =~= Set::empty());\n    } else {\n        lemma_nat_range(lo, sub(hi, 1));\n        assert(set_nat_range(lo, sub(hi, 1)).insert(sub(hi, 1)) =~= set_nat_range(lo, hi));\n    }\n}\n\n//spec fn inj<A, B>(f: spec_fn(A) -> B) -> bool {\n//    inj_on(f, univ())\n//}\n//\n//spec fn bij_betw<A, B>(f: spec_fn(A) -> B) -> bool {\n//    inj(f) && univ::<A>.map(f) ==\n//}\n\n//spec fn univ<A>() -> Set<A> {\n//    Set::new(|a:A| true)\n//}\n\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verified-nrkernel/verified-node-replication/verified-node-replication/src/extra.rs", "verified": true, "metadata": {"original_id": "verified-nrkernel_extra_c92552ed5a7d", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_b_6fa6a4b78604", "task": "task_b", "input_text": "fn pluck_smallest_even (nodes : & Vec < u32 >) -> (result : Vec < u32 >)\nrequires nodes @ . len () <= MAX \nensures result @ . len () == 0 || result @ . len () == 2 , result @ . len () == 0 ==> forall | i : int | 0 <= i < nodes @ . len () ==> nodes @ [i] % 2 != 0 , result @ . len () == 2 ==>", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pluck_smallest_even (nodes : & Vec < u32 >) -> (result : Vec < u32 >) requires nodes @ . len () <= MAX , ensures result @ . len () == 0 || result @ . len () == 2 , result @ . len () == 0 ==> forall | i : int | 0 <= i < nodes @ . len () ==> nodes @ [i] % 2 != 0 , result @ . len () == 2 ==> { &&& result @ [0] % 2 == 0 &&& 0 <= result @ [1] < nodes @ . len () &&& nodes @ [result @ [1] as int] == result @ [0] &&& forall | i : int | 0 <= i < nodes @ . len () ==> (nodes @ [i] % 2 == 0 ==> result @ [0] <= nodes @ [i]) &&& forall | i : int | 0 <= i < result @ [1] ==> nodes @ [i] % 2 != 0 || nodes @ [i] > result @ [0] } , { let mut smallest_even : Option < u32 > = None ; let mut smallest_index : Option < u32 > = None ; for i in 0 .. nodes . len () invariant 0 <= i <= nodes @ . len () , nodes @ . len () <= MAX , smallest_even . is_none () == smallest_index . is_none () , smallest_index . is_none () ==> forall | j : int | 0 <= j < i ==> nodes @ [j] % 2 != 0 , smallest_index . is_some () ==> { &&& 0 <= smallest_index . unwrap () < i as int &&& nodes @ [smallest_index . unwrap () as int] == smallest_even . unwrap () &&& smallest_even . unwrap () % 2 == 0 &&& forall | j : int | 0 <= j < i ==> (nodes @ [j] % 2 == 0 ==> smallest_even . unwrap () <= nodes @ [j]) &&& forall | j : int | 0 <= j < smallest_index . unwrap () ==> nodes @ [j] % 2 != 0 || nodes @ [j] > smallest_even . unwrap () } , { if nodes [i] % 2 == 0 && (smallest_even . is_none () || nodes [i] < smallest_even . unwrap ()) { smallest_even = Some (nodes [i]) ; smallest_index = Some ((i as u32)) ; } } if smallest_index . is_none () { Vec :: new () } else { vec ! [smallest_even . unwrap () , smallest_index . unwrap ()] } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pluck_smallest_even (nodes : & Vec < u32 >) -> (result : Vec < u32 >) requires nodes @ . len () <= MAX , ensures result @ . len () == 0 || result @ . len () == 2 , result @ . len () == 0 ==> forall | i : int | 0 <= i < nodes @ . len () ==> nodes @ [i] % 2 != 0 , result @ . len () == 2 ==> { &&& result @ [0] % 2 == 0 &&& 0 <= result @ [1] < nodes @ . len () &&& nodes @ [result @ [1] as int] == result @ [0] &&& forall | i : int | 0 <= i < nodes @ . len () ==> (nodes @ [i] % 2 == 0 ==> result @ [0] <= nodes @ [i]) &&& forall | i : int | 0 <= i < result @ [1] ==> nodes @ [i] % 2 != 0 || nodes @ [i] > result @ [0] } , { let mut smallest_even : Option < u32 > = None ; let mut smallest_index : Option < u32 > = None ; for i in 0 .. nodes . len () invariant 0 <= i <= nodes @ . len () , nodes @ . len () <= MAX , smallest_even . is_none () == smallest_index . is_none () , smallest_index . is_none () ==> forall | j : int | 0 <= j < i ==> nodes @ [j] % 2 != 0 , smallest_index . is_some () ==> { &&& 0 <= smallest_index . unwrap () < i as int &&& nodes @ [smallest_index . unwrap () as int] == smallest_even . unwrap () &&& smallest_even . unwrap () % 2 == 0 &&& forall | j : int | 0 <= j < i ==> (nodes @ [j] % 2 == 0 ==> smallest_even . unwrap () <= nodes @ [j]) &&& forall | j : int | 0 <= j < smallest_index . unwrap () ==> nodes @ [j] % 2 != 0 || nodes @ [j] > smallest_even . unwrap () } , { if nodes [i] % 2 == 0 && (smallest_even . is_none () || nodes [i] < smallest_even . unwrap ()) { smallest_even = Some (nodes [i]) ; smallest_index = Some ((i as u32)) ; } } if smallest_index . is_none () { Vec :: new () } else { vec ! [smallest_even . unwrap () , smallest_index . unwrap ()] } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/068-pluck_impl.rs", "verified": true, "metadata": {"original_id": "6fa6a4b78604", "function_name": "pluck_smallest_even", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_4173315a5ef2", "task": "task_b", "input_text": "fn is_digit (c : u8) -> (res : bool)\nensures res == is_digit_spec (c) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "4173315a5ef2", "function_name": "is_digit", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_a9a4d08af375", "task": "task_b", "input_text": "fn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)\nensures result == in_array (a @ , x) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/remove_duplicates_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "a9a4d08af375", "function_name": "in_array_exec", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_requires_3af70fcd4ee1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_22/verina_advanced_22_impl.rs", "verified": true, "metadata": {"original_id": "3af70fcd4ee1", "function_name": "aux", "bug_type": "missing_requires"}}
{"id": "task_a_1639d516bb20", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn prime (n : nat) -> bool { n > 1 && (forall | nr : nat | 1 < nr < n ==> # [trigger] (n % nr) != 0) }\nfn test_primeness (n : u64) -> (result : bool)  { if n <= 1 {  return false ; } let mut i = 2u64 ; while i < n  { if n % i == 0 {    return false ; } i = i + 1 ; }     return true ; }\n\n} // verus!", "target_text": "ensures result == prime (n as nat)\ndecreases n - i\ninvariant 2 <= i <= n , n > 1 , forall | nr : nat | 2 <= nr < i ==> # [trigger] ((n as nat) % nr) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn prime (n : nat) -> bool { n > 1 && (forall | nr : nat | 1 < nr < n ==> # [trigger] (n % nr) != 0) }\nfn test_primeness (n : u64) -> (result : bool) ensures result == prime (n as nat) { if n <= 1 { assert (! prime (n as nat)) ; return false ; } let mut i = 2u64 ; while i < n invariant 2 <= i <= n , n > 1 , forall | nr : nat | 2 <= nr < i ==> # [trigger] ((n as nat) % nr) != 0 , decreases n - i { if n % i == 0 { assert (1 < (i as nat) < (n as nat)) ; assert ((n as nat) % (i as nat) == 0) ; assert (! prime (n as nat)) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | nr : nat | 2 <= nr < (n as nat) ==> # [trigger] ((n as nat) % nr) != 0) ; assert (forall | nr : nat | 1 < nr < (n as nat) ==> # [trigger] ((n as nat) % nr) != 0) ; assert (prime (n as nat)) ; return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/DafnyPrograms_tmp_tmp74_f9k_c_prime-database/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "1639d516bb20", "function_name": "test_primeness", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_b_47e7ebd516ec", "task": "task_b", "input_text": "fn max_difference (arr : & Vec < i32 >) -> (diff : i32)\nrequires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 \nensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut min_val = arr [0] ; let mut max_val = arr [0] ; let mut k = 1 ; while k < arr . len () invariant 1 <= k <= arr . len () , forall | i : int | 0 <= i < k ==> min_val <= arr [i] , forall | i : int | 0 <= i < k ==> arr [i] <= max_val , exists | i : int | 0 <= i < k && arr [i] == min_val , exists | i : int | 0 <= i < k && arr [i] == max_val , decreases arr . len () - k { if arr [k] < min_val { min_val = arr [k] ; } if arr [k] > max_val { max_val = arr [k] ; } k += 1 ; } proof { assert (forall | i : int | 0 <= i < arr . len () ==> min_val <= arr [i]) ; assert (forall | i : int | 0 <= i < arr . len () ==> arr [i] <= max_val) ; assert (forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= max_val - min_val) ; } max_val - min_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut min_val = arr [0] ; let mut max_val = arr [0] ; let mut k = 1 ; while k < arr . len () invariant 1 <= k <= arr . len () , forall | i : int | 0 <= i < k ==> min_val <= arr [i] , forall | i : int | 0 <= i < k ==> arr [i] <= max_val , exists | i : int | 0 <= i < k && arr [i] == min_val , exists | i : int | 0 <= i < k && arr [i] == max_val , decreases arr . len () - k { if arr [k] < min_val { min_val = arr [k] ; } if arr [k] > max_val { max_val = arr [k] ; } k += 1 ; } proof { assert (forall | i : int | 0 <= i < arr . len () ==> min_val <= arr [i]) ; assert (forall | i : int | 0 <= i < arr . len () ==> arr [i] <= max_val) ; assert (forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= max_val - min_val) ; } max_val - min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_145_iter_2_current.rs", "verified": true, "metadata": {"original_id": "47e7ebd516ec", "function_name": "max_difference", "has_invariants": true, "has_asserts": true}}
{"id": "task_b_a19ad3009255", "task": "task_b", "input_text": "fn nat_abs_diff (x : i32 , y : i32) -> (result : usize)\nensures result as nat == spec_nat_abs_diff (x , y)", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_54/verina_basic_54_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "a19ad3009255", "function_name": "nat_abs_diff", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_5ba740165f1a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool)   { let mut k : usize = 0 ; while k <= p  { let mut l : usize = p + 1 ; while l < arr . len ()  { if arr [k] >= arr [l] { return false ; } l += 1 ; } k += 1 ; } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 , 0 <= p < arr . len () \nensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] \ndecreases p + 1 - k, arr . len () - l\ninvariant 0 <= k <= p + 1 , forall | k2 : int , l : int | 0 <= k2 < k && p < l < arr . len () ==> arr [k2] < arr [l] , p + 1 <= l <= arr . len () , forall | l2 : int | p < l2 < l ==> arr [k as int] < arr [l2] , forall | k2 : int , l2 : int | 0 <= k2 < k && p < l2 < arr . len () ==> arr [k2] < arr [l2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut k : usize = 0 ; while k <= p invariant 0 <= k <= p + 1 , forall | k2 : int , l : int | 0 <= k2 < k && p < l < arr . len () ==> arr [k2] < arr [l] , decreases p + 1 - k { let mut l : usize = p + 1 ; while l < arr . len () invariant p + 1 <= l <= arr . len () , forall | l2 : int | p < l2 < l ==> arr [k as int] < arr [l2] , forall | k2 : int , l2 : int | 0 <= k2 < k && p < l2 < arr . len () ==> arr [k2] < arr [l2] , decreases arr . len () - l { if arr [k] >= arr [l] { return false ; } l += 1 ; } k += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/barrier_impl.rs", "verified": true, "metadata": {"original_id": "5ba740165f1a", "function_name": "barrier", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_0255fb7432b6", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool)  { n % 2 == 1 }\n\n} // verus!", "target_text": "ensures result == odd (n as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool) ensures result == odd (n as int) { n % 2 == 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "0255fb7432b6", "function_name": "odd_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_a365c319b9d6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 ,  { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "a365c319b9d6", "function_name": "max_dafny_lsp", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_9f8fba720391", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >)  ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun4 (x : & Vec < u64 > , y : & mut Vec < u64 >) requires old (y) . len () == 0 , ensures forall | k : int | 0 <= k < y . len () ==> y [k] % 3 == 0 && x @ . contains (y @ [k]) , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/filter_weak_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9f8fba720391", "function_name": "myfun4", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_15352c76ef04", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 ,  { sum . set (0 , 6 * N) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s5lif_impl.rs", "verified": true, "metadata": {"original_id": "15352c76ef04", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_dc28565fd671", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_digits (x : nat) -> nat { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_9/verina_advanced_9_impl.rs", "verified": true, "metadata": {"original_id": "dc28565fd671", "function_name": "sum_of_digits_exec", "bug_type": "missing_decreases"}}
{"id": "task_b_verus_monotonic_counter_1a36c6e4f57c", "task": "task_b", "input_text": "fn main()\nrequires self.id() == other.id(),\n            self@.n() == other@.n(), self@ is FullRightToAdvance, old(self)@ is FullRightToAdvance, old(self).id() == old(other).id(),\n            old(self)@ is HalfRightToAdvance,\n            old(other)@ is HalfRightToAdvance, old(self).id() == other.id()\nensures result@ == (MonotonicCounterResourceValue::FullRightToAdvance, r.id() == self.id(),\n            r@.n() == self@.op(other@).n(), (, self.id() == old(self).id(),\n            self@ == (MonotonicCounterResourceValue::FullRightToAdvance, old(self)@ == old(other)@,\n            self.id() == other.id() == old(self).id(),\n            other@ == self@,\n            self@ == (MonotonicCounterResourceValue::HalfRightToAdvance, out@ is LowerBound,\n            out.id() == self.id(),\n            out@ == (MonotonicCounterResourceValue::LowerBound, self@ == old(self)@,\n            self@ is LowerBound && other@ is FullRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is FullRightToAdvance ==> other@.n() <= self@.n(),\n            self@ is LowerBound && other@ is HalfRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is HalfRightToAdvance ==> other@.n() <= self@.n()", "target_text": "//! This file implements monotonic counters using a custom resource\n//! algebra.\n//!\n//! To use it, use MonotonicCounterResource::alloc(), which will\n//! create a fresh monotonic counter and return a resource granting\n//! full access to it. You can increment it the counter by calling\n//! `increment` on a resource. For example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//! proof { full.increment(); }\n//! assert(full@.n() == 1);\n//! ```\n//!\n//! To split a full right to advance into two half rights to advance,\n//! use `split`. This is useful, for instance, to stash half inside an\n//! invariant and pass the other half to the thread having the right\n//! to advance. Both halves will have the same `id()` value,\n//! indicating they correspond to the same monotonic counter. For\n//! example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//! let tracked (mut half1, mut half2) = full.split();\n//! assert(half1.id() == half2.id());\n//! assert(half1@.n() == 0);\n//! assert(half2@.n() == 0);\n//! ```\n//!\n//! You can use two half authorities together to increment the\n//! associated counter, as in this example:\n//!\n//! ```\n//! let ghost v1 == half1@.n();\n//! proof { half1.increment_using_two_halves(&mut half2); }\n//! assert(half1.id() == half2.id());\n//! assert(half1@ == half2@);\n//! assert(half1@.n() == half2@.n() == v1 + 1);\n//! ```\n//!\n//! From any `MonotonicCounterResource`, one can use\n//! `extract_lower_bound()` to extract a `MonotonicCounterResource`\n//! that represents knowledge of a lower bound on the current value of\n//! the monotonic counter. You can also duplicate a\n//! `MonotonicCounterResource` using this function. Here are examples:\n//!\n//! ```\n//! let tracked mut lower_bound = half1.extract_lower_bound();\n//! assert(lower_bound@.n() == 1);\n//! let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();\n//! assert(lower_bound_duplicate@.n() == 1);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// A monotonic counter permission represents a resource with one of\n// the following three values:\n//\n// `LowerBound{ lower_bound }` -- knowledge that the monotonic counter\n// is at least `lower_bound`\n//\n// `FullRightToAdvance{ value }` -- knowledge that the monotonic counter is\n// exactly `value` and the authority to advance it past that value\n//\n// `HalfRightToAdvance{ value }` -- knowledge that the monotonic\n// counter is exactly `value` and half the authority to advance it\n// past that value. Can be combined with another half authority to\n// make a full authority.\npub enum MonotonicCounterResourceValue {\n    LowerBound { lower_bound: nat },\n    HalfRightToAdvance { value: nat },\n    FullRightToAdvance { value: nat },\n    Invalid,\n}\n\n// To use `MonotonicCounterResourceValue` as a resource, we have to implement\n// `PCM`, showing how to use it in a resource algebra.\nimpl PCM for MonotonicCounterResourceValue {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            // Two lower bounds can be combined into a lower bound\n            // that's the maximum of the two lower bounds.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound1 },\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound2 },\n            ) => {\n                let max_lower_bound = if lower_bound1 > lower_bound2 {\n                    lower_bound1\n                } else {\n                    lower_bound2\n                };\n                MonotonicCounterResourceValue::LowerBound { lower_bound: max_lower_bound }\n            },\n            // A lower bound can be combined with a right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // A lower bound can be combined with a half right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the half right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Two half rights to advance can be combined to make\n            // a whole right to advance, as long as the two values\n            // agree with each other.\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value1 },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value2 },\n            ) => if value1 == value2 {\n                MonotonicCounterResourceValue::FullRightToAdvance { value: value1 }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Any other combination is invalid\n            (_, _) => MonotonicCounterResourceValue::Invalid {  },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        MonotonicCounterResourceValue::LowerBound { lower_bound: 0 }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\nimpl MonotonicCounterResourceValue {\n    pub open spec fn n(self) -> nat {\n        match self {\n            MonotonicCounterResourceValue::LowerBound { lower_bound } => lower_bound,\n            MonotonicCounterResourceValue::HalfRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::FullRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::Invalid => 0,\n        }\n    }\n}\n\npub struct MonotonicCounterResource {\n    r: Resource<MonotonicCounterResourceValue>,\n}\n\nimpl MonotonicCounterResource {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> MonotonicCounterResourceValue {\n        self.r.value()\n    }\n\n    // This function creates a monotonic counter and returns a\n    // resource granting full authority to advance it and giving\n    // knowledge that the current value is 0.\n    pub proof fn alloc() -> (tracked result: Self)\n        ensures\n            result@ == (MonotonicCounterResourceValue::FullRightToAdvance { value: 0 }),\n    {\n        let v = MonotonicCounterResourceValue::FullRightToAdvance { value: 0 };\n        let tracked mut r = Resource::<MonotonicCounterResourceValue>::alloc(v);\n        Self { r }\n    }\n\n\n    // Join two resources\n    pub proof fn join(tracked self: Self, tracked other: Self) -> (tracked r: Self)\n        requires\n            self.id() == other.id(),\n            self@.n() == other@.n()\n        ensures\n            r.id() == self.id(),\n            r@.n() == self@.op(other@).n(),\n    {\n        let tracked mut r = self.r.join(other.r);\n        Self { r }\n    }\n\n    // This function splits a resource granting full authority to\n    // advance a monotonic counter into two resources each granting\n    // half authority to advance it. They both have the same `id()`,\n    // meaning they correspond to the same monotonic counter.\n    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))\n        requires\n            self@ is FullRightToAdvance,\n        ensures\n            ({\n                let (r1, r2) = return_value;\n                let value = self@->FullRightToAdvance_value;\n                &&& r1.id() == r2.id() == self.id()\n                &&& r1@ == (MonotonicCounterResourceValue::HalfRightToAdvance { value })\n                &&& r2@ == r1@\n            }),\n    {\n        let value = self@->FullRightToAdvance_value;\n        let v_half = MonotonicCounterResourceValue::HalfRightToAdvance { value };\n        let tracked (r1, r2) = self.r.split(v_half, v_half);\n        (Self { r: r1 }, Self { r: r2 })\n    }\n\n    // This function uses a resource granting full authority to\n    // advance a monotonic counter to increment the counter.\n    pub proof fn increment(tracked &mut self)\n        requires\n            old(self)@ is FullRightToAdvance,\n        ensures\n            self.id() == old(self).id(),\n            self@ == (MonotonicCounterResourceValue::FullRightToAdvance {\n                value: old(self)@->FullRightToAdvance_value + 1,\n            }),\n    {\n        let v = self@->FullRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::FullRightToAdvance { value: v + 1 };\n        update_mut(&mut self.r, r);\n    }\n\n    // This function uses two tracked resources, each granting half\n    // authority to advance a monotonic counter, to increment the\n    // counter. The two permissions must have the same `id()` values.\n    //\n    // It's not a requirement that the two halves match in value; this\n    // function can figure out that they match just from the fact that\n    // they co-exist.\n    pub proof fn increment_using_two_halves(tracked &mut self, tracked other: &mut Self)\n        requires\n            old(self).id() == old(other).id(),\n            old(self)@ is HalfRightToAdvance,\n            old(other)@ is HalfRightToAdvance,\n        ensures\n            old(self)@ == old(other)@,\n            self.id() == other.id() == old(self).id(),\n            other@ == self@,\n            self@ == (MonotonicCounterResourceValue::HalfRightToAdvance {\n                value: old(self)@->HalfRightToAdvance_value + 1,\n            }),\n    {\n        self.r.validate_2(&other.r);\n        let v = self@->HalfRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::HalfRightToAdvance { value: v + 1 };\n        update_and_redistribute(&mut self.r, &mut other.r, r, r);\n    }\n\n    pub proof fn extract_lower_bound(tracked &self) -> (tracked out: Self)\n        ensures\n            out@ is LowerBound,\n            out.id() == self.id(),\n            out@ == (MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() }),\n    {\n        self.r.validate();\n        let v = MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() };\n        let tracked r = copy_duplicable_part(&self.r, v);\n        Self { r }\n    }\n\n    pub proof fn lemma_lower_bound(tracked &mut self, tracked other: &Self)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self@ == old(self)@,\n            self@ is LowerBound && other@ is FullRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is FullRightToAdvance ==> other@.n() <= self@.n(),\n            self@ is LowerBound && other@ is HalfRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is HalfRightToAdvance ==> other@.n() <= self@.n(),\n\n    {\n        self.r.validate_2(&other.r)\n    }\n}\n\n// This example illustrates some uses of the monotonic counter.\nfn main() {\n    let tracked full = MonotonicCounterResource::alloc();\n    proof {\n        full.increment();\n    }\n    assert(full@.n() == 1);\n    let tracked full = MonotonicCounterResource::alloc();\n    let tracked zero_lower_bound = full.extract_lower_bound();\n    let tracked (mut half1, mut half2) = full.split();\n    assert(half1.id() == half2.id());\n    assert(half1@.n() == 0);\n    assert(half2@.n() == 0);\n    let ghost id = half1.id();\n    let ghost v1 = half1@.n();\n    let ghost v2 = half2@.n();\n    assert(v1 == v2);\n    proof {\n        half1.increment_using_two_halves(&mut half2);\n    }\n    assert(half1.id() == half2.id() == id);\n    assert(half1@.n() == half2@.n() == v1 + 1);\n    assert(half1@.n() == 1);\n    let tracked mut lower_bound = half1.extract_lower_bound();\n    assert(lower_bound@.n() == 1);\n    let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();\n    assert(lower_bound_duplicate@.n() == 1);\n\n\n    proof {\n        let tracked reconstructed_full = half1.join(half2);\n        zero_lower_bound.lemma_lower_bound(&reconstructed_full);\n        assert(zero_lower_bound@.n() <= reconstructed_full@.n());\n    }\n}\n\n} // verus!\n", "full_verified_code": "//! This file implements monotonic counters using a custom resource\n//! algebra.\n//!\n//! To use it, use MonotonicCounterResource::alloc(), which will\n//! create a fresh monotonic counter and return a resource granting\n//! full access to it. You can increment it the counter by calling\n//! `increment` on a resource. For example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//! proof { full.increment(); }\n//! assert(full@.n() == 1);\n//! ```\n//!\n//! To split a full right to advance into two half rights to advance,\n//! use `split`. This is useful, for instance, to stash half inside an\n//! invariant and pass the other half to the thread having the right\n//! to advance. Both halves will have the same `id()` value,\n//! indicating they correspond to the same monotonic counter. For\n//! example:\n//!\n//! ```\n//! let tracked full = MonotonicCounterResource::alloc();\n//! let tracked (mut half1, mut half2) = full.split();\n//! assert(half1.id() == half2.id());\n//! assert(half1@.n() == 0);\n//! assert(half2@.n() == 0);\n//! ```\n//!\n//! You can use two half authorities together to increment the\n//! associated counter, as in this example:\n//!\n//! ```\n//! let ghost v1 == half1@.n();\n//! proof { half1.increment_using_two_halves(&mut half2); }\n//! assert(half1.id() == half2.id());\n//! assert(half1@ == half2@);\n//! assert(half1@.n() == half2@.n() == v1 + 1);\n//! ```\n//!\n//! From any `MonotonicCounterResource`, one can use\n//! `extract_lower_bound()` to extract a `MonotonicCounterResource`\n//! that represents knowledge of a lower bound on the current value of\n//! the monotonic counter. You can also duplicate a\n//! `MonotonicCounterResource` using this function. Here are examples:\n//!\n//! ```\n//! let tracked mut lower_bound = half1.extract_lower_bound();\n//! assert(lower_bound@.n() == 1);\n//! let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();\n//! assert(lower_bound_duplicate@.n() == 1);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\n// A monotonic counter permission represents a resource with one of\n// the following three values:\n//\n// `LowerBound{ lower_bound }` -- knowledge that the monotonic counter\n// is at least `lower_bound`\n//\n// `FullRightToAdvance{ value }` -- knowledge that the monotonic counter is\n// exactly `value` and the authority to advance it past that value\n//\n// `HalfRightToAdvance{ value }` -- knowledge that the monotonic\n// counter is exactly `value` and half the authority to advance it\n// past that value. Can be combined with another half authority to\n// make a full authority.\npub enum MonotonicCounterResourceValue {\n    LowerBound { lower_bound: nat },\n    HalfRightToAdvance { value: nat },\n    FullRightToAdvance { value: nat },\n    Invalid,\n}\n\n// To use `MonotonicCounterResourceValue` as a resource, we have to implement\n// `PCM`, showing how to use it in a resource algebra.\nimpl PCM for MonotonicCounterResourceValue {\n    open spec fn valid(self) -> bool {\n        !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            // Two lower bounds can be combined into a lower bound\n            // that's the maximum of the two lower bounds.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound1 },\n                MonotonicCounterResourceValue::LowerBound { lower_bound: lower_bound2 },\n            ) => {\n                let max_lower_bound = if lower_bound1 > lower_bound2 {\n                    lower_bound1\n                } else {\n                    lower_bound2\n                };\n                MonotonicCounterResourceValue::LowerBound { lower_bound: max_lower_bound }\n            },\n            // A lower bound can be combined with a right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::FullRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::FullRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // A lower bound can be combined with a half right to\n            // advance as long as the lower bound doesn't exceed\n            // the value in the half right to advance.\n            (\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value },\n                MonotonicCounterResourceValue::LowerBound { lower_bound },\n            ) => if lower_bound <= value {\n                MonotonicCounterResourceValue::HalfRightToAdvance { value }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Two half rights to advance can be combined to make\n            // a whole right to advance, as long as the two values\n            // agree with each other.\n            (\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value1 },\n                MonotonicCounterResourceValue::HalfRightToAdvance { value: value2 },\n            ) => if value1 == value2 {\n                MonotonicCounterResourceValue::FullRightToAdvance { value: value1 }\n            } else {\n                MonotonicCounterResourceValue::Invalid {  }\n            },\n            // Any other combination is invalid\n            (_, _) => MonotonicCounterResourceValue::Invalid {  },\n        }\n    }\n\n    open spec fn unit() -> Self {\n        MonotonicCounterResourceValue::LowerBound { lower_bound: 0 }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n    }\n\n    proof fn op_unit(a: Self) {\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\nimpl MonotonicCounterResourceValue {\n    pub open spec fn n(self) -> nat {\n        match self {\n            MonotonicCounterResourceValue::LowerBound { lower_bound } => lower_bound,\n            MonotonicCounterResourceValue::HalfRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::FullRightToAdvance { value } => value,\n            MonotonicCounterResourceValue::Invalid => 0,\n        }\n    }\n}\n\npub struct MonotonicCounterResource {\n    r: Resource<MonotonicCounterResourceValue>,\n}\n\nimpl MonotonicCounterResource {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> MonotonicCounterResourceValue {\n        self.r.value()\n    }\n\n    // This function creates a monotonic counter and returns a\n    // resource granting full authority to advance it and giving\n    // knowledge that the current value is 0.\n    pub proof fn alloc() -> (tracked result: Self)\n        ensures\n            result@ == (MonotonicCounterResourceValue::FullRightToAdvance { value: 0 }),\n    {\n        let v = MonotonicCounterResourceValue::FullRightToAdvance { value: 0 };\n        let tracked mut r = Resource::<MonotonicCounterResourceValue>::alloc(v);\n        Self { r }\n    }\n\n\n    // Join two resources\n    pub proof fn join(tracked self: Self, tracked other: Self) -> (tracked r: Self)\n        requires\n            self.id() == other.id(),\n            self@.n() == other@.n()\n        ensures\n            r.id() == self.id(),\n            r@.n() == self@.op(other@).n(),\n    {\n        let tracked mut r = self.r.join(other.r);\n        Self { r }\n    }\n\n    // This function splits a resource granting full authority to\n    // advance a monotonic counter into two resources each granting\n    // half authority to advance it. They both have the same `id()`,\n    // meaning they correspond to the same monotonic counter.\n    pub proof fn split(tracked self) -> (tracked return_value: (Self, Self))\n        requires\n            self@ is FullRightToAdvance,\n        ensures\n            ({\n                let (r1, r2) = return_value;\n                let value = self@->FullRightToAdvance_value;\n                &&& r1.id() == r2.id() == self.id()\n                &&& r1@ == (MonotonicCounterResourceValue::HalfRightToAdvance { value })\n                &&& r2@ == r1@\n            }),\n    {\n        let value = self@->FullRightToAdvance_value;\n        let v_half = MonotonicCounterResourceValue::HalfRightToAdvance { value };\n        let tracked (r1, r2) = self.r.split(v_half, v_half);\n        (Self { r: r1 }, Self { r: r2 })\n    }\n\n    // This function uses a resource granting full authority to\n    // advance a monotonic counter to increment the counter.\n    pub proof fn increment(tracked &mut self)\n        requires\n            old(self)@ is FullRightToAdvance,\n        ensures\n            self.id() == old(self).id(),\n            self@ == (MonotonicCounterResourceValue::FullRightToAdvance {\n                value: old(self)@->FullRightToAdvance_value + 1,\n            }),\n    {\n        let v = self@->FullRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::FullRightToAdvance { value: v + 1 };\n        update_mut(&mut self.r, r);\n    }\n\n    // This function uses two tracked resources, each granting half\n    // authority to advance a monotonic counter, to increment the\n    // counter. The two permissions must have the same `id()` values.\n    //\n    // It's not a requirement that the two halves match in value; this\n    // function can figure out that they match just from the fact that\n    // they co-exist.\n    pub proof fn increment_using_two_halves(tracked &mut self, tracked other: &mut Self)\n        requires\n            old(self).id() == old(other).id(),\n            old(self)@ is HalfRightToAdvance,\n            old(other)@ is HalfRightToAdvance,\n        ensures\n            old(self)@ == old(other)@,\n            self.id() == other.id() == old(self).id(),\n            other@ == self@,\n            self@ == (MonotonicCounterResourceValue::HalfRightToAdvance {\n                value: old(self)@->HalfRightToAdvance_value + 1,\n            }),\n    {\n        self.r.validate_2(&other.r);\n        let v = self@->HalfRightToAdvance_value;\n        let r = MonotonicCounterResourceValue::HalfRightToAdvance { value: v + 1 };\n        update_and_redistribute(&mut self.r, &mut other.r, r, r);\n    }\n\n    pub proof fn extract_lower_bound(tracked &self) -> (tracked out: Self)\n        ensures\n            out@ is LowerBound,\n            out.id() == self.id(),\n            out@ == (MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() }),\n    {\n        self.r.validate();\n        let v = MonotonicCounterResourceValue::LowerBound { lower_bound: self@.n() };\n        let tracked r = copy_duplicable_part(&self.r, v);\n        Self { r }\n    }\n\n    pub proof fn lemma_lower_bound(tracked &mut self, tracked other: &Self)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self@ == old(self)@,\n            self@ is LowerBound && other@ is FullRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is FullRightToAdvance ==> other@.n() <= self@.n(),\n            self@ is LowerBound && other@ is HalfRightToAdvance ==> self@.n() <= other@.n(),\n            other@ is LowerBound && self@ is HalfRightToAdvance ==> other@.n() <= self@.n(),\n\n    {\n        self.r.validate_2(&other.r)\n    }\n}\n\n// This example illustrates some uses of the monotonic counter.\nfn main() {\n    let tracked full = MonotonicCounterResource::alloc();\n    proof {\n        full.increment();\n    }\n    assert(full@.n() == 1);\n    let tracked full = MonotonicCounterResource::alloc();\n    let tracked zero_lower_bound = full.extract_lower_bound();\n    let tracked (mut half1, mut half2) = full.split();\n    assert(half1.id() == half2.id());\n    assert(half1@.n() == 0);\n    assert(half2@.n() == 0);\n    let ghost id = half1.id();\n    let ghost v1 = half1@.n();\n    let ghost v2 = half2@.n();\n    assert(v1 == v2);\n    proof {\n        half1.increment_using_two_halves(&mut half2);\n    }\n    assert(half1.id() == half2.id() == id);\n    assert(half1@.n() == half2@.n() == v1 + 1);\n    assert(half1@.n() == 1);\n    let tracked mut lower_bound = half1.extract_lower_bound();\n    assert(lower_bound@.n() == 1);\n    let tracked lower_bound_duplicate = lower_bound.extract_lower_bound();\n    assert(lower_bound_duplicate@.n() == 1);\n\n\n    proof {\n        let tracked reconstructed_full = half1.join(half2);\n        zero_lower_bound.lemma_lower_bound(&reconstructed_full);\n        assert(zero_lower_bound@.n() <= reconstructed_full@.n());\n    }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/pcm/monotonic_counter.rs", "verified": true, "metadata": {"original_id": "verus_monotonic_counter_1a36c6e4f57c", "function_name": "", "has_invariants": true, "has_asserts": true}}
{"id": "task_b_ec65c331810f", "task": "task_b", "input_text": "fn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)\nensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> number > arr [j] { if number <= arr [i] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_433_impl.rs", "verified": true, "metadata": {"original_id": "ec65c331810f", "function_name": "is_greater", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_invariant_a3d45e5fcc06", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len ()  { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_424_impl.rs", "verified": true, "metadata": {"original_id": "a3d45e5fcc06", "function_name": "extract_rear_chars", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_fbed276fae94", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (numbers : Seq < int > , result : usize) -> bool { true }\nspec fn longest_increasing_subsequence_precond (numbers : Seq < int >) -> bool { true }\nfn longest_increasing_subsequence (numbers : Vec < i32 >) -> (result : usize) requires longest_increasing_subsequence_precond (numbers @ . map (| i : int , x : i32 | x as int)) , numbers . len () < 1000000 ,  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (numbers : Seq < int > , result : usize) -> bool { true }\nspec fn longest_increasing_subsequence_precond (numbers : Seq < int >) -> bool { true }\nfn longest_increasing_subsequence (numbers : Vec < i32 >) -> (result : usize) requires longest_increasing_subsequence_precond (numbers @ . map (| i : int , x : i32 | x as int)) , numbers . len () < 1000000 , ensures longest_increasing_subsequence_postcond (numbers @ . map (| i : int , x : i32 | x as int) , result) { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (numbers : Seq < int > , result : usize) -> bool { true }\nspec fn longest_increasing_subsequence_precond (numbers : Seq < int >) -> bool { true }\nfn longest_increasing_subsequence (numbers : Vec < i32 >) -> (result : usize) requires longest_increasing_subsequence_precond (numbers @ . map (| i : int , x : i32 | x as int)) , numbers . len () < 1000000 , ensures longest_increasing_subsequence_postcond (numbers @ . map (| i : int , x : i32 | x as int) , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_32/verina_advanced_32.rs", "verified": true, "metadata": {"original_id": "fbed276fae94", "function_name": "longest_increasing_subsequence", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_bbc941e4aa4d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_567_impl.rs", "verified": true, "metadata": {"original_id": "bbc941e4aa4d", "function_name": "is_sorted", "bug_type": "missing_decreases"}}
{"id": "task_b_5e9cc255e917", "task": "task_b", "input_text": "fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool)\nrequires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN \nensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN , ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () - 1 invariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , decreases nums . len () - 1 - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn pairs_sum_to_zero (nums : & [i32] , target : i32) -> (found : bool) requires nums . len () >= 2 , forall | i : int , j : int | 0 <= i < j < nums . len () ==> nums [i] + nums [j] <= MAX && nums [i] + nums [j] >= MIN , ensures found <==> exists | i : int , j : int | 0 <= i < j < nums . len () && nums [i] + nums [j] == target , { let mut i = 0 ; while i < nums . len () - 1 invariant 0 <= i <= nums . len () - 1 , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , decreases nums . len () - 1 - i { let mut j = i + 1 ; while j < nums . len () invariant 0 <= i < nums . len () - 1 , i + 1 <= j <= nums . len () , forall | k : int , l : int | 0 <= k < i && k < l < nums . len () ==> nums @ [k] + nums @ [l] != target , forall | l : int | i < l < j ==> nums @ [i as int] + nums @ [l] != target , decreases nums . len () - j { if nums [i] + nums [j] == target { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/043-pairs-sum-to-zero_impl.rs", "verified": true, "metadata": {"original_id": "5e9cc255e917", "function_name": "pairs_sum_to_zero", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_invariant_26c59e126839", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len ()  { if contains (arr2 , arr1 [i]) { proof { assert (exists | k : int | 0 <= k < arr2 . len () && arr2 [k] == arr1 [i as int]) ; assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (exists | k : int | 0 <= k < arr2 . len () && arr2 [k] == arr1 [i as int]) ; assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (exists | k : int | 0 <= k < arr2 . len () && arr2 [k] == arr1 [i as int]) ; assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_414_impl.rs", "verified": true, "metadata": {"original_id": "26c59e126839", "function_name": "any_value_exists", "bug_type": "missing_invariant"}}
{"id": "task_b_c18e772b405a", "task": "task_b", "input_text": "fn abs (x : i32) -> (result : i32)\nrequires x != MIN \nensures result >= 0 , result == x || result == - x ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x >= 0 { x } else { - x } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x >= 0 { x } else { - x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/abs_impl.rs", "verified": true, "metadata": {"original_id": "c18e772b405a", "function_name": "abs", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_cdcddf5c4b3d", "task": "task_b", "input_text": "fn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >)\nrequires v . len () <= 100 \nensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut c = v . clone () ; c . push (elem) ; c }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut c = v . clone () ; c . push (elem) ; c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/array_append_strong_iter_1_current.rs", "verified": true, "metadata": {"original_id": "cdcddf5c4b3d", "function_name": "append", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_requires_ec3952de258a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/brs1_impl.rs", "verified": true, "metadata": {"original_id": "ec3952de258a", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_e7149d4ece38", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)  ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut index = 0 ; while index < arr1 . len () invariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - index , { assert (index < arr2 . len ()) ; if arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut index = 0 ; while index < arr1 . len () invariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - index , { assert (index < arr2 . len ()) ; if arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut index = 0 ; while index < arr1 . len () invariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - index , { assert (index < arr2 . len ()) ; if arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_809_impl.rs", "verified": true, "metadata": {"original_id": "e7149d4ece38", "function_name": "is_smaller", "bug_type": "missing_requires"}}
{"id": "task_b_b14438244fd8", "task": "task_b", "input_text": "fn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)\nensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "b14438244fd8", "function_name": "contains", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_ensures_fa340bf79212", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () ,  { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/two_way_sort_impl.rs", "verified": true, "metadata": {"original_id": "fa340bf79212", "function_name": "swap", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_74e74503ed04", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_790_iter_2_current.rs", "verified": true, "metadata": {"original_id": "74e74503ed04", "function_name": "is_even_at_even_index", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_41fdc36900c2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) , ensures find_smallest_postcond (s @ , result) , { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] { if s [i] < min { min = s [i] ; } i += 1 ; } Some (min) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) , ensures find_smallest_postcond (s @ , result) , { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] decreases s . len () - i { if s [i] < min { min = s [i] ; } i += 1 ; } Some (min) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_smallest_precond (s : Seq < u32 >) -> bool { true }\nspec fn find_smallest_postcond (s : Seq < u32 > , result : Option < u32 >) -> bool { match result { None => s . len () == 0 , Some (r) => s . contains (r) && (forall | x : u32 | s . contains (x) ==> r <= x) } }\nfn find_smallest (s : & Vec < u32 >) -> (result : Option < u32 >) requires find_smallest_precond (s @) , ensures find_smallest_postcond (s @ , result) , { if s . len () == 0 { return None ; } let mut min = s [0] ; let mut i = 1 ; while i < s . len () invariant 0 < s . len () , 1 <= i <= s . len () , s @ . contains (min) , forall | j : int | 0 <= j < i ==> min <= s @ [j] decreases s . len () - i { if s [i] < min { min = s [i] ; } i += 1 ; } Some (min) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_2/verina_basic_2_impl.rs", "verified": true, "metadata": {"original_id": "41fdc36900c2", "function_name": "find_smallest", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_15bebac3d3c7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool)  ensures is_peak_valley_postcond (lst @ , result) { return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_22/verina_advanced_22_iter_0_original.rs", "verified": true, "metadata": {"original_id": "15bebac3d3c7", "function_name": "is_peak_valley", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_dfd9edf0ce2b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 ,  { 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i32) -> (r : i32) requires - 715827882 <= x <= 715827882 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_triple3/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "dfd9edf0ce2b", "function_name": "triple", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_6de671c213a4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nfn my_min (a : i32 , b : i32) -> (result : i32)  ensures my_min_postcond (a as int , b as int , result as int) , { if a <= b { a } else { b } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nfn my_min (a : i32 , b : i32) -> (result : i32) requires my_min_precond (a as int , b as int) , ensures my_min_postcond (a as int , b as int , result as int) , { if a <= b { a } else { b } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn my_min_precond (a : int , b : int) -> bool { true }\nspec fn my_min_postcond (a : int , b : int , result : int) -> bool { (result <= a && result <= b) && (result == a || result == b) }\nfn my_min (a : i32 , b : i32) -> (result : i32) requires my_min_precond (a as int , b as int) , ensures my_min_postcond (a as int , b as int , result as int) , { if a <= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_8/verina_basic_8_iter_1_current.rs", "verified": true, "metadata": {"original_id": "6de671c213a4", "function_name": "my_min", "bug_type": "missing_requires"}}
{"id": "task_a_b2f06b5278a0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len ()  { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX \nensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) \ndecreases s1 @ . len () - i\ninvariant s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= i <= s1 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result @ [3 * j] == s1 @ [j] && result @ [3 * j + 1] == s2 @ [j] && result @ [3 * j + 2] == s3 @ [j]) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len () invariant s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= i <= s1 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result @ [3 * j] == s1 @ [j] && result @ [3 * j + 1] == s2 @ [j] && result @ [3 * j + 2] == s3 @ [j]) , decreases s1 @ . len () - i { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_578_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b2f06b5278a0", "function_name": "interleave", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_assert_a2c6d590c065", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) , { if arr [i] % 2 == 0 { proof {   } return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) , { if arr [i] % 2 == 0 { proof { assert (is_even (arr [i as int])) ; assert (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) ; } return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (arr [k]) , { if arr [i] % 2 == 0 { proof { assert (is_even (arr [i as int])) ; assert (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_804_iter_2_current.rs", "verified": true, "metadata": {"original_id": "a2c6d590c065", "function_name": "is_product_even", "bug_type": "missing_assert"}}
{"id": "task_c_missing_requires_0ee14ac92912", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith)  ensures mul == ((a as int) * (b as int)) % (p as int) , { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/049-modp_iter_2_current.rs", "verified": true, "metadata": {"original_id": "0ee14ac92912", "function_name": "modmul", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_ed503af431ee", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx { if str1 [idx] == ' ' { result . push (ch) ; } else { result . push (str1 [idx]) ; } idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_230_impl.rs", "verified": true, "metadata": {"original_id": "ed503af431ee", "function_name": "replace_blanks_with_chars", "bug_type": "missing_decreases"}}
{"id": "task_b_verus_extensionality_b096ad3afeb9", "task": "task_b", "input_text": "fn main()\nrequires s1.len() == 3,\n        s1[0] == 0,\n        s1[1] == 4,\n        s1[2] == 8,\n        s2.len() == 3,\n        s2[0] == 0,\n        s2[1] == 4,\n        s2[2] == 8, s.len() >= 1, 0 <= i <= s.len(), s.len() == t.len(),\n        forall|i| 0 <= i < s.len() as int ==> are_equal(s, t, i), m.contains_pair(5, 17), forall|i| maps_are_equal_on(m, q, i)", "target_text": "#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{map::*, seq::*, seq_lib::*, set::*, set_lib::*};\n\nverus! {\n\n// Sequence extensionality\nproof fn test_seqs(s1: Seq<u64>, s2: Seq<u64>)\n    requires\n        s1.len() == 3,\n        s1[0] == 0,\n        s1[1] == 4,\n        s1[2] == 8,\n        s2.len() == 3,\n        s2[0] == 0,\n        s2[1] == 4,\n        s2[2] == 8,\n{\n    assert_seqs_equal!(s1, s2);\n    assert(s1 == s2);\n}\n\nproof fn pop_and_push(s: Seq<u64>)\n    requires\n        s.len() >= 1,\n{\n    let t = s.subrange(0, s.len() as int - 1).push(s[s.len() as int - 1]);\n    assert_seqs_equal!(s, t);\n    assert(s == t);\n}\n\nproof fn subrange_concat(s: Seq<u64>, i: int)\n    requires\n        0 <= i <= s.len(),\n{\n    let t1 = s.subrange(0, i);\n    let t2 = s.subrange(i, s.len() as int);\n    let t = t1.add(t2);\n    assert_seqs_equal!(s, t);\n    assert(s == t);\n}\n\nspec fn are_equal(s: Seq<u64>, t: Seq<u64>, i: int) -> bool {\n    s[i] == t[i]\n}\n\nproof fn assert_seqs_equal_with_proof(s: Seq<u64>, t: Seq<u64>)\n    requires\n        s.len() == t.len(),\n        forall|i| 0 <= i < s.len() as int ==> are_equal(s, t, i),\n{\n    assert_seqs_equal!(s, t, i => {\n        assert(are_equal(s, t, i)); // trigger\n    });\n    assert(s == t);\n}\n\n// Map extensionality\nproof fn test_map(m: Map<int, int>)\n    requires\n        m.contains_pair(5, 17),\n{\n    let q = m.remove(5).insert(5, 17);\n    assert_maps_equal!(m, q);\n    assert(m == q);\n}\n\nspec fn maps_are_equal_on(m: Map<int, int>, q: Map<int, int>, i: int) -> bool {\n    &&& m.dom().contains(i)\n    &&& q.dom().contains(i)\n    &&& m[i] == q[i]\n}\n\nproof fn assert_maps_equal_with_proof(m: Map<int, int>, q: Map<int, int>)\n    requires\n        forall|i| maps_are_equal_on(m, q, i),\n{\n    assert_maps_equal!(m, q, i => {\n        assert(maps_are_equal_on(m, q, i)); // trigger\n    });\n    assert(m == q);\n}\n\nproof fn assert_maps_equal_with_proof2() {\n    let m = Map::<u64, u64>::total(|t: u64| t & 184);\n    let q = Map::<u64, u64>::new(|t: u64| t ^ t == 0, |t: u64| 184 & t);\n    assert_maps_equal!(m, q, t => {\n        // show that the `q` map is total:\n        assert_bit_vector(t ^ t == 0);\n\n        // show that the values are equal:\n        assert_bit_vector(t & 184 == 184 & t);\n    });\n    assert(m == q);\n}\n\n// Set extensionality\nproof fn test_set(s: Set<int>, t: Set<int>) {\n    assert_sets_equal!(\n        s.union(t),\n        t.union(s),\n    );\n    assert(s.union(t) == t.union(s));\n}\n\nproof fn assert_sets_equal_with_proof() {\n    let s = Set::<u64>::new(|i: u64| i ^ 25 < 100);\n    let t = Set::<u64>::new(|i: u64| 25 ^ i < 100);\n    assert_sets_equal!(s, t, i => {\n        assert_bit_vector(i ^ 25 == 25 ^ i);\n    });\n    assert(s == t);\n}\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{map::*, seq::*, seq_lib::*, set::*, set_lib::*};\n\nverus! {\n\n// Sequence extensionality\nproof fn test_seqs(s1: Seq<u64>, s2: Seq<u64>)\n    requires\n        s1.len() == 3,\n        s1[0] == 0,\n        s1[1] == 4,\n        s1[2] == 8,\n        s2.len() == 3,\n        s2[0] == 0,\n        s2[1] == 4,\n        s2[2] == 8,\n{\n    assert_seqs_equal!(s1, s2);\n    assert(s1 == s2);\n}\n\nproof fn pop_and_push(s: Seq<u64>)\n    requires\n        s.len() >= 1,\n{\n    let t = s.subrange(0, s.len() as int - 1).push(s[s.len() as int - 1]);\n    assert_seqs_equal!(s, t);\n    assert(s == t);\n}\n\nproof fn subrange_concat(s: Seq<u64>, i: int)\n    requires\n        0 <= i <= s.len(),\n{\n    let t1 = s.subrange(0, i);\n    let t2 = s.subrange(i, s.len() as int);\n    let t = t1.add(t2);\n    assert_seqs_equal!(s, t);\n    assert(s == t);\n}\n\nspec fn are_equal(s: Seq<u64>, t: Seq<u64>, i: int) -> bool {\n    s[i] == t[i]\n}\n\nproof fn assert_seqs_equal_with_proof(s: Seq<u64>, t: Seq<u64>)\n    requires\n        s.len() == t.len(),\n        forall|i| 0 <= i < s.len() as int ==> are_equal(s, t, i),\n{\n    assert_seqs_equal!(s, t, i => {\n        assert(are_equal(s, t, i)); // trigger\n    });\n    assert(s == t);\n}\n\n// Map extensionality\nproof fn test_map(m: Map<int, int>)\n    requires\n        m.contains_pair(5, 17),\n{\n    let q = m.remove(5).insert(5, 17);\n    assert_maps_equal!(m, q);\n    assert(m == q);\n}\n\nspec fn maps_are_equal_on(m: Map<int, int>, q: Map<int, int>, i: int) -> bool {\n    &&& m.dom().contains(i)\n    &&& q.dom().contains(i)\n    &&& m[i] == q[i]\n}\n\nproof fn assert_maps_equal_with_proof(m: Map<int, int>, q: Map<int, int>)\n    requires\n        forall|i| maps_are_equal_on(m, q, i),\n{\n    assert_maps_equal!(m, q, i => {\n        assert(maps_are_equal_on(m, q, i)); // trigger\n    });\n    assert(m == q);\n}\n\nproof fn assert_maps_equal_with_proof2() {\n    let m = Map::<u64, u64>::total(|t: u64| t & 184);\n    let q = Map::<u64, u64>::new(|t: u64| t ^ t == 0, |t: u64| 184 & t);\n    assert_maps_equal!(m, q, t => {\n        // show that the `q` map is total:\n        assert_bit_vector(t ^ t == 0);\n\n        // show that the values are equal:\n        assert_bit_vector(t & 184 == 184 & t);\n    });\n    assert(m == q);\n}\n\n// Set extensionality\nproof fn test_set(s: Set<int>, t: Set<int>) {\n    assert_sets_equal!(\n        s.union(t),\n        t.union(s),\n    );\n    assert(s.union(t) == t.union(s));\n}\n\nproof fn assert_sets_equal_with_proof() {\n    let s = Set::<u64>::new(|i: u64| i ^ 25 < 100);\n    let t = Set::<u64>::new(|i: u64| 25 ^ i < 100);\n    assert_sets_equal!(s, t, i => {\n        assert_bit_vector(i ^ 25 == 25 ^ i);\n    });\n    assert(s == t);\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/extensionality.rs", "verified": true, "metadata": {"original_id": "verus_extensionality_b096ad3afeb9", "function_name": "", "has_invariants": false, "has_asserts": true}}
{"id": "task_c_missing_requires_2f8692a729d3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases N - i , { a . set (i as usize , N) ; i = i + 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases N - i , { a . set (i as usize , N) ; i = i + 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == N , decreases N - i , { a . set (i as usize , N) ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/sina1_impl.rs", "verified": true, "metadata": {"original_id": "2f8692a729d3", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_a_28f246cc2622", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let double_n = 2 * N ; sum . set (0 , double_n) ;  }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 2 \nensures sum [0] == 2 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 2 , ensures sum [0] == 2 * N , { let double_n = 2 * N ; sum . set (0 , double_n) ; assert (sum [0] == double_n) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/s12if_impl.rs", "verified": true, "metadata": {"original_id": "28f246cc2622", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_decreases_dfab1c7c31dc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } assert (upper_case [index as int] == (if is_lower_case (str1 [index as int]) { shift_minus_32_spec (str1 [index as int]) } else { str1 [index as int] })) ; index += 1 ; } assert (forall | i : int | 0 <= i < str1 . len () ==> upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) ; upper_case }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } assert (upper_case [index as int] == (if is_lower_case (str1 [index as int]) { shift_minus_32_spec (str1 [index as int]) } else { str1 [index as int] })) ; index += 1 ; } assert (forall | i : int | 0 <= i < str1 . len () ==> upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) ; upper_case }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_uppercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , { let mut upper_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , upper_case . len () == index , forall | i : int | 0 <= i < index ==> (upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) , decreases str1 . len () - index { if (str1 [index] >= 97 && str1 [index] <= 122) { upper_case . push ((str1 [index] - 32) as u8) ; } else { upper_case . push (str1 [index]) ; } assert (upper_case [index as int] == (if is_lower_case (str1 [index as int]) { shift_minus_32_spec (str1 [index as int]) } else { str1 [index as int] })) ; index += 1 ; } assert (forall | i : int | 0 <= i < str1 . len () ==> upper_case [i] == (if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] })) ; upper_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_624_iter_2_current.rs", "verified": true, "metadata": {"original_id": "dfab1c7c31dc", "function_name": "to_uppercase", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_34c5d3dd4acd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool)  ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 1 ; while idx < arr . len () invariant 1 <= idx <= arr . len () , forall | i : int , j : int | 0 <= i < j < idx ==> arr [i] <= arr [j] , decreases arr . len () - idx , { if arr [idx - 1] > arr [idx] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 1 ; while idx < arr . len () invariant 1 <= idx <= arr . len () , forall | i : int , j : int | 0 <= i < j < idx ==> arr [i] <= arr [j] , decreases arr . len () - idx , { if arr [idx - 1] > arr [idx] { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 1 ; while idx < arr . len () invariant 1 <= idx <= arr . len () , forall | i : int , j : int | 0 <= i < j < idx ==> arr [i] <= arr [j] , decreases arr . len () - idx , { if arr [idx - 1] > arr [idx] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_567_impl.rs", "verified": true, "metadata": {"original_id": "34c5d3dd4acd", "function_name": "is_sorted", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_4e6d0475eead", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] == 4 * N , { sum . set (0 , 4 * N) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s3lif_impl.rs", "verified": true, "metadata": {"original_id": "4e6d0475eead", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_718ed3ac6611", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000  { (a + b) / 2 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_avg/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "718ed3ac6611", "function_name": "compute_avg", "bug_type": "missing_ensures"}}
{"id": "task_b_6efcf313c019", "task": "task_b", "input_text": "fn add (x : i32 , y : i32) -> (res : Option < i32 >)\nensures res . is_some () ==> res . unwrap () == x + y ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >) ensures res . is_some () ==> res . unwrap () == x + y , { return None ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn add (x : i32 , y : i32) -> (res : Option < i32 >) ensures res . is_some () ==> res . unwrap () == x + y , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/053-add_iter_0_original.rs", "verified": true, "metadata": {"original_id": "6efcf313c019", "function_name": "add", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_1783d6bbb230", "task": "task_b", "input_text": "fn sort_intervals (intervals : & mut Vec < (usize , usize)\nensures intervals @ . len () == old (intervals) @ . len ()", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >) ensures intervals @ . len () == old (intervals) @ . len () { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >) ensures intervals @ . len () == old (intervals) @ . len () { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_38/verina_advanced_38.rs", "verified": true, "metadata": {"original_id": "1783d6bbb230", "function_name": "sort_intervals", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_cba32b42d8d3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < i ==> arr [j] != key , decreases arr . len () - i { if arr [i] == key { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_249_iter_2_current.rs", "verified": true, "metadata": {"original_id": "cba32b42d8d3", "function_name": "contains", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_4ebba314eff1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool)  { for i in 0 .. list1 . len () invariant forall | ii : int , j : int | 0 <= ii < i && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j] , { for j in 0 .. list2 . len () invariant i < list1 . len () && forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , { if i < list1 . len () && j < list2 . len () && list1 [i] == list2 [j] { assert (exists | ii : int , jj : int | 0 <= ii < list1 . len () && 0 <= jj < list2 . len () && (list1 [ii] == list2 [jj])) by { assert (0 <= i < list1 . len () && 0 <= j < list2 . len () && list1 [i as int] == list2 [j as int]) ; } return true ; } } } assert (forall | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () ==> list1 [i] != list2 [j]) by { assert (forall | ii : int , j : int | 0 <= ii < list1 . len () && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j]) ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool) ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) , { for i in 0 .. list1 . len () invariant forall | ii : int , j : int | 0 <= ii < i && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j] , { for j in 0 .. list2 . len () invariant i < list1 . len () && forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , { if i < list1 . len () && j < list2 . len () && list1 [i] == list2 [j] { assert (exists | ii : int , jj : int | 0 <= ii < list1 . len () && 0 <= jj < list2 . len () && (list1 [ii] == list2 [jj])) by { assert (0 <= i < list1 . len () && 0 <= j < list2 . len () && list1 [i as int] == list2 [j as int]) ; } return true ; } } } assert (forall | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () ==> list1 [i] != list2 [j]) by { assert (forall | ii : int , j : int | 0 <= ii < list1 . len () && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j]) ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_common_element (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (result : bool) ensures result == (exists | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () && (list1 [i] == list2 [j])) , { for i in 0 .. list1 . len () invariant forall | ii : int , j : int | 0 <= ii < i && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j] , { for j in 0 .. list2 . len () invariant i < list1 . len () && forall | jj : int | 0 <= jj < j ==> list1 [i as int] != list2 [jj] , { if i < list1 . len () && j < list2 . len () && list1 [i] == list2 [j] { assert (exists | ii : int , jj : int | 0 <= ii < list1 . len () && 0 <= jj < list2 . len () && (list1 [ii] == list2 [jj])) by { assert (0 <= i < list1 . len () && 0 <= j < list2 . len () && list1 [i as int] == list2 [j as int]) ; } return true ; } } } assert (forall | i : int , j : int | 0 <= i < list1 . len () && 0 <= j < list2 . len () ==> list1 [i] != list2 [j]) by { assert (forall | ii : int , j : int | 0 <= ii < list1 . len () && 0 <= j < list2 . len () ==> list1 [ii] != list2 [j]) ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_431_impl.rs", "verified": true, "metadata": {"original_id": "4ebba314eff1", "function_name": "has_common_element", "bug_type": "missing_ensures"}}
{"id": "task_a_59e692559f08", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32)  { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool)   { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n\n} // verus!", "target_text": "requires d > 0\nensures result == sum_of_digits (x as nat), result == is_sum_divisible_by (x as nat , d as nat)\ndecreases x", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sum_divisible_by (x : nat , d : nat) -> bool recommends d > 0 { sum_of_digits (x) % d == 0 }\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\nfn is_sum_divisible_by_exec (x : u32 , d : u32) -> (result : bool) requires d > 0 ensures result == is_sum_divisible_by (x as nat , d as nat) { let sum = sum_of_digits_exec (x) ; sum % d == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_9/verina_advanced_9_impl.rs", "verified": true, "metadata": {"original_id": "59e692559f08", "function_name": "is_sum_divisible_by_exec", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_f7e30aac2398", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool)   { for i in 0 .. a . len ()  { if n <= a [i] { return false ; } } true }\n\n} // verus!", "target_text": "requires a . len () > 0\nensures result <==> (forall | i : int | 0 <= i < a . len () ==> n > a [i])\ninvariant forall | j : int | 0 <= j < i ==> n > a [j]", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool) requires a . len () > 0 ensures result <==> (forall | i : int | 0 <= i < a . len () ==> n > a [i]) { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> n > a [j] { if n <= a [i] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_10/verina_basic_10_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "f7e30aac2398", "function_name": "is_greater", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_c_missing_ensures_a7ead548f143", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize) requires 0 <= j < old (a) . len () ,  { a . set (j , 60) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize) requires 0 <= j < old (a) . len () , ensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] , { a . set (j , 60) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize) requires 0 <= j < old (a) . len () , ensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] , { a . set (j , 60) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_test_array/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "a7ead548f143", "function_name": "test_array_elements", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_c0a1585678d5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pow_exec (base : u32 , exp : u32) -> u32 { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pow_exec (base : u32 , exp : u32) -> u32 decreases exp , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn pow_exec (base : u32 , exp : u32) -> u32 decreases exp , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_18/verina_advanced_18_iter_0_original.rs", "verified": true, "metadata": {"original_id": "c0a1585678d5", "function_name": "pow_exec", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_b9c1d5c54120", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant 0 < n < list @ . len () , n <= i <= list @ . len () , new_list @ == list @ . subrange (n as int , i as int) , { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 < n < list @ . len () , 0 <= j <= n , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant 0 < n < list @ . len () , n <= i <= list @ . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list @ . len () - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 < n < list @ . len () , 0 <= j <= n , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant 0 < n < list @ . len () , n <= i <= list @ . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list @ . len () - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 < n < list @ . len () , 0 <= j <= n , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_586_impl.rs", "verified": true, "metadata": {"original_id": "b9c1d5c54120", "function_name": "split_and_append", "bug_type": "missing_decreases"}}
{"id": "task_a_verified-storage_math_v_c45695888d25", "task": "task_a", "input_text": "#![allow(unused_imports)]\nuse vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::prelude::*;\n\nverus! {\n\n    pub proof fn lemma_mod_auto_basics(n: int, x: int)\n\n    {\n        lemma_fundamental_div_mod(x, n);\n        lemma_fundamental_div_mod(x + n, n);\n        lemma_fundamental_div_mod(x - n, n);\n        let zp = (x + n) / n - x / n - 1;\n        let zm = (x - n) / n - x / n + 1;\n        lemma_mul_is_distributive_sub(n, (x + n) / n, x / n + 1);\n        lemma_mul_is_distributive_add(n, x / n, 1);\n\n        lemma_mul_is_distributive_sub(n, (x - n) / n, x / n - 1);\n        lemma_mul_is_distributive_sub(n, x / n, 1);\n\n        if (zp > 0) { lemma_mul_inequality(1, zp, n); }\n        if (zp < 0) { lemma_mul_inequality(zp, -1, n); }\n        if (zp == 0) { lemma_mul_by_zero_is_zero(n); }\n        if (zm > 0) { lemma_mul_inequality(1, zm, n); }\n        if (zm < 0) { lemma_mul_inequality(zm, -1, n); }\n        if 0 <= x < n {\n            lemma_basic_div_specific_divisor(n);\n        }\n    }\n\n    pub proof fn lemma_div_relation_when_mods_have_same_order(d: int, x: int, y: int)\n\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n        lemma_mul_is_commutative(y / d, d);\n        lemma_mul_is_commutative(x / d, d);\n\n        if (y / d) > (x / d) {\n            lemma_mul_inequality(1, (y / d) - (x / d), d);\n\n        }\n        if (y / d) < (x / d) {\n            lemma_mul_inequality((y / d) - (x / d), -1, d);\n\n            lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n\n        }\n    }\n\n    pub proof fn lemma_div_relation_when_mods_have_same_order_alt(d: int, x: int, y: int)\n\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n        lemma_mul_is_commutative(y / d, d);\n        lemma_mul_is_commutative(x / d, d);\n\n        if (y / d) > (x / d) {\n            lemma_mul_inequality(1, (y / d) - (x / d), d);\n\n        }\n        if (y / d) < (x / d) {\n            lemma_mul_inequality((y / d) - (x / d), -1, d);\n\n        }\n    }\n\n    pub proof fn lemma_div_relation_when_mods_have_different_order(d: int, x: int, y: int)\n\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n        lemma_mul_is_commutative(y / d, d);\n        lemma_mul_is_commutative(x / d, d);\n\n        if (y / d) > (x / d) + 1 {\n            lemma_mul_inequality(2, (y / d) - (x / d), d);\n\n        }\n        if (y / d) <= (x / d) {\n            lemma_mul_inequality(0, (x / d) - (y / d), d);\n\n            lemma_mul_is_commutative((x / d) - (y / d), d);\n            lemma_mul_is_distributive_sub(d, x / d, y / d);\n\n        }\n    }\n\n    pub proof fn lemma_div_relation_when_mods_have_different_order_alt(d: int, x: int, y: int)\n\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_commutative(y / d, d);\n        lemma_mul_is_commutative(x / d, d);\n\n        if (y / d) > (x / d) + 1 {\n            lemma_mul_inequality(2, (y / d) - (x / d), d);\n            lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n\n        }\n        if (y / d) <= (x / d) {\n            lemma_mul_inequality(0, (x / d) - (y / d), d);\n\n            lemma_mul_is_commutative((x / d) - (y / d), d);\n            lemma_mul_is_distributive_sub(d, x / d, y / d);\n\n        }\n    }\n\n    pub proof fn lemma_mod_between(d: int, x: int, y: int, z: int)\n\n    {\n        if y - x == d {\n            lemma_mod_auto_basics(d, x);\n\n        }\n        else {\n            lemma_fundamental_div_mod(x, d);\n            lemma_fundamental_div_mod(y, d);\n            lemma_fundamental_div_mod(z, d);\n\n            lemma_mul_is_distributive_sub(d, (y / d), (x / d));\n\n            lemma_div_relation_when_mods_have_same_order(d, x, y);\n\n            let z_mod_d = x % d + (z - x);\n\n                lemma_mul_is_commutative(d, (x / d));\n            }\n            lemma_fundamental_div_mod_converse(z, d, (x / d), z_mod_d);\n        }\n    }\n\n    pub proof fn lemma_mod_not_between(d: int, x: int, y: int, z: int)\n\n    {\n        if y - x == d {\n            lemma_mod_auto_basics(d, x);\n\n        }\n        else {\n            lemma_fundamental_div_mod(x, d);\n            lemma_fundamental_div_mod(y, d);\n            lemma_fundamental_div_mod(z, d);\n\n            lemma_mul_is_distributive_sub(d, (y / d), (x / d));\n\n            lemma_div_relation_when_mods_have_different_order(d, x, y);\n\n            if y % d < z % d < x % d {\n                lemma_div_relation_when_mods_have_different_order(d, z, y);\n                lemma_div_relation_when_mods_have_same_order(d, z, x);\n\n            }\n        }\n    }\n\n    pub proof fn lemma_mod_addition_when_bounded(x: int, y: int, d: int)\n\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_mul_is_commutative(x / d, d);\n        lemma_fundamental_div_mod_converse(x + y, d, x / d, x % d + y);\n    }\n\n    pub proof fn lemma_mod_difference_equal(x: int, y: int, d: int)\n\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_distributive_sub(d, y / d, x / d);\n\n        lemma_div_relation_when_mods_have_same_order_alt(d, x, y);\n\n    }\n\n    pub proof fn lemma_mod_wrapped_len(x: int, y: int, d: int)\n\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_distributive_sub(d, y / d, x / d);\n\n        lemma_div_relation_when_mods_have_different_order_alt(d, x, y);\n\n    }\n\n    pub proof fn lemma_mod_equal(x: int, y: int, d: int)\n\n    {\n        lemma_mod_difference_equal(x, y, d);\n    }\n\n    pub proof fn lemma_mod_equal_converse(x: int, y: int, d: int)\n\n    {}\n\n    pub proof fn lemma_mod_not_equal(x: int, y: int, d: int)\n\n    {\n        if x % d == y % d {\n            if x < y {\n                lemma_mod_equal(x, y, d);\n\n            } else {\n\n            }\n        }\n\n    }\n\n    #[verifier(nonlinear)]\n    pub proof fn lemma_mul_div_equal(x: int, q: int, d: int)\n\n    {}\n\n    pub proof fn lemma_mod_subtract(x: int, y: int, d: int)\n\n    {\n\n        lemma_fundamental_div_mod(x, d);\n        lemma_mul_is_commutative(x / d, d);\n        lemma_mul_is_distributive_add_other_way(d, x / d, 1);\n        lemma_mul_is_distributive_add_other_way(d, x / d, 2);\n\n        lemma_mul_div_equal(x + y, (x / d + 1), d);\n\n        lemma_fundamental_div_mod(x + y, d);\n\n    }\n\n}\n", "target_text": "requires n > 0, d > 0,\n            x < y,\n            y - x <= d,\n            x % d < y % d, d > 0,\n            x <= y,\n            y - x < d,\n            x % d <= y % d, d > 0,\n            x < y,\n            y - x <= d,\n            y % d <= x % d, d > 0,\n            x <= y,\n            y - x < d,\n            y % d < x % d, d > 0,\n            x % d < y % d,\n            y - x <= d,\n            x <= z <= y, d > 0,\n            y % d < x % d,\n            y - x <= d,\n            x <= z <= y, d > 0,\n            y >= 0,\n            (x % d) + y < d, d > 0,\n            x <= y,\n            x % d <= y % d,\n            y - x < d, d > 0,\n            x <= y,\n            x % d > y % d,\n            y - x < d, d > 0,\n            x <= y,\n            x % d == y % d,\n            y - x < d, d > 0,\n            x == y, d > 0,\n            y - x < d,\n            y - x >= 0,\n            x != y, q * d <= x < (q + 1) * d, d > 0,\n            (x % d) + y >= d,\n            0 <= y < d\nensures (x + n) % n == x % n,\n            (x - n) % n == x % n,\n            (x + n) / n == x / n + 1,\n            (x - n) / n == x / n - 1,\n            0 <= x < n <==> x % n == x, y / d == x / d, y / d == x / d, y / d == x / d + 1, y / d == x / d + 1, x % d <= z % d <= y % d, z % d <= y % d || z % d >= x % d, (x + y) % d == (x % d) + y, y % d - x % d == y - x, d - (x % d) + (y % d) == y - x, x == y, x % d == y % d, x % d != y % d, (x / d) == q, (x % d) + y - d == (x + y) % d", "full_verified_code": "#![allow(unused_imports)]\nuse vstd::arithmetic::div_mod::*;\nuse vstd::arithmetic::mul::*;\nuse vstd::prelude::*;\n\nverus! {\n\n    pub proof fn lemma_mod_auto_basics(n: int, x: int)\n        requires\n            n > 0\n        ensures\n            (x + n) % n == x % n,\n            (x - n) % n == x % n,\n            (x + n) / n == x / n + 1,\n            (x - n) / n == x / n - 1,\n            0 <= x < n <==> x % n == x,\n    {\n        lemma_fundamental_div_mod(x, n);\n        lemma_fundamental_div_mod(x + n, n);\n        lemma_fundamental_div_mod(x - n, n);\n        let zp = (x + n) / n - x / n - 1;\n        let zm = (x - n) / n - x / n + 1;\n        lemma_mul_is_distributive_sub(n, (x + n) / n, x / n + 1);\n        lemma_mul_is_distributive_add(n, x / n, 1);\n        assert (n * zp == n * ((x + n) / n) - n * (x / n) - n * 1);\n        assert (0 == n * zp + ((x + n) % n) - (x % n));\n        lemma_mul_is_distributive_sub(n, (x - n) / n, x / n - 1);\n        lemma_mul_is_distributive_sub(n, x / n, 1);\n        assert (n * zm == n * ((x - n) / n) - n * (x / n) + n * 1);\n        assert (0 == n * zm + ((x - n) % n) - (x % n));\n        if (zp > 0) { lemma_mul_inequality(1, zp, n); }\n        if (zp < 0) { lemma_mul_inequality(zp, -1, n); }\n        if (zp == 0) { lemma_mul_by_zero_is_zero(n); }\n        if (zm > 0) { lemma_mul_inequality(1, zm, n); }\n        if (zm < 0) { lemma_mul_inequality(zm, -1, n); }\n        if 0 <= x < n {\n            lemma_basic_div_specific_divisor(n);\n        }\n    }\n\n    pub proof fn lemma_div_relation_when_mods_have_same_order(d: int, x: int, y: int)\n        requires\n            d > 0,\n            x < y,\n            y - x <= d,\n            x % d < y % d\n        ensures\n            y / d == x / d\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n        lemma_mul_is_commutative(y / d, d);\n        lemma_mul_is_commutative(x / d, d);\n\n        if (y / d) > (x / d) {\n            lemma_mul_inequality(1, (y / d) - (x / d), d);\n            assert (((y / d) - (x / d)) * d >= 1 * d);\n            assert ((y / d) * d - (x / d) * d >= d);\n            assert (false);\n        }\n        if (y / d) < (x / d) {\n            lemma_mul_inequality((y / d) - (x / d), -1, d);\n            assert (((y / d) - (x / d)) * d <= (-1) * d);\n            lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n            assert (false);\n        }\n    }\n\n    pub proof fn lemma_div_relation_when_mods_have_same_order_alt(d: int, x: int, y: int)\n        requires\n            d > 0,\n            x <= y,\n            y - x < d,\n            x % d <= y % d\n        ensures\n            y / d == x / d\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n        lemma_mul_is_commutative(y / d, d);\n        lemma_mul_is_commutative(x / d, d);\n\n        if (y / d) > (x / d) {\n            lemma_mul_inequality(1, (y / d) - (x / d), d);\n            assert (((y / d) - (x / d)) * d >= 1 * d);\n            assert (false);\n        }\n        if (y / d) < (x / d) {\n            lemma_mul_inequality((y / d) - (x / d), -1, d);\n            assert (((y / d) - (x / d)) * d <= (-1) * d);\n            assert (false);\n        }\n    }\n\n    pub proof fn lemma_div_relation_when_mods_have_different_order(d: int, x: int, y: int)\n        requires\n            d > 0,\n            x < y,\n            y - x <= d,\n            y % d <= x % d\n        ensures\n            y / d == x / d + 1\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n        lemma_mul_is_commutative(y / d, d);\n        lemma_mul_is_commutative(x / d, d);\n\n        if (y / d) > (x / d) + 1 {\n            lemma_mul_inequality(2, (y / d) - (x / d), d);\n            assert (((y / d) - (x / d)) * d >= 2 * d);\n            assert (false);\n        }\n        if (y / d) <= (x / d) {\n            lemma_mul_inequality(0, (x / d) - (y / d), d);\n            assert (0 * d <= ((x / d) - (y / d)) * d);\n            lemma_mul_is_commutative((x / d) - (y / d), d);\n            lemma_mul_is_distributive_sub(d, x / d, y / d);\n            assert (d * ((x / d) - (y / d)) == d * (x / d) - d * (y / d));\n            assert (0 * d <= x - y - x % d + y % d);\n            assert (false);\n        }\n    }\n\n    pub proof fn lemma_div_relation_when_mods_have_different_order_alt(d: int, x: int, y: int)\n        requires\n            d > 0,\n            x <= y,\n            y - x < d,\n            y % d < x % d\n        ensures\n            y / d == x / d + 1\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        lemma_mul_is_commutative(y / d, d);\n        lemma_mul_is_commutative(x / d, d);\n\n        if (y / d) > (x / d) + 1 {\n            lemma_mul_inequality(2, (y / d) - (x / d), d);\n            lemma_mul_is_distributive_sub_other_way(d, y / d, x / d);\n            assert (((y / d) - (x / d)) * d >= 2 * d);\n            assert (false);\n        }\n        if (y / d) <= (x / d) {\n            lemma_mul_inequality(0, (x / d) - (y / d), d);\n            assert (0 * d <= ((x / d) - (y / d)) * d);\n            lemma_mul_is_commutative((x / d) - (y / d), d);\n            lemma_mul_is_distributive_sub(d, x / d, y / d);\n            assert (d * ((x / d) - (y / d)) == d * (x / d) - d * (y / d));\n            assert (0 * d <= x - y - x % d + y % d);\n            assert (false);\n        }\n    }\n\n    pub proof fn lemma_mod_between(d: int, x: int, y: int, z: int)\n        requires\n            d > 0,\n            x % d < y % d,\n            y - x <= d,\n            x <= z <= y\n        ensures\n            x % d <= z % d <= y % d\n    {\n        if y - x == d {\n            lemma_mod_auto_basics(d, x);\n            assert (y % d == x % d);\n            assert (false);\n        }\n        else {\n            lemma_fundamental_div_mod(x, d);\n            lemma_fundamental_div_mod(y, d);\n            lemma_fundamental_div_mod(z, d);\n            assert (d * (y / d) - d * (x / d) + y % d - x % d < d);\n            assert (d * (y / d) - d * (x / d) < d);\n            lemma_mul_is_distributive_sub(d, (y / d), (x / d));\n            assert (d * ((y / d) - (x / d)) < d);\n\n            lemma_div_relation_when_mods_have_same_order(d, x, y);\n\n            let z_mod_d = x % d + (z - x);\n            assert (z == (x / d) * d + z_mod_d) by {\n                assert (z == d * (x / d) + z_mod_d);\n                lemma_mul_is_commutative(d, (x / d));\n            }\n            lemma_fundamental_div_mod_converse(z, d, (x / d), z_mod_d);\n        }\n    }\n\n    pub proof fn lemma_mod_not_between(d: int, x: int, y: int, z: int)\n        requires\n            d > 0,\n            y % d < x % d,\n            y - x <= d,\n            x <= z <= y\n        ensures\n            z % d <= y % d || z % d >= x % d\n    {\n        if y - x == d {\n            lemma_mod_auto_basics(d, x);\n            assert (y % d == x % d);\n            assert (false);\n        }\n        else {\n            lemma_fundamental_div_mod(x, d);\n            lemma_fundamental_div_mod(y, d);\n            lemma_fundamental_div_mod(z, d);\n            assert (d * (y / d) - d * (x / d) + y % d - x % d >= 0);\n            assert (d * (y / d) - d * (x / d) >= 0);\n            lemma_mul_is_distributive_sub(d, (y / d), (x / d));\n            assert (d * ((y / d) - (x / d)) >= 0);\n\n            lemma_div_relation_when_mods_have_different_order(d, x, y);\n\n            if y % d < z % d < x % d {\n                lemma_div_relation_when_mods_have_different_order(d, z, y);\n                lemma_div_relation_when_mods_have_same_order(d, z, x);\n                assert (false);\n            }\n        }\n    }\n\n    pub proof fn lemma_mod_addition_when_bounded(x: int, y: int, d: int)\n        requires\n            d > 0,\n            y >= 0,\n            (x % d) + y < d,\n        ensures\n            (x + y) % d == (x % d) + y\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_mul_is_commutative(x / d, d);\n        lemma_fundamental_div_mod_converse(x + y, d, x / d, x % d + y);\n    }\n\n    pub proof fn lemma_mod_difference_equal(x: int, y: int, d: int)\n        requires\n            d > 0,\n            x <= y,\n            x % d <= y % d,\n            y - x < d\n        ensures\n            y % d - x % d == y - x\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n\n        assert (d * (y / d) - d * (x / d) + y % d - x % d == y - x);\n        lemma_mul_is_distributive_sub(d, y / d, x / d);\n        assert (d * (y / d - x / d) + y % d - x % d == y - x);\n        assert (0 <= d * (y / d - x / d) + y % d - x % d < d);\n        lemma_div_relation_when_mods_have_same_order_alt(d, x, y);\n        assert (y / d == x / d);\n    }\n\n    pub proof fn lemma_mod_wrapped_len(x: int, y: int, d: int)\n        requires\n            d > 0,\n            x <= y,\n            x % d > y % d,\n            y - x < d\n        ensures\n            d - (x % d) + (y % d) == y - x\n    {\n        lemma_fundamental_div_mod(x, d);\n        lemma_fundamental_div_mod(y, d);\n        assert (d * (y / d) - d * (x / d) + y % d - x % d == y - x);\n        lemma_mul_is_distributive_sub(d, y / d, x / d);\n        assert (d * (y / d - x / d) + y % d - x % d == y - x);\n        assert (0 <= d * (y / d - x / d) + y % d - x % d < d);\n        lemma_div_relation_when_mods_have_different_order_alt(d, x, y);\n        assert (y / d == x / d + 1);\n        assert (y / d - x / d == 1 ==> d * (y / d - x / d) == d) by (nonlinear_arith);\n    }\n\n    pub proof fn lemma_mod_equal(x: int, y: int, d: int)\n        requires\n            d > 0,\n            x <= y,\n            x % d == y % d,\n            y - x < d\n        ensures\n            x == y\n    {\n        lemma_mod_difference_equal(x, y, d);\n    }\n\n    pub proof fn lemma_mod_equal_converse(x: int, y: int, d: int)\n        requires \n            d > 0,\n            x == y,\n        ensures \n            x % d == y % d\n    {}\n\n    pub proof fn lemma_mod_not_equal(x: int, y: int, d: int) \n        requires \n            d > 0,\n            y - x < d,\n            y - x >= 0,\n            x != y,\n        ensures \n            x % d != y % d\n    {\n        if x % d == y % d {\n            if x < y {\n                lemma_mod_equal(x, y, d);\n                assert(false);\n            } else {\n                assert(y - x < 0);\n                assert(false);\n            }\n        }\n\n    }\n\n    #[verifier(nonlinear)]\n    pub proof fn lemma_mul_div_equal(x: int, q: int, d: int)\n        requires\n            q * d <= x < (q + 1) * d\n        ensures\n            (x / d) == q\n    {}\n\n    pub proof fn lemma_mod_subtract(x: int, y: int, d: int)\n        requires\n            d > 0,\n            (x % d) + y >= d,\n            0 <= y < d\n        ensures\n            (x % d) + y - d == (x + y) % d\n    {\n        assert(d <= (x % d) + y < 2 * d);\n        assert((x / d) * d + d <= (x / d) * d + (x % d) + y < (x / d) * d + 2 * d);\n        lemma_fundamental_div_mod(x, d);\n        lemma_mul_is_commutative(x / d, d);\n        lemma_mul_is_distributive_add_other_way(d, x / d, 1);\n        lemma_mul_is_distributive_add_other_way(d, x / d, 2);\n        assert((x / d + 1) * d <= x + y < (x / d + 2) * d);\n        lemma_mul_div_equal(x + y, (x / d + 1), d);\n        assert(x / d + 1 == (x + y) / d);\n        lemma_fundamental_div_mod(x + y, d);\n        assert(x + y == d * ((x + y) / d) + (x + y) % d);\n    }\n\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verified-storage/pmemlog/src/math_v.rs", "verified": true, "metadata": {"original_id": "verified-storage_math_v_c45695888d25", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_verus_generics_2a21efd9e4a5", "task": "task_c", "input_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn f<A>(a1: A, a2: A) -> bool {\n    true\n}\n\nspec fn id<A, B>(a: A, b: B, c: A) -> A {\n    a\n}\n\nfn id_exec<A, B>(a: A, b: B, c: A) -> (r: A)\n    requires\n        f(a, c),\n\n{\n    a\n}\n\nspec fn id_int(i: int) -> int {\n    id(i, true, 10)\n}\n\nspec fn id_u64(i: u64) -> u64 {\n    id(i, true, 10)\n}\n\nfn id_u64_exec(i: u64) -> (r: u64)\n\n{\n    id_exec(i, true, 10)\n}\n\nstruct S<A> {\n    n: A,\n}\n\nspec fn s_property<B>(s: S<B>) -> int {\n    7\n}\n\nspec fn id_s(s: S<int>) -> S<int> {\n    id(s, true, s)\n}\n\nproof fn s_prop1(x: S<int>, y: S<int>) {\n    assert(s_property(x) == s_property(y));\n}\n\nproof fn s_prop2<C>(x: S<C>, y: S<C>) {\n    assert(s_property(x) == s_property(y));\n}\n\n#[verifier::opaque]\nspec fn g<A>(a: A) -> A {\n    a\n}\n\nproof fn test_g1(u: u8) {\n    reveal(g::<u8>);  // REVIEW: should reveal quantify over all A?\n    assert(g(u) == u);\n}\n\nproof fn test_g2(u: u8) {\n    assert(g(u) < 256 as int);\n}\n\n} // verus!\n", "target_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn f<A>(a1: A, a2: A) -> bool {\n    true\n}\n\nspec fn id<A, B>(a: A, b: B, c: A) -> A {\n    a\n}\n\nfn id_exec<A, B>(a: A, b: B, c: A) -> (r: A)\n    requires\n        f(a, c),\n    ensures\n        f(r, a),\n{\n    a\n}\n\nspec fn id_int(i: int) -> int {\n    id(i, true, 10)\n}\n\nspec fn id_u64(i: u64) -> u64 {\n    id(i, true, 10)\n}\n\nfn id_u64_exec(i: u64) -> (r: u64)\n    ensures\n        f(r, id_u64(i)),\n{\n    id_exec(i, true, 10)\n}\n\nstruct S<A> {\n    n: A,\n}\n\nspec fn s_property<B>(s: S<B>) -> int {\n    7\n}\n\nspec fn id_s(s: S<int>) -> S<int> {\n    id(s, true, s)\n}\n\nproof fn s_prop1(x: S<int>, y: S<int>) {\n    assert(s_property(x) == s_property(y));\n}\n\nproof fn s_prop2<C>(x: S<C>, y: S<C>) {\n    assert(s_property(x) == s_property(y));\n}\n\n#[verifier::opaque]\nspec fn g<A>(a: A) -> A {\n    a\n}\n\nproof fn test_g1(u: u8) {\n    reveal(g::<u8>);  // REVIEW: should reveal quantify over all A?\n    assert(g(u) == u);\n}\n\nproof fn test_g2(u: u8) {\n    assert(g(u) < 256 as int);\n}\n\n} // verus!\n", "full_verified_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn f<A>(a1: A, a2: A) -> bool {\n    true\n}\n\nspec fn id<A, B>(a: A, b: B, c: A) -> A {\n    a\n}\n\nfn id_exec<A, B>(a: A, b: B, c: A) -> (r: A)\n    requires\n        f(a, c),\n    ensures\n        f(r, a),\n{\n    a\n}\n\nspec fn id_int(i: int) -> int {\n    id(i, true, 10)\n}\n\nspec fn id_u64(i: u64) -> u64 {\n    id(i, true, 10)\n}\n\nfn id_u64_exec(i: u64) -> (r: u64)\n    ensures\n        f(r, id_u64(i)),\n{\n    id_exec(i, true, 10)\n}\n\nstruct S<A> {\n    n: A,\n}\n\nspec fn s_property<B>(s: S<B>) -> int {\n    7\n}\n\nspec fn id_s(s: S<int>) -> S<int> {\n    id(s, true, s)\n}\n\nproof fn s_prop1(x: S<int>, y: S<int>) {\n    assert(s_property(x) == s_property(y));\n}\n\nproof fn s_prop2<C>(x: S<C>, y: S<C>) {\n    assert(s_property(x) == s_property(y));\n}\n\n#[verifier::opaque]\nspec fn g<A>(a: A) -> A {\n    a\n}\n\nproof fn test_g1(u: u8) {\n    reveal(g::<u8>);  // REVIEW: should reveal quantify over all A?\n    assert(g(u) == u);\n}\n\nproof fn test_g2(u: u8) {\n    assert(g(u) < 256 as int);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/generics.rs", "verified": true, "metadata": {"original_id": "verus_generics_2a21efd9e4a5", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_b_9bef30898e7f", "task": "task_b", "input_text": "fn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >)\nrequires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 \nensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx]))", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/conditional_average_iter_3_current.rs", "verified": true, "metadata": {"original_id": "9bef30898e7f", "function_name": "conditional_average", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_invariant_a667ec7fce1e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MaxA (a : & [i32]) -> (m : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a [i] <= m , exists | i : int | 0 <= i < a . len () && a [i] == m , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len ()  { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MaxA (a : & [i32]) -> (m : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a [i] <= m , exists | i : int | 0 <= i < a . len () && a [i] == m , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 0 < idx <= a . len () , forall | i : int | 0 <= i < idx ==> a [i] <= max , exists | i : int | 0 <= i < idx && a [i] == max , decreases a . len () - idx , { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MaxA (a : & [i32]) -> (m : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a [i] <= m , exists | i : int | 0 <= i < a . len () && a [i] == m , { let mut max = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 0 < idx <= a . len () , forall | i : int | 0 <= i < idx ==> a [i] <= max , exists | i : int | 0 <= i < idx && a [i] == max , decreases a . len () - idx , { if a [idx] > max { max = a [idx] ; } idx += 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "a667ec7fce1e", "function_name": "MaxA", "bug_type": "missing_invariant"}}
{"id": "task_a_b87b20df173c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize)   { let mut min = list [0] . len () ; let mut idx = 1 ; while idx < list . len ()  { if list [idx] . len () < min { min = list [idx] . len () ; } idx += 1 ; } min }\n\n} // verus!", "target_text": "requires list . len () > 0 \nensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () \ndecreases list . len () - idx\ninvariant 0 <= idx <= list . len () , forall | i : int | 0 <= i < idx ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < idx && min == # [trigger] list [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut idx = 1 ; while idx < list . len () invariant 0 <= idx <= list . len () , forall | i : int | 0 <= i < idx ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < idx && min == # [trigger] list [i] . len () , decreases list . len () - idx { if list [idx] . len () < min { min = list [idx] . len () ; } idx += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_95_impl.rs", "verified": true, "metadata": {"original_id": "b87b20df173c", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_invariant_1eb6f2899eb8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut index = 0 ; while index < arr . len ()  { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] , decreases arr . len () - index , { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] , decreases arr . len () - index , { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_433_impl.rs", "verified": true, "metadata": {"original_id": "1eb6f2899eb8", "function_name": "is_greater", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_4a4dc9705230", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_only_one_distinct_element (arr : & Vec < i32 >) -> (result : bool) ensures result == (forall | i : int | 1 <= i < arr @ . len () ==> arr [0] == # [trigger] arr [i]) , { if arr . len () <= 1 { return true ; } let mut j = 1 ; while j < arr . len ()  { if arr [0] != arr [j] { return false ; } j += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_only_one_distinct_element (arr : & Vec < i32 >) -> (result : bool) ensures result == (forall | i : int | 1 <= i < arr @ . len () ==> arr [0] == # [trigger] arr [i]) , { if arr . len () <= 1 { return true ; } let mut j = 1 ; while j < arr . len () invariant 1 <= j <= arr . len () , forall | k : int | 1 <= k < j ==> arr [0] == # [trigger] arr [k] , decreases arr . len () - j { if arr [0] != arr [j] { return false ; } j += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn has_only_one_distinct_element (arr : & Vec < i32 >) -> (result : bool) ensures result == (forall | i : int | 1 <= i < arr @ . len () ==> arr [0] == # [trigger] arr [i]) , { if arr . len () <= 1 { return true ; } let mut j = 1 ; while j < arr . len () invariant 1 <= j <= arr . len () , forall | k : int | 1 <= k < j ==> arr [0] == # [trigger] arr [k] , decreases arr . len () - j { if arr [0] != arr [j] { return false ; } j += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_760_impl.rs", "verified": true, "metadata": {"original_id": "4a4dc9705230", "function_name": "has_only_one_distinct_element", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_555370735660", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize) requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , ensures result <= d , { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize) requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , ensures result <= d , decreases a . len () + b . len () - m - n { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize) requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , ensures result <= d , decreases a . len () + b . len () - m - n { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_54/verina_basic_54_impl.rs", "verified": true, "metadata": {"original_id": "555370735660", "function_name": "canyon_search_aux", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_1839b2af5d5d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s2if_impl.rs", "verified": true, "metadata": {"original_id": "1839b2af5d5d", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_71f559984c48", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] ,  { return Vec :: new () ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { return Vec :: new () ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/unique_iter_0_original.rs", "verified": true, "metadata": {"original_id": "71f559984c48", "function_name": "unique", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_65c867af533c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_majority_element_precond (lst : Seq < i32 >) -> bool { true }\nfn find_majority_element (lst : Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_majority_element_precond (lst : Seq < i32 >) -> bool { true }\nfn find_majority_element (lst : Vec < i32 >) -> (result : i32) requires find_majority_element_precond (lst @) , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_majority_element_precond (lst : Seq < i32 >) -> bool { true }\nfn find_majority_element (lst : Vec < i32 >) -> (result : i32) requires find_majority_element_precond (lst @) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_11/verina_advanced_11_iter_0_original.rs", "verified": true, "metadata": {"original_id": "65c867af533c", "function_name": "find_majority_element", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_93ad0d5e060c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) ,  { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn iter_copy_precond (s : Seq < int >) -> bool { true }\nfn iter_copy (s : & Vec < int >) -> (result : Vec < int >) requires iter_copy_precond (s @) , ensures s @ . len () == result @ . len () , forall | i : int | 0 <= i < s @ . len () ==> s @ [i] == result @ [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> s @ [j] == result @ [j] , decreases s . len () - i , { result . push (s [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_94/verina_basic_94_iter_2_current.rs", "verified": true, "metadata": {"original_id": "93ad0d5e060c", "function_name": "iter_copy", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_e7149d4ece38", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut index = 0 ; while index < arr1 . len () invariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - index , {  if arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut index = 0 ; while index < arr1 . len () invariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - index , { assert (index < arr2 . len ()) ; if arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut index = 0 ; while index < arr1 . len () invariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - index , { assert (index < arr2 . len ()) ; if arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_809_impl.rs", "verified": true, "metadata": {"original_id": "e7149d4ece38", "function_name": "is_smaller", "bug_type": "missing_assert"}}
{"id": "task_a_c598d24e772a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool)  { if a . len () == 0 { return true ; } let first = a [0] ; let mut i = 1 ; while i < a . len ()  { if a [i] != first { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] \ndecreases a . len () - i\ninvariant 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; let mut i = 1 ; while i < a . len () invariant 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] == first , decreases a . len () - i { if a [i] != first { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/has_only_one_distinct_element_iter_2_current.rs", "verified": true, "metadata": {"original_id": "c598d24e772a", "function_name": "has_only_one_distinct_element", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_invariant_38cb1d1d32e8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { if p >= arr . len () { return true ; } let mut i = 0 ; while i <= p  { let mut j = p + 1 ; while j < arr . len ()  { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { if p >= arr . len () { return true ; } let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { if p >= arr . len () { return true ; } let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/preconditions_removed/barrier_impl.rs", "verified": true, "metadata": {"original_id": "38cb1d1d32e8", "function_name": "barrier", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_f13e69fe3cf1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index = 0 ; let mut i = 1 ; while i < x . len () invariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] , { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index = 0 ; let mut i = 1 ; while i < x . len () invariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] , decreases x . len () - i { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index = 0 ; let mut i = 1 ; while i < x . len () invariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] , decreases x . len () - i { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/max_index_impl.rs", "verified": true, "metadata": {"original_id": "f13e69fe3cf1", "function_name": "myfun1", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_4e6d0475eead", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 ,  { sum . set (0 , 4 * N) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum . set (0 , 4 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s3lif_impl.rs", "verified": true, "metadata": {"original_id": "4e6d0475eead", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_7b894c483b19", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < pos  { result . push (a [i]) ; i += 1 ; } let mut j = pos + 1 ; while j < a . len ()  { result . push (a [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < pos invariant 0 <= i <= pos , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == a [j] , decreases pos - i , { result . push (a [i]) ; i += 1 ; } let mut j = pos + 1 ; while j < a . len () invariant pos < j <= a . len () , result . len () == pos + (j - pos - 1) , forall | k : int | 0 <= k < pos ==> result [k] == a [k] , forall | k : int | pos <= k < result . len () ==> result [k] == a [k + 1] , decreases a . len () - j , { result . push (a [j]) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < pos invariant 0 <= i <= pos , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == a [j] , decreases pos - i , { result . push (a [i]) ; i += 1 ; } let mut j = pos + 1 ; while j < a . len () invariant pos < j <= a . len () , result . len () == pos + (j - pos - 1) , forall | k : int | 0 <= k < pos ==> result [k] == a [k] , forall | k : int | pos <= k < result . len () ==> result [k] == a [k + 1] , decreases a . len () - j , { result . push (a [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_element_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7b894c483b19", "function_name": "remove_element", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_420628818d00", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool)  { c >= 48 && c <= 57 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "420628818d00", "function_name": "is_digit", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_e6b58a67275b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () ,  { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i as int] > arr2 [i as int] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { assert (! (arr1 [idx as int] > arr2 [idx as int])) ; assert (exists | i : int | 0 <= i < arr1 . len () && ! (arr1 [i] > arr2 [i])) ; return false ; } idx += 1 ; } assert (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) ; true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i as int] > arr2 [i as int] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { assert (! (arr1 [idx as int] > arr2 [idx as int])) ; assert (exists | i : int | 0 <= i < arr1 . len () && ! (arr1 [i] > arr2 [i])) ; return false ; } idx += 1 ; } assert (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) ; true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i as int] > arr2 [i as int] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { assert (! (arr1 [idx as int] > arr2 [idx as int])) ; assert (exists | i : int | 0 <= i < arr1 . len () && ! (arr1 [i] > arr2 [i])) ; return false ; } idx += 1 ; } assert (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_809_impl.rs", "verified": true, "metadata": {"original_id": "e6b58a67275b", "function_name": "is_smaller", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_476e4fc506c2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize)  ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , min >= 0 , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j , { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , min >= 0 , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j , { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , min >= 0 , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j , { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_95_impl.rs", "verified": true, "metadata": {"original_id": "476e4fc506c2", "function_name": "smallest_list_length", "bug_type": "missing_requires"}}
{"id": "task_b_99ac91a8e131", "task": "task_b", "input_text": "fn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)\nensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_249_iter_1_current.rs", "verified": true, "metadata": {"original_id": "99ac91a8e131", "function_name": "intersection", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_42262fbd4b9c", "task": "task_b", "input_text": "fn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,)\nrequires nums . len () == old (used) . len () \nensures used . len () == old (used) . len () ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,) requires nums . len () == old (used) . len () , ensures used . len () == old (used) . len () , { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn backtrack (nums : & Vec < i32 > , current_permutation : & mut Vec < i32 > , used : & mut Vec < bool > , result : & mut Vec < Vec < i32 > > ,) requires nums . len () == old (used) . len () , ensures used . len () == old (used) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/interprocedural/AlgorithmsRust/permutations_iter_0_original.rs", "verified": true, "metadata": {"original_id": "42262fbd4b9c", "function_name": "backtrack", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_ac591ad72f9a", "task": "task_b", "input_text": "fn is_integer (text : & Vec < char >) -> (result : bool)\nensures res == is_digit_sepc (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\nfn is_integer (text : & Vec < char >) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_sepc (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_sepc (text [j]) , decreases text . len () - i { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "ac591ad72f9a", "function_name": "is_integer", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_requires_9931d6d97d55", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn match_precond (s : Seq < char > , p : Seq < char >) -> bool { s . len () == p . len () }\nfn match_fn (s : Vec < char > , p : Vec < char >) -> (result : bool)  ensures result <==> forall | n : int | 0 <= n < s . len () ==> (s [n] == p [n] || p [n] == '?') { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s @ . len () == p @ . len () , forall | j : int | 0 <= j < i ==> (s [j] == p [j] || p [j] == '?') decreases s . len () - i { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn match_precond (s : Seq < char > , p : Seq < char >) -> bool { s . len () == p . len () }\nfn match_fn (s : Vec < char > , p : Vec < char >) -> (result : bool) requires match_precond (s @ , p @) ensures result <==> forall | n : int | 0 <= n < s . len () ==> (s [n] == p [n] || p [n] == '?') { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s @ . len () == p @ . len () , forall | j : int | 0 <= j < i ==> (s [j] == p [j] || p [j] == '?') decreases s . len () - i { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn match_precond (s : Seq < char > , p : Seq < char >) -> bool { s . len () == p . len () }\nfn match_fn (s : Vec < char > , p : Vec < char >) -> (result : bool) requires match_precond (s @ , p @) ensures result <==> forall | n : int | 0 <= n < s . len () ==> (s [n] == p [n] || p [n] == '?') { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s @ . len () == p @ . len () , forall | j : int | 0 <= j < i ==> (s [j] == p [j] || p [j] == '?') decreases s . len () - i { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_73/verina_basic_73_iter_2_current.rs", "verified": true, "metadata": {"original_id": "9931d6d97d55", "function_name": "match_fn", "bug_type": "missing_requires"}}
{"id": "task_b_af85767dbfc9", "task": "task_b", "input_text": "fn match_strings (s : Vec < char > , p : Vec < char >) -> (b : bool)\nrequires s . len () == p . len () \nensures b <==> forall | n : int | 0 <= n < s . len () ==> s [n] == p [n] || p [n] == '?'", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn match_strings (s : Vec < char > , p : Vec < char >) -> (b : bool) requires s . len () == p . len () , ensures b <==> forall | n : int | 0 <= n < s . len () ==> s [n] == p [n] || p [n] == '?' { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s . len () == p . len () , forall | n : int | 0 <= n < i ==> s [n] == p [n] || p [n] == '?' decreases s . len () - i { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } return true ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn match_strings (s : Vec < char > , p : Vec < char >) -> (b : bool) requires s . len () == p . len () , ensures b <==> forall | n : int | 0 <= n < s . len () ==> s [n] == p [n] || p [n] == '?' { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , s . len () == p . len () , forall | n : int | 0 <= n < i ==> s [n] == p [n] || p [n] == '?' decreases s . len () - i { if s [i] != p [i] && p [i] != '?' { return false ; } i += 1 ; } return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_match/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "af85767dbfc9", "function_name": "match_strings", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_ensures_11e4c10a27d3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32) requires last_digit_precond (n as nat) ,  { n % 10 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32) requires last_digit_precond (n as nat) , ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32) requires last_digit_precond (n as nat) , ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_11/verina_basic_11_iter_1_current.rs", "verified": true, "metadata": {"original_id": "11e4c10a27d3", "function_name": "last_digit", "bug_type": "missing_ensures"}}
{"id": "task_a_cdcddf5c4b3d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >)   { let mut c = v . clone () ; c . push (elem) ; c }\n\n} // verus!", "target_text": "requires v . len () <= 100 \nensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut c = v . clone () ; c . push (elem) ; c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/array_append_strong_iter_1_current.rs", "verified": true, "metadata": {"original_id": "cdcddf5c4b3d", "function_name": "append", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_requires_vostd_math_c3577f5d3987", "task": "task_c", "input_text": "use vstd::math::max;\nuse vstd::prelude::*;\nuse vstd::bits::*;\n\nverus! {\n\npub proof fn lemma_page_shl()\n    ensures\n        (4096 as u64) << 0 == 0x1000,\n        (4096 as u64) << 1 == 0x2000,\n        (4096 as u64) << 2 == 0x4000,\n        (4096 as u64) << 3 == 0x8000,\n        (4096 as u64) << 4 == 0x10000,\n        (4096 as u64) << 5 == 0x20000,\n        (4096 as u64) << 6 == 0x40000,\n        (4096 as u64) << 7 == 0x80000,\n        (4096 as u64) << 8 == 0x100000,\n        (4096 as u64) << 9 == 0x200000,\n        (4096 as u64) << 10 == 0x400000,\n        (4096 as u64) << 11 == 0x800000,\n        (4096 as u64) << 12 == 0x1000000,\n        (4096 as u64) << 13 == 0x2000000,\n        (4096 as u64) << 14 == 0x4000000,\n        (4096 as u64) << 15 == 0x8000000,\n        (4096 as u64) << 16 == 0x10000000,\n        (4096 as u64) << 17 == 0x20000000,\n        (4096 as u64) << 18 == 0x40000000,\n        (4096 as u64) << 19 == 0x80000000,\n        (4096 as u64) << 20 == 0x100000000,\n        (4096 as u64) << 21 == 0x200000000,\n        (4096 as u64) << 22 == 0x400000000,\n        (4096 as u64) << 23 == 0x800000000,\n        (4096 as u64) << 24 == 0x1000000000,\n        (4096 as u64) << 25 == 0x2000000000,\n        (4096 as u64) << 26 == 0x4000000000,\n        (4096 as u64) << 27 == 0x8000000000,\n{\n    broadcast use lemma_u64_shl_is_mul;\n\n    assert((4096 as u64) << 0 == 0x1000) by (compute_only);\n    assert((4096 as u64) << 1 == 0x2000) by (compute_only);\n    assert((4096 as u64) << 2 == 0x4000) by (compute_only);\n    assert((4096 as u64) << 3 == 0x8000) by (compute_only);\n    assert((4096 as u64) << 4 == 0x10000) by (compute_only);\n    assert((4096 as u64) << 5 == 0x20000) by (compute_only);\n    assert((4096 as u64) << 6 == 0x40000) by (compute_only);\n    assert((4096 as u64) << 7 == 0x80000) by (compute_only);\n    assert((4096 as u64) << 8 == 0x100000) by (compute_only);\n    assert((4096 as u64) << 9 == 0x200000) by (compute_only);\n    assert((4096 as u64) << 10 == 0x400000) by (compute_only);\n    assert((4096 as u64) << 11 == 0x800000) by (compute_only);\n    assert((4096 as u64) << 12 == 0x1000000) by (compute_only);\n    assert((4096 as u64) << 13 == 0x2000000) by (compute_only);\n    assert((4096 as u64) << 14 == 0x4000000) by (compute_only);\n    assert((4096 as u64) << 15 == 0x8000000) by (compute_only);\n    assert((4096 as u64) << 16 == 0x10000000) by (compute_only);\n    assert((4096 as u64) << 17 == 0x20000000) by (compute_only);\n    assert((4096 as u64) << 18 == 0x40000000) by (compute_only);\n    assert((4096 as u64) << 19 == 0x80000000) by (compute_only);\n    assert((4096 as u64) << 20 == 0x100000000) by (compute_only);\n    assert((4096 as u64) << 21 == 0x200000000) by (compute_only);\n    assert((4096 as u64) << 22 == 0x400000000) by (compute_only);\n    assert((4096 as u64) << 23 == 0x800000000) by (compute_only);\n    assert((4096 as u64) << 24 == 0x1000000000) by (compute_only);\n    assert((4096 as u64) << 25 == 0x2000000000) by (compute_only);\n    assert((4096 as u64) << 26 == 0x4000000000) by (compute_only);\n    assert((4096 as u64) << 27 == 0x8000000000) by (compute_only);\n}\n\npub proof fn lemma_u64_and_less_than(a: u64, b: u64)\n    ensures\n        a & b <= a,\n        a & b <= b,\n        a & b <= max(a as int, b as int) as u64,\n{\n    assert(a & b <= a) by (bit_vector);\n    assert(a & b <= b) by (bit_vector);\n    let max = max(a as int, b as int) as u64;\n}\n\npub proof fn lemma_usize_mod_0_maintain_after_add(x: usize, m: usize)\n\n    ensures\n        (x + m) % m as int == 0,\n{\n    use vstd::arithmetic::div_mod::*;\n\n    lemma_mod_adds(x as int, m as int, m as int);\n}\n\n} // verus!\n", "target_text": "use vstd::math::max;\nuse vstd::prelude::*;\nuse vstd::bits::*;\n\nverus! {\n\npub proof fn lemma_page_shl()\n    ensures\n        (4096 as u64) << 0 == 0x1000,\n        (4096 as u64) << 1 == 0x2000,\n        (4096 as u64) << 2 == 0x4000,\n        (4096 as u64) << 3 == 0x8000,\n        (4096 as u64) << 4 == 0x10000,\n        (4096 as u64) << 5 == 0x20000,\n        (4096 as u64) << 6 == 0x40000,\n        (4096 as u64) << 7 == 0x80000,\n        (4096 as u64) << 8 == 0x100000,\n        (4096 as u64) << 9 == 0x200000,\n        (4096 as u64) << 10 == 0x400000,\n        (4096 as u64) << 11 == 0x800000,\n        (4096 as u64) << 12 == 0x1000000,\n        (4096 as u64) << 13 == 0x2000000,\n        (4096 as u64) << 14 == 0x4000000,\n        (4096 as u64) << 15 == 0x8000000,\n        (4096 as u64) << 16 == 0x10000000,\n        (4096 as u64) << 17 == 0x20000000,\n        (4096 as u64) << 18 == 0x40000000,\n        (4096 as u64) << 19 == 0x80000000,\n        (4096 as u64) << 20 == 0x100000000,\n        (4096 as u64) << 21 == 0x200000000,\n        (4096 as u64) << 22 == 0x400000000,\n        (4096 as u64) << 23 == 0x800000000,\n        (4096 as u64) << 24 == 0x1000000000,\n        (4096 as u64) << 25 == 0x2000000000,\n        (4096 as u64) << 26 == 0x4000000000,\n        (4096 as u64) << 27 == 0x8000000000,\n{\n    broadcast use lemma_u64_shl_is_mul;\n\n    assert((4096 as u64) << 0 == 0x1000) by (compute_only);\n    assert((4096 as u64) << 1 == 0x2000) by (compute_only);\n    assert((4096 as u64) << 2 == 0x4000) by (compute_only);\n    assert((4096 as u64) << 3 == 0x8000) by (compute_only);\n    assert((4096 as u64) << 4 == 0x10000) by (compute_only);\n    assert((4096 as u64) << 5 == 0x20000) by (compute_only);\n    assert((4096 as u64) << 6 == 0x40000) by (compute_only);\n    assert((4096 as u64) << 7 == 0x80000) by (compute_only);\n    assert((4096 as u64) << 8 == 0x100000) by (compute_only);\n    assert((4096 as u64) << 9 == 0x200000) by (compute_only);\n    assert((4096 as u64) << 10 == 0x400000) by (compute_only);\n    assert((4096 as u64) << 11 == 0x800000) by (compute_only);\n    assert((4096 as u64) << 12 == 0x1000000) by (compute_only);\n    assert((4096 as u64) << 13 == 0x2000000) by (compute_only);\n    assert((4096 as u64) << 14 == 0x4000000) by (compute_only);\n    assert((4096 as u64) << 15 == 0x8000000) by (compute_only);\n    assert((4096 as u64) << 16 == 0x10000000) by (compute_only);\n    assert((4096 as u64) << 17 == 0x20000000) by (compute_only);\n    assert((4096 as u64) << 18 == 0x40000000) by (compute_only);\n    assert((4096 as u64) << 19 == 0x80000000) by (compute_only);\n    assert((4096 as u64) << 20 == 0x100000000) by (compute_only);\n    assert((4096 as u64) << 21 == 0x200000000) by (compute_only);\n    assert((4096 as u64) << 22 == 0x400000000) by (compute_only);\n    assert((4096 as u64) << 23 == 0x800000000) by (compute_only);\n    assert((4096 as u64) << 24 == 0x1000000000) by (compute_only);\n    assert((4096 as u64) << 25 == 0x2000000000) by (compute_only);\n    assert((4096 as u64) << 26 == 0x4000000000) by (compute_only);\n    assert((4096 as u64) << 27 == 0x8000000000) by (compute_only);\n}\n\npub proof fn lemma_u64_and_less_than(a: u64, b: u64)\n    ensures\n        a & b <= a,\n        a & b <= b,\n        a & b <= max(a as int, b as int) as u64,\n{\n    assert(a & b <= a) by (bit_vector);\n    assert(a & b <= b) by (bit_vector);\n    let max = max(a as int, b as int) as u64;\n}\n\npub proof fn lemma_usize_mod_0_maintain_after_add(x: usize, m: usize)\n    requires\n        x % m == 0,\n        m > 0,\n    ensures\n        (x + m) % m as int == 0,\n{\n    use vstd::arithmetic::div_mod::*;\n\n    lemma_mod_adds(x as int, m as int, m as int);\n}\n\n} // verus!\n", "full_verified_code": "use vstd::math::max;\nuse vstd::prelude::*;\nuse vstd::bits::*;\n\nverus! {\n\npub proof fn lemma_page_shl()\n    ensures\n        (4096 as u64) << 0 == 0x1000,\n        (4096 as u64) << 1 == 0x2000,\n        (4096 as u64) << 2 == 0x4000,\n        (4096 as u64) << 3 == 0x8000,\n        (4096 as u64) << 4 == 0x10000,\n        (4096 as u64) << 5 == 0x20000,\n        (4096 as u64) << 6 == 0x40000,\n        (4096 as u64) << 7 == 0x80000,\n        (4096 as u64) << 8 == 0x100000,\n        (4096 as u64) << 9 == 0x200000,\n        (4096 as u64) << 10 == 0x400000,\n        (4096 as u64) << 11 == 0x800000,\n        (4096 as u64) << 12 == 0x1000000,\n        (4096 as u64) << 13 == 0x2000000,\n        (4096 as u64) << 14 == 0x4000000,\n        (4096 as u64) << 15 == 0x8000000,\n        (4096 as u64) << 16 == 0x10000000,\n        (4096 as u64) << 17 == 0x20000000,\n        (4096 as u64) << 18 == 0x40000000,\n        (4096 as u64) << 19 == 0x80000000,\n        (4096 as u64) << 20 == 0x100000000,\n        (4096 as u64) << 21 == 0x200000000,\n        (4096 as u64) << 22 == 0x400000000,\n        (4096 as u64) << 23 == 0x800000000,\n        (4096 as u64) << 24 == 0x1000000000,\n        (4096 as u64) << 25 == 0x2000000000,\n        (4096 as u64) << 26 == 0x4000000000,\n        (4096 as u64) << 27 == 0x8000000000,\n{\n    broadcast use lemma_u64_shl_is_mul;\n\n    assert((4096 as u64) << 0 == 0x1000) by (compute_only);\n    assert((4096 as u64) << 1 == 0x2000) by (compute_only);\n    assert((4096 as u64) << 2 == 0x4000) by (compute_only);\n    assert((4096 as u64) << 3 == 0x8000) by (compute_only);\n    assert((4096 as u64) << 4 == 0x10000) by (compute_only);\n    assert((4096 as u64) << 5 == 0x20000) by (compute_only);\n    assert((4096 as u64) << 6 == 0x40000) by (compute_only);\n    assert((4096 as u64) << 7 == 0x80000) by (compute_only);\n    assert((4096 as u64) << 8 == 0x100000) by (compute_only);\n    assert((4096 as u64) << 9 == 0x200000) by (compute_only);\n    assert((4096 as u64) << 10 == 0x400000) by (compute_only);\n    assert((4096 as u64) << 11 == 0x800000) by (compute_only);\n    assert((4096 as u64) << 12 == 0x1000000) by (compute_only);\n    assert((4096 as u64) << 13 == 0x2000000) by (compute_only);\n    assert((4096 as u64) << 14 == 0x4000000) by (compute_only);\n    assert((4096 as u64) << 15 == 0x8000000) by (compute_only);\n    assert((4096 as u64) << 16 == 0x10000000) by (compute_only);\n    assert((4096 as u64) << 17 == 0x20000000) by (compute_only);\n    assert((4096 as u64) << 18 == 0x40000000) by (compute_only);\n    assert((4096 as u64) << 19 == 0x80000000) by (compute_only);\n    assert((4096 as u64) << 20 == 0x100000000) by (compute_only);\n    assert((4096 as u64) << 21 == 0x200000000) by (compute_only);\n    assert((4096 as u64) << 22 == 0x400000000) by (compute_only);\n    assert((4096 as u64) << 23 == 0x800000000) by (compute_only);\n    assert((4096 as u64) << 24 == 0x1000000000) by (compute_only);\n    assert((4096 as u64) << 25 == 0x2000000000) by (compute_only);\n    assert((4096 as u64) << 26 == 0x4000000000) by (compute_only);\n    assert((4096 as u64) << 27 == 0x8000000000) by (compute_only);\n}\n\npub proof fn lemma_u64_and_less_than(a: u64, b: u64)\n    ensures\n        a & b <= a,\n        a & b <= b,\n        a & b <= max(a as int, b as int) as u64,\n{\n    assert(a & b <= a) by (bit_vector);\n    assert(a & b <= b) by (bit_vector);\n    let max = max(a as int, b as int) as u64;\n}\n\npub proof fn lemma_usize_mod_0_maintain_after_add(x: usize, m: usize)\n    requires\n        x % m == 0,\n        m > 0,\n    ensures\n        (x + m) % m as int == 0,\n{\n    use vstd::arithmetic::div_mod::*;\n\n    lemma_mod_adds(x as int, m as int, m as int);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/lock-protocol-rcu/src/helpers/math.rs", "verified": true, "metadata": {"original_id": "vostd_math_c3577f5d3987", "function_name": "", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_39670f69002a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 ,  { let mut i = 0 ; while i < N invariant 0 <= i <= N , b . len () == N , forall | k : int | 0 <= k < i ==> b [k] == N + 2 , N < 1000 , decreases N - i { assert (i < N) ; assert (0 <= i < b . len ()) ; assert (N < 1000) ; b [i as usize] = N + 2 ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures forall | k : int | 0 <= k < N ==> b [k] == N + 2 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , b . len () == N , forall | k : int | 0 <= k < i ==> b [k] == N + 2 , N < 1000 , decreases N - i { assert (i < N) ; assert (0 <= i < b . len ()) ; assert (N < 1000) ; b [i as usize] = N + 2 ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures forall | k : int | 0 <= k < N ==> b [k] == N + 2 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , b . len () == N , forall | k : int | 0 <= k < i ==> b [k] == N + 2 , N < 1000 , decreases N - i { assert (i < N) ; assert (0 <= i < b . len ()) ; assert (N < 1000) ; b [i as usize] = N + 2 ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/sina4_impl.rs", "verified": true, "metadata": {"original_id": "39670f69002a", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_a_629e386f9130", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn test_array_elements_precond (a : & Vec < i32 > , j : usize) -> bool { j < a . len () }\npub open spec fn test_array_elements_postcond (a : & Vec < i32 > , j : usize , result : & Vec < i32 >) -> bool { &&& result [j as int] == 60 &&& forall | k : int | 0 <= k < a . len () && k != j ==> result [k] == a [k] &&& result . len () == a . len () }\npub fn test_array_elements (a : & Vec < i32 > , j : usize) -> (result : Vec < i32 >)   { let mut result = a . clone () ; result . set (j , 60) ; result }\n\n} // verus!", "target_text": "requires test_array_elements_precond (a , j)\nensures test_array_elements_postcond (a , j , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn test_array_elements_precond (a : & Vec < i32 > , j : usize) -> bool { j < a . len () }\npub open spec fn test_array_elements_postcond (a : & Vec < i32 > , j : usize , result : & Vec < i32 >) -> bool { &&& result [j as int] == 60 &&& forall | k : int | 0 <= k < a . len () && k != j ==> result [k] == a [k] &&& result . len () == a . len () }\npub fn test_array_elements (a : & Vec < i32 > , j : usize) -> (result : Vec < i32 >) requires test_array_elements_precond (a , j) ensures test_array_elements_postcond (a , j , & result) { let mut result = a . clone () ; result . set (j , 60) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_97/verina_basic_97_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "629e386f9130", "function_name": "test_array_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_057da121d61c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , decreases j { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , decreases j { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , decreases j { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/reverse_impl.rs", "verified": true, "metadata": {"original_id": "057da121d61c", "function_name": "reverse", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_b8721ee3399f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_greater (N : i32) -> (i : i32) requires 0 <= N , ensures i == 0 , { let mut i = N ; while i > 0  { i = i - 1 ; } i }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_greater (N : i32) -> (i : i32) requires 0 <= N , ensures i == 0 , { let mut i = N ; while i > 0 invariant 0 <= i <= N , decreases i , { i = i - 1 ; } i }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_greater (N : i32) -> (i : i32) requires 0 <= N , ensures i == 0 , { let mut i = N ; while i > 0 invariant 0 <= i <= N , decreases i , { i = i - 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "b8721ee3399f", "function_name": "down_while_greater", "bug_type": "missing_invariant"}}
{"id": "task_a_fe0933fa19b0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool)  { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; for i in 0 .. l . len () - 1  { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } } is_non_decreasing || is_non_increasing }\n\n} // verus!", "target_text": "ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) \ninvariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; for i in 0 .. l . len () - 1 invariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) , { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } } is_non_decreasing || is_non_increasing }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/HumanEval-RustBench/057-monotonic_impl.rs", "verified": true, "metadata": {"original_id": "fe0933fa19b0", "function_name": "monotonic", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_c_missing_invariant_504950a7e62a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_60/verina_basic_60_iter_2_current.rs", "verified": true, "metadata": {"original_id": "504950a7e62a", "function_name": "find_even_numbers", "bug_type": "missing_invariant"}}
{"id": "task_a_24dfb26f36d8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_not_equal (N : i32) -> (i : i32)   { let mut i = N ; while i != 0  { i = i - 1 ; } i }\n\n} // verus!", "target_text": "requires 0 <= N \nensures i == 0 \ndecreases i \ninvariant 0 <= i <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn down_while_not_equal (N : i32) -> (i : i32) requires 0 <= N , ensures i == 0 , { let mut i = N ; while i != 0 invariant 0 <= i <= N , decreases i , { i = i - 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "24dfb26f36d8", "function_name": "down_while_not_equal", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_requires_384695c57c63", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)  ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/unverified/cell_2_sum_iter_0_original.rs", "verified": true, "metadata": {"original_id": "384695c57c63", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_assert_verus_thread_4de3d08ebc95", "task": "task_c", "input_text": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\nuse vstd::thread::*;\n\nverus! {\n\nfn test_calling_thread_id_twice_same_value() {\n    let (tid1, Tracked(is1)) = thread_id();\n    let (tid2, Tracked(is2)) = thread_id();\n    proof {\n        is1.agrees(is2);\n    }\n\n}\n\nfn test_calling_thread_id_twice_diff_threads() {\n    let (tid1, Tracked(is1)) = thread_id();\n    spawn(\n        move ||\n            {\n                let (tid2, Tracked(is2)) = thread_id();\n                // This isn't allowed: Send error\n                /*proof {\n            is1.agrees(is2);\n        }*/\n            },\n    );\n}\n\n} // verus!\nfn main() {}\n", "target_text": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\nuse vstd::thread::*;\n\nverus! {\n\nfn test_calling_thread_id_twice_same_value() {\n    let (tid1, Tracked(is1)) = thread_id();\n    let (tid2, Tracked(is2)) = thread_id();\n    proof {\n        is1.agrees(is2);\n    }\n    assert(tid1 == tid2);\n}\n\nfn test_calling_thread_id_twice_diff_threads() {\n    let (tid1, Tracked(is1)) = thread_id();\n    spawn(\n        move ||\n            {\n                let (tid2, Tracked(is2)) = thread_id();\n                // This isn't allowed: Send error\n                /*proof {\n            is1.agrees(is2);\n        }*/\n            },\n    );\n}\n\n} // verus!\nfn main() {}\n", "full_verified_code": "// rust_verify/tests/example.rs\n#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\nuse vstd::thread::*;\n\nverus! {\n\nfn test_calling_thread_id_twice_same_value() {\n    let (tid1, Tracked(is1)) = thread_id();\n    let (tid2, Tracked(is2)) = thread_id();\n    proof {\n        is1.agrees(is2);\n    }\n    assert(tid1 == tid2);\n}\n\nfn test_calling_thread_id_twice_diff_threads() {\n    let (tid1, Tracked(is1)) = thread_id();\n    spawn(\n        move ||\n            {\n                let (tid2, Tracked(is2)) = thread_id();\n                // This isn't allowed: Send error\n                /*proof {\n            is1.agrees(is2);\n        }*/\n            },\n    );\n}\n\n} // verus!\nfn main() {}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/thread.rs", "verified": true, "metadata": {"original_id": "verus_thread_4de3d08ebc95", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_a_8f3fd5a0a3d4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >)  { a . clone () }\n\n} // verus!", "target_text": "ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { a . clone () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_copy_impl.rs", "verified": true, "metadata": {"original_id": "8f3fd5a0a3d4", "function_name": "array_copy", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_6269b9f91ab1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == k { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_808_iter_1_current.rs", "verified": true, "metadata": {"original_id": "6269b9f91ab1", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_b_9ad0eb7ec4b8", "task": "task_b", "input_text": "fn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >)\nrequires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] \nensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_72/verina_basic_72_impl.rs", "verified": true, "metadata": {"original_id": "9ad0eb7ec4b8", "function_name": "copy", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_invariant_9d1ba670100f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 decreases a . len () { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >) requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1 ensures out . len () == size { let mut result = Vec :: new () ; let mut i = 0 ; while i < size  { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 decreases a . len () { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >) requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1 ensures out . len () == size { let mut result = Vec :: new () ; let mut i = 0 ; while i < size invariant i <= size , result . len () == i decreases size - i { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn array_squared_sum (a : Seq < int >) -> int recommends a . len () > 0 decreases a . len () { if a . len () <= 1 { if a . len () == 1 { a [0] * a [0] } else { 0 } } else { (a [0] * a [0]) + array_squared_sum (a . subrange (1 , a . len () as int)) } }\nfn gaussian (size : usize , q : Vec < i32 > , q_hat : Vec < i32 >) -> (out : Vec < i32 >) requires q_hat . len () == size , q . len () == size , size > 0 , array_squared_sum (q_hat @ . map (| i , x | x as int)) <= 1 ensures out . len () == size { let mut result = Vec :: new () ; let mut i = 0 ; while i < size invariant i <= size , result . len () == i decreases size - i { result . push (0) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/703FinalProject_tmp_tmpr_10rn4z_gaussian/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "9d1ba670100f", "function_name": "gaussian", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_e0f871158ef8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { let mut i = 0 ; while i < v . len () invariant i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (i == v . len ()) ; assert (exists | q : int | i <= q < v . len () && v [q] % 2 == 1) ; assert (false) ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { let mut i = 0 ; while i < v . len () invariant i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (i == v . len ()) ; assert (exists | q : int | i <= q < v . len () && v [q] % 2 == 1) ; assert (false) ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { let mut i = 0 ; while i < v . len () invariant i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (i == v . len ()) ; assert (exists | q : int | i <= q < v . len () && v [q] % 2 == 1) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/unverified/choose_odd_impl.rs", "verified": true, "metadata": {"original_id": "e0f871158ef8", "function_name": "choose_odd", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_dc28565fd671", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32)  { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_digits (x : nat) -> nat decreases x { if x == 0 { 0nat } else { (x % 10) + sum_of_digits (x / 10) } }\n# [verifier :: external_body] fn sum_of_digits_exec (x : u32) -> (result : u32) ensures result == sum_of_digits (x as nat) { let mut n = x ; let mut sum = 0u32 ; while n > 0 { sum = sum + (n % 10) ; n = n / 10 ; } sum }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_9/verina_advanced_9_impl.rs", "verified": true, "metadata": {"original_id": "dc28565fd671", "function_name": "sum_of_digits_exec", "bug_type": "missing_ensures"}}
{"id": "task_a_69bc9f5f3eee", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool)   { for idx in 1 .. arr . len ()  { if arr [idx - 1] > arr [idx] { return false ; } } true }\n\n} // verus!", "target_text": "requires arr . len () > 0 \nensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) \ninvariant forall | i : int , j : int | 0 <= i < j < idx ==> arr [i] <= arr [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { for idx in 1 .. arr . len () invariant forall | i : int , j : int | 0 <= i < j < idx ==> arr [i] <= arr [j] , { if arr [idx - 1] > arr [idx] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_567_impl.rs", "verified": true, "metadata": {"original_id": "69bc9f5f3eee", "function_name": "is_sorted", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_b_b6c141da2625", "task": "task_b", "input_text": "fn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)\nensures result == in_array (a @ , x) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j as int] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j as int] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/remove_duplicates_impl.rs", "verified": true, "metadata": {"original_id": "b6c141da2625", "function_name": "in_array_exec", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_requires_6edf0fc34933", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)  ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i , { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j , { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i , { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j , { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i , { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j , { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_240_impl.rs", "verified": true, "metadata": {"original_id": "6edf0fc34933", "function_name": "replace_last_element", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_85c81ee22263", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @)  { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len () invariant 0 <= i <= nums . len () , nums . len () > 0 decreases nums . len () - i { if nums [i] > max_val { max_val = nums [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len () invariant 0 <= i <= nums . len () , nums . len () > 0 decreases nums . len () - i { if nums [i] > max_val { max_val = nums [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_strength_postcond (nums : Seq < i64 > , result : i64) -> bool { nums . len () > 0 }\nspec fn max_strength_precond (nums : Seq < i64 >) -> bool { nums . len () > 0 }\nfn max_strength (nums : Vec < i64 >) -> (result : i64) requires max_strength_precond (nums @) ensures max_strength_postcond (nums @ , result) { let mut max_val = nums [0] ; let mut i = 1 ; while i < nums . len () invariant 0 <= i <= nums . len () , nums . len () > 0 decreases nums . len () - i { if nums [i] > max_val { max_val = nums [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_43/verina_advanced_43_iter_2_current.rs", "verified": true, "metadata": {"original_id": "85c81ee22263", "function_name": "max_strength", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_5e43ef69574e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < nums . len ()  { if nums [i] > nums [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < nums . len () invariant 0 <= max_idx && max_idx < nums . len () , 1 <= i && i <= nums . len () , forall | j : int | 0 <= j && j < i ==> nums [j] <= nums [max_idx as int] , decreases nums . len () - i { if nums [i] > nums [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx : usize = 0 ; let mut i : usize = 1 ; while i < nums . len () invariant 0 <= max_idx && max_idx < nums . len () , 1 <= i && i <= nums . len () , forall | j : int | 0 <= j && j < i ==> nums [j] <= nums [max_idx as int] , decreases nums . len () - i { if nums [i] > nums [max_idx] { max_idx = i ; } i = i + 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/max_array_impl.rs", "verified": true, "metadata": {"original_id": "5e43ef69574e", "function_name": "max_array", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_1c9aefc878f6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >)  { }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >) ensures intervals @ . len () == old (intervals) @ . len () { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >) ensures intervals @ . len () == old (intervals) @ . len () { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_38/verina_advanced_38_iter_0_original.rs", "verified": true, "metadata": {"original_id": "1c9aefc878f6", "function_name": "sort_intervals", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_verus_integers_4d5451d5deb7", "task": "task_c", "input_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn add1_int(i: int) -> int {\n    i + 1\n}\n\nspec fn add1_nat(i: nat) -> nat {\n    i + 1\n}\n\n#[verifier::opaque]\nspec fn add1_nat_opaque(i: nat) -> nat {\n    i + 1\n}\n\nproof fn test0() -> (n: nat)\n    ensures\n        true,\n{\n    100\n}\n\nproof fn test1(i: int, n: nat, u: u8) {\n\n    //  // FAILS\n\n    //  // FAILS, because 256 is a u8 in u < 256\n    let n0 = test0();\n\n    //  // FAILS\n\n}\n\n} // verus!\n/*\nfn typing(u: u64, i: int, n: nat) -> int {\n    let u2 = i as u64;\n    let i2 = u as int;\n    let i3: int = u; // implicit coercion ok\n    //let i4: int = u + 1; // implicit coercion disallowed\n    //let u3: u64 = i; // implicit coercion disallowed\n    let i5: int = n; // implicit coercion ok\n    //let n2: nat = i; // implicit coercion disallowed\n    let n3: nat = 10;\n    let i6: int = -10;\n    let u3: u8 = 300;\n     // should fail\n    let x = 2 + 2;\n    x\n}\n*/\n", "target_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn add1_int(i: int) -> int {\n    i + 1\n}\n\nspec fn add1_nat(i: nat) -> nat {\n    i + 1\n}\n\n#[verifier::opaque]\nspec fn add1_nat_opaque(i: nat) -> nat {\n    i + 1\n}\n\nproof fn test0() -> (n: nat)\n    ensures\n        true,\n{\n    100\n}\n\nproof fn test1(i: int, n: nat, u: u8) {\n    assert(n >= 0);\n    assert(u >= 0);\n    assert(n + n >= 0);\n    assert((add(u, u) as int) < 256);\n    assert(u < 100 ==> (add(u, u) as int) < 250);\n    assert(add1_int(u as int) == u as int + 1);\n    // assert(add1_int(u) == (u + 1) as int); // FAILS\n    assert(add1_nat(u as nat) == u as nat + 1);\n    // assert((u as int) < 256 ==> u < 256); // FAILS, because 256 is a u8 in u < 256\n    let n0 = test0();\n    assert(n0 >= 0);\n    assert(add1_nat_opaque(5) >= 0);\n    // assert(i / 2 <= n); // FAILS\n    assert(n / 2 <= n);\n    assert(u / 2 <= u);\n    assert(u % 10 < 10);\n}\n\n} // verus!\n/*\nfn typing(u: u64, i: int, n: nat) -> int {\n    let u2 = i as u64;\n    let i2 = u as int;\n    let i3: int = u; // implicit coercion ok\n    //let i4: int = u + 1; // implicit coercion disallowed\n    //let u3: u64 = i; // implicit coercion disallowed\n    let i5: int = n; // implicit coercion ok\n    //let n2: nat = i; // implicit coercion disallowed\n    let n3: nat = 10;\n    let i6: int = -10;\n    let u3: u8 = 300;\n    assert(u3 > 100); // should fail\n    let x = 2 + 2;\n    x\n}\n*/\n", "full_verified_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\nfn main() {\n}\n\nspec fn add1_int(i: int) -> int {\n    i + 1\n}\n\nspec fn add1_nat(i: nat) -> nat {\n    i + 1\n}\n\n#[verifier::opaque]\nspec fn add1_nat_opaque(i: nat) -> nat {\n    i + 1\n}\n\nproof fn test0() -> (n: nat)\n    ensures\n        true,\n{\n    100\n}\n\nproof fn test1(i: int, n: nat, u: u8) {\n    assert(n >= 0);\n    assert(u >= 0);\n    assert(n + n >= 0);\n    assert((add(u, u) as int) < 256);\n    assert(u < 100 ==> (add(u, u) as int) < 250);\n    assert(add1_int(u as int) == u as int + 1);\n    // assert(add1_int(u) == (u + 1) as int); // FAILS\n    assert(add1_nat(u as nat) == u as nat + 1);\n    // assert((u as int) < 256 ==> u < 256); // FAILS, because 256 is a u8 in u < 256\n    let n0 = test0();\n    assert(n0 >= 0);\n    assert(add1_nat_opaque(5) >= 0);\n    // assert(i / 2 <= n); // FAILS\n    assert(n / 2 <= n);\n    assert(u / 2 <= u);\n    assert(u % 10 < 10);\n}\n\n} // verus!\n/*\nfn typing(u: u64, i: int, n: nat) -> int {\n    let u2 = i as u64;\n    let i2 = u as int;\n    let i3: int = u; // implicit coercion ok\n    //let i4: int = u + 1; // implicit coercion disallowed\n    //let u3: u64 = i; // implicit coercion disallowed\n    let i5: int = n; // implicit coercion ok\n    //let n2: nat = i; // implicit coercion disallowed\n    let n3: nat = 10;\n    let i6: int = -10;\n    let u3: u8 = 300;\n    assert(u3 > 100); // should fail\n    let x = 2 + 2;\n    x\n}\n*/\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/integers.rs", "verified": true, "metadata": {"original_id": "verus_integers_4d5451d5deb7", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_a_2e7cedc68edf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >)   { let mut result = a ; let old_val = result [4] ; result . set (4 , old_val + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "target_text": "requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN\nensures update_elements_postcond (& a , & result)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn update_elements_postcond (a : & Vec < i32 > , result : & Vec < i32 >) -> bool { &&& result . len () == a . len () &&& result [4] == a [4] + 3 &&& result [7] == 516 &&& forall | i : int | 0 <= i < a . len () && i != 4 && i != 7 ==> result [i] == a [i] }\nspec fn update_elements_precond (a : & Vec < i32 >) -> bool { a . len () >= 8 }\nfn update_elements (a : Vec < i32 >) -> (result : Vec < i32 >) requires update_elements_precond (& a) , a [4] < MAX - 3 , a [4] > MIN ensures update_elements_postcond (& a , & result) { let mut result = a ; let old_val = result [4] ; result . set (4 , old_val + 3) ; result . set (7 , 516) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_103/verina_basic_103_iter_2_current.rs", "verified": true, "metadata": {"original_id": "2e7cedc68edf", "function_name": "update_elements", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_requires_verus_chapter-1-22_fa6ac1200b1d", "task": "task_c", "input_text": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\n#[is_variant]\n#[derive(PartialEq, Eq)]  // TODO(utaal): Structural is not implemented for Box\nenum Tree {\n    Nil,\n    Node { value: i64, left: Box<Tree>, right: Box<Tree> },\n}\n\nimpl Tree {\n    spec fn view(&self) -> Seq<int>\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => seq![],\n            Tree::Node { value, left, right } => left@.add(seq![value as int]).add(right@),\n        }\n    }\n\n    spec fn is_sorted(&self) -> bool\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => true,\n            Tree::Node { value, left, right } => {\n                &&& sequences_ordered_at_interface(left@, seq![value as int])\n                &&& sequences_ordered_at_interface(seq![value as int], right@)\n                &&& left.is_sorted()\n                &&& right.is_sorted()\n            },\n        }\n    }// #[verifier::proof] fn sorted_tree_means_sorted_sequence(&self)\n    // TODO(utaal): is self being Spec too restrictive?\n\n}\n\nspec fn sequences_ordered_at_interface(seq1: Seq<int>, seq2: Seq<int>) -> bool {\n    if seq1.len() == 0 || seq2.len() == 0 {\n        true\n    } else {\n        seq1.last() <= seq2[0]\n    }\n}\n\nspec fn sequence_is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\n// TODO: change the default for --multiple-errors\n// we can have --jon-mode :p\n// TODO: shall multiple errors in the same method be sorted?\nproof fn sorted_tree_means_sorted_sequence(tree: Tree)\n\n    ensures\n        sequence_is_sorted(tree@),\n    decreases tree  // guessed by Dafny ,\n{\n    // reveal_with_fuel(sorted_tree_means_sorted_sequence, 3); // TODO(utaal) ICE revealing current method with fuel panics in AIR\n    if let Tree::Node { left, right, value: _ } = tree {\n        sorted_tree_means_sorted_sequence(*left);  // guessed by Dafny\n        sorted_tree_means_sorted_sequence(*right);  // guessed by Dafny\n    }\n}\n\n#[is_variant]\n#[derive(Eq, PartialEq, Structural)]\nenum TreeSortedness {\n    Unsorted,\n    Empty,\n    Bounded(i64, i64),\n}\n\nfn check_is_sorted_tree(tree: &Tree) -> (ret: TreeSortedness)\n    ensures\n        tree.is_sorted() == !ret.is_Unsorted(),\n        tree.is_Nil() == ret.is_Empty(),\n        if let TreeSortedness::Bounded(l, r) = ret {\n            l == tree@[0] && r == tree@.last()\n        } else {\n            true\n        },\n// TODO: suboptimal span for error message:\n// error: postcondition not satisfied\n//   --> rust_verify/example/summer_school.rs:82:13\n//    |\n// 82 |             TreeSortedness::Unsorted => true,\n//    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => TreeSortedness::Empty,\n        Tree::Node { left, value, right } => {\n            let left_sortedness = check_is_sorted_tree(left);\n            let left_bound;\n            match left_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => left_bound = *value,\n                TreeSortedness::Bounded(ll, lr) => if !(lr <= *value) {\n                    // assert(!sequences_ordered_at_interface(left@, seq![*value as int]));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(left@[0] == ll);\n                    // assert(left@.last() == lr);\n                    // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n                    left_bound = ll;\n                },\n            }\n            // assert(left.is_Nil() ==> left_sortedness.is_Empty());\n            // assert(left_sortedness.is_Empty() ==> left.is_Nil());\n\n            let right_sortedness = check_is_sorted_tree(right);\n            let right_bound;\n            match right_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => right_bound = *value,\n                TreeSortedness::Bounded(rl, rr) => if !(*value <= rl) {\n                    // assert(!sequences_ordered_at_interface(seq![*value as int], right@));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(*value <= rl);\n                    // assert(right@.last() == rr);\n                    // assert(right@[0] == rl);\n                    // assert(seq![*value as int].last() == *value as int);\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    right_bound = rr;\n                },\n            }\n            proof {\n                sorted_tree_means_sorted_sequence(**left);\n                sorted_tree_means_sorted_sequence(**right);\n            }\n            // assert(equal(tree@, left@.add(seq![*value as int]).add(right@)));\n            // assert(tree@.len() > 0);\n            // assert(left.is_sorted());\n            // assert(right.is_sorted());\n            // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n            // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n            // assert(tree.is_sorted());\n            // TODO cannot use proof variable inside forall/assert_by statements (left)\n            // #[verifier::spec] let left = left;\n            // assert_by(left_bound == tree@[0], {\n            //     if left.is_Nil() {\n            //         assert(left_sortedness.is_Empty());\n            //         assert(*value as int == tree@[0]);\n            //         assert(left_bound == *value);\n            //         assert(left_bound == tree@[0]);\n            //     } else {\n            //         assert(left_bound == tree@[0]);\n            //     }\n            // });\n            assert(right_bound == tree@.last());\n            TreeSortedness::Bounded(left_bound, right_bound)\n        },\n    }\n}\n\nfn find_in_binary_tree(tree: &Tree, needle: i64) -> (ret: bool)\n\n    ensures\n        ret == tree@.contains(needle as int),\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => false,\n        Tree::Node { left, value, right } => {\n            if needle == *value {\n                assert(tree@[left@.len() as int] == needle);  // trigger\n                true\n            } else if needle < *value {\n                let ret = find_in_binary_tree(left, needle);\n                if ret {\n                    //let idx = choose(|idx: nat| idx < left@.len() && left@.index(nat) == needle); // TODO(utaal): bad error message for stray nat?\n                    proof {\n                        let idx = choose|idx: int| 0 <= idx < left@.len() && left@[idx] == needle;\n                        assert(tree@[idx] == needle);  // trigger\n                    }\n                } else {\n                    proof {\n                        sorted_tree_means_sorted_sequence(**right);\n                    }\n                    //                    assert_forall_by(|idx: nat| {\n                    //                        requires(idx < tree@.len());\n                    //                        ensures(tree@.index(idx) != needle);\n                    //                        if idx < left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else if idx==left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else {\n                    //                          assert(tree@.index(idx) == right@.index(idx + left@.len() + 1));    // TODO(utaal): surprising complaint \"expected struct `verus_builtin::int`, found struct `verus_builtin::nat`\"\n                    //                          #[verifier::spec] let right_idx: int = idx - (left@.len() as int + 1);\n                    //                          assert(tree@.index(idx) == right@.index(right_idx));\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@)); // TODO(utal): How about *value as int is just value@? And then maybe even auto_view that? How cool would that be?\n                    //                          assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    //                          assert(sequence_is_sorted(right@));\n                    //                          if 0 < right_idx {\n                    //                            assert(right@.index(0) <= right@.index(right_idx));\n                    //                          }\n                    //                          assert((*value as int) <= right@.index(right_idx));\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        }\n                    //                    });\n                }\n                //                assert(ret == tree@.contains(needle));\n\n                ret\n            } else {\n                let ret = find_in_binary_tree(right, needle);\n                proof {\n                    if ret {\n                        let idx = choose|idx: int| 0 <= idx < right@.len() && right@[idx] == needle;\n                        assert(tree@[left@.len() + 1 + idx] == needle);  // trigger\n                    } else {\n                        sorted_tree_means_sorted_sequence(**left);\n                    }\n                }\n                //                assert(ret == tree@.contains(needle));    // TODO(jonh): symmetric case incomplete\n                ret\n            }\n        },\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\n#[is_variant]\n#[derive(PartialEq, Eq)]  // TODO(utaal): Structural is not implemented for Box\nenum Tree {\n    Nil,\n    Node { value: i64, left: Box<Tree>, right: Box<Tree> },\n}\n\nimpl Tree {\n    spec fn view(&self) -> Seq<int>\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => seq![],\n            Tree::Node { value, left, right } => left@.add(seq![value as int]).add(right@),\n        }\n    }\n\n    spec fn is_sorted(&self) -> bool\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => true,\n            Tree::Node { value, left, right } => {\n                &&& sequences_ordered_at_interface(left@, seq![value as int])\n                &&& sequences_ordered_at_interface(seq![value as int], right@)\n                &&& left.is_sorted()\n                &&& right.is_sorted()\n            },\n        }\n    }// #[verifier::proof] fn sorted_tree_means_sorted_sequence(&self)\n    // TODO(utaal): is self being Spec too restrictive?\n\n}\n\nspec fn sequences_ordered_at_interface(seq1: Seq<int>, seq2: Seq<int>) -> bool {\n    if seq1.len() == 0 || seq2.len() == 0 {\n        true\n    } else {\n        seq1.last() <= seq2[0]\n    }\n}\n\nspec fn sequence_is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\n// TODO: change the default for --multiple-errors\n// we can have --jon-mode :p\n// TODO: shall multiple errors in the same method be sorted?\nproof fn sorted_tree_means_sorted_sequence(tree: Tree)\n    requires\n        tree.is_sorted(),\n    ensures\n        sequence_is_sorted(tree@),\n    decreases tree  // guessed by Dafny ,\n{\n    // reveal_with_fuel(sorted_tree_means_sorted_sequence, 3); // TODO(utaal) ICE revealing current method with fuel panics in AIR\n    if let Tree::Node { left, right, value: _ } = tree {\n        sorted_tree_means_sorted_sequence(*left);  // guessed by Dafny\n        sorted_tree_means_sorted_sequence(*right);  // guessed by Dafny\n    }\n}\n\n#[is_variant]\n#[derive(Eq, PartialEq, Structural)]\nenum TreeSortedness {\n    Unsorted,\n    Empty,\n    Bounded(i64, i64),\n}\n\nfn check_is_sorted_tree(tree: &Tree) -> (ret: TreeSortedness)\n    ensures\n        tree.is_sorted() == !ret.is_Unsorted(),\n        tree.is_Nil() == ret.is_Empty(),\n        if let TreeSortedness::Bounded(l, r) = ret {\n            l == tree@[0] && r == tree@.last()\n        } else {\n            true\n        },\n// TODO: suboptimal span for error message:\n// error: postcondition not satisfied\n//   --> rust_verify/example/summer_school.rs:82:13\n//    |\n// 82 |             TreeSortedness::Unsorted => true,\n//    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => TreeSortedness::Empty,\n        Tree::Node { left, value, right } => {\n            let left_sortedness = check_is_sorted_tree(left);\n            let left_bound;\n            match left_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => left_bound = *value,\n                TreeSortedness::Bounded(ll, lr) => if !(lr <= *value) {\n                    // assert(!sequences_ordered_at_interface(left@, seq![*value as int]));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(left@[0] == ll);\n                    // assert(left@.last() == lr);\n                    // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n                    left_bound = ll;\n                },\n            }\n            // assert(left.is_Nil() ==> left_sortedness.is_Empty());\n            // assert(left_sortedness.is_Empty() ==> left.is_Nil());\n\n            let right_sortedness = check_is_sorted_tree(right);\n            let right_bound;\n            match right_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => right_bound = *value,\n                TreeSortedness::Bounded(rl, rr) => if !(*value <= rl) {\n                    // assert(!sequences_ordered_at_interface(seq![*value as int], right@));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(*value <= rl);\n                    // assert(right@.last() == rr);\n                    // assert(right@[0] == rl);\n                    // assert(seq![*value as int].last() == *value as int);\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    right_bound = rr;\n                },\n            }\n            proof {\n                sorted_tree_means_sorted_sequence(**left);\n                sorted_tree_means_sorted_sequence(**right);\n            }\n            // assert(equal(tree@, left@.add(seq![*value as int]).add(right@)));\n            // assert(tree@.len() > 0);\n            // assert(left.is_sorted());\n            // assert(right.is_sorted());\n            // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n            // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n            // assert(tree.is_sorted());\n            // TODO cannot use proof variable inside forall/assert_by statements (left)\n            // #[verifier::spec] let left = left;\n            // assert_by(left_bound == tree@[0], {\n            //     if left.is_Nil() {\n            //         assert(left_sortedness.is_Empty());\n            //         assert(*value as int == tree@[0]);\n            //         assert(left_bound == *value);\n            //         assert(left_bound == tree@[0]);\n            //     } else {\n            //         assert(left_bound == tree@[0]);\n            //     }\n            // });\n            assert(right_bound == tree@.last());\n            TreeSortedness::Bounded(left_bound, right_bound)\n        },\n    }\n}\n\nfn find_in_binary_tree(tree: &Tree, needle: i64) -> (ret: bool)\n    requires\n        tree.is_sorted(),\n    ensures\n        ret == tree@.contains(needle as int),\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => false,\n        Tree::Node { left, value, right } => {\n            if needle == *value {\n                assert(tree@[left@.len() as int] == needle);  // trigger\n                true\n            } else if needle < *value {\n                let ret = find_in_binary_tree(left, needle);\n                if ret {\n                    //let idx = choose(|idx: nat| idx < left@.len() && left@.index(nat) == needle); // TODO(utaal): bad error message for stray nat?\n                    proof {\n                        let idx = choose|idx: int| 0 <= idx < left@.len() && left@[idx] == needle;\n                        assert(tree@[idx] == needle);  // trigger\n                    }\n                } else {\n                    proof {\n                        sorted_tree_means_sorted_sequence(**right);\n                    }\n                    //                    assert_forall_by(|idx: nat| {\n                    //                        requires(idx < tree@.len());\n                    //                        ensures(tree@.index(idx) != needle);\n                    //                        if idx < left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else if idx==left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else {\n                    //                          assert(tree@.index(idx) == right@.index(idx + left@.len() + 1));    // TODO(utaal): surprising complaint \"expected struct `verus_builtin::int`, found struct `verus_builtin::nat`\"\n                    //                          #[verifier::spec] let right_idx: int = idx - (left@.len() as int + 1);\n                    //                          assert(tree@.index(idx) == right@.index(right_idx));\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@)); // TODO(utal): How about *value as int is just value@? And then maybe even auto_view that? How cool would that be?\n                    //                          assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    //                          assert(sequence_is_sorted(right@));\n                    //                          if 0 < right_idx {\n                    //                            assert(right@.index(0) <= right@.index(right_idx));\n                    //                          }\n                    //                          assert((*value as int) <= right@.index(right_idx));\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        }\n                    //                    });\n                }\n                //                assert(ret == tree@.contains(needle));\n\n                ret\n            } else {\n                let ret = find_in_binary_tree(right, needle);\n                proof {\n                    if ret {\n                        let idx = choose|idx: int| 0 <= idx < right@.len() && right@[idx] == needle;\n                        assert(tree@[left@.len() + 1 + idx] == needle);  // trigger\n                    } else {\n                        sorted_tree_means_sorted_sequence(**left);\n                    }\n                }\n                //                assert(ret == tree@.contains(needle));    // TODO(jonh): symmetric case incomplete\n                ret\n            }\n        },\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\n#[is_variant]\n#[derive(PartialEq, Eq)]  // TODO(utaal): Structural is not implemented for Box\nenum Tree {\n    Nil,\n    Node { value: i64, left: Box<Tree>, right: Box<Tree> },\n}\n\nimpl Tree {\n    spec fn view(&self) -> Seq<int>\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => seq![],\n            Tree::Node { value, left, right } => left@.add(seq![value as int]).add(right@),\n        }\n    }\n\n    spec fn is_sorted(&self) -> bool\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => true,\n            Tree::Node { value, left, right } => {\n                &&& sequences_ordered_at_interface(left@, seq![value as int])\n                &&& sequences_ordered_at_interface(seq![value as int], right@)\n                &&& left.is_sorted()\n                &&& right.is_sorted()\n            },\n        }\n    }// #[verifier::proof] fn sorted_tree_means_sorted_sequence(&self)\n    // TODO(utaal): is self being Spec too restrictive?\n\n}\n\nspec fn sequences_ordered_at_interface(seq1: Seq<int>, seq2: Seq<int>) -> bool {\n    if seq1.len() == 0 || seq2.len() == 0 {\n        true\n    } else {\n        seq1.last() <= seq2[0]\n    }\n}\n\nspec fn sequence_is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\n// TODO: change the default for --multiple-errors\n// we can have --jon-mode :p\n// TODO: shall multiple errors in the same method be sorted?\nproof fn sorted_tree_means_sorted_sequence(tree: Tree)\n    requires\n        tree.is_sorted(),\n    ensures\n        sequence_is_sorted(tree@),\n    decreases tree  // guessed by Dafny ,\n{\n    // reveal_with_fuel(sorted_tree_means_sorted_sequence, 3); // TODO(utaal) ICE revealing current method with fuel panics in AIR\n    if let Tree::Node { left, right, value: _ } = tree {\n        sorted_tree_means_sorted_sequence(*left);  // guessed by Dafny\n        sorted_tree_means_sorted_sequence(*right);  // guessed by Dafny\n    }\n}\n\n#[is_variant]\n#[derive(Eq, PartialEq, Structural)]\nenum TreeSortedness {\n    Unsorted,\n    Empty,\n    Bounded(i64, i64),\n}\n\nfn check_is_sorted_tree(tree: &Tree) -> (ret: TreeSortedness)\n    ensures\n        tree.is_sorted() == !ret.is_Unsorted(),\n        tree.is_Nil() == ret.is_Empty(),\n        if let TreeSortedness::Bounded(l, r) = ret {\n            l == tree@[0] && r == tree@.last()\n        } else {\n            true\n        },\n// TODO: suboptimal span for error message:\n// error: postcondition not satisfied\n//   --> rust_verify/example/summer_school.rs:82:13\n//    |\n// 82 |             TreeSortedness::Unsorted => true,\n//    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => TreeSortedness::Empty,\n        Tree::Node { left, value, right } => {\n            let left_sortedness = check_is_sorted_tree(left);\n            let left_bound;\n            match left_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => left_bound = *value,\n                TreeSortedness::Bounded(ll, lr) => if !(lr <= *value) {\n                    // assert(!sequences_ordered_at_interface(left@, seq![*value as int]));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(left@[0] == ll);\n                    // assert(left@.last() == lr);\n                    // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n                    left_bound = ll;\n                },\n            }\n            // assert(left.is_Nil() ==> left_sortedness.is_Empty());\n            // assert(left_sortedness.is_Empty() ==> left.is_Nil());\n\n            let right_sortedness = check_is_sorted_tree(right);\n            let right_bound;\n            match right_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => right_bound = *value,\n                TreeSortedness::Bounded(rl, rr) => if !(*value <= rl) {\n                    // assert(!sequences_ordered_at_interface(seq![*value as int], right@));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(*value <= rl);\n                    // assert(right@.last() == rr);\n                    // assert(right@[0] == rl);\n                    // assert(seq![*value as int].last() == *value as int);\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    right_bound = rr;\n                },\n            }\n            proof {\n                sorted_tree_means_sorted_sequence(**left);\n                sorted_tree_means_sorted_sequence(**right);\n            }\n            // assert(equal(tree@, left@.add(seq![*value as int]).add(right@)));\n            // assert(tree@.len() > 0);\n            // assert(left.is_sorted());\n            // assert(right.is_sorted());\n            // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n            // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n            // assert(tree.is_sorted());\n            // TODO cannot use proof variable inside forall/assert_by statements (left)\n            // #[verifier::spec] let left = left;\n            // assert_by(left_bound == tree@[0], {\n            //     if left.is_Nil() {\n            //         assert(left_sortedness.is_Empty());\n            //         assert(*value as int == tree@[0]);\n            //         assert(left_bound == *value);\n            //         assert(left_bound == tree@[0]);\n            //     } else {\n            //         assert(left_bound == tree@[0]);\n            //     }\n            // });\n            assert(right_bound == tree@.last());\n            TreeSortedness::Bounded(left_bound, right_bound)\n        },\n    }\n}\n\nfn find_in_binary_tree(tree: &Tree, needle: i64) -> (ret: bool)\n    requires\n        tree.is_sorted(),\n    ensures\n        ret == tree@.contains(needle as int),\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => false,\n        Tree::Node { left, value, right } => {\n            if needle == *value {\n                assert(tree@[left@.len() as int] == needle);  // trigger\n                true\n            } else if needle < *value {\n                let ret = find_in_binary_tree(left, needle);\n                if ret {\n                    //let idx = choose(|idx: nat| idx < left@.len() && left@.index(nat) == needle); // TODO(utaal): bad error message for stray nat?\n                    proof {\n                        let idx = choose|idx: int| 0 <= idx < left@.len() && left@[idx] == needle;\n                        assert(tree@[idx] == needle);  // trigger\n                    }\n                } else {\n                    proof {\n                        sorted_tree_means_sorted_sequence(**right);\n                    }\n                    //                    assert_forall_by(|idx: nat| {\n                    //                        requires(idx < tree@.len());\n                    //                        ensures(tree@.index(idx) != needle);\n                    //                        if idx < left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else if idx==left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else {\n                    //                          assert(tree@.index(idx) == right@.index(idx + left@.len() + 1));    // TODO(utaal): surprising complaint \"expected struct `verus_builtin::int`, found struct `verus_builtin::nat`\"\n                    //                          #[verifier::spec] let right_idx: int = idx - (left@.len() as int + 1);\n                    //                          assert(tree@.index(idx) == right@.index(right_idx));\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@)); // TODO(utal): How about *value as int is just value@? And then maybe even auto_view that? How cool would that be?\n                    //                          assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    //                          assert(sequence_is_sorted(right@));\n                    //                          if 0 < right_idx {\n                    //                            assert(right@.index(0) <= right@.index(right_idx));\n                    //                          }\n                    //                          assert((*value as int) <= right@.index(right_idx));\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        }\n                    //                    });\n                }\n                //                assert(ret == tree@.contains(needle));\n\n                ret\n            } else {\n                let ret = find_in_binary_tree(right, needle);\n                proof {\n                    if ret {\n                        let idx = choose|idx: int| 0 <= idx < right@.len() && right@[idx] == needle;\n                        assert(tree@[left@.len() + 1 + idx] == needle);  // trigger\n                    } else {\n                        sorted_tree_means_sorted_sequence(**left);\n                    }\n                }\n                //                assert(ret == tree@.contains(needle));    // TODO(jonh): symmetric case incomplete\n                ret\n            }\n        },\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/summer_school/chapter-1-22.rs", "verified": true, "metadata": {"original_id": "verus_chapter-1-22_fa6ac1200b1d", "function_name": "", "bug_type": "missing_requires"}}
{"id": "task_b_9cf715209978", "task": "task_b", "input_text": "fn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)\nrequires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == (arr1 [j] % arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == (arr1 [j] % arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_616_impl.rs", "verified": true, "metadata": {"original_id": "9cf715209978", "function_name": "element_wise_module", "has_invariants": true, "has_asserts": true}}
{"id": "task_c_missing_requires_65b358753fce", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool)  ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_int (a : int , b : int) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_compare/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "65b358753fce", "function_name": "compare_int", "bug_type": "missing_requires"}}
{"id": "task_a_verus_exec_attr_8a9f2ac676ab", "task": "task_a", "input_text": "#![feature(proc_macro_hygiene)]\n\nuse vstd::prelude::*;\n\n// ANCHOR: verus_spec\n#[verus_spec(sum =>\n\n{\n    x + y\n}\n// ANCHOR_END: verus_spec\n\n// ANCHOR: loop\n#[verus_spec(v =>  {\n    let mut v: Vec<u32> = Vec::new();\n\n    #[verus_spec(\n        {\n        v.push(i);\n    }\n    v\n}\n// ANCHOR_END: loop\n\n// ANCHOR: proof\n#[verus_spec]\nfn exec_with_proof() {\n   proof_decl!{\n     let ghost mut i = 0int;\n\n   }\n   test_for_loop(10);\n   proof!{\n\n   }\n}\n// ANCHOR_END: proof\n\n// ANCHOR: proof_with\n#[verus_spec(ret =>\nwith\n  Tracked(y): Tracked<&mut u32>,\n  Ghost(w): Ghost<u32>\n     -> z: Ghost<u32>\n\n {\n  proof! {\n    *y = x;\n  }\n  proof_with!(|= Ghost(x));\n  (x + 1)\n}\n\n#[verus_spec]\nfn exec_tracked_test(x: u32) {\n  proof_decl!{\n    let ghost mut z = 0u32;\n    let tracked mut y = 0u32;\n  }\n\n  proof_with!{Tracked(&mut y), Ghost(0) => Ghost(z)}\n  let x = exec_tracked(1);\n\n  proof!{\n\n  }\n}\n\nfn exec_external_test(x: u32) -> u32 {\n   exec_tracked(1)\n}\n\n// ANCHOR_END: proof_with\n\n// ANCHOR: dual_spec\n#[verus_verify(dual_spec)]\n#[verus_spec(\n     {\n    proof!{\n\n    }\n    {\n        proof!{}\n        x + y\n    }\n}\n\n#[verus_verify(dual_spec)]\n#[verus_spec(\n     {\n    f(x, 1)\n}\n// ANCHOR_END: dual_spec\n", "target_text": "requires x < 100,\n  *old(y) < 100, x < 100,\n        y < 100,\n    returns f(x, y)\n)]\nfn f(x: u32, y: u32) -> u32\nensures true)]\nfn test_for_loop(n: u32) -> Vec<u32>, sum < 200, \n)]\nfn my_exec_fun(x: u32, y: u32) -> u32, *y == x,\n  ret == x + 1,\n  z@ == x,\n)]\nfn exec_tracked(x: u32) -> u32\ninvariant v@ =~= Seq::new(i as nat, |k| k as u32),\n    )]\n    for i in 0..n", "full_verified_code": "#![feature(proc_macro_hygiene)]\n\nuse vstd::prelude::*;\n\n// ANCHOR: verus_spec\n#[verus_spec(sum => \n     requires \n         x < 100, \n         y < 100, \n     ensures \n         sum < 200, \n)]\nfn my_exec_fun(x: u32, y: u32) -> u32 \n{ \n    x + y \n}\n// ANCHOR_END: verus_spec\n\n// ANCHOR: loop\n#[verus_spec(v => ensures true)]\nfn test_for_loop(n: u32) -> Vec<u32> {\n    let mut v: Vec<u32> = Vec::new();\n\n    #[verus_spec(\n       invariant\n           v@ =~= Seq::new(i as nat, |k| k as u32),\n    )]\n    for i in 0..n {\n        v.push(i);\n    }\n    v\n}\n// ANCHOR_END: loop\n\n// ANCHOR: proof\n#[verus_spec]\nfn exec_with_proof() {\n   proof_decl!{\n     let ghost mut i = 0int;\n     assert(true);\n   }\n   test_for_loop(10);\n   proof!{\n     assert(i == 0);\n   }\n}\n// ANCHOR_END: proof\n\n// ANCHOR: proof_with\n#[verus_spec(ret =>\nwith\n  Tracked(y): Tracked<&mut u32>,\n  Ghost(w): Ghost<u32> \n     -> z: Ghost<u32>\nrequires\n  x < 100,\n  *old(y) < 100,\nensures\n  *y == x,\n  ret == x + 1,\n  z@ == x,\n)]\nfn exec_tracked(x: u32) -> u32 {\n  proof! {\n    *y = x;\n  }\n  proof_with!(|= Ghost(x));\n  (x + 1)\n}\n\n\n#[verus_spec]\nfn exec_tracked_test(x: u32) {\n  proof_decl!{\n    let ghost mut z = 0u32;\n    let tracked mut y = 0u32;\n  }\n\n  proof_with!{Tracked(&mut y), Ghost(0) => Ghost(z)}\n  let x = exec_tracked(1);\n\n  proof!{\n    assert(y == 1);\n    assert(z == 1);\n    assert(x == 2);\n  }\n}\n\nfn exec_external_test(x: u32) -> u32 {\n   exec_tracked(1)\n}\n\n// ANCHOR_END: proof_with\n\n// ANCHOR: dual_spec\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n    returns f(x, y)\n)]\nfn f(x: u32, y: u32) -> u32 {\n    proof!{\n        assert(true);\n    }\n    {\n        proof!{assert(true);}\n        x + y\n    }\n}\n\n#[verus_verify(dual_spec)]\n#[verus_spec(\n    requires\n        x < 100,\n    returns\n        f2(x),\n)]\npub fn f2(x: u32) -> u32 {\n    f(x, 1)\n}\n// ANCHOR_END: dual_spec\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/exec_attr.rs", "verified": true, "metadata": {"original_id": "verus_exec_attr_8a9f2ac676ab", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_ef07e1ebdfb8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32)   { if i < 0 { - i } else { i } }\n\n} // verus!", "target_text": "requires i != MIN \nensures i < 0 ==> res == - i , i >= 0 ==> res == i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/has_close_elements_iter_3_current.rs", "verified": true, "metadata": {"original_id": "ef07e1ebdfb8", "function_name": "abs", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_invariant_efd0d863cf28", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len ()  { result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant idx <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_399_impl.rs", "verified": true, "metadata": {"original_id": "efd0d863cf28", "function_name": "bit_wise_xor", "bug_type": "missing_invariant"}}
{"id": "task_a_1ed56038c628", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic () -> (result : i32) ensures result < 10 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/arithmetic_weird_iter_0_original.rs", "verified": true, "metadata": {"original_id": "1ed56038c628", "function_name": "arithmetic", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_cb3b4c22af88", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0  { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 < i <= a . len () , exists | k : int | 0 <= k < i && min_val == a [k] , forall | k : int | 0 <= k < i ==> min_val <= a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0 ensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] , { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 < i <= a . len () , exists | k : int | 0 <= k < i && min_val == a [k] , forall | k : int | 0 <= k < i ==> min_val <= a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn minArray (a : & [i32]) -> (m : i32) requires a . len () > 0 ensures forall | k : int | 0 <= k < a . len () ==> m <= a [k] , exists | k : int | 0 <= k < a . len () && m == a [k] , { let mut min_val = a [0] ; let mut i = 1 ; while i < a . len () invariant 0 < i <= a . len () , exists | k : int | 0 <= k < i && min_val == a [k] , forall | k : int | 0 <= k < i ==> min_val <= a [k] , decreases a . len () - i { if a [i] < min_val { min_val = a [i] ; } i += 1 ; } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "cb3b4c22af88", "function_name": "minArray", "bug_type": "missing_ensures"}}
{"id": "task_a_d1dd43ef56dd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)   { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32)   { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "target_text": "requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , min_array_precond (a) \nensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i \ndecreases a . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\nfn min_array (a : & Vec < i32 >) -> (result : i32) requires min_array_precond (a) , ensures forall | i : int | 0 <= i < a . len () ==> result <= a [i as int] , exists | i : int | 0 <= i < a . len () && result == a [i as int] , { find_min_loop (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_75/verina_basic_75_iter_1_current.rs", "verified": true, "metadata": {"original_id": "d1dd43ef56dd", "function_name": "min_array", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_b_3af55780098f", "task": "task_b", "input_text": "fn main_method (n : i32 , k : i32) -> (k_out : i32)\nrequires n > 0 , k > n , n <= 100 , k <= 200 \nensures k_out >= 0 ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { k }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "3af55780098f", "function_name": "main_method", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_d03fd30fde88", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn min (a : & [i32]) -> (res : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures exists | i : int | 0 <= i < a . len () && res == a [i] && forall | j : int | 0 <= j < a . len () ==> res <= a [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn min (a : & [i32]) -> (res : i32) requires a . len () > 0 , ensures exists | i : int | 0 <= i < a . len () && res == a [i] && forall | j : int | 0 <= j < a . len () ==> res <= a [j] , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/vericoding_dafny_to_verus_specs/numpy_specs/np_min.rs", "verified": true, "metadata": {"original_id": "d03fd30fde88", "function_name": "min", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_verus_recursion_e42edfec3663", "task": "task_c", "input_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nspec fn arith_sum_int(i: int) -> int\n    decreases i,\n{\n    if i <= 0 {\n        0\n    } else {\n        i + arith_sum_int(i - 1)\n    }\n}\n\n#[verifier::opaque]\nspec fn arith_sum_u64(i: u64) -> u64\n    decreases i,\n{\n    if i == 0 {\n        0\n    } else {\n        (i + arith_sum_u64((i - 1) as u64)) as u64\n    }\n}\n\nproof fn arith_sum_int_nonneg(i: nat)\n\n{\n    if i > 0 {\n        arith_sum_int_nonneg((i - 1) as nat);\n    }\n}\n\nproof fn arith_sum_test1() {\n    assert(arith_sum_int(0) == 0);\n    // Recursive functions default to 1 fuel, so without the assert above,\n    // the following assert will fail\n    assert(arith_sum_int(1) == 1);\n    assert(arith_sum_int(2) == 3);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test2() {\n    // Instead of writing out intermediate assertions,\n    // we can instead boost the fuel setting\n    reveal_with_fuel(arith_sum_int, 4);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test3() {\n    reveal_with_fuel(arith_sum_u64, 4);\n    assert(arith_sum_u64(3) == 6);\n}\n\nproof fn arith_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n\n{\n    if i < j {\n        arith_sum_monotonic(i, (j - 1) as nat);\n    }\n}\n\nfn compute_arith_sum(n: u64) -> (sum: u64)\n    requires\n        n < 100,\n\n{\n    let mut sum: u64 = 0;\n    for i in 0..n\n        invariant\n            n < 100,\n            arith_sum_int(i as int) == sum,\n            sum <= 100 * i,\n    {\n        sum = sum + (i + 1);\n    }\n    sum\n}\n\nfn run_arith_sum(n: u64) -> u64 {\n    let mut result: u64 = 0;\n    if n < 100 {\n        result = compute_arith_sum(n);\n    }\n    result\n}\n\nfn exec_with_decreases(n: u64) -> u64\n    decreases 100 - n,\n{\n    if n < 100 {\n        exec_with_decreases(n + 1)\n    } else {\n        n\n    }\n}\n\n} // verus!\nfn main() {\n    let args = std::env::args();\n    for arg in args {\n        if let Ok(n) = arg.parse::<u64>() {\n            println!(\"{}\", run_arith_sum(n));\n        }\n    }\n}\n", "target_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nspec fn arith_sum_int(i: int) -> int\n    decreases i,\n{\n    if i <= 0 {\n        0\n    } else {\n        i + arith_sum_int(i - 1)\n    }\n}\n\n#[verifier::opaque]\nspec fn arith_sum_u64(i: u64) -> u64\n    decreases i,\n{\n    if i == 0 {\n        0\n    } else {\n        (i + arith_sum_u64((i - 1) as u64)) as u64\n    }\n}\n\nproof fn arith_sum_int_nonneg(i: nat)\n    ensures\n        arith_sum_int(i as int) >= 0,\n    decreases i,\n{\n    if i > 0 {\n        arith_sum_int_nonneg((i - 1) as nat);\n    }\n}\n\nproof fn arith_sum_test1() {\n    assert(arith_sum_int(0) == 0);\n    // Recursive functions default to 1 fuel, so without the assert above,\n    // the following assert will fail\n    assert(arith_sum_int(1) == 1);\n    assert(arith_sum_int(2) == 3);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test2() {\n    // Instead of writing out intermediate assertions,\n    // we can instead boost the fuel setting\n    reveal_with_fuel(arith_sum_int, 4);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test3() {\n    reveal_with_fuel(arith_sum_u64, 4);\n    assert(arith_sum_u64(3) == 6);\n}\n\nproof fn arith_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        arith_sum_int(i as int) <= arith_sum_int(j as int),\n    decreases j,\n{\n    if i < j {\n        arith_sum_monotonic(i, (j - 1) as nat);\n    }\n}\n\nfn compute_arith_sum(n: u64) -> (sum: u64)\n    requires\n        n < 100,\n    ensures\n        arith_sum_int(n as int) == sum,\n{\n    let mut sum: u64 = 0;\n    for i in 0..n\n        invariant\n            n < 100,\n            arith_sum_int(i as int) == sum,\n            sum <= 100 * i,\n    {\n        sum = sum + (i + 1);\n    }\n    sum\n}\n\nfn run_arith_sum(n: u64) -> u64 {\n    let mut result: u64 = 0;\n    if n < 100 {\n        result = compute_arith_sum(n);\n    }\n    result\n}\n\nfn exec_with_decreases(n: u64) -> u64\n    decreases 100 - n,\n{\n    if n < 100 {\n        exec_with_decreases(n + 1)\n    } else {\n        n\n    }\n}\n\n} // verus!\nfn main() {\n    let args = std::env::args();\n    for arg in args {\n        if let Ok(n) = arg.parse::<u64>() {\n            println!(\"{}\", run_arith_sum(n));\n        }\n    }\n}\n", "full_verified_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n#[allow(unused_imports)]\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nverus! {\n\nspec fn arith_sum_int(i: int) -> int\n    decreases i,\n{\n    if i <= 0 {\n        0\n    } else {\n        i + arith_sum_int(i - 1)\n    }\n}\n\n#[verifier::opaque]\nspec fn arith_sum_u64(i: u64) -> u64\n    decreases i,\n{\n    if i == 0 {\n        0\n    } else {\n        (i + arith_sum_u64((i - 1) as u64)) as u64\n    }\n}\n\nproof fn arith_sum_int_nonneg(i: nat)\n    ensures\n        arith_sum_int(i as int) >= 0,\n    decreases i,\n{\n    if i > 0 {\n        arith_sum_int_nonneg((i - 1) as nat);\n    }\n}\n\nproof fn arith_sum_test1() {\n    assert(arith_sum_int(0) == 0);\n    // Recursive functions default to 1 fuel, so without the assert above,\n    // the following assert will fail\n    assert(arith_sum_int(1) == 1);\n    assert(arith_sum_int(2) == 3);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test2() {\n    // Instead of writing out intermediate assertions,\n    // we can instead boost the fuel setting\n    reveal_with_fuel(arith_sum_int, 4);\n    assert(arith_sum_int(3) == 6);\n}\n\nproof fn arith_sum_test3() {\n    reveal_with_fuel(arith_sum_u64, 4);\n    assert(arith_sum_u64(3) == 6);\n}\n\nproof fn arith_sum_monotonic(i: nat, j: nat)\n    requires\n        i <= j,\n    ensures\n        arith_sum_int(i as int) <= arith_sum_int(j as int),\n    decreases j,\n{\n    if i < j {\n        arith_sum_monotonic(i, (j - 1) as nat);\n    }\n}\n\nfn compute_arith_sum(n: u64) -> (sum: u64)\n    requires\n        n < 100,\n    ensures\n        arith_sum_int(n as int) == sum,\n{\n    let mut sum: u64 = 0;\n    for i in 0..n\n        invariant\n            n < 100,\n            arith_sum_int(i as int) == sum,\n            sum <= 100 * i,\n    {\n        sum = sum + (i + 1);\n    }\n    sum\n}\n\nfn run_arith_sum(n: u64) -> u64 {\n    let mut result: u64 = 0;\n    if n < 100 {\n        result = compute_arith_sum(n);\n    }\n    result\n}\n\nfn exec_with_decreases(n: u64) -> u64\n    decreases 100 - n,\n{\n    if n < 100 {\n        exec_with_decreases(n + 1)\n    } else {\n        n\n    }\n}\n\n} // verus!\nfn main() {\n    let args = std::env::args();\n    for arg in args {\n        if let Ok(n) = arg.parse::<u64>() {\n            println!(\"{}\", run_arith_sum(n));\n        }\n    }\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/recursion.rs", "verified": true, "metadata": {"original_id": "verus_recursion_e42edfec3663", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_a_e94174c8246b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize)   { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len ()  { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "target_text": "requires list . len () > 0 \nensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () \ndecreases list . len () - j \ninvariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j , { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_95_iter_2_current.rs", "verified": true, "metadata": {"original_id": "e94174c8246b", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_requires_1490a368946a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)  ensures sum <= 2 * N , { 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/cell_2_sum_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1490a368946a", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_000452c4f641", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool)  { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool)  { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (# [trigger] arr [k]) , { if is_even_exec (arr [i]) { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool) ensures result == is_even (n) { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (# [trigger] arr [k]) , { if is_even_exec (arr [i]) { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> bool { (n % 2) == 0 }\nfn is_even_exec (n : u32) -> (result : bool) ensures result == is_even (n) { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (# [trigger] arr [k]) , { if is_even_exec (arr [i]) { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "000452c4f641", "function_name": "is_product_even", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_fa9d0a6c75ee", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut idx = 0 ; while idx < text . len ()  { if ! is_digit (text [idx]) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut idx = 0 ; while idx < text . len () invariant forall | i : int | 0 <= i < idx ==> is_digit_spec (text [i]) , decreases text . len () - idx , { if ! is_digit (text [idx]) { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut idx = 0 ; while idx < text . len () invariant forall | i : int | 0 <= i < idx ==> is_digit_spec (text [i]) , decreases text . len () - idx , { if ! is_digit (text [idx]) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "fa9d0a6c75ee", "function_name": "is_integer", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_4fcf7012d1ec", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_60/verina_basic_60_impl.rs", "verified": true, "metadata": {"original_id": "4fcf7012d1ec", "function_name": "find_even_numbers", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_990bbedc39eb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] ,  { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >) requires double_array_elements_precond (s) ,  { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >) requires double_array_elements_precond (s) , ensures double_array_elements_postcond (s , result) , { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >) requires double_array_elements_precond (s) , ensures double_array_elements_postcond (s , result) , { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_58/verina_basic_58_impl.rs", "verified": true, "metadata": {"original_id": "990bbedc39eb", "function_name": "double_array_elements", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_84a6c8f03f06", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { let mut i = 0 ; while i < v . len () invariant i <= v . len () , exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { let mut i = 0 ; while i < v . len () invariant i <= v . len () , exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { let mut i = 0 ; while i < v . len () invariant i <= v . len () , exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/unverified/choose_odd_impl.rs", "verified": true, "metadata": {"original_id": "84a6c8f03f06", "function_name": "choose_odd", "bug_type": "missing_decreases"}}
{"id": "task_a_74438889dde4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32 , m : i32)   { let mut i = 0 ; while i < a . len ()  { if a [i] > N { a . set (i , N) ; } i += 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N \nensures forall | k : int | 0 <= k < N ==> a [k] <= N \ndecreases a . len () - i \ninvariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , N : i32 , m : i32) requires N > 0 , old (a) . len () == N , ensures forall | k : int | 0 <= k < N ==> a [k] <= N , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] <= N , decreases a . len () - i , { if a [i] > N { a . set (i , N) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/condn_impl.rs", "verified": true, "metadata": {"original_id": "74438889dde4", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_ensures_fe5bc5cad225", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool)  { n % 2 == 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_60/verina_basic_60_impl.rs", "verified": true, "metadata": {"original_id": "fe5bc5cad225", "function_name": "is_even_exec", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_27efb7251eee", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 90 || text [j] == 122)) , { if text [i] == 90 || text [i] == 122 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_454_iter_1_current.rs", "verified": true, "metadata": {"original_id": "27efb7251eee", "function_name": "contains_z", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_7a07e78bbb25", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 ,  { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn decode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 ,  { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn decode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 ,  { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == decode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> encode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let decoded = decode_char (s [i]) ; result . push (decoded) ; proof { opposite_encode_decode (decoded as int) ; } i = i + 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn decode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn decode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == decode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> encode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == decode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> encode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let decoded = decode_char (s [i]) ; result . push (decoded) ; proof { opposite_encode_decode (decoded as int) ; } i = i + 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn encode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 5) % 26 + 65 }\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nproof fn opposite_encode_decode (c : int) requires 65 <= c <= 90 , ensures encode_char_spec (decode_char_spec (c)) == c , decode_char_spec (encode_char_spec (c)) == c , { assert (encode_char_spec (decode_char_spec (c)) == ((c - 65 + 26 - 5) % 26 + 65 - 65 + 5) % 26 + 65) ; assert (((c - 65 + 21) % 26 + 5) % 26 + 65 == (c - 65 + 21 + 5) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; assert (decode_char_spec (encode_char_spec (c)) == ((c - 65 + 5) % 26 + 65 - 65 + 21) % 26 + 65) ; assert (((c - 65 + 5) % 26 + 21) % 26 + 65 == (c - 65 + 5 + 21) % 26 + 65) ; assert ((c - 65 + 26) % 26 + 65 == c - 65 + 65) ; }\nfn decode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n# [verifier :: loop_isolation (false)] fn decode_shift (s : & Vec < u8 >) -> (t : Vec < u8 >) requires forall | i : int | # ! [trigger s [i]] 0 <= i < s . len () ==> 65 <= s [i] <= 90 , ensures s . len () == t . len () , forall | i : int | # ! [auto] 0 <= i < t . len () ==> t [i] == decode_char_spec (s [i] as int) , forall | i : int | # ! [auto] 0 <= i < t . len () ==> encode_char_spec (t [i] as int) == s [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant i <= s . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j < i ==> result [j] == decode_char_spec (s [j] as int) , forall | j : int | # ! [auto] 0 <= j < i ==> encode_char_spec (result [j] as int) == s [j] , forall | j : int | # ! [trigger s [j]] 0 <= j < s . len () ==> 65 <= s [j] <= 90 , decreases s . len () - i , { let decoded = decode_char (s [i]) ; result . push (decoded) ; proof { opposite_encode_decode (decoded as int) ; } i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/050-encode_shift_impl.rs", "verified": true, "metadata": {"original_id": "7a07e78bbb25", "function_name": "decode_shift", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_d1cc4b8cf2ab", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32) requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1 ensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat decreases n { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32) requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1 ensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sum_of_fourth_power_of_odd_numbers_spec (n : nat) -> nat decreases n { if n == 0 { 0nat } else { let prev = sum_of_fourth_power_of_odd_numbers_spec ((n - 1) as nat) ; let next_odd = (2 * (n - 1) + 1) as nat ; let next_odd_fourth = (next_odd * next_odd * next_odd * next_odd) as nat ; (prev + next_odd_fourth) as nat } }\nspec fn sum_of_fourth_power_of_odd_numbers_precond (n : nat) -> bool { true }\nfn sum_of_fourth_power_of_odd_numbers (n : u32) -> (result : u32) requires sum_of_fourth_power_of_odd_numbers_precond (n as nat) , n <= 1 ensures result as nat == sum_of_fourth_power_of_odd_numbers_spec (n as nat) decreases n { if n == 0 { 0 } else { let prev = sum_of_fourth_power_of_odd_numbers (n - 1) ; let next_odd = 2 * (n - 1) + 1 ; let next_odd_fourth = next_odd * next_odd * next_odd * next_odd ; prev + next_odd_fourth } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_43/verina_basic_43_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "d1cc4b8cf2ab", "function_name": "sum_of_fourth_power_of_odd_numbers", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_ac3ced4a2d61", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_69/verina_advanced_69_impl.rs", "verified": true, "metadata": {"original_id": "ac3ced4a2d61", "function_name": "helper", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_assert_78bd1f99700b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (0 <= j < a . len () as int) && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof {     } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (0 <= j < a . len () as int) && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (i == a . len ()) ; assert (forall | k : int | (0 <= k < i as int) ==> a [k] != e) ; assert (exists | j : int | (0 <= j < a . len () as int) && a [j] == e) ; assert (false) ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (0 <= j < a . len () as int) && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (i == a . len ()) ; assert (forall | k : int | (0 <= k < i as int) ==> a [k] != e) ; assert (exists | j : int | (0 <= j < a . len () as int) && a [j] == e) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/linear_search2_impl.rs", "verified": true, "metadata": {"original_id": "78bd1f99700b", "function_name": "linear_search", "bug_type": "missing_assert"}}
{"id": "task_c_missing_assert_verus_quants_2c1605b7ea09", "task": "task_c", "input_text": "// rust_verify/tests/example.rs expect-warnings\n\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{prelude::*, seq::*};\n\nverus! {\n\n// ANCHOR: quants_finite\nspec fn is_even(i: int) -> bool {\n    i % 2 == 0\n}\n\nproof fn test_seq_5_is_evens(s: Seq<int>)\n    requires\n        s.len() == 5,\n        is_even(s[0]),\n        is_even(s[1]),\n        is_even(s[3]),\n        is_even(s[3]),\n        is_even(s[4]),\n{\n\n}\n// ANCHOR_END: quants_finite\n\nspec fn is_odd(i: int) -> bool {\n    i % 2 == 1\n}\n\n// ANCHOR: quants_recursion\nspec fn all_evens(s: Seq<int>) -> bool\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        true\n    } else {\n        is_even(s.last()) && all_evens(s.drop_last())\n    }\n}\n\nproof fn test_seq_recursive(s: Seq<int>)\n    requires\n        s.len() == 5,\n        all_evens(s),\n{\n\n    }\n}\n// ANCHOR_END: quants_recursion\n\n// ANCHOR: quants_use_forall\nproof fn test_use_forall(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n\n}\n// ANCHOR_END: quants_use_forall\n\n/*\n// ANCHOR: trigger_fails\nspec fn is_even(i: int) -> bool {\n    i % 2 == 0\n}\n\nproof fn test_use_forall_fail(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n     // FAILS: doesn't trigger is_even(s[i])\n}\n// ANCHOR_END: trigger_fails\n*/\n\n// ANCHOR: test_use_forall_succeeds1\nproof fn test_use_forall_succeeds1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n      // triggers is_even(s[3])\n      // succeeds, because previous line already instantiated the forall\n}\n// ANCHOR_END: test_use_forall_succeeds1\n\n// ANCHOR: test_use_forall_succeeds2\nproof fn test_use_forall_succeeds2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> is_even(#[trigger] s[i]),\n{\n      // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds2\n\n/*\n// ANCHOR: test_use_forall_succeeds3\nproof fn test_use_forall_succeeds3(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> is_even(s[i]), // Verus chooses s[i] as the trigger and prints a note\n{\n     // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds3\n*/\n\n// ANCHOR: test_use_forall_succeeds4\nproof fn test_use_forall_succeeds4(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int|\n            #![auto]\n            0 <= i < s.len() ==> is_even(s[i]),  // Verus chooses s[i] as the trigger\n{\n      // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds4\n\n/*\n// ANCHOR: test_use_forall_bad1\nproof fn test_use_forall_bad1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| (#[trigger](0 <= i)) && i < s.len() ==> is_even(s[i]),\n{\n\n}\n// ANCHOR_END: test_use_forall_bad1\n*/\n\n/*\n// ANCHOR: test_use_forall_bad2\nspec fn nonnegative(i: int) -> bool {\n    0 <= i\n}\n\nproof fn test_use_forall_bad2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| #[trigger] nonnegative(i) && i < s.len() ==> is_even(s[i]),\n{\n     // FAILS: doesn't trigger nonnegative(i)\n}\n// ANCHOR_END: test_use_forall_bad2\n*/\n\n// ANCHOR: test_distinct1\nspec fn is_distinct(x: int, y: int) -> bool {\n    x != y\n}\n\nproof fn test_distinct1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] is_distinct(s[i], s[j]),\n{\n\n}\n// ANCHOR_END: test_distinct1\n\n// ANCHOR: test_distinct2\nproof fn test_distinct2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] s[i] != #[trigger] s[j],\n{\n\n}\n// ANCHOR_END: test_distinct2\n\n// ANCHOR: test_distinct3\nproof fn test_distinct3(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| #![trigger s[i], s[j]] 0 <= i < j < s.len() ==> s[i] != s[j],\n{\n\n}\n// ANCHOR_END: test_distinct3\n\n/*\n// ANCHOR: test_distinct_fail1\nproof fn test_distinct_fail1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int|\n            0 <= i < j < s.len() ==> s[i] != #[trigger] s[j], // error: trigger fails to mention i\n{\n\n}\n// ANCHOR_END: test_distinct_fail1\n*/\n\n/*\n// ANCHOR: test_distinct_fail2\nproof fn test_distinct_fail2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| #![trigger s[i], s[j], is_even(i)]\n            0 <= i < j < s.len() ==> s[i] != s[j],\n{\n     // FAILS, because nothing matches is_even(i)\n}\n// ANCHOR_END: test_distinct_fail2\n*/\n\n// ANCHOR: test_distinct4\nproof fn test_distinct4(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int|\n            #![trigger s[i], s[j]]\n            #![trigger is_even(i), is_even(j)]\n            0 <= i < j < s.len() ==> s[i] != s[j],\n{\n\n}\n// ANCHOR_END: test_distinct4\n\n// ANCHOR: test_multitriggers\nproof fn test_multitriggers(a: Seq<int>, b: Seq<int>, c: Seq<int>)\n    requires\n        5 <= a.len(),\n        a.len() == b.len(),\n        a.len() == c.len(),\n        forall|i: int, j: int|\n            #![trigger a[i], b[j]]\n            #![trigger a[i], c[j]]\n            0 <= i < j < a.len() ==> a[i] != b[j] && a[i] != c[j],\n{\n      // succeeds, matches a[i], c[j]\n}\n// ANCHOR_END: test_multitriggers\n\n// ANCHOR: seq_update_different\nproof fn seq_update_different<A>(s: Seq<A>, i: int, j: int, a: A) {\n\n}\n// ANCHOR_END: seq_update_different\n\n// ANCHOR: test_sorted_good\nproof fn test_sorted_good(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i <= j < s.len() ==> s[i] <= s[j],\n{\n\n}\n// ANCHOR_END: test_sorted_good\n\n/*\n// ANCHOR: test_sorted_bad1\nproof fn test_sorted_bad(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int|\n            0 <= i < s.len() - 1 ==> s[i] <= s[i + 1],\n{\n\n}\n// ANCHOR_END: test_sorted_bad1\n*/\n\n// ANCHOR: test_exists_succeeds\nproof fn test_exists_succeeds() {\n\n      // succeeds with witness i = 4 or i = 6\n}\n// ANCHOR_END: test_exists_succeeds\n\n/*\n// ANCHOR: test_exists_fails\nproof fn test_exists_fails() {\n     // FAILS, no match for trigger\n}\n// ANCHOR_END: test_exists_fails\n*/\n\n// ANCHOR: test_choose_succeeds\nspec fn f(i: int) -> bool;\n\nproof fn test_choose_succeeds()\n    requires\n        exists|i: int| f(i),\n{\n    let i_witness = choose|i: int| f(i);\n\n}\n// ANCHOR_END: test_choose_succeeds\n\n/*\n// ANCHOR: test_choose_fails\nproof fn test_choose_fails() {\n    let i_witness = choose|i: int| f(i);\n     // i_witness is some integer\n     // FAILS because we don't know exists|i: int| f(i)\n}\n// ANCHOR_END: test_choose_fails\n*/\n\n// ANCHOR: test_choose_same\nproof fn test_choose_same() {\n    let x = choose|i: int| f(i);\n    let y = choose|i: int| f(i);\n\n}\n// ANCHOR_END: test_choose_same\n\n// ANCHOR: test_choose_succeeds2\nspec fn less_than(x: int, y: int) -> bool {\n    x < y\n}\n\nproof fn test_choose_succeeds2() {\n      // promote i = 3, i = 7 as a witness\n    let (x, y) = choose|i: int, j: int| less_than(i, j);\n\n}\n// ANCHOR_END: test_choose_succeeds2\n\n#[verusfmt::skip]\nmod M {\n#[allow(unused_imports)]\n\nuse verus_builtin::*;\n\n// ANCHOR: just_works\nspec fn is_distinct(x: int, y: int) -> bool {\n    x != y\n}\n\nspec fn dummy(i: int) -> bool;\n\nproof fn prove_forall()\n    ensures\n        forall|i: int, j: int|\n            #![trigger dummy(i), dummy(j)]\n            is_distinct(i, j) ==> is_distinct(j, i),\n{\n    // proving the forall just works; the trigger is irrelevant\n}\n\nproof fn use_exists(x: int)\n    requires\n        exists|i: int| #![trigger dummy(i)] x == i + 1 && is_distinct(i, 5),\n{\n    // using the exists just works; the trigger is irrelevant\n\n}\n// ANCHOR_END: just_works\n}\n\n// ANCHOR: hoist\nproof fn hoisted_forall(i: int, j: int)\n    ensures\n        is_distinct(i, j) ==> is_distinct(j, i),\n{\n}\n\nproof fn hoisted_exists(x: int, i: int)\n    requires\n        x == i + 1 && is_distinct(i, 5),\n{\n\n}\n// ANCHOR_END: hoist\n\n#[verifier::external_body]\nproof fn lemma_even_f(i: int)\n    requires\n        is_even(i),\n    ensures\n        f(i),\n{\n}\n\n/*\n// ANCHOR: test_even_f_fail1\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i), // FAILS because we don't call the lemma\n{\n}\n// ANCHOR_END: test_even_f_fail1\n*/\n\n/*\n// ANCHOR: test_even_f_fail2\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i),\n{\n    lemma_even_f(i); // ERROR: i is not in scope here\n}\n// ANCHOR_END: test_even_f_fail2\n*/\n\n// ANCHOR: test_even_f\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i),\n{\n    }\n// ANCHOR_END: test_even_f\n\nspec fn g(i: int, j: int) -> bool;\n\n#[verifier::external_body]\nproof fn lemma_g_proves_f(i: int, j: int)\n    requires\n        g(i, j),\n    ensures\n        f(i),\n{\n}\n\n/*\n// ANCHOR: test_g_proves_f_fails\nproof fn test_g_proves_f(i: int)\n    requires\n        exists|j: int| g(i, j),\n    ensures\n        f(i),\n{\n    lemma_g_proves_f(i, j); // ERROR: j is not in scope here\n}\n// ANCHOR_END: test_g_proves_f_fails\n*/\n\n// ANCHOR: test_g_proves_f\nproof fn test_g_proves_f(i: int)\n    requires\n        exists|j: int| g(i, j),\n    ensures\n        f(i),\n{\n    lemma_g_proves_f(i, choose|j: int| g(i, j));\n}\n// ANCHOR_END: test_g_proves_f\n\n// ANCHOR: binary_search\nfn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n        invariant\n            i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n            forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        decreases i2 - i1,\n    {\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n    }\n    i1\n}\n\nfn main() {\n    let mut v: Vec<u64> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n      // needed to trigger exists|i: int| ... k == v[i]\n    let r = binary_search(&v, 30);\n\n}\n// ANCHOR_END: binary_search\n\n} // verus!\n", "target_text": "// rust_verify/tests/example.rs expect-warnings\n\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{prelude::*, seq::*};\n\nverus! {\n\n// ANCHOR: quants_finite\nspec fn is_even(i: int) -> bool {\n    i % 2 == 0\n}\n\nproof fn test_seq_5_is_evens(s: Seq<int>)\n    requires\n        s.len() == 5,\n        is_even(s[0]),\n        is_even(s[1]),\n        is_even(s[3]),\n        is_even(s[3]),\n        is_even(s[4]),\n{\n    assert(is_even(s[3]));\n}\n// ANCHOR_END: quants_finite\n\nspec fn is_odd(i: int) -> bool {\n    i % 2 == 1\n}\n\n// ANCHOR: quants_recursion\nspec fn all_evens(s: Seq<int>) -> bool\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        true\n    } else {\n        is_even(s.last()) && all_evens(s.drop_last())\n    }\n}\n\nproof fn test_seq_recursive(s: Seq<int>)\n    requires\n        s.len() == 5,\n        all_evens(s),\n{\n    assert(is_even(s[3])) by {\n        reveal_with_fuel(all_evens, 2);\n    }\n}\n// ANCHOR_END: quants_recursion\n\n// ANCHOR: quants_use_forall\nproof fn test_use_forall(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(is_even(s[3]));\n}\n// ANCHOR_END: quants_use_forall\n\n/*\n// ANCHOR: trigger_fails\nspec fn is_even(i: int) -> bool {\n    i % 2 == 0\n}\n\nproof fn test_use_forall_fail(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(s[3] % 2 == 0); // FAILS: doesn't trigger is_even(s[i])\n}\n// ANCHOR_END: trigger_fails\n*/\n\n// ANCHOR: test_use_forall_succeeds1\nproof fn test_use_forall_succeeds1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(is_even(s[3]));  // triggers is_even(s[3])\n    assert(s[3] % 2 == 0);  // succeeds, because previous line already instantiated the forall\n}\n// ANCHOR_END: test_use_forall_succeeds1\n\n// ANCHOR: test_use_forall_succeeds2\nproof fn test_use_forall_succeeds2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> is_even(#[trigger] s[i]),\n{\n    assert(s[3] % 2 == 0);  // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds2\n\n/*\n// ANCHOR: test_use_forall_succeeds3\nproof fn test_use_forall_succeeds3(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> is_even(s[i]), // Verus chooses s[i] as the trigger and prints a note\n{\n    assert(s[3] % 2 == 0); // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds3\n*/\n\n// ANCHOR: test_use_forall_succeeds4\nproof fn test_use_forall_succeeds4(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int|\n            #![auto]\n            0 <= i < s.len() ==> is_even(s[i]),  // Verus chooses s[i] as the trigger\n{\n    assert(s[3] % 2 == 0);  // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds4\n\n/*\n// ANCHOR: test_use_forall_bad1\nproof fn test_use_forall_bad1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| (#[trigger](0 <= i)) && i < s.len() ==> is_even(s[i]),\n{\n    assert(s[3] % 2 == 0);\n}\n// ANCHOR_END: test_use_forall_bad1\n*/\n\n/*\n// ANCHOR: test_use_forall_bad2\nspec fn nonnegative(i: int) -> bool {\n    0 <= i\n}\n\nproof fn test_use_forall_bad2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| #[trigger] nonnegative(i) && i < s.len() ==> is_even(s[i]),\n{\n    assert(is_even(s[3])); // FAILS: doesn't trigger nonnegative(i)\n}\n// ANCHOR_END: test_use_forall_bad2\n*/\n\n// ANCHOR: test_distinct1\nspec fn is_distinct(x: int, y: int) -> bool {\n    x != y\n}\n\nproof fn test_distinct1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] is_distinct(s[i], s[j]),\n{\n    assert(is_distinct(s[2], s[4]));\n}\n// ANCHOR_END: test_distinct1\n\n// ANCHOR: test_distinct2\nproof fn test_distinct2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] s[i] != #[trigger] s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct2\n\n// ANCHOR: test_distinct3\nproof fn test_distinct3(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| #![trigger s[i], s[j]] 0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct3\n\n/*\n// ANCHOR: test_distinct_fail1\nproof fn test_distinct_fail1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int|\n            0 <= i < j < s.len() ==> s[i] != #[trigger] s[j], // error: trigger fails to mention i\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct_fail1\n*/\n\n/*\n// ANCHOR: test_distinct_fail2\nproof fn test_distinct_fail2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| #![trigger s[i], s[j], is_even(i)]\n            0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]); // FAILS, because nothing matches is_even(i)\n}\n// ANCHOR_END: test_distinct_fail2\n*/\n\n// ANCHOR: test_distinct4\nproof fn test_distinct4(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int|\n            #![trigger s[i], s[j]]\n            #![trigger is_even(i), is_even(j)]\n            0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct4\n\n// ANCHOR: test_multitriggers\nproof fn test_multitriggers(a: Seq<int>, b: Seq<int>, c: Seq<int>)\n    requires\n        5 <= a.len(),\n        a.len() == b.len(),\n        a.len() == c.len(),\n        forall|i: int, j: int|\n            #![trigger a[i], b[j]]\n            #![trigger a[i], c[j]]\n            0 <= i < j < a.len() ==> a[i] != b[j] && a[i] != c[j],\n{\n    assert(a[2] != c[4]);  // succeeds, matches a[i], c[j]\n}\n// ANCHOR_END: test_multitriggers\n\n// ANCHOR: seq_update_different\nproof fn seq_update_different<A>(s: Seq<A>, i: int, j: int, a: A) {\n    assert(forall|i: int, j: int|\n        0 <= i < s.len() && 0 <= j < s.len() && i != j ==> s.update(j, a)[i] == s[i]);\n}\n// ANCHOR_END: seq_update_different\n\n// ANCHOR: test_sorted_good\nproof fn test_sorted_good(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i <= j < s.len() ==> s[i] <= s[j],\n{\n    assert(s[2] <= s[4]);\n}\n// ANCHOR_END: test_sorted_good\n\n/*\n// ANCHOR: test_sorted_bad1\nproof fn test_sorted_bad(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int|\n            0 <= i < s.len() - 1 ==> s[i] <= s[i + 1],\n{\n    assert(s[2] <= s[4]);\n}\n// ANCHOR_END: test_sorted_bad1\n*/\n\n// ANCHOR: test_exists_succeeds\nproof fn test_exists_succeeds() {\n    assert(is_even(4));\n    assert(!is_even(5));\n    assert(is_even(6));\n    assert(exists|i: int| #[trigger] is_even(i));  // succeeds with witness i = 4 or i = 6\n}\n// ANCHOR_END: test_exists_succeeds\n\n/*\n// ANCHOR: test_exists_fails\nproof fn test_exists_fails() {\n    assert(exists|i: int| #[trigger] is_even(i)); // FAILS, no match for trigger\n}\n// ANCHOR_END: test_exists_fails\n*/\n\n// ANCHOR: test_choose_succeeds\nspec fn f(i: int) -> bool;\n\nproof fn test_choose_succeeds()\n    requires\n        exists|i: int| f(i),\n{\n    let i_witness = choose|i: int| f(i);\n    assert(f(i_witness));\n}\n// ANCHOR_END: test_choose_succeeds\n\n/*\n// ANCHOR: test_choose_fails\nproof fn test_choose_fails() {\n    let i_witness = choose|i: int| f(i);\n    assert(i_witness < 0 || i_witness >= 0); // i_witness is some integer\n    assert(f(i_witness)); // FAILS because we don't know exists|i: int| f(i)\n}\n// ANCHOR_END: test_choose_fails\n*/\n\n// ANCHOR: test_choose_same\nproof fn test_choose_same() {\n    let x = choose|i: int| f(i);\n    let y = choose|i: int| f(i);\n    assert(x == y);\n}\n// ANCHOR_END: test_choose_same\n\n// ANCHOR: test_choose_succeeds2\nspec fn less_than(x: int, y: int) -> bool {\n    x < y\n}\n\nproof fn test_choose_succeeds2() {\n    assert(less_than(3, 7));  // promote i = 3, i = 7 as a witness\n    let (x, y) = choose|i: int, j: int| less_than(i, j);\n    assert(x < y);\n}\n// ANCHOR_END: test_choose_succeeds2\n\n#[verusfmt::skip]\nmod M {\n#[allow(unused_imports)]\n\nuse verus_builtin::*;\n\n// ANCHOR: just_works\nspec fn is_distinct(x: int, y: int) -> bool {\n    x != y\n}\n\nspec fn dummy(i: int) -> bool;\n\nproof fn prove_forall()\n    ensures\n        forall|i: int, j: int|\n            #![trigger dummy(i), dummy(j)]\n            is_distinct(i, j) ==> is_distinct(j, i),\n{\n    // proving the forall just works; the trigger is irrelevant\n}\n\nproof fn use_exists(x: int)\n    requires\n        exists|i: int| #![trigger dummy(i)] x == i + 1 && is_distinct(i, 5),\n{\n    // using the exists just works; the trigger is irrelevant\n    assert(x != 6);\n}\n// ANCHOR_END: just_works\n}\n\n// ANCHOR: hoist\nproof fn hoisted_forall(i: int, j: int)\n    ensures\n        is_distinct(i, j) ==> is_distinct(j, i),\n{\n}\n\nproof fn hoisted_exists(x: int, i: int)\n    requires\n        x == i + 1 && is_distinct(i, 5),\n{\n    assert(x != 6);\n}\n// ANCHOR_END: hoist\n\n#[verifier::external_body]\nproof fn lemma_even_f(i: int)\n    requires\n        is_even(i),\n    ensures\n        f(i),\n{\n}\n\n/*\n// ANCHOR: test_even_f_fail1\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i), // FAILS because we don't call the lemma\n{\n}\n// ANCHOR_END: test_even_f_fail1\n*/\n\n/*\n// ANCHOR: test_even_f_fail2\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i),\n{\n    lemma_even_f(i); // ERROR: i is not in scope here\n}\n// ANCHOR_END: test_even_f_fail2\n*/\n\n// ANCHOR: test_even_f\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i),\n{\n    assert forall|i: int| is_even(i) implies f(i) by {\n        // First, i is in scope here\n        // Second, we assume is_even(i) here\n        lemma_even_f(i);\n        // Finally, we have to prove f(i) here\n    }\n}\n// ANCHOR_END: test_even_f\n\nspec fn g(i: int, j: int) -> bool;\n\n#[verifier::external_body]\nproof fn lemma_g_proves_f(i: int, j: int)\n    requires\n        g(i, j),\n    ensures\n        f(i),\n{\n}\n\n/*\n// ANCHOR: test_g_proves_f_fails\nproof fn test_g_proves_f(i: int)\n    requires\n        exists|j: int| g(i, j),\n    ensures\n        f(i),\n{\n    lemma_g_proves_f(i, j); // ERROR: j is not in scope here\n}\n// ANCHOR_END: test_g_proves_f_fails\n*/\n\n// ANCHOR: test_g_proves_f\nproof fn test_g_proves_f(i: int)\n    requires\n        exists|j: int| g(i, j),\n    ensures\n        f(i),\n{\n    lemma_g_proves_f(i, choose|j: int| g(i, j));\n}\n// ANCHOR_END: test_g_proves_f\n\n// ANCHOR: binary_search\nfn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n        invariant\n            i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n            forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        decreases i2 - i1,\n    {\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n    }\n    i1\n}\n\nfn main() {\n    let mut v: Vec<u64> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    assert(v[3] == 30);  // needed to trigger exists|i: int| ... k == v[i]\n    let r = binary_search(&v, 30);\n    assert(r == 3);\n}\n// ANCHOR_END: binary_search\n\n} // verus!\n", "full_verified_code": "// rust_verify/tests/example.rs expect-warnings\n\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{prelude::*, seq::*};\n\nverus! {\n\n// ANCHOR: quants_finite\nspec fn is_even(i: int) -> bool {\n    i % 2 == 0\n}\n\nproof fn test_seq_5_is_evens(s: Seq<int>)\n    requires\n        s.len() == 5,\n        is_even(s[0]),\n        is_even(s[1]),\n        is_even(s[3]),\n        is_even(s[3]),\n        is_even(s[4]),\n{\n    assert(is_even(s[3]));\n}\n// ANCHOR_END: quants_finite\n\nspec fn is_odd(i: int) -> bool {\n    i % 2 == 1\n}\n\n// ANCHOR: quants_recursion\nspec fn all_evens(s: Seq<int>) -> bool\n    decreases s.len(),\n{\n    if s.len() == 0 {\n        true\n    } else {\n        is_even(s.last()) && all_evens(s.drop_last())\n    }\n}\n\nproof fn test_seq_recursive(s: Seq<int>)\n    requires\n        s.len() == 5,\n        all_evens(s),\n{\n    assert(is_even(s[3])) by {\n        reveal_with_fuel(all_evens, 2);\n    }\n}\n// ANCHOR_END: quants_recursion\n\n// ANCHOR: quants_use_forall\nproof fn test_use_forall(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(is_even(s[3]));\n}\n// ANCHOR_END: quants_use_forall\n\n/*\n// ANCHOR: trigger_fails\nspec fn is_even(i: int) -> bool {\n    i % 2 == 0\n}\n\nproof fn test_use_forall_fail(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(s[3] % 2 == 0); // FAILS: doesn't trigger is_even(s[i])\n}\n// ANCHOR_END: trigger_fails\n*/\n\n// ANCHOR: test_use_forall_succeeds1\nproof fn test_use_forall_succeeds1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> #[trigger] is_even(s[i]),\n{\n    assert(is_even(s[3]));  // triggers is_even(s[3])\n    assert(s[3] % 2 == 0);  // succeeds, because previous line already instantiated the forall\n}\n// ANCHOR_END: test_use_forall_succeeds1\n\n// ANCHOR: test_use_forall_succeeds2\nproof fn test_use_forall_succeeds2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> is_even(#[trigger] s[i]),\n{\n    assert(s[3] % 2 == 0);  // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds2\n\n/*\n// ANCHOR: test_use_forall_succeeds3\nproof fn test_use_forall_succeeds3(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| 0 <= i < s.len() ==> is_even(s[i]), // Verus chooses s[i] as the trigger and prints a note\n{\n    assert(s[3] % 2 == 0); // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds3\n*/\n\n// ANCHOR: test_use_forall_succeeds4\nproof fn test_use_forall_succeeds4(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int|\n            #![auto]\n            0 <= i < s.len() ==> is_even(s[i]),  // Verus chooses s[i] as the trigger\n{\n    assert(s[3] % 2 == 0);  // succeeds by triggering s[3]\n}\n// ANCHOR_END: test_use_forall_succeeds4\n\n/*\n// ANCHOR: test_use_forall_bad1\nproof fn test_use_forall_bad1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| (#[trigger](0 <= i)) && i < s.len() ==> is_even(s[i]),\n{\n    assert(s[3] % 2 == 0);\n}\n// ANCHOR_END: test_use_forall_bad1\n*/\n\n/*\n// ANCHOR: test_use_forall_bad2\nspec fn nonnegative(i: int) -> bool {\n    0 <= i\n}\n\nproof fn test_use_forall_bad2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int| #[trigger] nonnegative(i) && i < s.len() ==> is_even(s[i]),\n{\n    assert(is_even(s[3])); // FAILS: doesn't trigger nonnegative(i)\n}\n// ANCHOR_END: test_use_forall_bad2\n*/\n\n// ANCHOR: test_distinct1\nspec fn is_distinct(x: int, y: int) -> bool {\n    x != y\n}\n\nproof fn test_distinct1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] is_distinct(s[i], s[j]),\n{\n    assert(is_distinct(s[2], s[4]));\n}\n// ANCHOR_END: test_distinct1\n\n// ANCHOR: test_distinct2\nproof fn test_distinct2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i < j < s.len() ==> #[trigger] s[i] != #[trigger] s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct2\n\n// ANCHOR: test_distinct3\nproof fn test_distinct3(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| #![trigger s[i], s[j]] 0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct3\n\n/*\n// ANCHOR: test_distinct_fail1\nproof fn test_distinct_fail1(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int|\n            0 <= i < j < s.len() ==> s[i] != #[trigger] s[j], // error: trigger fails to mention i\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct_fail1\n*/\n\n/*\n// ANCHOR: test_distinct_fail2\nproof fn test_distinct_fail2(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| #![trigger s[i], s[j], is_even(i)]\n            0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]); // FAILS, because nothing matches is_even(i)\n}\n// ANCHOR_END: test_distinct_fail2\n*/\n\n// ANCHOR: test_distinct4\nproof fn test_distinct4(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int|\n            #![trigger s[i], s[j]]\n            #![trigger is_even(i), is_even(j)]\n            0 <= i < j < s.len() ==> s[i] != s[j],\n{\n    assert(s[4] != s[2]);\n}\n// ANCHOR_END: test_distinct4\n\n// ANCHOR: test_multitriggers\nproof fn test_multitriggers(a: Seq<int>, b: Seq<int>, c: Seq<int>)\n    requires\n        5 <= a.len(),\n        a.len() == b.len(),\n        a.len() == c.len(),\n        forall|i: int, j: int|\n            #![trigger a[i], b[j]]\n            #![trigger a[i], c[j]]\n            0 <= i < j < a.len() ==> a[i] != b[j] && a[i] != c[j],\n{\n    assert(a[2] != c[4]);  // succeeds, matches a[i], c[j]\n}\n// ANCHOR_END: test_multitriggers\n\n// ANCHOR: seq_update_different\nproof fn seq_update_different<A>(s: Seq<A>, i: int, j: int, a: A) {\n    assert(forall|i: int, j: int|\n        0 <= i < s.len() && 0 <= j < s.len() && i != j ==> s.update(j, a)[i] == s[i]);\n}\n// ANCHOR_END: seq_update_different\n\n// ANCHOR: test_sorted_good\nproof fn test_sorted_good(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int, j: int| 0 <= i <= j < s.len() ==> s[i] <= s[j],\n{\n    assert(s[2] <= s[4]);\n}\n// ANCHOR_END: test_sorted_good\n\n/*\n// ANCHOR: test_sorted_bad1\nproof fn test_sorted_bad(s: Seq<int>)\n    requires\n        5 <= s.len(),\n        forall|i: int|\n            0 <= i < s.len() - 1 ==> s[i] <= s[i + 1],\n{\n    assert(s[2] <= s[4]);\n}\n// ANCHOR_END: test_sorted_bad1\n*/\n\n// ANCHOR: test_exists_succeeds\nproof fn test_exists_succeeds() {\n    assert(is_even(4));\n    assert(!is_even(5));\n    assert(is_even(6));\n    assert(exists|i: int| #[trigger] is_even(i));  // succeeds with witness i = 4 or i = 6\n}\n// ANCHOR_END: test_exists_succeeds\n\n/*\n// ANCHOR: test_exists_fails\nproof fn test_exists_fails() {\n    assert(exists|i: int| #[trigger] is_even(i)); // FAILS, no match for trigger\n}\n// ANCHOR_END: test_exists_fails\n*/\n\n// ANCHOR: test_choose_succeeds\nspec fn f(i: int) -> bool;\n\nproof fn test_choose_succeeds()\n    requires\n        exists|i: int| f(i),\n{\n    let i_witness = choose|i: int| f(i);\n    assert(f(i_witness));\n}\n// ANCHOR_END: test_choose_succeeds\n\n/*\n// ANCHOR: test_choose_fails\nproof fn test_choose_fails() {\n    let i_witness = choose|i: int| f(i);\n    assert(i_witness < 0 || i_witness >= 0); // i_witness is some integer\n    assert(f(i_witness)); // FAILS because we don't know exists|i: int| f(i)\n}\n// ANCHOR_END: test_choose_fails\n*/\n\n// ANCHOR: test_choose_same\nproof fn test_choose_same() {\n    let x = choose|i: int| f(i);\n    let y = choose|i: int| f(i);\n    assert(x == y);\n}\n// ANCHOR_END: test_choose_same\n\n// ANCHOR: test_choose_succeeds2\nspec fn less_than(x: int, y: int) -> bool {\n    x < y\n}\n\nproof fn test_choose_succeeds2() {\n    assert(less_than(3, 7));  // promote i = 3, i = 7 as a witness\n    let (x, y) = choose|i: int, j: int| less_than(i, j);\n    assert(x < y);\n}\n// ANCHOR_END: test_choose_succeeds2\n\n#[verusfmt::skip]\nmod M {\n#[allow(unused_imports)]\n\nuse verus_builtin::*;\n\n// ANCHOR: just_works\nspec fn is_distinct(x: int, y: int) -> bool {\n    x != y\n}\n\nspec fn dummy(i: int) -> bool;\n\nproof fn prove_forall()\n    ensures\n        forall|i: int, j: int|\n            #![trigger dummy(i), dummy(j)]\n            is_distinct(i, j) ==> is_distinct(j, i),\n{\n    // proving the forall just works; the trigger is irrelevant\n}\n\nproof fn use_exists(x: int)\n    requires\n        exists|i: int| #![trigger dummy(i)] x == i + 1 && is_distinct(i, 5),\n{\n    // using the exists just works; the trigger is irrelevant\n    assert(x != 6);\n}\n// ANCHOR_END: just_works\n}\n\n// ANCHOR: hoist\nproof fn hoisted_forall(i: int, j: int)\n    ensures\n        is_distinct(i, j) ==> is_distinct(j, i),\n{\n}\n\nproof fn hoisted_exists(x: int, i: int)\n    requires\n        x == i + 1 && is_distinct(i, 5),\n{\n    assert(x != 6);\n}\n// ANCHOR_END: hoist\n\n#[verifier::external_body]\nproof fn lemma_even_f(i: int)\n    requires\n        is_even(i),\n    ensures\n        f(i),\n{\n}\n\n/*\n// ANCHOR: test_even_f_fail1\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i), // FAILS because we don't call the lemma\n{\n}\n// ANCHOR_END: test_even_f_fail1\n*/\n\n/*\n// ANCHOR: test_even_f_fail2\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i),\n{\n    lemma_even_f(i); // ERROR: i is not in scope here\n}\n// ANCHOR_END: test_even_f_fail2\n*/\n\n// ANCHOR: test_even_f\nproof fn test_even_f()\n    ensures\n        forall|i: int| is_even(i) ==> f(i),\n{\n    assert forall|i: int| is_even(i) implies f(i) by {\n        // First, i is in scope here\n        // Second, we assume is_even(i) here\n        lemma_even_f(i);\n        // Finally, we have to prove f(i) here\n    }\n}\n// ANCHOR_END: test_even_f\n\nspec fn g(i: int, j: int) -> bool;\n\n#[verifier::external_body]\nproof fn lemma_g_proves_f(i: int, j: int)\n    requires\n        g(i, j),\n    ensures\n        f(i),\n{\n}\n\n/*\n// ANCHOR: test_g_proves_f_fails\nproof fn test_g_proves_f(i: int)\n    requires\n        exists|j: int| g(i, j),\n    ensures\n        f(i),\n{\n    lemma_g_proves_f(i, j); // ERROR: j is not in scope here\n}\n// ANCHOR_END: test_g_proves_f_fails\n*/\n\n// ANCHOR: test_g_proves_f\nproof fn test_g_proves_f(i: int)\n    requires\n        exists|j: int| g(i, j),\n    ensures\n        f(i),\n{\n    lemma_g_proves_f(i, choose|j: int| g(i, j));\n}\n// ANCHOR_END: test_g_proves_f\n\n// ANCHOR: binary_search\nfn binary_search(v: &Vec<u64>, k: u64) -> (r: usize)\n    requires\n        forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        exists|i: int| 0 <= i < v.len() && k == v[i],\n    ensures\n        r < v.len(),\n        k == v[r as int],\n{\n    let mut i1: usize = 0;\n    let mut i2: usize = v.len() - 1;\n    while i1 != i2\n        invariant\n            i2 < v.len(),\n            exists|i: int| i1 <= i <= i2 && k == v[i],\n            forall|i: int, j: int| 0 <= i <= j < v.len() ==> v[i] <= v[j],\n        decreases i2 - i1,\n    {\n        let ix = i1 + (i2 - i1) / 2;\n        if v[ix] < k {\n            i1 = ix + 1;\n        } else {\n            i2 = ix;\n        }\n    }\n    i1\n}\n\nfn main() {\n    let mut v: Vec<u64> = Vec::new();\n    v.push(0);\n    v.push(10);\n    v.push(20);\n    v.push(30);\n    v.push(40);\n    assert(v[3] == 30);  // needed to trigger exists|i: int| ... k == v[i]\n    let r = binary_search(&v, 30);\n    assert(r == 3);\n}\n// ANCHOR_END: binary_search\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/quants.rs", "verified": true, "metadata": {"original_id": "verus_quants_2c1605b7ea09", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_a_fbc23ba4a7da", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize)  { string . len () }\n\n} // verus!", "target_text": "ensures length == string . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize) ensures length == string . len () , { string . len () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/023-strlen_iter_1_current.rs", "verified": true, "metadata": {"original_id": "fbc23ba4a7da", "function_name": "strlen", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d059178c6f16", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith)   { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len ()  { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "requires a . len () == b . len () \nensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) \ndecreases a . len () - idx \ninvariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < a . len () invariant idx <= a . len () , result . len () == idx , forall | i : int | # ! [auto] 0 <= i && i < idx ==> result [i] == (a [i] as i64) * (b [i] as i64) , decreases a . len () - idx , { let product = (a [idx] as i64) * (b [idx] as i64) ; result . push (product) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_product_impl.rs", "verified": true, "metadata": {"original_id": "d059178c6f16", "function_name": "array_product", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_ensures_d196e324da0e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () ,  { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () ,  { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () ,  { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >) requires bubble_sort_precond (a @) ,  { let mut result = a ; if result . len () >= 2 { let len = result . len () ; bubble_outer (& mut result , len - 2) ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >) requires bubble_sort_precond (a @) , ensures result . len () == a . len () , { let mut result = a ; if result . len () >= 2 { let len = result . len () ; bubble_outer (& mut result , len - 2) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn bubble_sort_precond (a : Seq < i32 >) -> bool { true }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_sort (a : Vec < i32 >) -> (result : Vec < i32 >) requires bubble_sort_precond (a @) , ensures result . len () == a . len () , { let mut result = a ; if result . len () >= 2 { let len = result . len () ; bubble_outer (& mut result , len - 2) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d196e324da0e", "function_name": "bubble_sort", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_3fd1866c621d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize)  ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_69/verina_basic_69_iter_1_current.rs", "verified": true, "metadata": {"original_id": "3fd1866c621d", "function_name": "linear_search_aux", "bug_type": "missing_requires"}}
{"id": "task_a_6ec50bf7bdb9", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize)   { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize)   { helper (xs , target , 0) }\n\n} // verus!", "target_text": "requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , search_insert_precond (xs @ , target) \nensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , search_insert_postcond (xs @ , target , result as int) , idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx \ndecreases ys . len () - idx ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_69/verina_advanced_69_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "6ec50bf7bdb9", "function_name": "search_insert", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_c_missing_invariant_7959cef72ca9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let division_result = arr1 [i] / arr2 [i] ; result . push (division_result) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i , { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let division_result = arr1 [i] / arr2 [i] ; result . push (division_result) ; i = i + 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i , { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let division_result = arr1 [i] / arr2 [i] ; result . push (division_result) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_261_impl.rs", "verified": true, "metadata": {"original_id": "7959cef72ca9", "function_name": "element_wise_division", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_88bffd3a8741", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 ,  { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Diffy/verified/res2_iter_2_current.rs", "verified": true, "metadata": {"original_id": "88bffd3a8741", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_7501af37a05e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] ,  { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_75/verina_basic_75_impl.rs", "verified": true, "metadata": {"original_id": "7501af37a05e", "function_name": "find_min_loop", "bug_type": "missing_ensures"}}
{"id": "task_b_376bfc725936", "task": "task_b", "input_text": "fn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)\nensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "376bfc725936", "function_name": "shared_elements", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_decreases_20267ae8e034", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn helper (lst : & Vec < i32 > , cur_max : i32 , global_max : i32 , index : usize) -> (result : i32) requires index <= lst . len () , lst . len () <= 100 { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn helper (lst : & Vec < i32 > , cur_max : i32 , global_max : i32 , index : usize) -> (result : i32) requires index <= lst . len () , lst . len () <= 100 decreases lst . len () - index { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn helper (lst : & Vec < i32 > , cur_max : i32 , global_max : i32 , index : usize) -> (result : i32) requires index <= lst . len () , lst . len () <= 100 decreases lst . len () - index { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_45/verina_advanced_45_iter_0_original.rs", "verified": true, "metadata": {"original_id": "20267ae8e034", "function_name": "helper", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_invariant_01364d90b6bb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) , { for j in 0 .. text . len ()  { if text [j] == 'Z' || text [j] == 'z' { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) , { for j in 0 .. text . len () invariant forall | i : int | 0 <= i < j ==> text [i] != 'Z' && text [i] != 'z' , { if text [j] == 'Z' || text [j] == 'z' { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) , { for j in 0 .. text . len () invariant forall | i : int | 0 <= i < j ==> text [i] != 'Z' && text [i] != 'z' , { if text [j] == 'Z' || text [j] == 'z' { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "01364d90b6bb", "function_name": "contains_z", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_a1c61a5b9f0b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { if p >= arr . len () || p + 1 >= arr . len () { return true ; } for i in 0 .. (p + 1)  { for j in (p + 1) .. arr . len ()  { if arr [i] >= arr [j] { return false ; } } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { if p >= arr . len () || p + 1 >= arr . len () { return true ; } for i in 0 .. (p + 1) invariant forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k as int] < arr [l] , { for j in (p + 1) .. arr . len () invariant forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k as int] < arr [l] , forall | l : int | (p + 1) <= l < j ==> arr [i as int] < arr [l] , { if arr [i] >= arr [j] { return false ; } } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { if p >= arr . len () || p + 1 >= arr . len () { return true ; } for i in 0 .. (p + 1) invariant forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k as int] < arr [l] , { for j in (p + 1) .. arr . len () invariant forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k as int] < arr [l] , forall | l : int | (p + 1) <= l < j ==> arr [i as int] < arr [l] , { if arr [i] >= arr [j] { return false ; } } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/preconditions_removed/barrier_impl.rs", "verified": true, "metadata": {"original_id": "a1c61a5b9f0b", "function_name": "barrier", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_d1df77f93f4c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 ,  { 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "d1df77f93f4c", "function_name": "triple", "bug_type": "missing_ensures"}}
{"id": "task_b_ca7d8ff7a219", "task": "task_b", "input_text": "fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >)\nrequires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN \nensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant i < a . len () , row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { let sum = a [i] [j] + b [i] [j] ; row . push (sum) ; } c . push (row) ; } c }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant i < a . len () , row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { let sum = a [i] [j] + b [i] [j] ; row . push (sum) ; } c . push (row) ; } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/index_wise_addition_impl.rs", "verified": true, "metadata": {"original_id": "ca7d8ff7a219", "function_name": "index_wise_addition", "has_invariants": true, "has_asserts": false}}
{"id": "task_a_3af70fcd4ee1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool)  { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\n\n} // verus!", "target_text": "requires start < l . len ()\ndecreases l . len () - start", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (l : & Vec < i32 > , start : usize , increasing : bool , started_decreasing : bool) -> (res : bool) requires start < l . len () decreases l . len () - start { if start == l . len () - 1 { return started_decreasing ; } let current = l [start] ; let next = l [start + 1] ; if increasing { if current < next { aux (l , start + 1 , true , false) } else if current > next { if start == 0 { false } else { aux (l , start + 1 , false , true) } } else { false } } else { if current > next { aux (l , start + 1 , false , true) } else { false } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_22/verina_advanced_22_impl.rs", "verified": true, "metadata": {"original_id": "3af70fcd4ee1", "function_name": "aux", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_c_missing_requires_0a7649c8135d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32)  ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\nfn max_array (a : & Vec < i32 >) -> (result : i32)  ensures result == max_array_aux_spec (a , 1nat , a [0]) , forall | k : int | 0 <= k < a . len () ==> result >= a [k] , exists | k : int | 0 <= k < a . len () && result == a [k] , { max_array_aux (a , 1 , a [0]) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\nfn max_array (a : & Vec < i32 >) -> (result : i32) requires max_array_precond (a) , ensures result == max_array_aux_spec (a , 1nat , a [0]) , forall | k : int | 0 <= k < a . len () ==> result >= a [k] , exists | k : int | 0 <= k < a . len () && result == a [k] , { max_array_aux (a , 1 , a [0]) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\nfn max_array (a : & Vec < i32 >) -> (result : i32) requires max_array_precond (a) , ensures result == max_array_aux_spec (a , 1nat , a [0]) , forall | k : int | 0 <= k < a . len () ==> result >= a [k] , exists | k : int | 0 <= k < a . len () && result == a [k] , { max_array_aux (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_74/verina_basic_74_iter_1_current.rs", "verified": true, "metadata": {"original_id": "0a7649c8135d", "function_name": "max_array", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_7809d6963c00", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : & [i32]) -> (res : i32) requires a . len () > 0 , ensures exists | i : int | 0 <= i < a . len () && res == a [i] , forall | i : int | 0 <= i < a . len () ==> a [i] <= res , { let mut max_val = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 0 < idx <= a . len () , exists | i : int | 0 <= i < idx && max_val == a [i] , forall | i : int | 0 <= i < idx ==> a [i] <= max_val , { if a [idx] > max_val { max_val = a [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : & [i32]) -> (res : i32) requires a . len () > 0 , ensures exists | i : int | 0 <= i < a . len () && res == a [i] , forall | i : int | 0 <= i < a . len () ==> a [i] <= res , { let mut max_val = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 0 < idx <= a . len () , exists | i : int | 0 <= i < idx && max_val == a [i] , forall | i : int | 0 <= i < idx ==> a [i] <= max_val , decreases a . len () - idx , { if a [idx] > max_val { max_val = a [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : & [i32]) -> (res : i32) requires a . len () > 0 , ensures exists | i : int | 0 <= i < a . len () && res == a [i] , forall | i : int | 0 <= i < a . len () ==> a [i] <= res , { let mut max_val = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 0 < idx <= a . len () , exists | i : int | 0 <= i < idx && max_val == a [i] , forall | i : int | 0 <= i < idx ==> a [i] <= max_val , decreases a . len () - idx , { if a [idx] > max_val { max_val = a [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/vericoding_dafny_to_verus_specs/numpy_specs/np_max_impl.rs", "verified": true, "metadata": {"original_id": "7809d6963c00", "function_name": "max", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_fef14b4409cb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)  ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)  ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)  ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp_i = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp_i) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_iter_3_current.rs", "verified": true, "metadata": {"original_id": "fef14b4409cb", "function_name": "bubble_outer", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_1114468138b6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () ,  { let mut new_list = Vec :: new () ; assert (k > 0) ; assert (k < list . len ()) ; assert (k - 1 < list . len ()) ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 < list . len () , i <= list . len () , new_list @ == list @ . subrange (0 , i as int) , decreases k - 1 - i , { assert (i < k - 1) ; assert (i < list . len ()) ; new_list . push (list [i]) ; i += 1 ; } assert (i == k - 1) ; assert (k - 1 < list . len ()) ; let mut j = k ; while j < list . len () invariant k <= j <= list . len () , k < list . len () , k - 1 < list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { assert (j < list . len ()) ; new_list . push (list [j]) ; j += 1 ; } assert (j == list . len ()) ; assert (new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int))) ; new_list }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; assert (k > 0) ; assert (k < list . len ()) ; assert (k - 1 < list . len ()) ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 < list . len () , i <= list . len () , new_list @ == list @ . subrange (0 , i as int) , decreases k - 1 - i , { assert (i < k - 1) ; assert (i < list . len ()) ; new_list . push (list [i]) ; i += 1 ; } assert (i == k - 1) ; assert (k - 1 < list . len ()) ; let mut j = k ; while j < list . len () invariant k <= j <= list . len () , k < list . len () , k - 1 < list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { assert (j < list . len ()) ; new_list . push (list [j]) ; j += 1 ; } assert (j == list . len ()) ; assert (new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int))) ; new_list }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; assert (k > 0) ; assert (k < list . len ()) ; assert (k - 1 < list . len ()) ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 < list . len () , i <= list . len () , new_list @ == list @ . subrange (0 , i as int) , decreases k - 1 - i , { assert (i < k - 1) ; assert (i < list . len ()) ; new_list . push (list [i]) ; i += 1 ; } assert (i == k - 1) ; assert (k - 1 < list . len ()) ; let mut j = k ; while j < list . len () invariant k <= j <= list . len () , k < list . len () , k - 1 < list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { assert (j < list . len ()) ; new_list . push (list [j]) ; j += 1 ; } assert (j == list . len ()) ; assert (new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int))) ; new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_610_impl.rs", "verified": true, "metadata": {"original_id": "1114468138b6", "function_name": "remove_kth_element", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_dba398f0c0c8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_odd_at_odd_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - index { if (index % 2) != (arr [index] % 2) { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_775_impl.rs", "verified": true, "metadata": {"original_id": "dba398f0c0c8", "function_name": "is_odd_at_odd_index", "bug_type": "missing_decreases"}}
{"id": "task_b_c9ec81a21486", "task": "task_b", "input_text": "fn is_digit (c : u8) -> (res : bool)\nensures res == is_digit_sepc (c) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_sepc (c) , { c >= 48 && c <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "c9ec81a21486", "function_name": "is_digit", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_9da300340c57", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_divisible_by_k_precond (arr : Seq < i32 > , k : i32) -> bool { k > 0 }\nspec fn max_subarray_sum_divisible_by_k_postcond (arr : Seq < i32 > , k : i32 , result : i32) -> bool { let result_int = result as int ; (result == 0 ==> (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= 0)) && (result != 0 ==> ((exists | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) && get_subarray_sum (arr , start , len) == result_int) && (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= result_int))) }\nspec fn get_subarray_sum (arr : Seq < i32 > , start : int , len : int) -> int { if 0 <= start && start + len <= arr . len () && len >= 0 { array_sum (arr . subrange (start , start + len)) } else { 0int } }\nspec fn is_divisible_subarray (arr : Seq < i32 > , start : int , len : int , k : i32) -> bool { 0 <= start && start + len <= arr . len () && len > 0 && len % (k as int) == 0 }\nspec fn array_sum (arr : Seq < i32 >) -> int { if arr . len () == 0 { 0int } else { arr [0] as int + array_sum (arr . subrange (1 , arr . len () as int)) } }\n# [verifier :: external_body] fn max_subarray_sum_divisible_by_k (arr : & Vec < i32 > , k : i32) -> (result : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires max_subarray_sum_divisible_by_k_precond (arr @ , k) \nensures max_subarray_sum_divisible_by_k_postcond (arr @ , k , result) \ndecreases arr . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_subarray_sum_divisible_by_k_precond (arr : Seq < i32 > , k : i32) -> bool { k > 0 }\nspec fn max_subarray_sum_divisible_by_k_postcond (arr : Seq < i32 > , k : i32 , result : i32) -> bool { let result_int = result as int ; (result == 0 ==> (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= 0)) && (result != 0 ==> ((exists | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) && get_subarray_sum (arr , start , len) == result_int) && (forall | start : int , len : int | # ! [auto] is_divisible_subarray (arr , start , len , k) ==> get_subarray_sum (arr , start , len) <= result_int))) }\nspec fn get_subarray_sum (arr : Seq < i32 > , start : int , len : int) -> int { if 0 <= start && start + len <= arr . len () && len >= 0 { array_sum (arr . subrange (start , start + len)) } else { 0int } }\nspec fn is_divisible_subarray (arr : Seq < i32 > , start : int , len : int , k : i32) -> bool { 0 <= start && start + len <= arr . len () && len > 0 && len % (k as int) == 0 }\nspec fn array_sum (arr : Seq < i32 >) -> int decreases arr . len () { if arr . len () == 0 { 0int } else { arr [0] as int + array_sum (arr . subrange (1 , arr . len () as int)) } }\n# [verifier :: external_body] fn max_subarray_sum_divisible_by_k (arr : & Vec < i32 > , k : i32) -> (result : i32) requires max_subarray_sum_divisible_by_k_precond (arr @ , k) , ensures max_subarray_sum_divisible_by_k_postcond (arr @ , k , result) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_44/verina_advanced_44_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9da300340c57", "function_name": "max_subarray_sum_divisible_by_k", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_c_missing_ensures_0cca59d8cea0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) ,  { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_618_impl.rs", "verified": true, "metadata": {"original_id": "0cca59d8cea0", "function_name": "element_wise_divide", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_28fc4eedcec5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_to_int (a : Seq < i32 >) -> Seq < int > { a . map (| _idx : int , x : i32 | x as int) }\nspec fn is_prefix_sum_for (a : Seq < int > , c : Seq < int >) -> bool { &&& a . len () + 1 == c . len () &&& c [0] == 0 &&& forall | i : int | 0 <= i < a . len () ==> c [i + 1] == c [i] + a [i] }\nspec fn sum (a : Seq < int > , i : int , j : int) -> int decreases j - i { if i >= j { 0 } else { a [i] + sum (a , i + 1 , j) } }\nproof fn aux (a : Seq < int > , c : Seq < int > , i : int , j : int)  ensures sum (a , i , j) == c [j] - c [i] decreases j - i { if i == j { } else { aux (a , c , i + 1 , j) ; } }\nfn query_fast (a : & Vec < i32 > , c : & Vec < i32 > , i : usize , j : usize) -> (r : i32)  ensures r == sum (seq_to_int (a @) , i as int , j as int) { proof { aux (seq_to_int (a @) , seq_to_int (c @) , i as int , j as int) ; } c [j] - c [i] }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_to_int (a : Seq < i32 >) -> Seq < int > { a . map (| _idx : int , x : i32 | x as int) }\nspec fn is_prefix_sum_for (a : Seq < int > , c : Seq < int >) -> bool { &&& a . len () + 1 == c . len () &&& c [0] == 0 &&& forall | i : int | 0 <= i < a . len () ==> c [i + 1] == c [i] + a [i] }\nspec fn sum (a : Seq < int > , i : int , j : int) -> int decreases j - i { if i >= j { 0 } else { a [i] + sum (a , i + 1 , j) } }\nproof fn aux (a : Seq < int > , c : Seq < int > , i : int , j : int) requires 0 <= i <= j <= a . len () , a . len () + 1 == c . len () , c [0] == 0 , is_prefix_sum_for (a , c) ensures sum (a , i , j) == c [j] - c [i] decreases j - i { if i == j { } else { aux (a , c , i + 1 , j) ; } }\nfn query_fast (a : & Vec < i32 > , c : & Vec < i32 > , i : usize , j : usize) -> (r : i32) requires a . len () + 1 == c . len () , c [0] == 0 , i <= j <= a . len () , is_prefix_sum_for (seq_to_int (a @) , seq_to_int (c @)) , forall | k : int | 0 <= k < c @ . len () ==> - 1000000 <= # [trigger] c @ [k] <= 1000000 , ensures r == sum (seq_to_int (a @) , i as int , j as int) { proof { aux (seq_to_int (a @) , seq_to_int (c @) , i as int , j as int) ; } c [j] - c [i] }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_to_int (a : Seq < i32 >) -> Seq < int > { a . map (| _idx : int , x : i32 | x as int) }\nspec fn is_prefix_sum_for (a : Seq < int > , c : Seq < int >) -> bool { &&& a . len () + 1 == c . len () &&& c [0] == 0 &&& forall | i : int | 0 <= i < a . len () ==> c [i + 1] == c [i] + a [i] }\nspec fn sum (a : Seq < int > , i : int , j : int) -> int decreases j - i { if i >= j { 0 } else { a [i] + sum (a , i + 1 , j) } }\nproof fn aux (a : Seq < int > , c : Seq < int > , i : int , j : int) requires 0 <= i <= j <= a . len () , a . len () + 1 == c . len () , c [0] == 0 , is_prefix_sum_for (a , c) ensures sum (a , i , j) == c [j] - c [i] decreases j - i { if i == j { } else { aux (a , c , i + 1 , j) ; } }\nfn query_fast (a : & Vec < i32 > , c : & Vec < i32 > , i : usize , j : usize) -> (r : i32) requires a . len () + 1 == c . len () , c [0] == 0 , i <= j <= a . len () , is_prefix_sum_for (seq_to_int (a @) , seq_to_int (c @)) , forall | k : int | 0 <= k < c @ . len () ==> - 1000000 <= # [trigger] c @ [k] <= 1000000 , ensures r == sum (seq_to_int (a @) , i as int , j as int) { proof { aux (seq_to_int (a @) , seq_to_int (c @) , i as int , j as int) ; } c [j] - c [i] }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/CVS-handout1_tmp_tmptm52no3k_1/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "28fc4eedcec5", "function_name": "query_fast", "bug_type": "missing_requires"}}
{"id": "task_c_missing_assert_e419f4a84550", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits_spec_satisfied (s : Vec < char >) requires all_digits_precond (s @) { let result = all_digits (& s) ;  }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits_spec_satisfied (s : Vec < char >) requires all_digits_precond (s @) { let result = all_digits (& s) ; assert (all_digits_postcond (s @ , result)) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn all_digits_precond (s : Seq < char >) -> bool { true }\nspec fn all_digits_postcond (s : Seq < char > , result : bool) -> bool { result == (forall | i : int | 0 <= i < s . len () ==> is_digit_spec (s [i])) }\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn all_digits (s : & Vec < char >) -> (result : bool) requires all_digits_precond (s @) , ensures all_digits_postcond (s @ , result) , { let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (s @ [j]) , decreases s . len () - i { if ! is_digit (s [i]) { return false ; } i += 1 ; } true }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\nfn all_digits_spec_satisfied (s : Vec < char >) requires all_digits_precond (s @) { let result = all_digits (& s) ; assert (all_digits_postcond (s @ , result)) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_61/verina_basic_61_impl.rs", "verified": true, "metadata": {"original_id": "e419f4a84550", "function_name": "all_digits_spec_satisfied", "bug_type": "missing_assert"}}
{"id": "task_c_missing_ensures_c51551a2d340", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) , decreases str1 . len () - idx { let c = str1 [idx] ; if c >= 'a' && c <= 'z' { let uppercase_c = ((c as u8) - 32) as char ; result . push (uppercase_c) ; } else { result . push (c) ; } idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (inner_expr_to_uppercase (str1 , i))) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) , decreases str1 . len () - idx { let c = str1 [idx] ; if c >= 'a' && c <= 'z' { let uppercase_c = ((c as u8) - 32) as char ; result . push (uppercase_c) ; } else { result . push (c) ; } idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (inner_expr_to_uppercase (str1 , i))) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) , decreases str1 . len () - idx { let c = str1 [idx] ; if c >= 'a' && c <= 'z' { let uppercase_c = ((c as u8) - 32) as char ; result . push (uppercase_c) ; } else { result . push (c) ; } idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_624_impl.rs", "verified": true, "metadata": {"original_id": "c51551a2d340", "function_name": "to_uppercase", "bug_type": "missing_ensures"}}
{"id": "task_b_67588e015e9d", "task": "task_b", "input_text": "fn smallest_num (nums : & Vec < i32 >) -> (min : i32)\nrequires nums . len () > 0 \nensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len () invariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] , decreases nums . len () - j { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_num (nums : & Vec < i32 >) -> (min : i32) requires nums . len () > 0 , ensures forall | i : int | 0 <= i < nums . len () ==> min <= nums [i] , exists | i : int | 0 <= i < nums . len () && min == nums [i] , { let mut min = nums [0] ; let mut j = 1 ; while j < nums . len () invariant 1 <= j <= nums . len () , forall | i : int | 0 <= i < j ==> min <= nums [i] , exists | i : int | 0 <= i < j && min == nums [i] , decreases nums . len () - j { if nums [j] < min { min = nums [j] ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_62_iter_2_current.rs", "verified": true, "metadata": {"original_id": "67588e015e9d", "function_name": "smallest_num", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_ensures_55769cda55ba", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool)  { c == ' ' || c == ',' || c == '.' }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { c == ' ' || c == ',' || c == '.' }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_space_comma_dot_spec (c : char) -> bool { c == ' ' || c == ',' || c == '.' }\nfn is_space_comma_dot (c : char) -> (result : bool) ensures result == is_space_comma_dot_spec (c) { c == ' ' || c == ',' || c == '.' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_36/verina_basic_36_impl.rs", "verified": true, "metadata": {"original_id": "55769cda55ba", "function_name": "is_space_comma_dot", "bug_type": "missing_ensures"}}
{"id": "task_a_ddcc6d106cdf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool)  { let code = c as u32 ; code >= 48 && code <= 57 }\n\n} // verus!", "target_text": "ensures res == is_digit_sepc (c) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_sepc (c : char) -> (res : bool) { (c as u32) >= 48 && (c as u32) <= 57 }\nfn is_digit (c : char) -> (res : bool) ensures res == is_digit_sepc (c) , { let code = c as u32 ; code >= 48 && code <= 57 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ddcc6d106cdf", "function_name": "is_digit", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_16383c330ae4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn happy_spec (s : Seq < char >) -> (ret : bool) { s . len () >= 3 && (forall | i : int | 0 < i && i + 1 < s . len () ==> three_distinct_spec (s , i)) }\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () ,  { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n# [verifier :: loop_isolation (false)] fn is_happy (s : & Vec < char >) -> (happy : bool)  { if s . len () < 3 { return false ; } let mut j : usize = 1 ; while j + 1 < s . len () invariant s . len () >= 3 , 1 <= j <= s . len () - 1 , forall | i : int | 1 <= i < j ==> three_distinct_spec (s @ , i) , decreases s . len () - j { if ! three_distinct (s , j) { return false ; } j = j + 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn happy_spec (s : Seq < char >) -> (ret : bool) { s . len () >= 3 && (forall | i : int | 0 < i && i + 1 < s . len () ==> three_distinct_spec (s , i)) }\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n# [verifier :: loop_isolation (false)] fn is_happy (s : & Vec < char >) -> (happy : bool) ensures happy <==> happy_spec (s @) , { if s . len () < 3 { return false ; } let mut j : usize = 1 ; while j + 1 < s . len () invariant s . len () >= 3 , 1 <= j <= s . len () - 1 , forall | i : int | 1 <= i < j ==> three_distinct_spec (s @ , i) , decreases s . len () - j { if ! three_distinct (s , j) { return false ; } j = j + 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn happy_spec (s : Seq < char >) -> (ret : bool) { s . len () >= 3 && (forall | i : int | 0 < i && i + 1 < s . len () ==> three_distinct_spec (s , i)) }\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n# [verifier :: loop_isolation (false)] fn is_happy (s : & Vec < char >) -> (happy : bool) ensures happy <==> happy_spec (s @) , { if s . len () < 3 { return false ; } let mut j : usize = 1 ; while j + 1 < s . len () invariant s . len () >= 3 , 1 <= j <= s . len () - 1 , forall | i : int | 1 <= i < j ==> three_distinct_spec (s @ , i) , decreases s . len () - j { if ! three_distinct (s , j) { return false ; } j = j + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/080-is_happy_iter_2_current.rs", "verified": true, "metadata": {"original_id": "16383c330ae4", "function_name": "is_happy", "bug_type": "missing_ensures"}}
{"id": "task_b_82193e2a0593", "task": "task_b", "input_text": "fn search_insert (xs : & Vec < int > , target : int) -> (result : usize)\nrequires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , search_insert_precond (xs @ , target) \nensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , search_insert_postcond (xs @ , target , result as int) , idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_69/verina_advanced_69_impl.rs", "verified": true, "metadata": {"original_id": "82193e2a0593", "function_name": "search_insert", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_requires_c20619b9e882", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nspec fn max_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32)  ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\nfn max_array (a : & Vec < i32 >) -> (result : i32)  ensures result == max_array_aux_spec (a , 1nat , a [0]) , forall | k : int | 0 <= k < a . len () ==> result >= a [k] , exists | k : int | 0 <= k < a . len () && result == a [k] , { max_array_aux (a , 1 , a [0]) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nspec fn max_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\nfn max_array (a : & Vec < i32 >) -> (result : i32) requires max_array_precond (a) , ensures result == max_array_aux_spec (a , 1nat , a [0]) , forall | k : int | 0 <= k < a . len () ==> result >= a [k] , exists | k : int | 0 <= k < a . len () && result == a [k] , { max_array_aux (a , 1 , a [0]) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_array_aux_spec (a : & Vec < i32 > , index : nat , current : i32) -> i32 recommends index <= a . len () , a . len () > 0 , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index as int] { current } else { a [index as int] } ; max_array_aux_spec (a , index + 1 , new_current) } else { current } }\nspec fn max_array_precond (a : & Vec < i32 >) -> bool { a . len () > 0 }\nfn max_array_aux (a : & Vec < i32 > , index : usize , current : i32) -> (result : i32) requires index <= a . len () , a . len () > 0 , ensures result == max_array_aux_spec (a , index as nat , current) , result >= current , forall | k : int | index <= k < a . len () ==> result >= a [k] , (exists | k : int | index <= k < a . len () && result == a [k]) || result == current , decreases a . len () - index , { if index < a . len () { let new_current = if current > a [index] { current } else { a [index] } ; max_array_aux (a , index + 1 , new_current) } else { current } }\nfn max_array (a : & Vec < i32 >) -> (result : i32) requires max_array_precond (a) , ensures result == max_array_aux_spec (a , 1nat , a [0]) , forall | k : int | 0 <= k < a . len () ==> result >= a [k] , exists | k : int | 0 <= k < a . len () && result == a [k] , { max_array_aux (a , 1 , a [0]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_74/verina_basic_74_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "c20619b9e882", "function_name": "max_array", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_1bc64135516d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool)  { if a . len () == 0 { return true ; } let first = a [0] ; for i in 1 .. a . len () invariant forall | k : int | 0 <= k < i ==> a [k] == first , { if a [i] != first { return false ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; for i in 1 .. a . len () invariant forall | k : int | 0 <= k < i ==> a [k] == first , { if a [i] != first { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn has_only_one_distinct_element (a : & [i32]) -> (result : bool) ensures result ==> forall | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () ==> a [i] == a [j] , ! result ==> exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < a . len () && a [i] != a [j] , { if a . len () == 0 { return true ; } let first = a [0] ; for i in 1 .. a . len () invariant forall | k : int | 0 <= k < i ==> a [k] == first , { if a [i] != first { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/has_only_one_distinct_element_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1bc64135516d", "function_name": "has_only_one_distinct_element", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_583c089d4d04", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof {   } return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (exists | k : int | 0 <= k < arr2 . len () && arr2 [k] == arr1 [i as int]) ; assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn any_value_exists (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) ensures result == exists | k : int | 0 <= k < arr1 . len () && arr2 @ . contains (# [trigger] arr1 [k]) , { for i in 0 .. arr1 . len () invariant forall | j : int | 0 <= j < i ==> ! arr2 @ . contains (arr1 [j]) , { if contains (arr2 , arr1 [i]) { proof { assert (exists | k : int | 0 <= k < arr2 . len () && arr2 [k] == arr1 [i as int]) ; assert (arr2 @ . contains (arr1 [i as int])) ; } return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_414_iter_3_current.rs", "verified": true, "metadata": {"original_id": "583c089d4d04", "function_name": "any_value_exists", "bug_type": "missing_assert"}}
{"id": "task_c_missing_invariant_f417526be3c4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0 ; while i < numbers . len ()  { let mut j = 0 ; while j < numbers . len ()  { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = if diff < 0 { - diff } else { diff } ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold decreases numbers . len () - i { let mut j = 0 ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold , forall | y : int | 0 <= y && y < j && (i as int) != y ==> abs_spec (numbers [i as int] - numbers [y]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = if diff < 0 { - diff } else { diff } ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold decreases numbers . len () - i { let mut j = 0 ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | x : int , y : int | 0 <= x && x < i && 0 <= y && y < numbers . len () && x != y ==> abs_spec (numbers [x] - numbers [y]) >= threshold , forall | y : int | 0 <= y && y < j && (i as int) != y ==> abs_spec (numbers [i as int] - numbers [y]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = if diff < 0 { - diff } else { diff } ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/has_close_elements_iter_3_current.rs", "verified": true, "metadata": {"original_id": "f417526be3c4", "function_name": "has_close_elements", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_16383c330ae4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn happy_spec (s : Seq < char >) -> (ret : bool) { s . len () >= 3 && (forall | i : int | 0 < i && i + 1 < s . len () ==> three_distinct_spec (s , i)) }\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool)  ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n# [verifier :: loop_isolation (false)] fn is_happy (s : & Vec < char >) -> (happy : bool) ensures happy <==> happy_spec (s @) , { if s . len () < 3 { return false ; } let mut j : usize = 1 ; while j + 1 < s . len () invariant s . len () >= 3 , 1 <= j <= s . len () - 1 , forall | i : int | 1 <= i < j ==> three_distinct_spec (s @ , i) , decreases s . len () - j { if ! three_distinct (s , j) { return false ; } j = j + 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn happy_spec (s : Seq < char >) -> (ret : bool) { s . len () >= 3 && (forall | i : int | 0 < i && i + 1 < s . len () ==> three_distinct_spec (s , i)) }\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n# [verifier :: loop_isolation (false)] fn is_happy (s : & Vec < char >) -> (happy : bool) ensures happy <==> happy_spec (s @) , { if s . len () < 3 { return false ; } let mut j : usize = 1 ; while j + 1 < s . len () invariant s . len () >= 3 , 1 <= j <= s . len () - 1 , forall | i : int | 1 <= i < j ==> three_distinct_spec (s @ , i) , decreases s . len () - j { if ! three_distinct (s , j) { return false ; } j = j + 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn happy_spec (s : Seq < char >) -> (ret : bool) { s . len () >= 3 && (forall | i : int | 0 < i && i + 1 < s . len () ==> three_distinct_spec (s , i)) }\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n# [verifier :: loop_isolation (false)] fn is_happy (s : & Vec < char >) -> (happy : bool) ensures happy <==> happy_spec (s @) , { if s . len () < 3 { return false ; } let mut j : usize = 1 ; while j + 1 < s . len () invariant s . len () >= 3 , 1 <= j <= s . len () - 1 , forall | i : int | 1 <= i < j ==> three_distinct_spec (s @ , i) , decreases s . len () - j { if ! three_distinct (s , j) { return false ; } j = j + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/080-is_happy_iter_2_current.rs", "verified": true, "metadata": {"original_id": "16383c330ae4", "function_name": "is_happy", "bug_type": "missing_requires"}}
{"id": "task_a_da09a0a8af91", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize)   { let mut max_index = 0 ; let mut i = 1 ; while i < x . len ()  { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "target_text": "requires x . len () >= 1 \nensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () \ndecreases x . len () - i\ninvariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index = 0 ; let mut i = 1 ; while i < x . len () invariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] , decreases x . len () - i { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/max_index_iter_2_current.rs", "verified": true, "metadata": {"original_id": "da09a0a8af91", "function_name": "myfun1", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_decreases_vostd_map_extra_a1f35ebe1435", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd::{map::*, set::*};\n\nverus! {\n\n/// The length of inserting a key-value pair `(k,v)` into a map `m` depends on whether\n/// the key `k` already exists in the map. If it does, the length remains the same;\n/// if it doesn't, the length increases by 1.\npub proof fn lemma_map_insert_len<K, V>(m: Map<K, V>, k: K, v: V)\n    requires\n        m.dom().finite(),\n    ensures\n        #[trigger] m.insert(k, v).len() == m.len() + (if m.contains_key(k) {\n            0int\n        } else {\n            1\n        }),\n{\n    axiom_map_insert_domain(m, k, v)\n}\n\n/// The length of removing a key-value pair `(k,v)` from a map `m` depends on whether\n/// the key `k` exists in the map. If it does, the length {\n            1\n        } else {\n            0int\n        }),\n{\n    axiom_map_remove_domain(m, k)\n}\n\n/// Filters a map based on a predicate function applied to its values.\npub open spec fn value_filter<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool) -> Map<K, V> {\n    m.restrict(m.dom().filter(|s| f(m[s])))\n}\n\npub open spec fn value_filter_choose<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool) -> K {\n    choose|k: K| value_filter(m, f).contains_key(k)\n}\n\npub broadcast group group_value_filter_lemmas {\n    lemma_value_filter_finite,\n    lemma_value_filter_choose,\n    lemma_insert_value_filter_same_len,\n    lemma_insert_value_filter_different_len_contains,\n    lemma_insert_value_filter_different_len_not_contains,\n}\n\n/// The result of value-filtering a finite map is also finite.\npub broadcast proof fn lemma_value_filter_finite<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n    requires\n        m.dom().finite(),\n    ensures\n        #[trigger] value_filter(m, f).dom().finite(),\n{\n    assert(value_filter(m, f).dom() == m.dom().filter(|s| f(m[s])));\n    m.dom().lemma_len_filter(|s| f(m[s]));\n}\n\n/// If a key `k` exists in the map `m`, then whether the value-filtered map\n/// contains the key depends on whether the predicate function `f` is true for\n/// its value.\npub proof fn lemma_value_filter_contains<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        m.contains_key(k),\n    ensures\n        if f(m[k]) {\n            value_filter(m, f).contains_key(k)\n        } else {\n            !value_filter(m, f).contains_key(k)\n        },\n{\n}\n\n/// If the predicate function `f` is true for all values in the map `m`, then\n/// the value-filtered map is equal to the original map.\npub proof fn lemma_value_filter_all_true<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n    requires\n        forall|k: K| m.contains_key(k) ==> #[trigger] f(m[k]),\n    ensures\n        value_filter(m, f) =~= m,\n{\n}\n\n/// If the predicate function `f` is false for all values in the map `m`, then\n/// the value-filtered map is empty.\npub proof fn lemma_value_filter_all_false<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n    ensures\n        value_filter(m, f).is_empty() <==> forall|k: K| m.contains_key(k) ==> !#[trigger] f(m[k]),\n{\n    if value_filter(m, f).is_empty() {\n        assert forall|k: K| m.contains_key(k) implies !#[trigger] f(m[k]) by {\n            if f(m[k]) {\n                assert(value_filter(m, f).contains_key(k));\n            }\n        }\n    }\n}\n\n/// If the predicate function `f` is true for `m[k]`, then fist removing `k`\n/// from the map `m` and then applying the value filter is equivalent to\n/// applying the value filter first and then removing `k` from the result.\npub proof fn lemma_remove_value_filter_true<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        f(m[k]),\n    ensures\n        value_filter(m.remove(k), f) =~= value_filter(m, f).remove(k),\n{\n}\n\n/// If the predicate function `f` is false for `m[k]`, then first removing `k`\n/// from the map `m` and then applying the value filter is equivalent to\n/// directly applying the value filter to the original map `m`.\npub proof fn lemma_remove_value_filter_false<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        !f(m[k]),\n    ensures\n        value_filter(m.remove(k), f) =~= value_filter(m, f),\n{\n}\n\n/// If the predicate function `f` is true for the newly inserted value `v`,\n/// then inserting `(k,v)` into the map `m` and then applying the value filter\n/// is equivalent to applying the value filter to the original map `m` and\n/// then inserting `(k,v)` into the result.\npub proof fn lemma_insert_value_filter_true<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K, v: V)\n    requires\n        f(v),\n    ensures\n        value_filter(m.insert(k, v), f) =~= value_filter(m, f).insert(k, v),\n{\n}\n\n/// If the predicate function `f` is false for the newly inserted value `v`,\n/// then inserting `(k,v)` into the map `m` and then applying the value filter\n/// is equivalent to applying the value filter to the original map `m` and\n/// then removing `k` from the result (if 'k' exists in 'm') or leaving it unchanged\n/// (if it doesn't).\npub proof fn lemma_insert_value_filter_false<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K, v: V)\n    requires\n        !f(v),\n    ensures\n        value_filter(m.insert(k, v), f) =~= if m.contains_key(k) {\n            value_filter(m, f).remove(k)\n        } else {\n            value_filter(m, f)\n        },\n        value_filter(m.insert(k, v), f) =~= if m.contains_key(k) {\n            value_filter(m, f).remove(k)\n        } else {\n            value_filter(m, f)\n        },\n{\n}\n\n/// The length of the value-filtered map after inserting `(k,v)` into `m`\n/// is equal to the length of the value-filtered map for the original map `m`\n/// if `k` exists in `m`, and `m[k]` and `v` both satisfy/un-satisfy the predicate\n/// function `f`.\npub broadcast proof fn lemma_insert_value_filter_same_len<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n    requires\n        m.dom().finite(),\n        m.contains_key(k) && f(m[k]) == f(v) || !m.contains_key(k) && !f(v),\n    ensures\n        #[trigger] value_filter(m.insert(k, v), f).len() == value_filter(m, f).len(),\n{\n    lemma_value_filter_finite(m, f);\n    if f(v) {\n        lemma_insert_value_filter_true(m, f, k, v);\n        lemma_map_insert_len(value_filter(m, f), k, v);\n    } else {\n        lemma_insert_value_filter_false(m, f, k, v);\n        lemma_map_remove_len(value_filter(m, f), k);\n    }\n}\n\n/// The length of the value-filtered map after inserting `(k,v)` into `m`\n/// is equal to the length of the value-filtered map for the original map `m`\n/// plus one if `m[k]` does not satisfy `f` but `v` does, and minus one if\n/// `m[k]` satisfies `f` but `v` does not.\npub broadcast proof fn lemma_insert_value_filter_different_len_contains<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n    requires\n        m.dom().finite(),\n        m.contains_key(k),\n        f(m[k]) != f(v),\n    ensures\n        #[trigger] value_filter(m.insert(k, v), f).len() == value_filter(m, f).len() + if f(v) {\n            1\n        } else {\n            -1\n        },\n{\n    lemma_value_filter_finite(m, f);\n    if (f(v)) {\n        lemma_insert_value_filter_true(m, f, k, v);\n        lemma_map_insert_len(m, k, v);\n    } else {\n        lemma_insert_value_filter_false(m, f, k, v);\n        assert(value_filter(m.insert(k, v), f).len() == value_filter(m, f).remove(k).len());\n        lemma_map_remove_len(value_filter(m, f), k);\n    }\n}\n\n/// The length of the value-filtered map after inserting `(k,v)` into `m`\n/// is equal to the length of the value-filtered map for the original map `m`\n/// plus one if `k` does not exist in `m` and `v` satisfies the predicate function `f`.\npub broadcast proof fn lemma_insert_value_filter_different_len_not_contains<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n    requires\n        m.dom().finite(),\n        !m.contains_key(k),\n        f(v),\n    ensures\n        #[trigger] value_filter(m.insert(k, v), f).len() == value_filter(m, f).len() + 1,\n{\n    lemma_value_filter_finite(m, f);\n    lemma_insert_value_filter_true(m, f, k, v);\n    lemma_map_insert_len(m, k, v);\n}\n\npub proof fn lemma_value_filter_contains_key<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        value_filter(m, f).contains_key(k),\n    ensures\n        m.contains_key(k),\n{\n}\n\npub broadcast proof fn lemma_value_filter_choose<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n    requires\n        value_filter(m, f).len() != 0,\n    ensures\n        value_filter(m, f).contains_key(#[trigger] value_filter_choose(m, f)),\n        f(m[value_filter_choose(m, f)]),\n{\n    if value_filter(m, f).dom().finite() {\n        axiom_set_choose_len(value_filter(m, f).dom());\n    } else {\n        axiom_set_choose_infinite(value_filter(m, f).dom());\n    }\n}\n\n} // verus!\nverus! {\n\n/// Returns true if predicate `f(k,v)` holds for all `(k,v)` in `map`.\npub open spec fn forall_map<K, V>(map: Map<K, V>, f: spec_fn(K, V) -> bool) -> bool {\n    forall|k| #[trigger] map.contains_key(k) ==> f(k, map[k])\n}\n\n/// Returns true if predicate `f(v)` holds for all values in `map`.\npub open spec fn forall_map_values<K, V>(map: Map<K, V>, f: spec_fn(V) -> bool) -> bool {\n    forall|k| #[trigger] map.contains_key(k) ==> f(map[k])\n}\n\npub broadcast group group_forall_map_lemmas {\n    lemma_forall_map_insert,\n    lemma_forall_map_values_insert,\n    lemma_forall_map_remove,\n    lemma_forall_map_values_remove,\n}\n\n/// For any key in the map, `f(k, map[k])` holds if `forall_map(map, f)` holds.\npub proof fn lemma_forall_map_entry<K, V>(m: Map<K, V>, f: spec_fn(K, V) -> bool, k: K)\n    requires\n        forall_map(m, f),\n        m.contains_key(k),\n    ensures\n        f(k, m[k]),\n{\n}\n\n/// For any key in the map, `f(map[k])` holds if `forall_map_values(map, f)` holds.\npub proof fn lemma_forall_map_values_entry<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        forall_map_values(m, f),\n        m.contains_key(k),\n    ensures\n        f(m[k]),\n{\n}\n\n/// `forall_map(m.insert(k, v), f)` holds if `f(k, v)` holds and\n/// `forall_map(m.remove(k),f)` (if `m` contains `k`) or `forall_map(m, f)` (if `m` does not contain `k`).\npub broadcast proof fn lemma_forall_map_insert<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(K, V) -> bool,\n    k: K,\n    v: V,\n)\n    ensures\n        #[trigger] forall_map(m.insert(k, v), f) ==> f(k, v) && if m.contains_key(k) {\n            forall_map(m.remove(k), f)\n        } else {\n            forall_map(m, f)\n        },\n{\n    assert(m.insert(k, v).contains_key(k));\n    if m.contains_key(k) {\n        assert(m.insert(k, v) == m.remove(k).insert(k, v));\n    } else {\n        assert(m.insert(k, v) == m.insert(k, v));\n    }\n    if forall_map(m.insert(k, v), f) {\n        if m.contains_key(k) {\n        } else {\n            assert(forall|k0| #[trigger] m.contains_key(k0) ==> m.insert(k, v).contains_key(k0));\n        }\n    }\n}\n\n/// `forall_map_values(m.insert(k, v), f)` holds if `f(v)` holds and\n/// `forall_map_values(m.remove(k),f)` (if `m` contains `k`) or `forall_map_values(m, f)` (if `m` does not contain `k`).\npub broadcast proof fn lemma_forall_map_values_insert<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n    ensures\n        #[trigger] forall_map_values(m.insert(k, v), f) ==> f(v) && if m.contains_key(k) {\n            forall_map_values(m.remove(k), f)\n        } else {\n            forall_map_values(m, f)\n        },\n{\n    assert(m.insert(k, v).contains_key(k));\n    if m.contains_key(k) {\n        assert(m.insert(k, v) == m.remove(k).insert(k, v));\n    } else {\n        assert(m.insert(k, v) == m.insert(k, v));\n    }\n    if forall_map_values(m.insert(k, v), f) {\n        if m.contains_key(k) {\n        } else {\n            assert(forall|k0| #[trigger] m.contains_key(k0) ==> m.insert(k, v).contains_key(k0));\n        }\n    }\n}\n\n/// `forall_map(m,f)` holds if `forall_map(m.remove(k), f)` holds and\n/// `f(k, m[k])` holds (if `m` contains `k`).\npub broadcast proof fn lemma_forall_map_remove<K, V>(m: Map<K, V>, f: spec_fn(K, V) -> bool, k: K)\n    ensures\n        forall_map(m, f) <==> #[trigger] forall_map(m.remove(k), f) && (m.contains_key(k) ==> f(\n            k,\n            m[k],\n        )),\n{\n    if m.contains_key(k) {\n        assert(m == m.remove(k).insert(k, m[k]));\n    } else {\n        assert(m == m.remove(k));\n    }\n}\n\n/// `forall_map_values(m,f)` holds if `forall_map_values(m.remove(k), f)` holds and\n/// `f(m[k])` holds (if `m` contains `k`).\npub broadcast proof fn lemma_forall_map_values_remove<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n)\n    ensures\n        forall_map_values(m, f) <==> #[trigger] forall_map_values(m.remove(k), f) && (\n        m.contains_key(k) ==> f(m[k])),\n{\n    if m.contains_key(k) {\n        assert(m == m.remove(k).insert(k, m[k]));\n    } else {\n        assert(m == m.remove(k));\n    }\n\n}\n\n/// Returns a new map that projects the first key of a pair `(K1, K2)`,\n/// keeping the values associated with the second key `K2`.\npub open spec fn project_first_key<K1, K2, V>(m: Map<(K1, K2), V>, k1: K1) -> Map<K2, V> {\n    Map::new(|k2: K2| m.contains_key((k1, k2)), |k2: K2| m[(k1, k2)])\n}\n\n/// Returns a new map that projects the second key of a pair `(K1, K2)`,\n/// keeping the values associated with the first key `K1`.\npub open spec fn project_second_key<K1, K2, V>(m: Map<(K1, K2), V>, k2: K2) -> Map<K1, V> {\n    Map::new(|k1: K1| m.contains_key((k1, k2)), |k1: K1| m[(k1, k2)])\n}\n\n/// A lemma showing that `project_first_key`` is sound.\n/// There is no need to actually use this lemma in practice at most of the time because Verus can automatically prove it.\npub proof fn lemma_project_first_key_sound<K1, K2, V>(m: Map<(K1, K2), V>, k1: K1)\n    ensures\n        forall|k2: K2|\n            {\n                &&& #[trigger] project_first_key(m, k1).contains_key(k2) <==> m.contains_key(\n                    (k1, k2),\n                )\n                &&& project_first_key(m, k1).contains_key(k2) ==> project_first_key(m, k1)[k2]\n                    == m[(k1, k2)]\n            },\n{\n}\n\n/// If the value filter of the projected map is non-empty, then there exists a key `k2`\n/// such that the original map contains the pair `(k1, k2)` and `m[(k1, k2)]` satisfies the predicate `f`.\npub proof fn lemma_project_first_key_value_filter_non_empty<K1, K2, V>(\n    m: Map<(K1, K2), V>,\n    k1: K1,\n    f: spec_fn(V) -> bool,\n)\n    requires\n        value_filter(project_first_key(m, k1), f).len() != 0,\n    ensures\n        exists|k2: K2| #[trigger]\n            project_first_key(m, k1).contains_key(k2) && f(project_first_key(m, k1)[k2]),\n{\n    lemma_value_filter_choose(project_first_key(m, k1), f);\n    let k2 = value_filter_choose(project_first_key(m, k1), f);\n    assert(project_first_key(m, k1).contains_key(k2) && f(m[(k1, k2)]));\n}\n\npub proof fn lemma_project_first_key_value_filter_empty<K1, K2, V>(\n    m: Map<(K1, K2), V>,\n    k1: K1,\n    f: spec_fn(V) -> bool,\n)\n    requires\n        m.dom().finite(),\n        value_filter(project_first_key(m, k1), f).len() == 0,\n    ensures\n        forall|k2: K2| #[trigger]\n            project_first_key(m, k1).contains_key(k2) ==> !f(project_first_key(m, k1)[k2]),\n{\n    assert forall|k2: K2| #[trigger] project_first_key(m, k1).contains_key(k2) implies !f(\n        project_first_key(m, k1)[k2],\n    ) by {\n        if f(project_first_key(m, k1)[k2]) {\n            assert(value_filter(project_first_key(m, k1), f).dom().contains(k2));\n            lemma_project_first_key_finite(m, k1);\n            lemma_value_filter_finite(project_first_key(m, k1), f);\n            Set::lemma_len0_is_empty(value_filter(project_first_key(m, k1), f).dom());\n            assert(false);\n        }\n    }\n}\n\n/// If the original map is finite, then the projected map is also finite.\npub proof fn lemma_project_first_key_finite<K1, K2, V>(m: Map<(K1, K2), V>, k1: K1)\n    requires\n        m.dom().finite(),\n    ensures\n        project_first_key(m, k1).dom().finite(),\n    {\n    if m.dom().len() == 0 {\n        assert(project_first_key(m, k1).dom() == Set::<K2>::empty());\n    } else {\n        let pair = m.dom().choose();\n        lemma_project_first_key_finite(m.remove(pair), k1);\n        if pair.0 != k1 {\n            assert(project_first_key(m, k1) == project_first_key(m.remove(pair), k1));\n        } else {\n            assert(project_first_key(m, k1).dom() == project_first_key(\n                m.remove(pair),\n                k1,\n            ).dom().insert(pair.1));\n        }\n    }\n}\n\n} // verus!\n", "target_text": "use vstd::prelude::*;\nuse vstd::{map::*, set::*};\n\nverus! {\n\n/// The length of inserting a key-value pair `(k,v)` into a map `m` depends on whether\n/// the key `k` already exists in the map. If it does, the length remains the same;\n/// if it doesn't, the length increases by 1.\npub proof fn lemma_map_insert_len<K, V>(m: Map<K, V>, k: K, v: V)\n    requires\n        m.dom().finite(),\n    ensures\n        #[trigger] m.insert(k, v).len() == m.len() + (if m.contains_key(k) {\n            0int\n        } else {\n            1\n        }),\n{\n    axiom_map_insert_domain(m, k, v)\n}\n\n/// The length of removing a key-value pair `(k,v)` from a map `m` depends on whether\n/// the key `k` exists in the map. If it does, the length decreases by 1; if it doesn't,\n/// the length remains the same.\npub proof fn lemma_map_remove_len<K, V>(m: Map<K, V>, k: K)\n    requires\n        m.dom().finite(),\n    ensures\n        m.len() == #[trigger] m.remove(k).len() + (if m.contains_key(k) {\n            1\n        } else {\n            0int\n        }),\n{\n    axiom_map_remove_domain(m, k)\n}\n\n/// Filters a map based on a predicate function applied to its values.\npub open spec fn value_filter<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool) -> Map<K, V> {\n    m.restrict(m.dom().filter(|s| f(m[s])))\n}\n\npub open spec fn value_filter_choose<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool) -> K {\n    choose|k: K| value_filter(m, f).contains_key(k)\n}\n\npub broadcast group group_value_filter_lemmas {\n    lemma_value_filter_finite,\n    lemma_value_filter_choose,\n    lemma_insert_value_filter_same_len,\n    lemma_insert_value_filter_different_len_contains,\n    lemma_insert_value_filter_different_len_not_contains,\n}\n\n/// The result of value-filtering a finite map is also finite.\npub broadcast proof fn lemma_value_filter_finite<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n    requires\n        m.dom().finite(),\n    ensures\n        #[trigger] value_filter(m, f).dom().finite(),\n{\n    assert(value_filter(m, f).dom() == m.dom().filter(|s| f(m[s])));\n    m.dom().lemma_len_filter(|s| f(m[s]));\n}\n\n/// If a key `k` exists in the map `m`, then whether the value-filtered map\n/// contains the key depends on whether the predicate function `f` is true for\n/// its value.\npub proof fn lemma_value_filter_contains<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        m.contains_key(k),\n    ensures\n        if f(m[k]) {\n            value_filter(m, f).contains_key(k)\n        } else {\n            !value_filter(m, f).contains_key(k)\n        },\n{\n}\n\n/// If the predicate function `f` is true for all values in the map `m`, then\n/// the value-filtered map is equal to the original map.\npub proof fn lemma_value_filter_all_true<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n    requires\n        forall|k: K| m.contains_key(k) ==> #[trigger] f(m[k]),\n    ensures\n        value_filter(m, f) =~= m,\n{\n}\n\n/// If the predicate function `f` is false for all values in the map `m`, then\n/// the value-filtered map is empty.\npub proof fn lemma_value_filter_all_false<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n    ensures\n        value_filter(m, f).is_empty() <==> forall|k: K| m.contains_key(k) ==> !#[trigger] f(m[k]),\n{\n    if value_filter(m, f).is_empty() {\n        assert forall|k: K| m.contains_key(k) implies !#[trigger] f(m[k]) by {\n            if f(m[k]) {\n                assert(value_filter(m, f).contains_key(k));\n            }\n        }\n    }\n}\n\n/// If the predicate function `f` is true for `m[k]`, then fist removing `k`\n/// from the map `m` and then applying the value filter is equivalent to\n/// applying the value filter first and then removing `k` from the result.\npub proof fn lemma_remove_value_filter_true<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        f(m[k]),\n    ensures\n        value_filter(m.remove(k), f) =~= value_filter(m, f).remove(k),\n{\n}\n\n/// If the predicate function `f` is false for `m[k]`, then first removing `k`\n/// from the map `m` and then applying the value filter is equivalent to\n/// directly applying the value filter to the original map `m`.\npub proof fn lemma_remove_value_filter_false<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        !f(m[k]),\n    ensures\n        value_filter(m.remove(k), f) =~= value_filter(m, f),\n{\n}\n\n/// If the predicate function `f` is true for the newly inserted value `v`,\n/// then inserting `(k,v)` into the map `m` and then applying the value filter\n/// is equivalent to applying the value filter to the original map `m` and\n/// then inserting `(k,v)` into the result.\npub proof fn lemma_insert_value_filter_true<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K, v: V)\n    requires\n        f(v),\n    ensures\n        value_filter(m.insert(k, v), f) =~= value_filter(m, f).insert(k, v),\n{\n}\n\n/// If the predicate function `f` is false for the newly inserted value `v`,\n/// then inserting `(k,v)` into the map `m` and then applying the value filter\n/// is equivalent to applying the value filter to the original map `m` and\n/// then removing `k` from the result (if 'k' exists in 'm') or leaving it unchanged\n/// (if it doesn't).\npub proof fn lemma_insert_value_filter_false<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K, v: V)\n    requires\n        !f(v),\n    ensures\n        value_filter(m.insert(k, v), f) =~= if m.contains_key(k) {\n            value_filter(m, f).remove(k)\n        } else {\n            value_filter(m, f)\n        },\n        value_filter(m.insert(k, v), f) =~= if m.contains_key(k) {\n            value_filter(m, f).remove(k)\n        } else {\n            value_filter(m, f)\n        },\n{\n}\n\n/// The length of the value-filtered map after inserting `(k,v)` into `m`\n/// is equal to the length of the value-filtered map for the original map `m`\n/// if `k` exists in `m`, and `m[k]` and `v` both satisfy/un-satisfy the predicate\n/// function `f`.\npub broadcast proof fn lemma_insert_value_filter_same_len<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n    requires\n        m.dom().finite(),\n        m.contains_key(k) && f(m[k]) == f(v) || !m.contains_key(k) && !f(v),\n    ensures\n        #[trigger] value_filter(m.insert(k, v), f).len() == value_filter(m, f).len(),\n{\n    lemma_value_filter_finite(m, f);\n    if f(v) {\n        lemma_insert_value_filter_true(m, f, k, v);\n        lemma_map_insert_len(value_filter(m, f), k, v);\n    } else {\n        lemma_insert_value_filter_false(m, f, k, v);\n        lemma_map_remove_len(value_filter(m, f), k);\n    }\n}\n\n/// The length of the value-filtered map after inserting `(k,v)` into `m`\n/// is equal to the length of the value-filtered map for the original map `m`\n/// plus one if `m[k]` does not satisfy `f` but `v` does, and minus one if\n/// `m[k]` satisfies `f` but `v` does not.\npub broadcast proof fn lemma_insert_value_filter_different_len_contains<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n    requires\n        m.dom().finite(),\n        m.contains_key(k),\n        f(m[k]) != f(v),\n    ensures\n        #[trigger] value_filter(m.insert(k, v), f).len() == value_filter(m, f).len() + if f(v) {\n            1\n        } else {\n            -1\n        },\n{\n    lemma_value_filter_finite(m, f);\n    if (f(v)) {\n        lemma_insert_value_filter_true(m, f, k, v);\n        lemma_map_insert_len(m, k, v);\n    } else {\n        lemma_insert_value_filter_false(m, f, k, v);\n        assert(value_filter(m.insert(k, v), f).len() == value_filter(m, f).remove(k).len());\n        lemma_map_remove_len(value_filter(m, f), k);\n    }\n}\n\n/// The length of the value-filtered map after inserting `(k,v)` into `m`\n/// is equal to the length of the value-filtered map for the original map `m`\n/// plus one if `k` does not exist in `m` and `v` satisfies the predicate function `f`.\npub broadcast proof fn lemma_insert_value_filter_different_len_not_contains<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n    requires\n        m.dom().finite(),\n        !m.contains_key(k),\n        f(v),\n    ensures\n        #[trigger] value_filter(m.insert(k, v), f).len() == value_filter(m, f).len() + 1,\n{\n    lemma_value_filter_finite(m, f);\n    lemma_insert_value_filter_true(m, f, k, v);\n    lemma_map_insert_len(m, k, v);\n}\n\npub proof fn lemma_value_filter_contains_key<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        value_filter(m, f).contains_key(k),\n    ensures\n        m.contains_key(k),\n{\n}\n\npub broadcast proof fn lemma_value_filter_choose<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n    requires\n        value_filter(m, f).len() != 0,\n    ensures\n        value_filter(m, f).contains_key(#[trigger] value_filter_choose(m, f)),\n        f(m[value_filter_choose(m, f)]),\n{\n    if value_filter(m, f).dom().finite() {\n        axiom_set_choose_len(value_filter(m, f).dom());\n    } else {\n        axiom_set_choose_infinite(value_filter(m, f).dom());\n    }\n}\n\n} // verus!\nverus! {\n\n/// Returns true if predicate `f(k,v)` holds for all `(k,v)` in `map`.\npub open spec fn forall_map<K, V>(map: Map<K, V>, f: spec_fn(K, V) -> bool) -> bool {\n    forall|k| #[trigger] map.contains_key(k) ==> f(k, map[k])\n}\n\n/// Returns true if predicate `f(v)` holds for all values in `map`.\npub open spec fn forall_map_values<K, V>(map: Map<K, V>, f: spec_fn(V) -> bool) -> bool {\n    forall|k| #[trigger] map.contains_key(k) ==> f(map[k])\n}\n\npub broadcast group group_forall_map_lemmas {\n    lemma_forall_map_insert,\n    lemma_forall_map_values_insert,\n    lemma_forall_map_remove,\n    lemma_forall_map_values_remove,\n}\n\n/// For any key in the map, `f(k, map[k])` holds if `forall_map(map, f)` holds.\npub proof fn lemma_forall_map_entry<K, V>(m: Map<K, V>, f: spec_fn(K, V) -> bool, k: K)\n    requires\n        forall_map(m, f),\n        m.contains_key(k),\n    ensures\n        f(k, m[k]),\n{\n}\n\n/// For any key in the map, `f(map[k])` holds if `forall_map_values(map, f)` holds.\npub proof fn lemma_forall_map_values_entry<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        forall_map_values(m, f),\n        m.contains_key(k),\n    ensures\n        f(m[k]),\n{\n}\n\n/// `forall_map(m.insert(k, v), f)` holds if `f(k, v)` holds and\n/// `forall_map(m.remove(k),f)` (if `m` contains `k`) or `forall_map(m, f)` (if `m` does not contain `k`).\npub broadcast proof fn lemma_forall_map_insert<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(K, V) -> bool,\n    k: K,\n    v: V,\n)\n    ensures\n        #[trigger] forall_map(m.insert(k, v), f) ==> f(k, v) && if m.contains_key(k) {\n            forall_map(m.remove(k), f)\n        } else {\n            forall_map(m, f)\n        },\n{\n    assert(m.insert(k, v).contains_key(k));\n    if m.contains_key(k) {\n        assert(m.insert(k, v) == m.remove(k).insert(k, v));\n    } else {\n        assert(m.insert(k, v) == m.insert(k, v));\n    }\n    if forall_map(m.insert(k, v), f) {\n        if m.contains_key(k) {\n        } else {\n            assert(forall|k0| #[trigger] m.contains_key(k0) ==> m.insert(k, v).contains_key(k0));\n        }\n    }\n}\n\n/// `forall_map_values(m.insert(k, v), f)` holds if `f(v)` holds and\n/// `forall_map_values(m.remove(k),f)` (if `m` contains `k`) or `forall_map_values(m, f)` (if `m` does not contain `k`).\npub broadcast proof fn lemma_forall_map_values_insert<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n    ensures\n        #[trigger] forall_map_values(m.insert(k, v), f) ==> f(v) && if m.contains_key(k) {\n            forall_map_values(m.remove(k), f)\n        } else {\n            forall_map_values(m, f)\n        },\n{\n    assert(m.insert(k, v).contains_key(k));\n    if m.contains_key(k) {\n        assert(m.insert(k, v) == m.remove(k).insert(k, v));\n    } else {\n        assert(m.insert(k, v) == m.insert(k, v));\n    }\n    if forall_map_values(m.insert(k, v), f) {\n        if m.contains_key(k) {\n        } else {\n            assert(forall|k0| #[trigger] m.contains_key(k0) ==> m.insert(k, v).contains_key(k0));\n        }\n    }\n}\n\n/// `forall_map(m,f)` holds if `forall_map(m.remove(k), f)` holds and\n/// `f(k, m[k])` holds (if `m` contains `k`).\npub broadcast proof fn lemma_forall_map_remove<K, V>(m: Map<K, V>, f: spec_fn(K, V) -> bool, k: K)\n    ensures\n        forall_map(m, f) <==> #[trigger] forall_map(m.remove(k), f) && (m.contains_key(k) ==> f(\n            k,\n            m[k],\n        )),\n{\n    if m.contains_key(k) {\n        assert(m == m.remove(k).insert(k, m[k]));\n    } else {\n        assert(m == m.remove(k));\n    }\n}\n\n/// `forall_map_values(m,f)` holds if `forall_map_values(m.remove(k), f)` holds and\n/// `f(m[k])` holds (if `m` contains `k`).\npub broadcast proof fn lemma_forall_map_values_remove<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n)\n    ensures\n        forall_map_values(m, f) <==> #[trigger] forall_map_values(m.remove(k), f) && (\n        m.contains_key(k) ==> f(m[k])),\n{\n    if m.contains_key(k) {\n        assert(m == m.remove(k).insert(k, m[k]));\n    } else {\n        assert(m == m.remove(k));\n    }\n\n}\n\n/// Returns a new map that projects the first key of a pair `(K1, K2)`,\n/// keeping the values associated with the second key `K2`.\npub open spec fn project_first_key<K1, K2, V>(m: Map<(K1, K2), V>, k1: K1) -> Map<K2, V> {\n    Map::new(|k2: K2| m.contains_key((k1, k2)), |k2: K2| m[(k1, k2)])\n}\n\n/// Returns a new map that projects the second key of a pair `(K1, K2)`,\n/// keeping the values associated with the first key `K1`.\npub open spec fn project_second_key<K1, K2, V>(m: Map<(K1, K2), V>, k2: K2) -> Map<K1, V> {\n    Map::new(|k1: K1| m.contains_key((k1, k2)), |k1: K1| m[(k1, k2)])\n}\n\n/// A lemma showing that `project_first_key`` is sound.\n/// There is no need to actually use this lemma in practice at most of the time because Verus can automatically prove it.\npub proof fn lemma_project_first_key_sound<K1, K2, V>(m: Map<(K1, K2), V>, k1: K1)\n    ensures\n        forall|k2: K2|\n            {\n                &&& #[trigger] project_first_key(m, k1).contains_key(k2) <==> m.contains_key(\n                    (k1, k2),\n                )\n                &&& project_first_key(m, k1).contains_key(k2) ==> project_first_key(m, k1)[k2]\n                    == m[(k1, k2)]\n            },\n{\n}\n\n/// If the value filter of the projected map is non-empty, then there exists a key `k2`\n/// such that the original map contains the pair `(k1, k2)` and `m[(k1, k2)]` satisfies the predicate `f`.\npub proof fn lemma_project_first_key_value_filter_non_empty<K1, K2, V>(\n    m: Map<(K1, K2), V>,\n    k1: K1,\n    f: spec_fn(V) -> bool,\n)\n    requires\n        value_filter(project_first_key(m, k1), f).len() != 0,\n    ensures\n        exists|k2: K2| #[trigger]\n            project_first_key(m, k1).contains_key(k2) && f(project_first_key(m, k1)[k2]),\n{\n    lemma_value_filter_choose(project_first_key(m, k1), f);\n    let k2 = value_filter_choose(project_first_key(m, k1), f);\n    assert(project_first_key(m, k1).contains_key(k2) && f(m[(k1, k2)]));\n}\n\npub proof fn lemma_project_first_key_value_filter_empty<K1, K2, V>(\n    m: Map<(K1, K2), V>,\n    k1: K1,\n    f: spec_fn(V) -> bool,\n)\n    requires\n        m.dom().finite(),\n        value_filter(project_first_key(m, k1), f).len() == 0,\n    ensures\n        forall|k2: K2| #[trigger]\n            project_first_key(m, k1).contains_key(k2) ==> !f(project_first_key(m, k1)[k2]),\n{\n    assert forall|k2: K2| #[trigger] project_first_key(m, k1).contains_key(k2) implies !f(\n        project_first_key(m, k1)[k2],\n    ) by {\n        if f(project_first_key(m, k1)[k2]) {\n            assert(value_filter(project_first_key(m, k1), f).dom().contains(k2));\n            lemma_project_first_key_finite(m, k1);\n            lemma_value_filter_finite(project_first_key(m, k1), f);\n            Set::lemma_len0_is_empty(value_filter(project_first_key(m, k1), f).dom());\n            assert(false);\n        }\n    }\n}\n\n/// If the original map is finite, then the projected map is also finite.\npub proof fn lemma_project_first_key_finite<K1, K2, V>(m: Map<(K1, K2), V>, k1: K1)\n    requires\n        m.dom().finite(),\n    ensures\n        project_first_key(m, k1).dom().finite(),\n    decreases m.dom().len(),\n{\n    if m.dom().len() == 0 {\n        assert(project_first_key(m, k1).dom() == Set::<K2>::empty());\n    } else {\n        let pair = m.dom().choose();\n        lemma_project_first_key_finite(m.remove(pair), k1);\n        if pair.0 != k1 {\n            assert(project_first_key(m, k1) == project_first_key(m.remove(pair), k1));\n        } else {\n            assert(project_first_key(m, k1).dom() == project_first_key(\n                m.remove(pair),\n                k1,\n            ).dom().insert(pair.1));\n        }\n    }\n}\n\n} // verus!\n", "full_verified_code": "use vstd::prelude::*;\nuse vstd::{map::*, set::*};\n\nverus! {\n\n/// The length of inserting a key-value pair `(k,v)` into a map `m` depends on whether\n/// the key `k` already exists in the map. If it does, the length remains the same;\n/// if it doesn't, the length increases by 1.\npub proof fn lemma_map_insert_len<K, V>(m: Map<K, V>, k: K, v: V)\n    requires\n        m.dom().finite(),\n    ensures\n        #[trigger] m.insert(k, v).len() == m.len() + (if m.contains_key(k) {\n            0int\n        } else {\n            1\n        }),\n{\n    axiom_map_insert_domain(m, k, v)\n}\n\n/// The length of removing a key-value pair `(k,v)` from a map `m` depends on whether\n/// the key `k` exists in the map. If it does, the length decreases by 1; if it doesn't,\n/// the length remains the same.\npub proof fn lemma_map_remove_len<K, V>(m: Map<K, V>, k: K)\n    requires\n        m.dom().finite(),\n    ensures\n        m.len() == #[trigger] m.remove(k).len() + (if m.contains_key(k) {\n            1\n        } else {\n            0int\n        }),\n{\n    axiom_map_remove_domain(m, k)\n}\n\n/// Filters a map based on a predicate function applied to its values.\npub open spec fn value_filter<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool) -> Map<K, V> {\n    m.restrict(m.dom().filter(|s| f(m[s])))\n}\n\npub open spec fn value_filter_choose<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool) -> K {\n    choose|k: K| value_filter(m, f).contains_key(k)\n}\n\npub broadcast group group_value_filter_lemmas {\n    lemma_value_filter_finite,\n    lemma_value_filter_choose,\n    lemma_insert_value_filter_same_len,\n    lemma_insert_value_filter_different_len_contains,\n    lemma_insert_value_filter_different_len_not_contains,\n}\n\n/// The result of value-filtering a finite map is also finite.\npub broadcast proof fn lemma_value_filter_finite<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n    requires\n        m.dom().finite(),\n    ensures\n        #[trigger] value_filter(m, f).dom().finite(),\n{\n    assert(value_filter(m, f).dom() == m.dom().filter(|s| f(m[s])));\n    m.dom().lemma_len_filter(|s| f(m[s]));\n}\n\n/// If a key `k` exists in the map `m`, then whether the value-filtered map\n/// contains the key depends on whether the predicate function `f` is true for\n/// its value.\npub proof fn lemma_value_filter_contains<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        m.contains_key(k),\n    ensures\n        if f(m[k]) {\n            value_filter(m, f).contains_key(k)\n        } else {\n            !value_filter(m, f).contains_key(k)\n        },\n{\n}\n\n/// If the predicate function `f` is true for all values in the map `m`, then\n/// the value-filtered map is equal to the original map.\npub proof fn lemma_value_filter_all_true<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n    requires\n        forall|k: K| m.contains_key(k) ==> #[trigger] f(m[k]),\n    ensures\n        value_filter(m, f) =~= m,\n{\n}\n\n/// If the predicate function `f` is false for all values in the map `m`, then\n/// the value-filtered map is empty.\npub proof fn lemma_value_filter_all_false<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n    ensures\n        value_filter(m, f).is_empty() <==> forall|k: K| m.contains_key(k) ==> !#[trigger] f(m[k]),\n{\n    if value_filter(m, f).is_empty() {\n        assert forall|k: K| m.contains_key(k) implies !#[trigger] f(m[k]) by {\n            if f(m[k]) {\n                assert(value_filter(m, f).contains_key(k));\n            }\n        }\n    }\n}\n\n/// If the predicate function `f` is true for `m[k]`, then fist removing `k`\n/// from the map `m` and then applying the value filter is equivalent to\n/// applying the value filter first and then removing `k` from the result.\npub proof fn lemma_remove_value_filter_true<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        f(m[k]),\n    ensures\n        value_filter(m.remove(k), f) =~= value_filter(m, f).remove(k),\n{\n}\n\n/// If the predicate function `f` is false for `m[k]`, then first removing `k`\n/// from the map `m` and then applying the value filter is equivalent to\n/// directly applying the value filter to the original map `m`.\npub proof fn lemma_remove_value_filter_false<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        !f(m[k]),\n    ensures\n        value_filter(m.remove(k), f) =~= value_filter(m, f),\n{\n}\n\n/// If the predicate function `f` is true for the newly inserted value `v`,\n/// then inserting `(k,v)` into the map `m` and then applying the value filter\n/// is equivalent to applying the value filter to the original map `m` and\n/// then inserting `(k,v)` into the result.\npub proof fn lemma_insert_value_filter_true<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K, v: V)\n    requires\n        f(v),\n    ensures\n        value_filter(m.insert(k, v), f) =~= value_filter(m, f).insert(k, v),\n{\n}\n\n/// If the predicate function `f` is false for the newly inserted value `v`,\n/// then inserting `(k,v)` into the map `m` and then applying the value filter\n/// is equivalent to applying the value filter to the original map `m` and\n/// then removing `k` from the result (if 'k' exists in 'm') or leaving it unchanged\n/// (if it doesn't).\npub proof fn lemma_insert_value_filter_false<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K, v: V)\n    requires\n        !f(v),\n    ensures\n        value_filter(m.insert(k, v), f) =~= if m.contains_key(k) {\n            value_filter(m, f).remove(k)\n        } else {\n            value_filter(m, f)\n        },\n        value_filter(m.insert(k, v), f) =~= if m.contains_key(k) {\n            value_filter(m, f).remove(k)\n        } else {\n            value_filter(m, f)\n        },\n{\n}\n\n/// The length of the value-filtered map after inserting `(k,v)` into `m`\n/// is equal to the length of the value-filtered map for the original map `m`\n/// if `k` exists in `m`, and `m[k]` and `v` both satisfy/un-satisfy the predicate\n/// function `f`.\npub broadcast proof fn lemma_insert_value_filter_same_len<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n    requires\n        m.dom().finite(),\n        m.contains_key(k) && f(m[k]) == f(v) || !m.contains_key(k) && !f(v),\n    ensures\n        #[trigger] value_filter(m.insert(k, v), f).len() == value_filter(m, f).len(),\n{\n    lemma_value_filter_finite(m, f);\n    if f(v) {\n        lemma_insert_value_filter_true(m, f, k, v);\n        lemma_map_insert_len(value_filter(m, f), k, v);\n    } else {\n        lemma_insert_value_filter_false(m, f, k, v);\n        lemma_map_remove_len(value_filter(m, f), k);\n    }\n}\n\n/// The length of the value-filtered map after inserting `(k,v)` into `m`\n/// is equal to the length of the value-filtered map for the original map `m`\n/// plus one if `m[k]` does not satisfy `f` but `v` does, and minus one if\n/// `m[k]` satisfies `f` but `v` does not.\npub broadcast proof fn lemma_insert_value_filter_different_len_contains<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n    requires\n        m.dom().finite(),\n        m.contains_key(k),\n        f(m[k]) != f(v),\n    ensures\n        #[trigger] value_filter(m.insert(k, v), f).len() == value_filter(m, f).len() + if f(v) {\n            1\n        } else {\n            -1\n        },\n{\n    lemma_value_filter_finite(m, f);\n    if (f(v)) {\n        lemma_insert_value_filter_true(m, f, k, v);\n        lemma_map_insert_len(m, k, v);\n    } else {\n        lemma_insert_value_filter_false(m, f, k, v);\n        assert(value_filter(m.insert(k, v), f).len() == value_filter(m, f).remove(k).len());\n        lemma_map_remove_len(value_filter(m, f), k);\n    }\n}\n\n/// The length of the value-filtered map after inserting `(k,v)` into `m`\n/// is equal to the length of the value-filtered map for the original map `m`\n/// plus one if `k` does not exist in `m` and `v` satisfies the predicate function `f`.\npub broadcast proof fn lemma_insert_value_filter_different_len_not_contains<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n    requires\n        m.dom().finite(),\n        !m.contains_key(k),\n        f(v),\n    ensures\n        #[trigger] value_filter(m.insert(k, v), f).len() == value_filter(m, f).len() + 1,\n{\n    lemma_value_filter_finite(m, f);\n    lemma_insert_value_filter_true(m, f, k, v);\n    lemma_map_insert_len(m, k, v);\n}\n\npub proof fn lemma_value_filter_contains_key<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        value_filter(m, f).contains_key(k),\n    ensures\n        m.contains_key(k),\n{\n}\n\npub broadcast proof fn lemma_value_filter_choose<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool)\n    requires\n        value_filter(m, f).len() != 0,\n    ensures\n        value_filter(m, f).contains_key(#[trigger] value_filter_choose(m, f)),\n        f(m[value_filter_choose(m, f)]),\n{\n    if value_filter(m, f).dom().finite() {\n        axiom_set_choose_len(value_filter(m, f).dom());\n    } else {\n        axiom_set_choose_infinite(value_filter(m, f).dom());\n    }\n}\n\n} // verus!\nverus! {\n\n/// Returns true if predicate `f(k,v)` holds for all `(k,v)` in `map`.\npub open spec fn forall_map<K, V>(map: Map<K, V>, f: spec_fn(K, V) -> bool) -> bool {\n    forall|k| #[trigger] map.contains_key(k) ==> f(k, map[k])\n}\n\n/// Returns true if predicate `f(v)` holds for all values in `map`.\npub open spec fn forall_map_values<K, V>(map: Map<K, V>, f: spec_fn(V) -> bool) -> bool {\n    forall|k| #[trigger] map.contains_key(k) ==> f(map[k])\n}\n\npub broadcast group group_forall_map_lemmas {\n    lemma_forall_map_insert,\n    lemma_forall_map_values_insert,\n    lemma_forall_map_remove,\n    lemma_forall_map_values_remove,\n}\n\n/// For any key in the map, `f(k, map[k])` holds if `forall_map(map, f)` holds.\npub proof fn lemma_forall_map_entry<K, V>(m: Map<K, V>, f: spec_fn(K, V) -> bool, k: K)\n    requires\n        forall_map(m, f),\n        m.contains_key(k),\n    ensures\n        f(k, m[k]),\n{\n}\n\n/// For any key in the map, `f(map[k])` holds if `forall_map_values(map, f)` holds.\npub proof fn lemma_forall_map_values_entry<K, V>(m: Map<K, V>, f: spec_fn(V) -> bool, k: K)\n    requires\n        forall_map_values(m, f),\n        m.contains_key(k),\n    ensures\n        f(m[k]),\n{\n}\n\n/// `forall_map(m.insert(k, v), f)` holds if `f(k, v)` holds and\n/// `forall_map(m.remove(k),f)` (if `m` contains `k`) or `forall_map(m, f)` (if `m` does not contain `k`).\npub broadcast proof fn lemma_forall_map_insert<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(K, V) -> bool,\n    k: K,\n    v: V,\n)\n    ensures\n        #[trigger] forall_map(m.insert(k, v), f) ==> f(k, v) && if m.contains_key(k) {\n            forall_map(m.remove(k), f)\n        } else {\n            forall_map(m, f)\n        },\n{\n    assert(m.insert(k, v).contains_key(k));\n    if m.contains_key(k) {\n        assert(m.insert(k, v) == m.remove(k).insert(k, v));\n    } else {\n        assert(m.insert(k, v) == m.insert(k, v));\n    }\n    if forall_map(m.insert(k, v), f) {\n        if m.contains_key(k) {\n        } else {\n            assert(forall|k0| #[trigger] m.contains_key(k0) ==> m.insert(k, v).contains_key(k0));\n        }\n    }\n}\n\n/// `forall_map_values(m.insert(k, v), f)` holds if `f(v)` holds and\n/// `forall_map_values(m.remove(k),f)` (if `m` contains `k`) or `forall_map_values(m, f)` (if `m` does not contain `k`).\npub broadcast proof fn lemma_forall_map_values_insert<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n    v: V,\n)\n    ensures\n        #[trigger] forall_map_values(m.insert(k, v), f) ==> f(v) && if m.contains_key(k) {\n            forall_map_values(m.remove(k), f)\n        } else {\n            forall_map_values(m, f)\n        },\n{\n    assert(m.insert(k, v).contains_key(k));\n    if m.contains_key(k) {\n        assert(m.insert(k, v) == m.remove(k).insert(k, v));\n    } else {\n        assert(m.insert(k, v) == m.insert(k, v));\n    }\n    if forall_map_values(m.insert(k, v), f) {\n        if m.contains_key(k) {\n        } else {\n            assert(forall|k0| #[trigger] m.contains_key(k0) ==> m.insert(k, v).contains_key(k0));\n        }\n    }\n}\n\n/// `forall_map(m,f)` holds if `forall_map(m.remove(k), f)` holds and\n/// `f(k, m[k])` holds (if `m` contains `k`).\npub broadcast proof fn lemma_forall_map_remove<K, V>(m: Map<K, V>, f: spec_fn(K, V) -> bool, k: K)\n    ensures\n        forall_map(m, f) <==> #[trigger] forall_map(m.remove(k), f) && (m.contains_key(k) ==> f(\n            k,\n            m[k],\n        )),\n{\n    if m.contains_key(k) {\n        assert(m == m.remove(k).insert(k, m[k]));\n    } else {\n        assert(m == m.remove(k));\n    }\n}\n\n/// `forall_map_values(m,f)` holds if `forall_map_values(m.remove(k), f)` holds and\n/// `f(m[k])` holds (if `m` contains `k`).\npub broadcast proof fn lemma_forall_map_values_remove<K, V>(\n    m: Map<K, V>,\n    f: spec_fn(V) -> bool,\n    k: K,\n)\n    ensures\n        forall_map_values(m, f) <==> #[trigger] forall_map_values(m.remove(k), f) && (\n        m.contains_key(k) ==> f(m[k])),\n{\n    if m.contains_key(k) {\n        assert(m == m.remove(k).insert(k, m[k]));\n    } else {\n        assert(m == m.remove(k));\n    }\n\n}\n\n/// Returns a new map that projects the first key of a pair `(K1, K2)`,\n/// keeping the values associated with the second key `K2`.\npub open spec fn project_first_key<K1, K2, V>(m: Map<(K1, K2), V>, k1: K1) -> Map<K2, V> {\n    Map::new(|k2: K2| m.contains_key((k1, k2)), |k2: K2| m[(k1, k2)])\n}\n\n/// Returns a new map that projects the second key of a pair `(K1, K2)`,\n/// keeping the values associated with the first key `K1`.\npub open spec fn project_second_key<K1, K2, V>(m: Map<(K1, K2), V>, k2: K2) -> Map<K1, V> {\n    Map::new(|k1: K1| m.contains_key((k1, k2)), |k1: K1| m[(k1, k2)])\n}\n\n/// A lemma showing that `project_first_key`` is sound.\n/// There is no need to actually use this lemma in practice at most of the time because Verus can automatically prove it.\npub proof fn lemma_project_first_key_sound<K1, K2, V>(m: Map<(K1, K2), V>, k1: K1)\n    ensures\n        forall|k2: K2|\n            {\n                &&& #[trigger] project_first_key(m, k1).contains_key(k2) <==> m.contains_key(\n                    (k1, k2),\n                )\n                &&& project_first_key(m, k1).contains_key(k2) ==> project_first_key(m, k1)[k2]\n                    == m[(k1, k2)]\n            },\n{\n}\n\n/// If the value filter of the projected map is non-empty, then there exists a key `k2`\n/// such that the original map contains the pair `(k1, k2)` and `m[(k1, k2)]` satisfies the predicate `f`.\npub proof fn lemma_project_first_key_value_filter_non_empty<K1, K2, V>(\n    m: Map<(K1, K2), V>,\n    k1: K1,\n    f: spec_fn(V) -> bool,\n)\n    requires\n        value_filter(project_first_key(m, k1), f).len() != 0,\n    ensures\n        exists|k2: K2| #[trigger]\n            project_first_key(m, k1).contains_key(k2) && f(project_first_key(m, k1)[k2]),\n{\n    lemma_value_filter_choose(project_first_key(m, k1), f);\n    let k2 = value_filter_choose(project_first_key(m, k1), f);\n    assert(project_first_key(m, k1).contains_key(k2) && f(m[(k1, k2)]));\n}\n\npub proof fn lemma_project_first_key_value_filter_empty<K1, K2, V>(\n    m: Map<(K1, K2), V>,\n    k1: K1,\n    f: spec_fn(V) -> bool,\n)\n    requires\n        m.dom().finite(),\n        value_filter(project_first_key(m, k1), f).len() == 0,\n    ensures\n        forall|k2: K2| #[trigger]\n            project_first_key(m, k1).contains_key(k2) ==> !f(project_first_key(m, k1)[k2]),\n{\n    assert forall|k2: K2| #[trigger] project_first_key(m, k1).contains_key(k2) implies !f(\n        project_first_key(m, k1)[k2],\n    ) by {\n        if f(project_first_key(m, k1)[k2]) {\n            assert(value_filter(project_first_key(m, k1), f).dom().contains(k2));\n            lemma_project_first_key_finite(m, k1);\n            lemma_value_filter_finite(project_first_key(m, k1), f);\n            Set::lemma_len0_is_empty(value_filter(project_first_key(m, k1), f).dom());\n            assert(false);\n        }\n    }\n}\n\n/// If the original map is finite, then the projected map is also finite.\npub proof fn lemma_project_first_key_finite<K1, K2, V>(m: Map<(K1, K2), V>, k1: K1)\n    requires\n        m.dom().finite(),\n    ensures\n        project_first_key(m, k1).dom().finite(),\n    decreases m.dom().len(),\n{\n    if m.dom().len() == 0 {\n        assert(project_first_key(m, k1).dom() == Set::<K2>::empty());\n    } else {\n        let pair = m.dom().choose();\n        lemma_project_first_key_finite(m.remove(pair), k1);\n        if pair.0 != k1 {\n            assert(project_first_key(m, k1) == project_first_key(m.remove(pair), k1));\n        } else {\n            assert(project_first_key(m, k1).dom() == project_first_key(\n                m.remove(pair),\n                k1,\n            ).dom().insert(pair.1));\n        }\n    }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/vstd_extra/src/map_extra.rs", "verified": true, "metadata": {"original_id": "vostd_map_extra_a1f35ebe1435", "function_name": "", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_5d51a32c80a1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_binary_digit (c : char) -> (ret : bool) { c == '0' || c == '1' }\nspec fn xor_char (a : char , b : char) -> (result : char) recommends is_binary_digit (a) , is_binary_digit (b) , { if a == b { '0' } else { '1' } }\nfn string_xor (a : & [char] , b : & [char]) -> (result : Vec < char >) requires a @ . len () == b @ . len () , forall | i : int | 0 <= i < a @ . len () as int ==> is_binary_digit (# [trigger] a [i]) , forall | i : int | 0 <= i < b @ . len () as int ==> is_binary_digit (# [trigger] b [i]) , ensures result . len () == a @ . len () , forall | i : int | 0 <= i < result . len () as int ==> # [trigger] result [i] == xor_char (a [i] , b [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a @ . len () , a @ . len () == b @ . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == xor_char (a [j] , b [j]) , { let xor_result = if a [i] == b [i] { '0' } else { '1' } ; result . push (xor_result) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_binary_digit (c : char) -> (ret : bool) { c == '0' || c == '1' }\nspec fn xor_char (a : char , b : char) -> (result : char) recommends is_binary_digit (a) , is_binary_digit (b) , { if a == b { '0' } else { '1' } }\nfn string_xor (a : & [char] , b : & [char]) -> (result : Vec < char >) requires a @ . len () == b @ . len () , forall | i : int | 0 <= i < a @ . len () as int ==> is_binary_digit (# [trigger] a [i]) , forall | i : int | 0 <= i < b @ . len () as int ==> is_binary_digit (# [trigger] b [i]) , ensures result . len () == a @ . len () , forall | i : int | 0 <= i < result . len () as int ==> # [trigger] result [i] == xor_char (a [i] , b [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a @ . len () , a @ . len () == b @ . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == xor_char (a [j] , b [j]) , decreases a @ . len () - i { let xor_result = if a [i] == b [i] { '0' } else { '1' } ; result . push (xor_result) ; i = i + 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_binary_digit (c : char) -> (ret : bool) { c == '0' || c == '1' }\nspec fn xor_char (a : char , b : char) -> (result : char) recommends is_binary_digit (a) , is_binary_digit (b) , { if a == b { '0' } else { '1' } }\nfn string_xor (a : & [char] , b : & [char]) -> (result : Vec < char >) requires a @ . len () == b @ . len () , forall | i : int | 0 <= i < a @ . len () as int ==> is_binary_digit (# [trigger] a [i]) , forall | i : int | 0 <= i < b @ . len () as int ==> is_binary_digit (# [trigger] b [i]) , ensures result . len () == a @ . len () , forall | i : int | 0 <= i < result . len () as int ==> # [trigger] result [i] == xor_char (a [i] , b [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a @ . len () , a @ . len () == b @ . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == xor_char (a [j] , b [j]) , decreases a @ . len () - i { let xor_result = if a [i] == b [i] { '0' } else { '1' } ; result . push (xor_result) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/011-string_xor_impl.rs", "verified": true, "metadata": {"original_id": "5d51a32c80a1", "function_name": "string_xor", "bug_type": "missing_decreases"}}
{"id": "task_a_86698098f817", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32)   { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32)   { if s [0] <= s [1] { secondSmallestAux (s , 2 , 0 , 1) } else { secondSmallestAux (s , 2 , 1 , 0) } }\n\n} // verus!", "target_text": "requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , secondSmallest_precond (s) \nensures exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i \ndecreases s . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { if s [0] <= s [1] { secondSmallestAux (s , 2 , 0 , 1) } else { secondSmallestAux (s , 2 , 1 , 0) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_40/verina_basic_40_impl.rs", "verified": true, "metadata": {"original_id": "86698098f817", "function_name": "secondSmallest", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_73b4e757c2f1", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_valid_digit (c : char) -> bool { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nfn is_valid_digit_exec (c : char) -> (result : bool)  { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\n\n} // verus!", "target_text": "ensures result == is_valid_digit (c)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_valid_digit (c : char) -> bool { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\nfn is_valid_digit_exec (c : char) -> (result : bool) ensures result == is_valid_digit (c) { c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_26/verina_advanced_26_impl.rs", "verified": true, "metadata": {"original_id": "73b4e757c2f1", "function_name": "is_valid_digit_exec", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_c5e0e1ff8db1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool) requires seq . len () > 0 ,  { let first_len = seq [0] . len () ; for k in 1 .. seq . len () invariant forall | i : int | (0 <= i < k) ==> seq [i] . len () == first_len , { if seq [k] . len () != first_len { assert (seq [k as int] . len () != seq [0] . len ()) ; return false ; } } assert (forall | i : int | (0 <= i < seq . len ()) ==> seq [i] . len () == first_len) ; true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool) requires seq . len () > 0 , ensures result == (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> (# [trigger] seq [i] . len () == # [trigger] seq [j] . len ())) , { let first_len = seq [0] . len () ; for k in 1 .. seq . len () invariant forall | i : int | (0 <= i < k) ==> seq [i] . len () == first_len , { if seq [k] . len () != first_len { assert (seq [k as int] . len () != seq [0] . len ()) ; return false ; } } assert (forall | i : int | (0 <= i < seq . len ()) ==> seq [i] . len () == first_len) ; true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool) requires seq . len () > 0 , ensures result == (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> (# [trigger] seq [i] . len () == # [trigger] seq [j] . len ())) , { let first_len = seq [0] . len () ; for k in 1 .. seq . len () invariant forall | i : int | (0 <= i < k) ==> seq [i] . len () == first_len , { if seq [k] . len () != first_len { assert (seq [k as int] . len () != seq [0] . len ()) ; return false ; } } assert (forall | i : int | (0 <= i < seq . len ()) ==> seq [i] . len () == first_len) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_70_impl.rs", "verified": true, "metadata": {"original_id": "c5e0e1ff8db1", "function_name": "all_sequence_equal_length", "bug_type": "missing_ensures"}}
{"id": "task_b_4ff9e20b4700", "task": "task_b", "input_text": "fn max_dafny_lsp (a : & [i32]) -> (x : usize)\nrequires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "4ff9e20b4700", "function_name": "max_dafny_lsp", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_ensures_40b51ce988ca", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] ,  { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_binary_search/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "40b51ce988ca", "function_name": "binary_search", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_d5eae418e192", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >)  { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn digit_to_letters (c : char) -> Seq < char > { match c { '2' => seq ! ['a' , 'b' , 'c'] , '3' => seq ! ['d' , 'e' , 'f'] , '4' => seq ! ['g' , 'h' , 'i'] , '5' => seq ! ['j' , 'k' , 'l'] , '6' => seq ! ['m' , 'n' , 'o'] , '7' => seq ! ['p' , 'q' , 'r' , 's'] , '8' => seq ! ['t' , 'u' , 'v'] , '9' => seq ! ['w' , 'x' , 'y' , 'z'] , _ => seq ! [] , } }\nfn digit_to_letters_exec (c : char) -> (result : Vec < char >) ensures result @ == digit_to_letters (c) { match c { '2' => vec ! ['a' , 'b' , 'c'] , '3' => vec ! ['d' , 'e' , 'f'] , '4' => vec ! ['g' , 'h' , 'i'] , '5' => vec ! ['j' , 'k' , 'l'] , '6' => vec ! ['m' , 'n' , 'o'] , '7' => vec ! ['p' , 'q' , 'r' , 's'] , '8' => vec ! ['t' , 'u' , 'v'] , '9' => vec ! ['w' , 'x' , 'y' , 'z'] , _ => Vec :: new () , } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_26/verina_advanced_26_iter_5_current.rs", "verified": true, "metadata": {"original_id": "d5eae418e192", "function_name": "digit_to_letters_exec", "bug_type": "missing_ensures"}}
{"id": "task_b_98ed39156ac1", "task": "task_b", "input_text": "fn barrier (arr : & [i32] , p : usize) -> (result : bool)\nrequires arr . len () > 0 , 0 <= p < arr . len () \nensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/barrier_impl.rs", "verified": true, "metadata": {"original_id": "98ed39156ac1", "function_name": "barrier", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_fffd0321c22e", "task": "task_b", "input_text": "fn even_exec (n : u32) -> (result : bool)\nensures result == even (n as int)", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool) ensures result == even (n as int) { n % 2 == 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn even (n : int) -> bool { n % 2 == 0 }\nfn even_exec (n : u32) -> (result : bool) ensures result == even (n as int) { n % 2 == 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "fffd0321c22e", "function_name": "even_exec", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_cee4533fa4fe", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize)   { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right  { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] \nensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key \ndecreases right - left\ninvariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_binary_search/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "cee4533fa4fe", "function_name": "binary_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_b_9d3446f3b2ea", "task": "task_b", "input_text": "fn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)\nensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , l : int | 0 <= k < l < result . len () ==> result [k] != result [l] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "9d3446f3b2ea", "function_name": "shared_elements", "has_invariants": true, "has_asserts": false}}
{"id": "task_a_b079a0134c6d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut shared = Vec :: new () ; for i in 0 .. list1 . len ()  { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& shared , elem) { shared . push (elem) ; } } shared }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& shared , elem) { shared . push (elem) ; } } shared }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "b079a0134c6d", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_b_7b37e24cffbf", "task": "task_b", "input_text": "fn shortest_beautiful_substring (s : Vec < char > , k : u32) -> (result : Vec < char >)\nrequires shortest_beautiful_substring_precond (s @ , k as nat) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shortest_beautiful_substring_precond (s : Seq < char > , k : nat) -> bool { forall | i : int | 0 <= i < s . len () ==> (s [i] == '0' || s [i] == '1') }\nfn shortest_beautiful_substring (s : Vec < char > , k : u32) -> (result : Vec < char >) requires shortest_beautiful_substring_precond (s @ , k as nat) , { return Vec :: new () ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn shortest_beautiful_substring_precond (s : Seq < char > , k : nat) -> bool { forall | i : int | 0 <= i < s . len () ==> (s [i] == '0' || s [i] == '1') }\nfn shortest_beautiful_substring (s : Vec < char > , k : u32) -> (result : Vec < char >) requires shortest_beautiful_substring_precond (s @ , k as nat) , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_71/verina_advanced_71_iter_0_original.rs", "verified": true, "metadata": {"original_id": "7b37e24cffbf", "function_name": "shortest_beautiful_substring", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_11e4c10a27d3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32)   { n % 10 }\n\n} // verus!", "target_text": "requires last_digit_precond (n as nat) \nensures 0 <= result < 10 , result == last_digit_spec (n as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn last_digit_precond (n : nat) -> bool { true }\nspec fn last_digit_spec (n : nat) -> nat { n % 10 }\nfn last_digit (n : u32) -> (result : u32) requires last_digit_precond (n as nat) , ensures 0 <= result < 10 , result == last_digit_spec (n as nat) , { n % 10 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_11/verina_basic_11_iter_1_current.rs", "verified": true, "metadata": {"original_id": "11e4c10a27d3", "function_name": "last_digit", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_b_8daca2889972", "task": "task_b", "input_text": "fn F () -> (r : i32)\nensures r == F_spec () && r <= 0", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_tmp_tmp0wu8wmfr_tests_F1a/verus_code.rs", "verified": true, "metadata": {"original_id": "8daca2889972", "function_name": "F", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_verus_datatypes_d92f3245f800", "task": "task_a", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: point\nstruct Point {\n    x: int,\n    y: int,\n}\n// ANCHOR_END: point\n\n// ANCHOR: point-impl\nimpl Point {\n    spec fn len2(&self) -> int {\n        self.x * self.x + self.y * self.y\n    }\n}\n\nfn rotate_90(p: Point) -> (o: Point)\n\n{\n    let o = Point { x: -p.y, y: p.x };\n\n    o\n}\n// ANCHOR_END: point-impl\n\n// ANCHOR: beverage\nenum Beverage {\n    Coffee { creamers: nat, sugar: bool },\n    Soda { flavor: Syrup },\n    Water { ice: bool },\n}\n// ANCHOR_END: beverage\n\n// ANCHOR: syrup\nenum Syrup {\n    Cola,\n    RootBeer,\n    Orange,\n    LemonLime,\n}\n// ANCHOR_END: syrup\n\nstruct Dessert {}\nimpl Dessert {\n    fn new() -> Dessert {\n        Dessert {}\n    }\n}\n\n// ANCHOR: make_float\nfn make_float(bev: Beverage) -> Dessert\n\n{\n\n    Dessert::new(/*...*/)\n}\n// ANCHOR_END: make_float\n\n// ANCHOR: count_creamers\nproof fn sufficiently_creamy(bev: Beverage) -> bool\n\n{\n   bev->creamers >= 2\n}\n// ANCHOR_END: count_creamers\n\n// ANCHOR: life\nenum Life {\n    Mammal { legs: int, has_pocket: bool },\n    Arthropod { legs: int, wings: int },\n    Plant { leaves: int },\n}\n\nspec fn is_insect(l: Life) -> bool\n{\n    l is Arthropod && l->Arthropod_legs == 6\n}\n// ANCHOR_END: life\n\n// ANCHOR: shape\nenum Shape {\n    Circle(int),\n    Rect(int, int),\n}\n\nspec fn area_2(s: Shape) -> int {\n    match s {\n        Shape::Circle(radius) => { radius * radius * 3 },\n        Shape::Rect(width, height) => { width * height }\n    }\n}\n// ANCHOR_END: shape\n\n// ANCHOR: rect_height\nspec fn rect_height(s: Shape) -> int\n    recommends s is Rect\n{\n    s->1\n}\n// ANCHOR_END: rect_height\n\n// ANCHOR: cuddly\nuse Life::*;\nspec fn cuddly(l: Life) -> bool {\n    ||| l matches Mammal { legs, .. } && legs == 4\n    ||| l matches Arthropod { legs, wings } && legs == 8 && wings == 0\n}\n// ANCHOR_END: cuddly\n\n// ANCHOR: kangaroo\nspec fn is_kangaroo(l: Life) -> bool {\n    &&& l matches Life::Mammal { legs, has_pocket }\n    &&& legs == 2\n    &&& has_pocket\n}\n\nspec fn walks_upright(l: Life) -> bool {\n    l matches Life::Mammal { legs, .. } ==> legs == 2\n}\n// ANCHOR_END: kangaroo\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "requires bev is Soda, bev is Coffee\nensures o.len2() == p.len2()", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: point\nstruct Point {\n    x: int,\n    y: int,\n}\n// ANCHOR_END: point\n\n// ANCHOR: point-impl\nimpl Point {\n    spec fn len2(&self) -> int {\n        self.x * self.x + self.y * self.y\n    }\n}\n\nfn rotate_90(p: Point) -> (o: Point)\n    ensures o.len2() == p.len2()\n{\n    let o = Point { x: -p.y, y: p.x };\n    assert((-p.y) * (-p.y) == p.y * p.y) by(nonlinear_arith);\n    o\n}\n// ANCHOR_END: point-impl\n\n// ANCHOR: beverage\nenum Beverage {\n    Coffee { creamers: nat, sugar: bool },\n    Soda { flavor: Syrup },\n    Water { ice: bool },\n}\n// ANCHOR_END: beverage\n\n// ANCHOR: syrup\nenum Syrup {\n    Cola,\n    RootBeer,\n    Orange,\n    LemonLime,\n}\n// ANCHOR_END: syrup\n\nstruct Dessert {}\nimpl Dessert {\n    fn new() -> Dessert {\n        Dessert {}\n    }\n}\n\n// ANCHOR: make_float\nfn make_float(bev: Beverage) -> Dessert\n    requires bev is Soda\n{\n    assert(bev !is Coffee);\n    Dessert::new(/*...*/)\n}\n// ANCHOR_END: make_float\n\n// ANCHOR: count_creamers\nproof fn sufficiently_creamy(bev: Beverage) -> bool\n    requires bev is Coffee\n{\n   bev->creamers >= 2\n}\n// ANCHOR_END: count_creamers\n\n// ANCHOR: life\nenum Life {\n    Mammal { legs: int, has_pocket: bool },\n    Arthropod { legs: int, wings: int },\n    Plant { leaves: int },\n}\n\nspec fn is_insect(l: Life) -> bool\n{\n    l is Arthropod && l->Arthropod_legs == 6\n}\n// ANCHOR_END: life\n\n// ANCHOR: shape\nenum Shape {\n    Circle(int),\n    Rect(int, int),\n}\n\nspec fn area_2(s: Shape) -> int {\n    match s {\n        Shape::Circle(radius) => { radius * radius * 3 },\n        Shape::Rect(width, height) => { width * height }\n    }\n}\n// ANCHOR_END: shape\n\n// ANCHOR: rect_height\nspec fn rect_height(s: Shape) -> int\n    recommends s is Rect\n{\n    s->1\n}\n// ANCHOR_END: rect_height\n\n// ANCHOR: cuddly\nuse Life::*;\nspec fn cuddly(l: Life) -> bool {\n    ||| l matches Mammal { legs, .. } && legs == 4\n    ||| l matches Arthropod { legs, wings } && legs == 8 && wings == 0\n}\n// ANCHOR_END: cuddly\n\n// ANCHOR: kangaroo\nspec fn is_kangaroo(l: Life) -> bool {\n    &&& l matches Life::Mammal { legs, has_pocket }\n    &&& legs == 2\n    &&& has_pocket\n}\n\nspec fn walks_upright(l: Life) -> bool {\n    l matches Life::Mammal { legs, .. } ==> legs == 2\n}\n// ANCHOR_END: kangaroo\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/datatypes.rs", "verified": true, "metadata": {"original_id": "verus_datatypes_d92f3245f800", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_b_7e5f64e44c35", "task": "task_b", "input_text": "pub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)\nrequires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 5 * N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , 5 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum . set (0 , 5 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s4lif_impl.rs", "verified": true, "metadata": {"original_id": "7e5f64e44c35", "function_name": "myfun", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_invariant_9879df0d9b53", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1  { new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len ()  { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ == list @ . subrange (0 , i as int) , decreases k - 1 - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len () invariant k <= j <= list . len () , k <= list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ == list @ . subrange (0 , i as int) , decreases k - 1 - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len () invariant k <= j <= list . len () , k <= list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_610_impl.rs", "verified": true, "metadata": {"original_id": "9879df0d9b53", "function_name": "remove_kth_element", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_5518664c862b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >) requires a . len () <= 100 && b . len () <= 100 , ensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] , { let mut c = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , c @ . len () == i , forall | j : int | (0 <= j && j < i) ==> c [j] == a [j] , { c . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , c @ . len () == a @ . len () + j , forall | k : int | (0 <= k && k < a . len ()) ==> c [k] == a [k] , forall | k : int | (a . len () <= k && k < c @ . len ()) ==> c [k] == b [k - a . len ()] , { c . push (b [j]) ; j += 1 ; } c }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >) requires a . len () <= 100 && b . len () <= 100 , ensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] , { let mut c = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , c @ . len () == i , forall | j : int | (0 <= j && j < i) ==> c [j] == a [j] , decreases a . len () - i , { c . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , c @ . len () == a @ . len () + j , forall | k : int | (0 <= k && k < a . len ()) ==> c [k] == a [k] , forall | k : int | (a . len () <= k && k < c @ . len ()) ==> c [k] == b [k - a . len ()] , decreases b . len () - j , { c . push (b [j]) ; j += 1 ; } c }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >) requires a . len () <= 100 && b . len () <= 100 , ensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] , { let mut c = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , c @ . len () == i , forall | j : int | (0 <= j && j < i) ==> c [j] == a [j] , decreases a . len () - i , { c . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , c @ . len () == a @ . len () + j , forall | k : int | (0 <= k && k < a . len ()) ==> c [k] == a [k] , forall | k : int | (a . len () <= k && k < c @ . len ()) ==> c [k] == b [k - a . len ()] , decreases b . len () - j , { c . push (b [j]) ; j += 1 ; } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/array_concat_strong_impl.rs", "verified": true, "metadata": {"original_id": "5518664c862b", "function_name": "concat", "bug_type": "missing_decreases"}}
{"id": "task_a_2f121e2a452e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize)   { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize)   { helper (xs , target , 0) }\n\n} // verus!", "target_text": "requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , search_insert_precond (xs @ , target) \nensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , search_insert_postcond (xs @ , target , result as int) , idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx \ndecreases ys . len () - idx ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_69/verina_advanced_69_impl.rs", "verified": true, "metadata": {"original_id": "2f121e2a452e", "function_name": "search_insert", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_e13ed677bb0c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MaxA (a : & [i32]) -> (m : i32)   { let mut max = a [0] ; let mut index = 1 ; while index < a . len ()  { if a [index] > max { max = a [index] ; } index += 1 ; } max }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures forall | i : int | 0 <= i < a . len () ==> a [i] <= m , exists | i : int | 0 <= i < a . len () && a [i] == m \ndecreases a . len () - index \ninvariant 0 <= index <= a . len () , forall | i : int | 0 <= i < index ==> a [i] <= max , exists | i : int | 0 <= i < index && a [i] == max ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MaxA (a : & [i32]) -> (m : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a [i] <= m , exists | i : int | 0 <= i < a . len () && a [i] == m , { let mut max = a [0] ; let mut index = 1 ; while index < a . len () invariant 0 <= index <= a . len () , forall | i : int | 0 <= i < index ==> a [i] <= max , exists | i : int | 0 <= i < index && a [i] == max , decreases a . len () - index , { if a [index] > max { max = a [index] ; } index += 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "e13ed677bb0c", "function_name": "MaxA", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_7551765cf41c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32)   { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32)   { let (minIdx , secondIdx) = if s [0] <= s [1] { (0 , 1) } else { (1 , 0) } ; secondSmallestAux (s , 2 , minIdx , secondIdx) }\n\n} // verus!", "target_text": "requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , secondSmallest_precond (s) \nensures exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i \ndecreases s . len () - i ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn secondSmallest_precond (s : & Vec < i32 >) -> bool { s . len () > 1 }\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { return s [secondIdx] ; } let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val && current != min_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } }\npub fn secondSmallest (s : & Vec < i32 >) -> (result : i32) requires secondSmallest_precond (s) , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { let (minIdx , secondIdx) = if s [0] <= s [1] { (0 , 1) } else { (1 , 0) } ; secondSmallestAux (s , 2 , minIdx , secondIdx) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_40/verina_basic_40_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "7551765cf41c", "function_name": "secondSmallest", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_131504e65e79", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize)   { let mut i : usize = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; } i }\n\n} // verus!", "target_text": "requires linear_search_precond (a @ , e) \nensures linear_search_postcond (a @ , e , result) \ndecreases a . len () - i\ninvariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_postcond (a : Seq < i32 > , e : i32 , result : usize) -> bool { result <= a . len () && (result == a . len () || a . index (result as int) == e) && (forall | i : int | 0 <= i < result ==> a . index (i) != e) }\nspec fn linear_search_precond (a : Seq < i32 > , e : i32) -> bool { true }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a @ , e) , ensures linear_search_postcond (a @ , e , result) , { let mut i : usize = 0 ; while i < a . len () invariant i <= a . len () , forall | j : int | 0 <= j < i ==> a @ . index (j) != e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_68/verina_basic_68_impl.rs", "verified": true, "metadata": {"original_id": "131504e65e79", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_invariant_890c0a971069", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_elements_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "890c0a971069", "function_name": "in_array_exec", "bug_type": "missing_invariant"}}
{"id": "task_b_00f622c61972", "task": "task_b", "input_text": "fn triple_over (x : u32) -> (r : u32)\nrequires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { let doubled = x + x ; doubled + x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { let doubled = x + x ; doubled + x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "00f622c61972", "function_name": "triple_over", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_05d0b38c00a3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize)  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize) ensures pos <= dp . len () { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize) ensures pos <= dp . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_24/verina_advanced_24.rs", "verified": true, "metadata": {"original_id": "05d0b38c00a3", "function_name": "binary_search_position", "bug_type": "missing_ensures"}}
{"id": "task_b_bae2c7702c04", "task": "task_b", "input_text": "fn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)\nensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "bae2c7702c04", "function_name": "contains", "has_invariants": true, "has_asserts": false}}
{"id": "task_a_eacd0ad24593", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)   { }\n\n} // verus!", "target_text": "requires 0 <= i < j < old (a) . len () \nensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/two_way_sort_impl.rs", "verified": true, "metadata": {"original_id": "eacd0ad24593", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_3ab42e75f852", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >)   { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len ()  { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n  { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "requires list @ . len () > 0 , 0 < n < list @ . len () \nensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) \ndecreases list @ . len () - i , n - j \ninvariant 0 < n < list @ . len () , n <= i <= list @ . len () , new_list @ == list @ . subrange (n as int , i as int) , 0 < n < list @ . len () , 0 <= j <= n , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant 0 < n < list @ . len () , n <= i <= list @ . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list @ . len () - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 < n < list @ . len () , 0 <= j <= n , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_586_impl.rs", "verified": true, "metadata": {"original_id": "3ab42e75f852", "function_name": "split_and_append", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_b_55cfdc94cc4a", "task": "task_b", "input_text": "fn update_elements (a : & mut Vec < i32 >)\nrequires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX \nensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX , ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX , ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_update_array/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "55cfdc94cc4a", "function_name": "update_elements", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_invariant_2f7261f8e3d5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/remove_elements_iter_1_current.rs", "verified": true, "metadata": {"original_id": "2f7261f8e3d5", "function_name": "in_array_exec", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_48c0504e309d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] ,  { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop invariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases high - low { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop invariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases high - low { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop invariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases high - low { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/binary_search_impl.rs", "verified": true, "metadata": {"original_id": "48c0504e309d", "function_name": "binary_search", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_59468cd5d2ca", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 ,  { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "59468cd5d2ca", "function_name": "triple_if", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_assert_9cf715209978", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == (arr1 [j] % arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i {     let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == (arr1 [j] % arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == (arr1 [j] % arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_616_impl.rs", "verified": true, "metadata": {"original_id": "9cf715209978", "function_name": "element_wise_module", "bug_type": "missing_assert"}}
{"id": "task_a_a239dbf1c5f7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_to_decimal_precond (digits : Seq < nat >) -> bool { forall | i : int | 0 <= i < digits . len () ==> (digits [i] == 0 || digits [i] == 1) }\nfn binary_to_decimal (digits : Vec < u32 >) -> (result : u32)  { return 0 ; }\n\n} // verus!", "target_text": "requires binary_to_decimal_precond (digits @ . map (| i : int , x : u32 | x as nat)) , digits @ . len () == 0 || (digits @ . len () <= 10 && forall | j : int | 0 <= j < digits @ . len () ==> digits [j] <= 1) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_to_decimal_precond (digits : Seq < nat >) -> bool { forall | i : int | 0 <= i < digits . len () ==> (digits [i] == 0 || digits [i] == 1) }\nfn binary_to_decimal (digits : Vec < u32 >) -> (result : u32) requires binary_to_decimal_precond (digits @ . map (| i : int , x : u32 | x as nat)) , digits @ . len () == 0 || (digits @ . len () <= 10 && forall | j : int | 0 <= j < digits @ . len () ==> digits [j] <= 1) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_7/verina_advanced_7_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a239dbf1c5f7", "function_name": "binary_to_decimal", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_requires_6c04be9b8443", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)  ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_51/verina_basic_51_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "6c04be9b8443", "function_name": "binary_search_loop", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_cee4533fa4fe", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] ,  { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_binary_search/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "cee4533fa4fe", "function_name": "binary_search", "bug_type": "missing_ensures"}}
{"id": "task_a_f397da29f9f7", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSort (a : & mut Vec < int > , c : usize , f : usize)   { }\n\n} // verus!", "target_text": "requires 0 <= c <= f <= old (a) . len () \nensures a . len () == old (a) . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSort (a : & mut Vec < int > , c : usize , f : usize) requires 0 <= c <= f <= old (a) . len () , ensures a . len () == old (a) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f397da29f9f7", "function_name": "bubbleSort", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_1a323275286e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , decreases arr . len () - i { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , decreases arr . len () - i { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { let mut i = 0 ; while i < arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , decreases arr . len () - i { if arr [i] == k { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/unverified/task_id_808_iter_2_current.rs", "verified": true, "metadata": {"original_id": "1a323275286e", "function_name": "contains_k", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_33b2294d8aac", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)  { }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/verified/havoc_inline_post_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "33b2294d8aac", "function_name": "havoc_inline_post", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_9879df0d9b53", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () ,  { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ == list @ . subrange (0 , i as int) , decreases k - 1 - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len () invariant k <= j <= list . len () , k <= list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ == list @ . subrange (0 , i as int) , decreases k - 1 - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len () invariant k <= j <= list . len () , k <= list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ == list @ . subrange (0 , i as int) , decreases k - 1 - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len () invariant k <= j <= list . len () , k <= list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_610_impl.rs", "verified": true, "metadata": {"original_id": "9879df0d9b53", "function_name": "remove_kth_element", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_16300e4e7930", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] == 5 * N , { sum [0] = 5 * N ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum [0] = 5 * N ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 5 * N , { sum [0] = 5 * N ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s5if_impl.rs", "verified": true, "metadata": {"original_id": "16300e4e7930", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_b_8933e0081cf9", "task": "task_b", "input_text": "fn solution (nums : Vec < u32 >) -> (result : u32)\nrequires solution_precond (nums @) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn solution_precond (nums : Seq < u32 >) -> bool { 1 <= nums . len () && nums . len () <= 100 && forall | i : int | 0 <= i < nums . len () ==> 1 <= nums [i] && nums [i] <= 100 }\n# [verifier :: exec_allows_no_decreases_clause] fn solution (nums : Vec < u32 >) -> (result : u32) requires solution_precond (nums @) , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn solution_precond (nums : Seq < u32 >) -> bool { 1 <= nums . len () && nums . len () <= 100 && forall | i : int | 0 <= i < nums . len () ==> 1 <= nums [i] && nums [i] <= 100 }\n# [verifier :: exec_allows_no_decreases_clause] fn solution (nums : Vec < u32 >) -> (result : u32) requires solution_precond (nums @) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_74/verina_advanced_74_iter_0_original.rs", "verified": true, "metadata": {"original_id": "8933e0081cf9", "function_name": "solution", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_assert_08fa248ef5f5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof {  } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_linear_search2/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "08fa248ef5f5", "function_name": "linear_search", "bug_type": "missing_assert"}}
{"id": "task_a_cea8626b15a4", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (v : & mut Vec < u64 >)  { let len = v . len () ; let mut i = 0 ; while i < len / 2  { let temp = v [i] ; let temp2 = v [len - i - 1] ; v . set (i , temp2) ; v . set (len - i - 1 , temp) ; i += 1 ; } }\n\n} // verus!", "target_text": "ensures v . len () == old (v) . len () , forall | i : int | 0 <= i < old (v) . len () ==> v [i] == old (v) [old (v) . len () - i - 1] \ndecreases len / 2 - i \ninvariant v . len () == len , len == old (v) . len () , forall | j : int | 0 <= j < i ==> v [j] == old (v) [len - j - 1] , forall | j : int | len - i <= j < len ==> v [j] == old (v) [len - j - 1] , forall | j : int | i <= j < len - i ==> v [j] == old (v) [j] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (v : & mut Vec < u64 >) ensures v . len () == old (v) . len () , forall | i : int | 0 <= i < old (v) . len () ==> v [i] == old (v) [old (v) . len () - i - 1] , { let len = v . len () ; let mut i = 0 ; while i < len / 2 invariant v . len () == len , len == old (v) . len () , forall | j : int | 0 <= j < i ==> v [j] == old (v) [len - j - 1] , forall | j : int | len - i <= j < len ==> v [j] == old (v) [len - j - 1] , forall | j : int | i <= j < len - i ==> v [j] == old (v) [j] , decreases len / 2 - i , { let temp = v [i] ; let temp2 = v [len - i - 1] ; v . set (i , temp2) ; v . set (len - i - 1 , temp) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/unverified/reverse_impl.rs", "verified": true, "metadata": {"original_id": "cea8626b15a4", "function_name": "reverse", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_invariant_385ba17c20ec", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd ::  {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] # [cfg (verus_keep_ghost)] exec fn seq_to_vec (Ghost (s) : Ghost < Seq < Seq < bool > > >) -> (result : Vec < Vec < bool > >) ensures result . deep_view () == s { arbitrary () }\n\n} // verus!", "target_text": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] # [cfg (verus_keep_ghost)] exec fn seq_to_vec (Ghost (s) : Ghost < Seq < Seq < bool > > >) -> (result : Vec < Vec < bool > >) ensures result . deep_view () == s { arbitrary () }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: arithmetic :: overflow :: CheckedU64 ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: div_mod :: { lemma_fundamental_div_mod , lemma_mod_multiples_vanish } ;\nuse vstd :: set_lib :: * ;\nuse vstd :: seq :: * ;\n# [cfg (verus_keep_ghost)] use vstd :: arithmetic :: mul :: lemma_mul_inequality ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: tokens :: frac :: * ;\nuse vstd :: bytes :: u64_from_le_bytes ;\nuse vstd :: slice :: slice_subrange ;\n# [cfg (verus_keep_ghost)] use vstd :: std_specs :: hash :: * ;\nuse vstd :: invariant :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: relations :: * ;\nuse vstd :: bytes ;\nuse vstd :: layout :: * ;\nuse vstd :: proph :: * ;\nuse vstd :: pcm :: * ;\nuse vstd :: pervasive :: runtime_assert ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] # [cfg (verus_keep_ghost)] exec fn seq_to_vec (Ghost (s) : Ghost < Seq < Seq < bool > > >) -> (result : Vec < Vec < bool > >) ensures result . deep_view () == s { arbitrary () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "capybarakv_inlined.rs", "verified": true, "metadata": {"original_id": "385ba17c20ec", "function_name": "seq_to_vec", "bug_type": "missing_invariant"}}
{"id": "task_a_99db684ec04d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nproof fn lemma_vec_push < T > (vec : Seq < T > , i : T , l : usize)   { }\nfn contains (str : & Vec < i32 > , key : i32) -> (result : bool)  { let mut idx = 0 ; while idx < str . len ()  { if str [idx] == key { return true ; } idx += 1 ; } false }\nfn remove_elements (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len ()  { let elem = arr1 [idx] ; if ! contains (arr2 , elem) {  result . push (elem) ; } idx += 1 ; } result }\n\n} // verus!", "target_text": "requires l == vec . len () \nensures forall | k : int | 0 <= k < vec . len () ==> # [trigger] vec [k] == vec . push (i) [k] , vec . push (i) . index (l as int) == i , result <==> (exists | i : int | 0 <= i < str . len () && (str [i] == key)) , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && ! arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int | 0 <= i < arr1 . len () ==> (arr2 @ . contains (# [trigger] arr1 [i]) || result @ . contains (# [trigger] arr1 [i] ,)) \ndecreases str . len () - idx , arr1 . len () - idx \ninvariant 0 <= idx <= str . len () , forall | j : int | 0 <= j < idx ==> str [j] != key , 0 <= idx <= arr1 . len () , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && ! arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int | 0 <= i < idx ==> (arr2 @ . contains (# [trigger] arr1 [i]) || result @ . contains (# [trigger] arr1 [i] ,)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nproof fn lemma_vec_push < T > (vec : Seq < T > , i : T , l : usize) requires l == vec . len () , ensures forall | k : int | 0 <= k < vec . len () ==> # [trigger] vec [k] == vec . push (i) [k] , vec . push (i) . index (l as int) == i , { }\nfn contains (str : & Vec < i32 > , key : i32) -> (result : bool) ensures result <==> (exists | i : int | 0 <= i < str . len () && (str [i] == key)) , { let mut idx = 0 ; while idx < str . len () invariant 0 <= idx <= str . len () , forall | j : int | 0 <= j < idx ==> str [j] != key , decreases str . len () - idx , { if str [idx] == key { return true ; } idx += 1 ; } false }\nfn remove_elements (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && ! arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int | 0 <= i < arr1 . len () ==> (arr2 @ . contains (# [trigger] arr1 [i]) || result @ . contains (# [trigger] arr1 [i] ,)) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && ! arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int | 0 <= i < idx ==> (arr2 @ . contains (# [trigger] arr1 [i]) || result @ . contains (# [trigger] arr1 [i] ,)) , decreases arr1 . len () - idx , { let elem = arr1 [idx] ; if ! contains (arr2 , elem) { proof { let old_result = result @ ; let old_len = result . len () ; lemma_vec_push (old_result , elem , old_len) ; } result . push (elem) ; } idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_161_impl.rs", "verified": true, "metadata": {"original_id": "99db684ec04d", "function_name": "remove_elements", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_requires_b602dd885e0b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize)  ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn swap (a : & mut Vec < bool > , i : usize , j : usize) requires 0 <= i < j < old (a) . len () , ensures a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , a . len () == old (a) . len () , a @ . to_multiset () =~~= old (a) @ . to_multiset () , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/two_way_sort_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b602dd885e0b", "function_name": "swap", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_6ec50bf7bdb9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { idx } else if target <= ys [idx] { idx } else { helper (ys , target , idx + 1) } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_69/verina_advanced_69_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "6ec50bf7bdb9", "function_name": "search_insert", "bug_type": "missing_decreases"}}
{"id": "task_a_1b6ca1d9ff6b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/remove_elements_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "1b6ca1d9ff6b", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_c_missing_ensures_f5ed356316b3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 ,  { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 2 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/ms3_impl.rs", "verified": true, "metadata": {"original_id": "f5ed356316b3", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_a_0a6ed5b553c3", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >)   { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len ()  { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "target_text": "requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] \nensures if let Some (idx) = index\ndecreases arr . len () - index\ninvariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index ==> arr [k] != target ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_first_occurrence (arr : & Vec < i32 > , target : i32) -> (index : Option < usize >) requires forall | i : int , j : int | 0 <= i < j < arr . len () ==> arr [i] <= arr [j] , ensures if let Some (idx) = index { idx < arr . len () && arr [idx as int] == target && forall | k : int | 0 <= k < idx ==> arr [k] != target } else { forall | k : int | 0 <= k < arr . len () ==> arr [k] != target } , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | k : int | 0 <= k < index ==> arr [k] != target , decreases arr . len () - index { if arr [index] == target { return Some (index) ; } index += 1 ; } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_733_impl.rs", "verified": true, "metadata": {"original_id": "0a6ed5b553c3", "function_name": "find_first_occurrence", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_ensures_6288996593a1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i] != s [i + 1]) }\nspec fn happy_spec (s : Seq < char >) -> (ret : bool) { s . len () >= 3 && (forall | i : int | 0 < i && i + 1 < s . len () ==> three_distinct_spec (s , i)) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () ,  { s [i - 1] != s [i] && s [i] != s [i + 1] && s [i] != s [i + 1] }\n# [verifier :: loop_isolation (false)] fn is_happy (s : & Vec < char >) -> (happy : bool)  { if s . len () < 3 { return false ; } let mut j = 1 ; while j < s . len () - 1 invariant 1 <= j <= s . len () , forall | i : int | 0 < i < j && i + 1 < s . len () ==> three_distinct_spec (s @ , i) , decreases s . len () - j , { if ! three_distinct (s , j) { return false ; } j += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i] != s [i + 1]) }\nspec fn happy_spec (s : Seq < char >) -> (ret : bool) { s . len () >= 3 && (forall | i : int | 0 < i && i + 1 < s . len () ==> three_distinct_spec (s , i)) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { s [i - 1] != s [i] && s [i] != s [i + 1] && s [i] != s [i + 1] }\n# [verifier :: loop_isolation (false)] fn is_happy (s : & Vec < char >) -> (happy : bool) ensures happy <==> happy_spec (s @) , { if s . len () < 3 { return false ; } let mut j = 1 ; while j < s . len () - 1 invariant 1 <= j <= s . len () , forall | i : int | 0 < i < j && i + 1 < s . len () ==> three_distinct_spec (s @ , i) , decreases s . len () - j , { if ! three_distinct (s , j) { return false ; } j += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i] != s [i + 1]) }\nspec fn happy_spec (s : Seq < char >) -> (ret : bool) { s . len () >= 3 && (forall | i : int | 0 < i && i + 1 < s . len () ==> three_distinct_spec (s , i)) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { s [i - 1] != s [i] && s [i] != s [i + 1] && s [i] != s [i + 1] }\n# [verifier :: loop_isolation (false)] fn is_happy (s : & Vec < char >) -> (happy : bool) ensures happy <==> happy_spec (s @) , { if s . len () < 3 { return false ; } let mut j = 1 ; while j < s . len () - 1 invariant 1 <= j <= s . len () , forall | i : int | 0 < i < j && i + 1 < s . len () ==> three_distinct_spec (s @ , i) , decreases s . len () - j , { if ! three_distinct (s , j) { return false ; } j += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/080-is_happy_impl.rs", "verified": true, "metadata": {"original_id": "6288996593a1", "function_name": "is_happy", "bug_type": "missing_ensures"}}
{"id": "task_a_0cca59d8cea0", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len ()  {    let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) \ndecreases arr1 . len () - i\ninvariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] / arr2 [j] , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_618_impl.rs", "verified": true, "metadata": {"original_id": "0cca59d8cea0", "function_name": "element_wise_divide", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_ensures_f101c4cc3062", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn barrier (v : & [int] , p : usize) -> (b : bool) requires v . len () > 0 , p < v . len () ,  { let mut i = 0 ; if p >= v . len () - 1 { return true ; } while i <= p invariant 0 <= i <= p + 1 , i <= v . len () , p < v . len () - 1 , forall | k : int , l : int | 0 <= k < i && p < l < v . len () ==> v [k] < v [l] decreases p + 1 - i { let mut j = p + 1 ; while j < v . len () invariant 0 <= i <= p , i < v . len () , p + 1 <= j <= v . len () , p < v . len () - 1 , forall | l : int | p < l < j ==> v [i as int] < v [l] , forall | k : int , l : int | 0 <= k < i && p < l < v . len () ==> v [k] < v [l] decreases v . len () - j { if v [i] >= v [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn barrier (v : & [int] , p : usize) -> (b : bool) requires v . len () > 0 , p < v . len () , ensures b == (forall | k : int , l : int | 0 <= k <= p && p < l < v . len () ==> v [k] < v [l]) { let mut i = 0 ; if p >= v . len () - 1 { return true ; } while i <= p invariant 0 <= i <= p + 1 , i <= v . len () , p < v . len () - 1 , forall | k : int , l : int | 0 <= k < i && p < l < v . len () ==> v [k] < v [l] decreases p + 1 - i { let mut j = p + 1 ; while j < v . len () invariant 0 <= i <= p , i < v . len () , p + 1 <= j <= v . len () , p < v . len () - 1 , forall | l : int | p < l < j ==> v [i as int] < v [l] , forall | k : int , l : int | 0 <= k < i && p < l < v . len () ==> v [k] < v [l] decreases v . len () - j { if v [i] >= v [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn barrier (v : & [int] , p : usize) -> (b : bool) requires v . len () > 0 , p < v . len () , ensures b == (forall | k : int , l : int | 0 <= k <= p && p < l < v . len () ==> v [k] < v [l]) { let mut i = 0 ; if p >= v . len () - 1 { return true ; } while i <= p invariant 0 <= i <= p + 1 , i <= v . len () , p < v . len () - 1 , forall | k : int , l : int | 0 <= k < i && p < l < v . len () ==> v [k] < v [l] decreases p + 1 - i { let mut j = p + 1 ; while j < v . len () invariant 0 <= i <= p , i < v . len () , p + 1 <= j <= v . len () , p < v . len () - 1 , forall | l : int | p < l < j ==> v [i as int] < v [l] , forall | k : int , l : int | 0 <= k < i && p < l < v . len () ==> v [k] < v [l] decreases v . len () - j { if v [i] >= v [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny-Exercises_tmp_tmpjm75muf__Session10Exercises_ExerciseBarrier/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "f101c4cc3062", "function_name": "barrier", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_vostd_page_prop_470fb761b33a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::ext_equal]\n#[derive(Clone, Copy, PartialEq, Eq)]\npub struct PageProperty {\n    /// The flags associated with the page,\n    pub flags: PageFlags,\n    /// The cache policy for the page.\n    pub cache: CachePolicy,\n    pub priv_flags: PrivilegedPageFlags,\n}\n\nglobal layout PageProperty is size == 3, align == 1;\n\n} // verus!\nverus! {\n\npub broadcast proof fn lemma_page_property_equal_correctness(a: PageProperty, b: PageProperty)\n    requires\n        #[trigger] a.flags == #[trigger] b.flags,\n        a.cache == b.cache,\n        a.priv_flags == b.priv_flags,\n\n{\n}\n\npub broadcast proof fn lemma_page_property_equal_soundness(a: PageProperty, b: PageProperty)\n    requires\n        a == b,\n\n{\n}\n\n} // verus!\nverus! {\n\nimpl PageProperty {\n    pub open spec fn new_user_spec(flags: PageFlags, cache: CachePolicy) -> Self {\n        Self { flags, cache, priv_flags: PrivilegedPageFlags::USER() }\n    }\n\n    #[verifier::when_used_as_spec(new_user_spec)]\n    pub fn new_user(flags: PageFlags, cache: CachePolicy) -> (res: Self)\n\n    {\n        Self { flags, cache, priv_flags: PrivilegedPageFlags::USER() }\n    }\n\n    pub open spec fn new_absent_spec() -> Self {\n        Self {\n            flags: PageFlags::empty(),\n            cache: CachePolicy::Writeback,\n            priv_flags: PrivilegedPageFlags::empty(),\n        }\n    }\n\n    #[verifier::when_used_as_spec(new_absent_spec)]\n    pub fn new_absent() -> (res: Self)\n\n    {\n        Self {\n            flags: PageFlags::empty(),\n            cache: CachePolicy::Writeback,\n            priv_flags: PrivilegedPageFlags::empty(),\n        }\n    }\n}\n\n} // verus!\nverus! {\n\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n#[repr(u8)]\npub enum CachePolicy {\n    Uncacheable,\n    WriteCombining,\n    WriteProtected,\n    Writethrough,\n    Writeback,\n}\n\n#[allow(non_snake_case)]\nimpl CachePolicy {\n    #[verifier::inline]\n    pub open spec fn N_spec() -> usize {\n        (CachePolicy::Writeback.value() + 1) as usize\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(N_spec)]\n    pub const fn N() -> (res: usize)\n\n    {\n        (CachePolicy::Writeback.value() + 1) as usize\n    }\n\n    #[verifier::inline]\n    pub open spec fn value_spec(&self) -> u8 {\n        match self {\n            CachePolicy::Uncacheable => 0,\n            CachePolicy::WriteCombining => 1,\n            CachePolicy::WriteProtected => 2,\n            CachePolicy::Writethrough => 3,\n            CachePolicy::Writeback => 4,\n        }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(value_spec)]\n    pub const fn value(&self) -> (res: u8)\n\n    {\n        match self {\n            CachePolicy::Uncacheable => 0,\n            CachePolicy::WriteCombining => 1,\n            CachePolicy::WriteProtected => 2,\n            CachePolicy::Writethrough => 3,\n            CachePolicy::Writeback => 4,\n        }\n    }\n}\n\n} // verus!\nverus! {\n\n#[verifier::ext_equal]\n#[repr(transparent)]\n#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\npub struct PageFlags {\n    pub bits: u8,\n}\n\npub broadcast proof fn lemma_page_flags_equal_correctness(a: PageFlags, b: PageFlags)\n    requires\n        #[trigger] a.bits == #[trigger] b.bits,\n\n{\n}\n\npub broadcast proof fn lemma_page_flags_equal_soundness(a: PageFlags, b: PageFlags)\n    requires\n        a == b,\n\n{\n}\n\nimpl PageFlags {\n    pub open spec fn present(self) -> bool {\n        self.bits & 0b00000001 != 0\n    }\n\n    #[verifier::inline]\n    pub open spec fn empty_spec() -> Self {\n        Self { bits: 0 }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(empty_spec)]\n    pub const fn empty() -> (res: Self)\n\n    {\n        Self { bits: 0 }\n    }\n\n    #[verifier::inline]\n    pub open spec fn value_spec(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(value_spec)]\n    pub const fn value(&self) -> (res: u8)\n\n    {\n        self.bits\n    }\n\n    #[verifier::inline]\n    pub open spec fn from_bits_spec(value: u8) -> Self {\n        Self { bits: value }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(from_bits_spec)]\n    pub fn from_bits(value: u8) -> (res: Self)\n\n    {\n        Self { bits: value }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn R_spec() -> Self {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(R_spec)]\n    pub const fn R() -> (res: Self)\n\n    {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn W_spec() -> Self {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(W_spec)]\n    pub const fn W() -> (res: Self)\n\n    {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn X_spec() -> Self {\n        Self { bits: 0b00000100 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(X_spec)]\n    pub const fn X() -> (res: Self)\n\n    {\n        Self { bits: 0b00000100 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn RW_spec() -> Self {\n        Self { bits: Self::R().value() | Self::W().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(X_spec)]\n    pub const fn RW() -> (res: Self)\n\n    {\n        Self { bits: Self::R().value() | Self::W().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn RX_spec() -> Self {\n        Self { bits: Self::R().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(RX_spec)]\n    pub const fn RX() -> (res: Self)\n\n    {\n        Self { bits: Self::R().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn RWX_spec() -> Self {\n        Self { bits: Self::R().value() | Self::W().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(RWX_spec)]\n    pub const fn RWX() -> (res: Self)\n\n    {\n        Self { bits: Self::R().value() | Self::W().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn ACCESSED_spec() -> Self {\n        Self { bits: 0b00001000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(ACCESSED_spec)]\n    pub const fn ACCESSED() -> (res: Self)\n\n    {\n        Self { bits: 0b00001000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn DIRTY_spec() -> Self {\n        Self { bits: 0b00010000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(DIRTY_spec)]\n    pub const fn DIRTY() -> (res: Self)\n\n    {\n        Self { bits: 0b00010000 }\n    }\n}\n\n} // verus!\nverus! {\n\n#[verifier::ext_equal]\n#[repr(transparent)]\n#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\npub struct PrivilegedPageFlags {\n    pub bits: u8,\n}\n\npub broadcast proof fn lemma_privileged_page_flags_equal_correctness(\n    a: PrivilegedPageFlags,\n    b: PrivilegedPageFlags,\n)\n    requires\n        #[trigger] a.bits == #[trigger] b.bits,\n\n{\n}\n\npub broadcast proof fn lemma_privileged_page_flags_equal_soundness(\n    a: PrivilegedPageFlags,\n    b: PrivilegedPageFlags,\n)\n    requires\n        a == b,\n\n{\n}\n\nimpl PrivilegedPageFlags {\n    #[verifier::inline]\n    pub open spec fn empty_spec() -> Self {\n        Self { bits: 0 }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(empty_spec)]\n    pub const fn empty() -> (res: Self)\n\n    {\n        Self { bits: 0 }\n    }\n\n    #[verifier::inline]\n    pub open spec fn value_spec(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(value_spec)]\n    pub const fn value(&self) -> (res: u8)\n\n    {\n        self.bits\n    }\n\n    #[verifier::inline]\n    pub open spec fn from_bits_spec(value: u8) -> Self {\n        Self { bits: value }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(from_bits_spec)]\n    pub fn from_bits(value: u8) -> (res: Self)\n\n    {\n        Self { bits: value }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn USER_spec() -> Self {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(USER_spec)]\n    pub const fn USER() -> (res: Self)\n\n    {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn GLOBAL_spec() -> Self {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(GLOBAL_spec)]\n    pub const fn GLOBAL() -> (res: Self)\n\n    {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn SHARED_spec() -> Self {\n        Self { bits: 0b10000000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(SHARED_spec)]\n    pub const fn SHARED() -> (res: Self)\n\n    {\n        Self { bits: 0b10000000 }\n    }\n}\n\n} // verus!\n", "target_text": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::ext_equal]\n#[derive(Clone, Copy, PartialEq, Eq)]\npub struct PageProperty {\n    /// The flags associated with the page,\n    pub flags: PageFlags,\n    /// The cache policy for the page.\n    pub cache: CachePolicy,\n    pub priv_flags: PrivilegedPageFlags,\n}\n\nglobal layout PageProperty is size == 3, align == 1;\n\n} // verus!\nverus! {\n\npub broadcast proof fn lemma_page_property_equal_correctness(a: PageProperty, b: PageProperty)\n    requires\n        #[trigger] a.flags == #[trigger] b.flags,\n        a.cache == b.cache,\n        a.priv_flags == b.priv_flags,\n    ensures\n        a == b,\n{\n}\n\npub broadcast proof fn lemma_page_property_equal_soundness(a: PageProperty, b: PageProperty)\n    requires\n        a == b,\n    ensures\n        #[trigger] a.flags == #[trigger] b.flags,\n        a.cache == b.cache,\n        a.priv_flags == b.priv_flags,\n{\n}\n\n} // verus!\nverus! {\n\nimpl PageProperty {\n    pub open spec fn new_user_spec(flags: PageFlags, cache: CachePolicy) -> Self {\n        Self { flags, cache, priv_flags: PrivilegedPageFlags::USER() }\n    }\n\n    #[verifier::when_used_as_spec(new_user_spec)]\n    pub fn new_user(flags: PageFlags, cache: CachePolicy) -> (res: Self)\n        ensures\n            res == Self::new_user_spec(flags, cache),\n    {\n        Self { flags, cache, priv_flags: PrivilegedPageFlags::USER() }\n    }\n\n    pub open spec fn new_absent_spec() -> Self {\n        Self {\n            flags: PageFlags::empty(),\n            cache: CachePolicy::Writeback,\n            priv_flags: PrivilegedPageFlags::empty(),\n        }\n    }\n\n    #[verifier::when_used_as_spec(new_absent_spec)]\n    pub fn new_absent() -> (res: Self)\n        ensures\n            res == Self::new_absent_spec(),\n    {\n        Self {\n            flags: PageFlags::empty(),\n            cache: CachePolicy::Writeback,\n            priv_flags: PrivilegedPageFlags::empty(),\n        }\n    }\n}\n\n} // verus!\nverus! {\n\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n#[repr(u8)]\npub enum CachePolicy {\n    Uncacheable,\n    WriteCombining,\n    WriteProtected,\n    Writethrough,\n    Writeback,\n}\n\n#[allow(non_snake_case)]\nimpl CachePolicy {\n    #[verifier::inline]\n    pub open spec fn N_spec() -> usize {\n        (CachePolicy::Writeback.value() + 1) as usize\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(N_spec)]\n    pub const fn N() -> (res: usize)\n        ensures\n            res == Self::N_spec(),\n    {\n        (CachePolicy::Writeback.value() + 1) as usize\n    }\n\n    #[verifier::inline]\n    pub open spec fn value_spec(&self) -> u8 {\n        match self {\n            CachePolicy::Uncacheable => 0,\n            CachePolicy::WriteCombining => 1,\n            CachePolicy::WriteProtected => 2,\n            CachePolicy::Writethrough => 3,\n            CachePolicy::Writeback => 4,\n        }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(value_spec)]\n    pub const fn value(&self) -> (res: u8)\n        ensures\n            res == self.value(),\n    {\n        match self {\n            CachePolicy::Uncacheable => 0,\n            CachePolicy::WriteCombining => 1,\n            CachePolicy::WriteProtected => 2,\n            CachePolicy::Writethrough => 3,\n            CachePolicy::Writeback => 4,\n        }\n    }\n}\n\n} // verus!\nverus! {\n\n#[verifier::ext_equal]\n#[repr(transparent)]\n#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\npub struct PageFlags {\n    pub bits: u8,\n}\n\npub broadcast proof fn lemma_page_flags_equal_correctness(a: PageFlags, b: PageFlags)\n    requires\n        #[trigger] a.bits == #[trigger] b.bits,\n    ensures\n        a == b,\n{\n}\n\npub broadcast proof fn lemma_page_flags_equal_soundness(a: PageFlags, b: PageFlags)\n    requires\n        a == b,\n    ensures\n        #[trigger] a.bits == #[trigger] b.bits,\n{\n}\n\nimpl PageFlags {\n    pub open spec fn present(self) -> bool {\n        self.bits & 0b00000001 != 0\n    }\n\n    #[verifier::inline]\n    pub open spec fn empty_spec() -> Self {\n        Self { bits: 0 }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(empty_spec)]\n    pub const fn empty() -> (res: Self)\n        ensures\n            res == Self::empty_spec(),\n    {\n        Self { bits: 0 }\n    }\n\n    #[verifier::inline]\n    pub open spec fn value_spec(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(value_spec)]\n    pub const fn value(&self) -> (res: u8)\n        ensures\n            res == self.value_spec(),\n    {\n        self.bits\n    }\n\n    #[verifier::inline]\n    pub open spec fn from_bits_spec(value: u8) -> Self {\n        Self { bits: value }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(from_bits_spec)]\n    pub fn from_bits(value: u8) -> (res: Self)\n        ensures\n            res == Self::from_bits_spec(value),\n            res.bits == value,\n    {\n        Self { bits: value }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn R_spec() -> Self {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(R_spec)]\n    pub const fn R() -> (res: Self)\n        ensures\n            res == Self::R_spec(),\n    {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn W_spec() -> Self {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(W_spec)]\n    pub const fn W() -> (res: Self)\n        ensures\n            res == Self::W_spec(),\n    {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn X_spec() -> Self {\n        Self { bits: 0b00000100 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(X_spec)]\n    pub const fn X() -> (res: Self)\n        ensures\n            res == Self::X_spec(),\n    {\n        Self { bits: 0b00000100 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn RW_spec() -> Self {\n        Self { bits: Self::R().value() | Self::W().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(X_spec)]\n    pub const fn RW() -> (res: Self)\n        ensures\n            res == Self::RW_spec(),\n    {\n        Self { bits: Self::R().value() | Self::W().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn RX_spec() -> Self {\n        Self { bits: Self::R().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(RX_spec)]\n    pub const fn RX() -> (res: Self)\n        ensures\n            res == Self::RX_spec(),\n    {\n        Self { bits: Self::R().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn RWX_spec() -> Self {\n        Self { bits: Self::R().value() | Self::W().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(RWX_spec)]\n    pub const fn RWX() -> (res: Self)\n        ensures\n            res == Self::RWX_spec(),\n    {\n        Self { bits: Self::R().value() | Self::W().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn ACCESSED_spec() -> Self {\n        Self { bits: 0b00001000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(ACCESSED_spec)]\n    pub const fn ACCESSED() -> (res: Self)\n        ensures\n            res == Self::ACCESSED_spec(),\n    {\n        Self { bits: 0b00001000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn DIRTY_spec() -> Self {\n        Self { bits: 0b00010000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(DIRTY_spec)]\n    pub const fn DIRTY() -> (res: Self)\n        ensures\n            res == Self::DIRTY_spec(),\n    {\n        Self { bits: 0b00010000 }\n    }\n}\n\n} // verus!\nverus! {\n\n#[verifier::ext_equal]\n#[repr(transparent)]\n#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\npub struct PrivilegedPageFlags {\n    pub bits: u8,\n}\n\npub broadcast proof fn lemma_privileged_page_flags_equal_correctness(\n    a: PrivilegedPageFlags,\n    b: PrivilegedPageFlags,\n)\n    requires\n        #[trigger] a.bits == #[trigger] b.bits,\n    ensures\n        a == b,\n{\n}\n\npub broadcast proof fn lemma_privileged_page_flags_equal_soundness(\n    a: PrivilegedPageFlags,\n    b: PrivilegedPageFlags,\n)\n    requires\n        a == b,\n    ensures\n        #[trigger] a.bits == #[trigger] b.bits,\n{\n}\n\nimpl PrivilegedPageFlags {\n    #[verifier::inline]\n    pub open spec fn empty_spec() -> Self {\n        Self { bits: 0 }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(empty_spec)]\n    pub const fn empty() -> (res: Self)\n        ensures\n            res == Self::empty_spec(),\n    {\n        Self { bits: 0 }\n    }\n\n    #[verifier::inline]\n    pub open spec fn value_spec(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(value_spec)]\n    pub const fn value(&self) -> (res: u8)\n        ensures\n            res == self.value_spec(),\n    {\n        self.bits\n    }\n\n    #[verifier::inline]\n    pub open spec fn from_bits_spec(value: u8) -> Self {\n        Self { bits: value }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(from_bits_spec)]\n    pub fn from_bits(value: u8) -> (res: Self)\n        ensures\n            res == Self::from_bits_spec(value),\n    {\n        Self { bits: value }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn USER_spec() -> Self {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(USER_spec)]\n    pub const fn USER() -> (res: Self)\n        ensures\n            res == Self::USER_spec(),\n    {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn GLOBAL_spec() -> Self {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(GLOBAL_spec)]\n    pub const fn GLOBAL() -> (res: Self)\n        ensures\n            res == Self::GLOBAL_spec(),\n    {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn SHARED_spec() -> Self {\n        Self { bits: 0b10000000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(SHARED_spec)]\n    pub const fn SHARED() -> (res: Self)\n        ensures\n            res == Self::SHARED_spec(),\n    {\n        Self { bits: 0b10000000 }\n    }\n}\n\n} // verus!\n", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\n#[verifier::ext_equal]\n#[derive(Clone, Copy, PartialEq, Eq)]\npub struct PageProperty {\n    /// The flags associated with the page,\n    pub flags: PageFlags,\n    /// The cache policy for the page.\n    pub cache: CachePolicy,\n    pub priv_flags: PrivilegedPageFlags,\n}\n\nglobal layout PageProperty is size == 3, align == 1;\n\n} // verus!\nverus! {\n\npub broadcast proof fn lemma_page_property_equal_correctness(a: PageProperty, b: PageProperty)\n    requires\n        #[trigger] a.flags == #[trigger] b.flags,\n        a.cache == b.cache,\n        a.priv_flags == b.priv_flags,\n    ensures\n        a == b,\n{\n}\n\npub broadcast proof fn lemma_page_property_equal_soundness(a: PageProperty, b: PageProperty)\n    requires\n        a == b,\n    ensures\n        #[trigger] a.flags == #[trigger] b.flags,\n        a.cache == b.cache,\n        a.priv_flags == b.priv_flags,\n{\n}\n\n} // verus!\nverus! {\n\nimpl PageProperty {\n    pub open spec fn new_user_spec(flags: PageFlags, cache: CachePolicy) -> Self {\n        Self { flags, cache, priv_flags: PrivilegedPageFlags::USER() }\n    }\n\n    #[verifier::when_used_as_spec(new_user_spec)]\n    pub fn new_user(flags: PageFlags, cache: CachePolicy) -> (res: Self)\n        ensures\n            res == Self::new_user_spec(flags, cache),\n    {\n        Self { flags, cache, priv_flags: PrivilegedPageFlags::USER() }\n    }\n\n    pub open spec fn new_absent_spec() -> Self {\n        Self {\n            flags: PageFlags::empty(),\n            cache: CachePolicy::Writeback,\n            priv_flags: PrivilegedPageFlags::empty(),\n        }\n    }\n\n    #[verifier::when_used_as_spec(new_absent_spec)]\n    pub fn new_absent() -> (res: Self)\n        ensures\n            res == Self::new_absent_spec(),\n    {\n        Self {\n            flags: PageFlags::empty(),\n            cache: CachePolicy::Writeback,\n            priv_flags: PrivilegedPageFlags::empty(),\n        }\n    }\n}\n\n} // verus!\nverus! {\n\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n#[repr(u8)]\npub enum CachePolicy {\n    Uncacheable,\n    WriteCombining,\n    WriteProtected,\n    Writethrough,\n    Writeback,\n}\n\n#[allow(non_snake_case)]\nimpl CachePolicy {\n    #[verifier::inline]\n    pub open spec fn N_spec() -> usize {\n        (CachePolicy::Writeback.value() + 1) as usize\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(N_spec)]\n    pub const fn N() -> (res: usize)\n        ensures\n            res == Self::N_spec(),\n    {\n        (CachePolicy::Writeback.value() + 1) as usize\n    }\n\n    #[verifier::inline]\n    pub open spec fn value_spec(&self) -> u8 {\n        match self {\n            CachePolicy::Uncacheable => 0,\n            CachePolicy::WriteCombining => 1,\n            CachePolicy::WriteProtected => 2,\n            CachePolicy::Writethrough => 3,\n            CachePolicy::Writeback => 4,\n        }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(value_spec)]\n    pub const fn value(&self) -> (res: u8)\n        ensures\n            res == self.value(),\n    {\n        match self {\n            CachePolicy::Uncacheable => 0,\n            CachePolicy::WriteCombining => 1,\n            CachePolicy::WriteProtected => 2,\n            CachePolicy::Writethrough => 3,\n            CachePolicy::Writeback => 4,\n        }\n    }\n}\n\n} // verus!\nverus! {\n\n#[verifier::ext_equal]\n#[repr(transparent)]\n#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\npub struct PageFlags {\n    pub bits: u8,\n}\n\npub broadcast proof fn lemma_page_flags_equal_correctness(a: PageFlags, b: PageFlags)\n    requires\n        #[trigger] a.bits == #[trigger] b.bits,\n    ensures\n        a == b,\n{\n}\n\npub broadcast proof fn lemma_page_flags_equal_soundness(a: PageFlags, b: PageFlags)\n    requires\n        a == b,\n    ensures\n        #[trigger] a.bits == #[trigger] b.bits,\n{\n}\n\nimpl PageFlags {\n    pub open spec fn present(self) -> bool {\n        self.bits & 0b00000001 != 0\n    }\n\n    #[verifier::inline]\n    pub open spec fn empty_spec() -> Self {\n        Self { bits: 0 }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(empty_spec)]\n    pub const fn empty() -> (res: Self)\n        ensures\n            res == Self::empty_spec(),\n    {\n        Self { bits: 0 }\n    }\n\n    #[verifier::inline]\n    pub open spec fn value_spec(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(value_spec)]\n    pub const fn value(&self) -> (res: u8)\n        ensures\n            res == self.value_spec(),\n    {\n        self.bits\n    }\n\n    #[verifier::inline]\n    pub open spec fn from_bits_spec(value: u8) -> Self {\n        Self { bits: value }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(from_bits_spec)]\n    pub fn from_bits(value: u8) -> (res: Self)\n        ensures\n            res == Self::from_bits_spec(value),\n            res.bits == value,\n    {\n        Self { bits: value }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn R_spec() -> Self {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(R_spec)]\n    pub const fn R() -> (res: Self)\n        ensures\n            res == Self::R_spec(),\n    {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn W_spec() -> Self {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(W_spec)]\n    pub const fn W() -> (res: Self)\n        ensures\n            res == Self::W_spec(),\n    {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn X_spec() -> Self {\n        Self { bits: 0b00000100 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(X_spec)]\n    pub const fn X() -> (res: Self)\n        ensures\n            res == Self::X_spec(),\n    {\n        Self { bits: 0b00000100 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn RW_spec() -> Self {\n        Self { bits: Self::R().value() | Self::W().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(X_spec)]\n    pub const fn RW() -> (res: Self)\n        ensures\n            res == Self::RW_spec(),\n    {\n        Self { bits: Self::R().value() | Self::W().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn RX_spec() -> Self {\n        Self { bits: Self::R().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(RX_spec)]\n    pub const fn RX() -> (res: Self)\n        ensures\n            res == Self::RX_spec(),\n    {\n        Self { bits: Self::R().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn RWX_spec() -> Self {\n        Self { bits: Self::R().value() | Self::W().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(RWX_spec)]\n    pub const fn RWX() -> (res: Self)\n        ensures\n            res == Self::RWX_spec(),\n    {\n        Self { bits: Self::R().value() | Self::W().value() | Self::X().value() }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn ACCESSED_spec() -> Self {\n        Self { bits: 0b00001000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(ACCESSED_spec)]\n    pub const fn ACCESSED() -> (res: Self)\n        ensures\n            res == Self::ACCESSED_spec(),\n    {\n        Self { bits: 0b00001000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn DIRTY_spec() -> Self {\n        Self { bits: 0b00010000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(DIRTY_spec)]\n    pub const fn DIRTY() -> (res: Self)\n        ensures\n            res == Self::DIRTY_spec(),\n    {\n        Self { bits: 0b00010000 }\n    }\n}\n\n} // verus!\nverus! {\n\n#[verifier::ext_equal]\n#[repr(transparent)]\n#[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\npub struct PrivilegedPageFlags {\n    pub bits: u8,\n}\n\npub broadcast proof fn lemma_privileged_page_flags_equal_correctness(\n    a: PrivilegedPageFlags,\n    b: PrivilegedPageFlags,\n)\n    requires\n        #[trigger] a.bits == #[trigger] b.bits,\n    ensures\n        a == b,\n{\n}\n\npub broadcast proof fn lemma_privileged_page_flags_equal_soundness(\n    a: PrivilegedPageFlags,\n    b: PrivilegedPageFlags,\n)\n    requires\n        a == b,\n    ensures\n        #[trigger] a.bits == #[trigger] b.bits,\n{\n}\n\nimpl PrivilegedPageFlags {\n    #[verifier::inline]\n    pub open spec fn empty_spec() -> Self {\n        Self { bits: 0 }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(empty_spec)]\n    pub const fn empty() -> (res: Self)\n        ensures\n            res == Self::empty_spec(),\n    {\n        Self { bits: 0 }\n    }\n\n    #[verifier::inline]\n    pub open spec fn value_spec(&self) -> u8 {\n        self.bits\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(value_spec)]\n    pub const fn value(&self) -> (res: u8)\n        ensures\n            res == self.value_spec(),\n    {\n        self.bits\n    }\n\n    #[verifier::inline]\n    pub open spec fn from_bits_spec(value: u8) -> Self {\n        Self { bits: value }\n    }\n\n    #[inline(always)]\n    #[verifier::when_used_as_spec(from_bits_spec)]\n    pub fn from_bits(value: u8) -> (res: Self)\n        ensures\n            res == Self::from_bits_spec(value),\n    {\n        Self { bits: value }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn USER_spec() -> Self {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(USER_spec)]\n    pub const fn USER() -> (res: Self)\n        ensures\n            res == Self::USER_spec(),\n    {\n        Self { bits: 0b00000001 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn GLOBAL_spec() -> Self {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(GLOBAL_spec)]\n    pub const fn GLOBAL() -> (res: Self)\n        ensures\n            res == Self::GLOBAL_spec(),\n    {\n        Self { bits: 0b00000010 }\n    }\n\n    #[allow(non_snake_case)]\n    #[verifier::inline]\n    pub open spec fn SHARED_spec() -> Self {\n        Self { bits: 0b10000000 }\n    }\n\n    #[allow(non_snake_case)]\n    #[inline(always)]\n    #[verifier::when_used_as_spec(SHARED_spec)]\n    pub const fn SHARED() -> (res: Self)\n        ensures\n            res == Self::SHARED_spec(),\n    {\n        Self { bits: 0b10000000 }\n    }\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/aster_common/src/page_prop.rs", "verified": true, "metadata": {"original_id": "vostd_page_prop_470fb761b33a", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_b_7bc3232cdb17", "task": "task_b", "input_text": "fn max_difference (arr : & Vec < i32 >) -> (diff : i32)\nrequires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 \nensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut min_val = arr [0] ; let mut max_val = arr [0] ; let mut k = 1 ; while k < arr . len () invariant 1 <= k <= arr . len () , forall | i : int | 0 <= i < k ==> min_val <= arr [i] , forall | i : int | 0 <= i < k ==> arr [i] <= max_val , exists | i : int | 0 <= i < k && arr [i] == min_val , exists | i : int | 0 <= i < k && arr [i] == max_val , decreases arr . len () - k { if arr [k] < min_val { min_val = arr [k] ; } if arr [k] > max_val { max_val = arr [k] ; } k += 1 ; } proof { assert (forall | i : int | 0 <= i < arr . len () ==> min_val <= arr [i]) ; assert (forall | i : int | 0 <= i < arr . len () ==> arr [i] <= max_val) ; assert (forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= max_val - min_val) ; } max_val - min_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_difference (arr : & Vec < i32 >) -> (diff : i32) requires arr . len () > 0 , forall | i : int | 0 <= i < arr . len () ==> MIN / 2 < # [trigger] arr [i] < MAX / 2 , ensures forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= diff , { let mut min_val = arr [0] ; let mut max_val = arr [0] ; let mut k = 1 ; while k < arr . len () invariant 1 <= k <= arr . len () , forall | i : int | 0 <= i < k ==> min_val <= arr [i] , forall | i : int | 0 <= i < k ==> arr [i] <= max_val , exists | i : int | 0 <= i < k && arr [i] == min_val , exists | i : int | 0 <= i < k && arr [i] == max_val , decreases arr . len () - k { if arr [k] < min_val { min_val = arr [k] ; } if arr [k] > max_val { max_val = arr [k] ; } k += 1 ; } proof { assert (forall | i : int | 0 <= i < arr . len () ==> min_val <= arr [i]) ; assert (forall | i : int | 0 <= i < arr . len () ==> arr [i] <= max_val) ; assert (forall | i : int , j : int | 0 <= i < arr . len () && 0 <= j < arr . len () ==> arr [i] - arr [j] <= max_val - min_val) ; } max_val - min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_145_impl.rs", "verified": true, "metadata": {"original_id": "7bc3232cdb17", "function_name": "max_difference", "has_invariants": true, "has_asserts": true}}
{"id": "task_c_missing_ensures_c8dd4b36aa98", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >)  { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i , { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i , { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn list_deep_clone (arr : & Vec < u64 >) -> (copied : Vec < u64 >) ensures arr @ . len () == copied @ . len () , forall | i : int | (0 <= i < arr . len ()) ==> arr [i] == copied [i] , { let mut copied = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant i <= arr . len () , copied @ . len () == i , forall | j : int | (0 <= j < i) ==> arr [j] == copied [j] , decreases arr . len () - i , { copied . push (arr [i]) ; i += 1 ; } copied }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_307_impl.rs", "verified": true, "metadata": {"original_id": "c8dd4b36aa98", "function_name": "list_deep_clone", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_4952c72576de", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_240_impl.rs", "verified": true, "metadata": {"original_id": "4952c72576de", "function_name": "replace_last_element", "bug_type": "missing_decreases"}}
{"id": "task_b_314de6cfc900", "task": "task_b", "input_text": "fn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >)\nrequires swap_precond (arr @ , i , j) \nensures swap_postcond (arr @ , i , j , result @) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >) requires swap_precond (arr @ , i , j) , ensures swap_postcond (arr @ , i , j , result @) , { let mut result = arr ; let temp_i = result [i as usize] ; let temp_j = result [j as usize] ; result . set (i as usize , temp_j) ; result . set (j as usize , temp_i) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn swap_precond (arr : Seq < i32 > , i : i32 , j : i32) -> bool { i >= 0 && j >= 0 && (i as nat) < arr . len () && (j as nat) < arr . len () }\nspec fn swap_postcond (arr : Seq < i32 > , i : i32 , j : i32 , result : Seq < i32 >) -> bool { result [i as int] == arr [j as int] && result [j as int] == arr [i as int] && result . len () == arr . len () && forall | k : int | 0 <= k < arr . len () && k != i && k != j ==> result [k] == arr [k] }\nfn swap (arr : Vec < i32 > , i : i32 , j : i32) -> (result : Vec < i32 >) requires swap_precond (arr @ , i , j) , ensures swap_postcond (arr @ , i , j , result @) , { let mut result = arr ; let temp_i = result [i as usize] ; let temp_j = result [j as usize] ; result . set (i as usize , temp_j) ; result . set (j as usize , temp_i) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_95/verina_basic_95_iter_2_current.rs", "verified": true, "metadata": {"original_id": "314de6cfc900", "function_name": "swap", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_8361c88285f7", "task": "task_b", "input_text": "fn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >)\nensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; for i in 0 .. numbers . len () invariant result . len () == 2 * i - (if i == 0 { 0int } else { 1int }) , forall | j : int | 0 <= j && j < result . len () && j % 2 == 0 ==> result [j] == numbers [j / 2] , forall | j : int | 0 <= j && j < result . len () && j % 2 == 1 ==> result [j] == delim { if i > 0 { result . push (delim) ; } result . push (numbers [i]) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; for i in 0 .. numbers . len () invariant result . len () == 2 * i - (if i == 0 { 0int } else { 1int }) , forall | j : int | 0 <= j && j < result . len () && j % 2 == 0 ==> result [j] == numbers [j / 2] , forall | j : int | 0 <= j && j < result . len () && j % 2 == 1 ==> result [j] == delim { if i > 0 { result . push (delim) ; } result . push (numbers [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/intersperse_impl.rs", "verified": true, "metadata": {"original_id": "8361c88285f7", "function_name": "intersperse", "has_invariants": true, "has_asserts": false}}
{"id": "task_a_fea20d875003", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize)   { let mut i = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; }  0 }\n\n} // verus!", "target_text": "requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e \nensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e \ndecreases a . len () - i \ninvariant i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e , decreases a . len () - i , { if a [i] == e { return i ; } i += 1 ; } assert (false) ; 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/unverified/linear_search2_impl.rs", "verified": true, "metadata": {"original_id": "fea20d875003", "function_name": "linear_search", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_decreases_b97b454af90a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (# [trigger] str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn to_toggle_case_spec (s : u8) -> u8 { if is_lower_case (s) { shift_minus_32_spec (s) } else if is_upper_case (s) { shift32_spec (s) } else { s } }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift_minus_32_spec (c : u8) -> u8 { (c - 32) as u8 }\nspec fn is_lower_case (c : u8) -> bool { c >= 97 && c <= 122 }\nfn to_toggle_case (str1 : & [u8]) -> (toggle_case : Vec < u8 >) ensures str1 @ . len () == toggle_case @ . len () , forall | i : int | 0 <= i < str1 . len () ==> toggle_case [i] == to_toggle_case_spec (# [trigger] str1 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == to_toggle_case_spec (# [trigger] str1 [i]) , decreases str1 . len () - idx , { let c = str1 [idx] ; let toggled = if c >= 97 && c <= 122 { c - 32 } else if c >= 65 && c <= 90 { c + 32 } else { c } ; result . push (toggled) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_557_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b97b454af90a", "function_name": "to_toggle_case", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_decreases_a53ae1316ec6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (text [j]) , { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (text [j]) , decreases text . len () - i , { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> is_digit_spec (text [j]) , decreases text . len () - i , { if ! is_digit (text [i]) { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_113_impl.rs", "verified": true, "metadata": {"original_id": "a53ae1316ec6", "function_name": "is_integer", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_1639d516bb20", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn prime (n : nat) -> bool { n > 1 && (forall | nr : nat | 1 < nr < n ==> # [trigger] (n % nr) != 0) }\nfn test_primeness (n : u64) -> (result : bool)  { if n <= 1 { assert (! prime (n as nat)) ; return false ; } let mut i = 2u64 ; while i < n invariant 2 <= i <= n , n > 1 , forall | nr : nat | 2 <= nr < i ==> # [trigger] ((n as nat) % nr) != 0 , decreases n - i { if n % i == 0 { assert (1 < (i as nat) < (n as nat)) ; assert ((n as nat) % (i as nat) == 0) ; assert (! prime (n as nat)) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | nr : nat | 2 <= nr < (n as nat) ==> # [trigger] ((n as nat) % nr) != 0) ; assert (forall | nr : nat | 1 < nr < (n as nat) ==> # [trigger] ((n as nat) % nr) != 0) ; assert (prime (n as nat)) ; return true ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn prime (n : nat) -> bool { n > 1 && (forall | nr : nat | 1 < nr < n ==> # [trigger] (n % nr) != 0) }\nfn test_primeness (n : u64) -> (result : bool) ensures result == prime (n as nat) { if n <= 1 { assert (! prime (n as nat)) ; return false ; } let mut i = 2u64 ; while i < n invariant 2 <= i <= n , n > 1 , forall | nr : nat | 2 <= nr < i ==> # [trigger] ((n as nat) % nr) != 0 , decreases n - i { if n % i == 0 { assert (1 < (i as nat) < (n as nat)) ; assert ((n as nat) % (i as nat) == 0) ; assert (! prime (n as nat)) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | nr : nat | 2 <= nr < (n as nat) ==> # [trigger] ((n as nat) % nr) != 0) ; assert (forall | nr : nat | 1 < nr < (n as nat) ==> # [trigger] ((n as nat) % nr) != 0) ; assert (prime (n as nat)) ; return true ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn prime (n : nat) -> bool { n > 1 && (forall | nr : nat | 1 < nr < n ==> # [trigger] (n % nr) != 0) }\nfn test_primeness (n : u64) -> (result : bool) ensures result == prime (n as nat) { if n <= 1 { assert (! prime (n as nat)) ; return false ; } let mut i = 2u64 ; while i < n invariant 2 <= i <= n , n > 1 , forall | nr : nat | 2 <= nr < i ==> # [trigger] ((n as nat) % nr) != 0 , decreases n - i { if n % i == 0 { assert (1 < (i as nat) < (n as nat)) ; assert ((n as nat) % (i as nat) == 0) ; assert (! prime (n as nat)) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | nr : nat | 2 <= nr < (n as nat) ==> # [trigger] ((n as nat) % nr) != 0) ; assert (forall | nr : nat | 1 < nr < (n as nat) ==> # [trigger] ((n as nat) % nr) != 0) ; assert (prime (n as nat)) ; return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/DafnyPrograms_tmp_tmp74_f9k_c_prime-database/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "1639d516bb20", "function_name": "test_primeness", "bug_type": "missing_ensures"}}
{"id": "task_b_960dc809f6e3", "task": "task_b", "input_text": "fn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)\nensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& shared , element) { shared . push (element) ; } } shared }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let element = list1 [i] ; if contains (list2 , element) && ! contains (& shared , element) { shared . push (element) ; } } shared }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_2_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "960dc809f6e3", "function_name": "shared_elements", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_aa21f257d2de", "task": "task_b", "input_text": "fn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)\nensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& shared , elem) { shared . push (elem) ; } } shared }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& shared , elem) { shared . push (elem) ; } } shared }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_2_iter_1_current.rs", "verified": true, "metadata": {"original_id": "aa21f257d2de", "function_name": "shared_elements", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_ensures_d885bab00260", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) decreases n , { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 ,  { let result = ((a as u64) * (b as u64)) % (p as u64) ; result as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith) requires p > 0 ,  { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n invariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) , decreases n - i , { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) decreases n , { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let result = ((a as u64) * (b as u64)) % (p as u64) ; result as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith) requires p > 0 , ensures r == modp_rec (n as nat , p as nat) , { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n invariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) , decreases n - i , { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) decreases n , { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let result = ((a as u64) * (b as u64)) % (p as u64) ; result as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith) requires p > 0 , ensures r == modp_rec (n as nat , p as nat) , { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n invariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) , decreases n - i , { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/049-modp_impl.rs", "verified": true, "metadata": {"original_id": "d885bab00260", "function_name": "modp", "bug_type": "missing_ensures"}}
{"id": "task_a_a356d66f5b81", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize)   { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len ()  { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "requires a . len () > 0 \nensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] \ndecreases a . len () - i \ninvariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/max_dafny_lsp_impl.rs", "verified": true, "metadata": {"original_id": "a356d66f5b81", "function_name": "max_dafny_lsp", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_decreases_d6570104686d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut res = Vec :: new () ; let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , i == 0 ==> res . len () == 0 , i > 0 ==> res . len () == 2 * i - 1 , forall | j : int | 0 <= j < res . len () && j % 2 == 0 ==> res [j] == numbers [j / 2] , forall | j : int | 0 <= j < res . len () && j % 2 == 1 ==> res [j] == delim { if i > 0 { res . push (delim) ; } res . push (numbers [i]) ; i += 1 ; } res }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut res = Vec :: new () ; let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , i == 0 ==> res . len () == 0 , i > 0 ==> res . len () == 2 * i - 1 , forall | j : int | 0 <= j < res . len () && j % 2 == 0 ==> res [j] == numbers [j / 2] , forall | j : int | 0 <= j < res . len () && j % 2 == 1 ==> res [j] == delim decreases numbers . len () - i { if i > 0 { res . push (delim) ; } res . push (numbers [i]) ; i += 1 ; } res }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn intersperse (numbers : & [i32] , delim : i32) -> (res : Vec < i32 >) ensures numbers . len () == 0 ==> res . len () == 0 , numbers . len () != 0 ==> res . len () == 2 * numbers . len () - 1 , forall | i : int | 0 <= i && i < res . len () && i % 2 == 0 ==> res [i] == numbers [i / 2] , forall | i : int | 0 <= i && i < res . len () && i % 2 == 1 ==> res [i] == delim { if numbers . len () == 0 { return Vec :: new () ; } let mut res = Vec :: new () ; let mut i = 0 ; while i < numbers . len () invariant 0 <= i <= numbers . len () , i == 0 ==> res . len () == 0 , i > 0 ==> res . len () == 2 * i - 1 , forall | j : int | 0 <= j < res . len () && j % 2 == 0 ==> res [j] == numbers [j / 2] , forall | j : int | 0 <= j < res . len () && j % 2 == 1 ==> res [j] == delim decreases numbers . len () - i { if i > 0 { res . push (delim) ; } res . push (numbers [i]) ; i += 1 ; } res }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/intersperse_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d6570104686d", "function_name": "intersperse", "bug_type": "missing_decreases"}}
{"id": "task_b_ad0a463794bb", "task": "task_b", "input_text": "fn min (a : & [i32]) -> (res : i32)\nrequires a . len () > 0 \nensures exists | i : int | 0 <= i < a . len () && res == a [i] && forall | j : int | 0 <= j < a . len () ==> res <= a [j] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn min (a : & [i32]) -> (res : i32) requires a . len () > 0 , ensures exists | i : int | 0 <= i < a . len () && res == a [i] && forall | j : int | 0 <= j < a . len () ==> res <= a [j] , { let mut min_val = a [0] ; for i in 1 .. a . len () { if a [i] < min_val { min_val = a [i] ; } } min_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: external_body] fn min (a : & [i32]) -> (res : i32) requires a . len () > 0 , ensures exists | i : int | 0 <= i < a . len () && res == a [i] && forall | j : int | 0 <= j < a . len () ==> res <= a [j] , { let mut min_val = a [0] ; for i in 1 .. a . len () { if a [i] < min_val { min_val = a [i] ; } } min_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/vericoding_dafny_to_verus_specs/numpy_specs/np_min_iter_2_current.rs", "verified": true, "metadata": {"original_id": "ad0a463794bb", "function_name": "min", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_34bfca31cda2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32)  { 0 }\n\n} // verus!", "target_text": "ensures result < 10", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/arithmetic_weird_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "34bfca31cda2", "function_name": "arithmetic_weird", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_f98f564c27cc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32)   { return 0 ; }\n\n} // verus!", "target_text": "requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 \nensures k_out >= 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_k (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k >= n + 1 , k >= 0 , n <= 1000000 , k <= 1000000 , ensures k_out >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_15/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f98f564c27cc", "function_name": "compute_k", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_decreases_352fd7cf6f7e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop invariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop invariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases high - low { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (v : & Vec < u64 > , k : u64) -> (r : usize) requires forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , exists | i : int | 0 <= i < v . len () && k == v [i] , ensures r < v . len () , k == v [r as int] , { let mut low : usize = 0 ; let mut high : usize = v . len () - 1 ; loop invariant low <= high , high < v . len () , exists | i : int | low <= i <= high && k == v [i] , forall | i : int , j : int | 0 <= i <= j < v . len () ==> v [i] <= v [j] , decreases high - low { let mid = low + (high - low) / 2 ; if v [mid] == k { return mid ; } else if v [mid] < k { low = mid + 1 ; } else { high = mid - 1 ; } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/binary_search_iter_2_current.rs", "verified": true, "metadata": {"original_id": "352fd7cf6f7e", "function_name": "binary_search", "bug_type": "missing_decreases"}}
{"id": "task_b_c04ba5c8f4b4", "task": "task_b", "input_text": "fn max_array (nums : & [i32]) -> (idx : usize)\nrequires nums . len () >= 1 \nensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < nums . len () invariant 0 <= max_idx < nums . len () , 1 <= i <= nums . len () , forall | j : int | 0 <= j < i ==> nums [j] <= nums [max_idx as int] , decreases nums . len () - i , { if nums [i] > nums [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max_array (nums : & [i32]) -> (idx : usize) requires nums . len () >= 1 , ensures 0 <= idx && idx < nums . len () , forall | i : int | 0 <= i && i < nums . len () ==> nums [i] <= nums [idx as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < nums . len () invariant 0 <= max_idx < nums . len () , 1 <= i <= nums . len () , forall | j : int | 0 <= j < i ==> nums [j] <= nums [max_idx as int] , decreases nums . len () - i , { if nums [i] > nums [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/max_array_iter_2_current.rs", "verified": true, "metadata": {"original_id": "c04ba5c8f4b4", "function_name": "max_array", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_requires_c35438a2b9a6", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32)  ensures result >= 0 , result == x || result == - x , { if x >= 0 { x } else { - x } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x >= 0 { x } else { - x } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x >= 0 { x } else { - x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/abs_iter_1_current.rs", "verified": true, "metadata": {"original_id": "c35438a2b9a6", "function_name": "abs", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_8b9a3246ecde", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32)  ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn find_min_loop (a : & Vec < i32 > , i : usize , current_min : i32) -> (result : i32) requires a . len () > 0 , i <= a . len () , exists | j : int | 0 <= j < a . len () && current_min == a [j as int] , forall | j : int | 0 <= j < i ==> current_min <= a [j as int] , ensures exists | k : int | 0 <= k < a . len () && result == a [k as int] , forall | j : int | 0 <= j < a . len () ==> result <= a [j as int] , decreases a . len () - i , { if i == a . len () { current_min } else { let new_min = if a [i] < current_min { a [i] } else { current_min } ; find_min_loop (a , i + 1 , new_min) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_75/verina_basic_75_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8b9a3246ecde", "function_name": "find_min_loop", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_478115b3906a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >)  ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= pos < a . len () , result . len () == if i <= pos { i as int } else { i as int - 1 } , forall | j : int | 0 <= j < pos && j < i ==> result [j] == a [j] , forall | j : int | pos < j < i ==> result [j - 1] == a [j] , decreases a . len () - i { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= pos < a . len () , result . len () == if i <= pos { i as int } else { i as int - 1 } , forall | j : int | 0 <= j < pos && j < i ==> result [j] == a [j] , forall | j : int | pos < j < i ==> result [j - 1] == a [j] , decreases a . len () - i { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , 0 <= pos < a . len () , result . len () == if i <= pos { i as int } else { i as int - 1 } , forall | j : int | 0 <= j < pos && j < i ==> result [j] == a [j] , forall | j : int | pos < j < i ==> result [j - 1] == a [j] , decreases a . len () - i { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/remove_element_impl.rs", "verified": true, "metadata": {"original_id": "478115b3906a", "function_name": "remove_element", "bug_type": "missing_requires"}}
{"id": "task_a_2c35719f4dbe", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == k { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != k ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "2c35719f4dbe", "function_name": "contains_k", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_b_4f29741cb0fd", "task": "task_b", "input_text": "pub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)\nrequires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 3 \nensures sum [0] == 3 * N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 3 , ensures sum [0] == 3 * N , { let result = 3 * N ; sum . set (0 , result) ; assert (sum [0] == result) ; assert (result == 3 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N <= MAX / 3 , ensures sum [0] == 3 * N , { let result = 3 * N ; sum . set (0 , result) ; assert (sum [0] == result) ; assert (result == 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/s3if_impl.rs", "verified": true, "metadata": {"original_id": "4f29741cb0fd", "function_name": "myfun", "has_invariants": false, "has_asserts": true}}
{"id": "task_a_verified-storage_crashinv_t_4ec59bc784c9", "task": "task_a", "input_text": "#![cfg_attr(verus_keep_ghost, verus::trusted)]\nuse vstd::prelude::*;\nuse vstd::invariant::*;\n\nuse std::sync::Arc;\n\nverus! {\n    // hold_until_crash() represents the notion that an atomic\n    {\n        unimplemented!()\n    }\n\n    pub struct InvariantRecoverer<Pred, State>\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        ghost pred: Pred,\n        ghost namespace: int,\n        ghost _state: core::marker::PhantomData<State>,\n    }\n\n    impl<Pred, State> InvariantRecoverer<Pred, State>\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        pub uninterp spec fn held_before_crash(self) -> bool;\n\n        pub closed spec fn pred(self) -> Pred { self.pred }\n        pub closed spec fn namespace(self) -> int { self.namespace }\n\n        pub proof fn new(pred: Pred, namespace: int) -> (tracked result: Self)\n\n        {\n            Self{\n                pred: pred,\n                namespace: namespace,\n                _state: core::marker::PhantomData,\n            }\n        }\n\n        // This axiom is used in formalizing the assumption that some atomic\n        //\n        {\n            unimplemented!()\n        }\n    }\n}\n", "target_text": "requires self.held_before_crash() as a precondition, to\n        // ensure it doesn't get used accidentally, since it's not sound in\n        // general.  However, a caller that wants to make this assumption can\n        // allocate a tracked InvariantRecoverer using ::new, then assume()\n        // the held_before_crash() predicate, and finally call ::recover().\n        //\n        // The InvariantRecoverer is tracked to precisely capture that the\n        // caller gets to recover one invariant for every assume() of\n        // held_before_crash().\n        #[verifier::external_body]\n        pub proof fn get(tracked self) -> (tracked result: AtomicInvariant::<Pred, State, Pred>)\n            requires\n                self.held_before_crash()\nensures result.pred() == pred,\n                result.namespace() == namespace, result.constant() == self.pred(),\n                result.namespace() == self.namespace(), that the invariant cannot be destroyed,\n    // using inv.into_inner(), and therefore it will be sound after crash\n    // to assume InvariantRecoverer::held_before_crash() and thereby\n    // recover the invariant.\n    #[verifier::external_body]\n    pub proof fn hold_until_crash<Pred, State>(\n        tracked inv: Arc<AtomicInvariant<Pred, State, Pred>>\n    )\n        where\n            Pred: InvariantPredicate<Pred, State>\ninvariant // will keep holding until the system crashes.\n    //\n    // Effectively, keep_until_crash() simulates holding a reference on\n    // the Arc<>.  This ensures that the invariant cannot be destroyed,\n    // using inv.into_inner(), and therefore it will be sound after crash\n    // to assume InvariantRecoverer::held_before_crash() and thereby\n    // recover the invariant.\n    #[verifier::external_body]\n    pub proof fn hold_until_crash<Pred, State>(\n        tracked inv: Arc<AtomicInvariant<Pred, State, Pred>>\n    )\n        where\n            Pred: InvariantPredicate<Pred, State>, held before a crash (described by the invariant predicate\n        // and the invariant namespace), and can be assumed to still hold after\n        // the system has restarted after a crash.\n        //\n        // This axiom requires self.held_before_crash() as a precondition, to\n        // ensure it doesn't get used accidentally, since it's not sound in\n        // general.  However, a caller that wants to make this assumption can\n        // allocate a tracked InvariantRecoverer using ::new, then assume()\n        // the held_before_crash() predicate, and finally call ::recover().\n        //\n        // The InvariantRecoverer is tracked to precisely capture that the\n        // caller gets to recover one invariant for every assume() of\n        // held_before_crash().\n        #[verifier::external_body]\n        pub proof fn get(tracked self) -> (tracked result: AtomicInvariant::<Pred, State, Pred>)\n            requires\n                self.held_before_crash(),\n            ensures\n                result.constant() == self.pred(),\n                result.namespace() == self.namespace()", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verus::trusted)]\nuse vstd::prelude::*;\nuse vstd::invariant::*;\n\nuse std::sync::Arc;\n\nverus! {\n    // hold_until_crash() represents the notion that an atomic invariant\n    // will keep holding until the system crashes.\n    //\n    // Effectively, keep_until_crash() simulates holding a reference on\n    // the Arc<>.  This ensures that the invariant cannot be destroyed,\n    // using inv.into_inner(), and therefore it will be sound after crash\n    // to assume InvariantRecoverer::held_before_crash() and thereby\n    // recover the invariant.\n    #[verifier::external_body]\n    pub proof fn hold_until_crash<Pred, State>(\n        tracked inv: Arc<AtomicInvariant<Pred, State, Pred>>\n    )\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        unimplemented!()\n    }\n\n    pub struct InvariantRecoverer<Pred, State>\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        ghost pred: Pred,\n        ghost namespace: int,\n        ghost _state: core::marker::PhantomData<State>,\n    }\n\n    impl<Pred, State> InvariantRecoverer<Pred, State>\n        where\n            Pred: InvariantPredicate<Pred, State>\n    {\n        pub uninterp spec fn held_before_crash(self) -> bool;\n\n        pub closed spec fn pred(self) -> Pred { self.pred }\n        pub closed spec fn namespace(self) -> int { self.namespace }\n\n        pub proof fn new(pred: Pred, namespace: int) -> (tracked result: Self)\n            ensures\n                result.pred() == pred,\n                result.namespace() == namespace,\n        {\n            Self{\n                pred: pred,\n                namespace: namespace,\n                _state: core::marker::PhantomData,\n            }\n        }\n\n        // This axiom is used in formalizing the assumption that some atomic\n        // invariant held before a crash (described by the invariant predicate\n        // and the invariant namespace), and can be assumed to still hold after\n        // the system has restarted after a crash.\n        //\n        // This axiom requires self.held_before_crash() as a precondition, to\n        // ensure it doesn't get used accidentally, since it's not sound in\n        // general.  However, a caller that wants to make this assumption can\n        // allocate a tracked InvariantRecoverer using ::new, then assume()\n        // the held_before_crash() predicate, and finally call ::recover().\n        //\n        // The InvariantRecoverer is tracked to precisely capture that the\n        // caller gets to recover one invariant for every assume() of\n        // held_before_crash().\n        #[verifier::external_body]\n        pub proof fn get(tracked self) -> (tracked result: AtomicInvariant::<Pred, State, Pred>)\n            requires\n                self.held_before_crash(),\n            ensures\n                result.constant() == self.pred(),\n                result.namespace() == self.namespace(),\n        {\n            unimplemented!()\n        }\n    }\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verified-storage/capybaraKV/capybarakv/src/pmem/crashinv_t.rs", "verified": true, "metadata": {"original_id": "verified-storage_crashinv_t_4ec59bc784c9", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_c_missing_invariant_057da121d61c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0  { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , decreases j { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , decreases j { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/reverse_impl.rs", "verified": true, "metadata": {"original_id": "057da121d61c", "function_name": "reverse", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_verus_datatypes_d92f3245f800", "task": "task_c", "input_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: point\nstruct Point {\n    x: int,\n    y: int,\n}\n// ANCHOR_END: point\n\n// ANCHOR: point-impl\nimpl Point {\n    spec fn len2(&self) -> int {\n        self.x * self.x + self.y * self.y\n    }\n}\n\nfn rotate_90(p: Point) -> (o: Point)\n    ensures o.len2() == p.len2()\n{\n    let o = Point { x: -p.y, y: p.x };\n    assert((-p.y) * (-p.y) == p.y * p.y) by(nonlinear_arith);\n    o\n}\n// ANCHOR_END: point-impl\n\n// ANCHOR: beverage\nenum Beverage {\n    Coffee { creamers: nat, sugar: bool },\n    Soda { flavor: Syrup },\n    Water { ice: bool },\n}\n// ANCHOR_END: beverage\n\n// ANCHOR: syrup\nenum Syrup {\n    Cola,\n    RootBeer,\n    Orange,\n    LemonLime,\n}\n// ANCHOR_END: syrup\n\nstruct Dessert {}\nimpl Dessert {\n    fn new() -> Dessert {\n        Dessert {}\n    }\n}\n\n// ANCHOR: make_float\nfn make_float(bev: Beverage) -> Dessert\n\n{\n    assert(bev !is Coffee);\n    Dessert::new(/*...*/)\n}\n// ANCHOR_END: make_float\n\n// ANCHOR: count_creamers\nproof fn sufficiently_creamy(bev: Beverage) -> bool\n\n{\n   bev->creamers >= 2\n}\n// ANCHOR_END: count_creamers\n\n// ANCHOR: life\nenum Life {\n    Mammal { legs: int, has_pocket: bool },\n    Arthropod { legs: int, wings: int },\n    Plant { leaves: int },\n}\n\nspec fn is_insect(l: Life) -> bool\n{\n    l is Arthropod && l->Arthropod_legs == 6\n}\n// ANCHOR_END: life\n\n// ANCHOR: shape\nenum Shape {\n    Circle(int),\n    Rect(int, int),\n}\n\nspec fn area_2(s: Shape) -> int {\n    match s {\n        Shape::Circle(radius) => { radius * radius * 3 },\n        Shape::Rect(width, height) => { width * height }\n    }\n}\n// ANCHOR_END: shape\n\n// ANCHOR: rect_height\nspec fn rect_height(s: Shape) -> int\n    recommends s is Rect\n{\n    s->1\n}\n// ANCHOR_END: rect_height\n\n// ANCHOR: cuddly\nuse Life::*;\nspec fn cuddly(l: Life) -> bool {\n    ||| l matches Mammal { legs, .. } && legs == 4\n    ||| l matches Arthropod { legs, wings } && legs == 8 && wings == 0\n}\n// ANCHOR_END: cuddly\n\n// ANCHOR: kangaroo\nspec fn is_kangaroo(l: Life) -> bool {\n    &&& l matches Life::Mammal { legs, has_pocket }\n    &&& legs == 2\n    &&& has_pocket\n}\n\nspec fn walks_upright(l: Life) -> bool {\n    l matches Life::Mammal { legs, .. } ==> legs == 2\n}\n// ANCHOR_END: kangaroo\n\nfn main() {\n}\n\n} // verus!\n", "target_text": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: point\nstruct Point {\n    x: int,\n    y: int,\n}\n// ANCHOR_END: point\n\n// ANCHOR: point-impl\nimpl Point {\n    spec fn len2(&self) -> int {\n        self.x * self.x + self.y * self.y\n    }\n}\n\nfn rotate_90(p: Point) -> (o: Point)\n    ensures o.len2() == p.len2()\n{\n    let o = Point { x: -p.y, y: p.x };\n    assert((-p.y) * (-p.y) == p.y * p.y) by(nonlinear_arith);\n    o\n}\n// ANCHOR_END: point-impl\n\n// ANCHOR: beverage\nenum Beverage {\n    Coffee { creamers: nat, sugar: bool },\n    Soda { flavor: Syrup },\n    Water { ice: bool },\n}\n// ANCHOR_END: beverage\n\n// ANCHOR: syrup\nenum Syrup {\n    Cola,\n    RootBeer,\n    Orange,\n    LemonLime,\n}\n// ANCHOR_END: syrup\n\nstruct Dessert {}\nimpl Dessert {\n    fn new() -> Dessert {\n        Dessert {}\n    }\n}\n\n// ANCHOR: make_float\nfn make_float(bev: Beverage) -> Dessert\n    requires bev is Soda\n{\n    assert(bev !is Coffee);\n    Dessert::new(/*...*/)\n}\n// ANCHOR_END: make_float\n\n// ANCHOR: count_creamers\nproof fn sufficiently_creamy(bev: Beverage) -> bool\n    requires bev is Coffee\n{\n   bev->creamers >= 2\n}\n// ANCHOR_END: count_creamers\n\n// ANCHOR: life\nenum Life {\n    Mammal { legs: int, has_pocket: bool },\n    Arthropod { legs: int, wings: int },\n    Plant { leaves: int },\n}\n\nspec fn is_insect(l: Life) -> bool\n{\n    l is Arthropod && l->Arthropod_legs == 6\n}\n// ANCHOR_END: life\n\n// ANCHOR: shape\nenum Shape {\n    Circle(int),\n    Rect(int, int),\n}\n\nspec fn area_2(s: Shape) -> int {\n    match s {\n        Shape::Circle(radius) => { radius * radius * 3 },\n        Shape::Rect(width, height) => { width * height }\n    }\n}\n// ANCHOR_END: shape\n\n// ANCHOR: rect_height\nspec fn rect_height(s: Shape) -> int\n    recommends s is Rect\n{\n    s->1\n}\n// ANCHOR_END: rect_height\n\n// ANCHOR: cuddly\nuse Life::*;\nspec fn cuddly(l: Life) -> bool {\n    ||| l matches Mammal { legs, .. } && legs == 4\n    ||| l matches Arthropod { legs, wings } && legs == 8 && wings == 0\n}\n// ANCHOR_END: cuddly\n\n// ANCHOR: kangaroo\nspec fn is_kangaroo(l: Life) -> bool {\n    &&& l matches Life::Mammal { legs, has_pocket }\n    &&& legs == 2\n    &&& has_pocket\n}\n\nspec fn walks_upright(l: Life) -> bool {\n    l matches Life::Mammal { legs, .. } ==> legs == 2\n}\n// ANCHOR_END: kangaroo\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "#[allow(unused_imports)]\nuse verus_builtin::*;\n#[allow(unused_imports)]\nuse verus_builtin_macros::*;\n\nverus! {\n\n// ANCHOR: point\nstruct Point {\n    x: int,\n    y: int,\n}\n// ANCHOR_END: point\n\n// ANCHOR: point-impl\nimpl Point {\n    spec fn len2(&self) -> int {\n        self.x * self.x + self.y * self.y\n    }\n}\n\nfn rotate_90(p: Point) -> (o: Point)\n    ensures o.len2() == p.len2()\n{\n    let o = Point { x: -p.y, y: p.x };\n    assert((-p.y) * (-p.y) == p.y * p.y) by(nonlinear_arith);\n    o\n}\n// ANCHOR_END: point-impl\n\n// ANCHOR: beverage\nenum Beverage {\n    Coffee { creamers: nat, sugar: bool },\n    Soda { flavor: Syrup },\n    Water { ice: bool },\n}\n// ANCHOR_END: beverage\n\n// ANCHOR: syrup\nenum Syrup {\n    Cola,\n    RootBeer,\n    Orange,\n    LemonLime,\n}\n// ANCHOR_END: syrup\n\nstruct Dessert {}\nimpl Dessert {\n    fn new() -> Dessert {\n        Dessert {}\n    }\n}\n\n// ANCHOR: make_float\nfn make_float(bev: Beverage) -> Dessert\n    requires bev is Soda\n{\n    assert(bev !is Coffee);\n    Dessert::new(/*...*/)\n}\n// ANCHOR_END: make_float\n\n// ANCHOR: count_creamers\nproof fn sufficiently_creamy(bev: Beverage) -> bool\n    requires bev is Coffee\n{\n   bev->creamers >= 2\n}\n// ANCHOR_END: count_creamers\n\n// ANCHOR: life\nenum Life {\n    Mammal { legs: int, has_pocket: bool },\n    Arthropod { legs: int, wings: int },\n    Plant { leaves: int },\n}\n\nspec fn is_insect(l: Life) -> bool\n{\n    l is Arthropod && l->Arthropod_legs == 6\n}\n// ANCHOR_END: life\n\n// ANCHOR: shape\nenum Shape {\n    Circle(int),\n    Rect(int, int),\n}\n\nspec fn area_2(s: Shape) -> int {\n    match s {\n        Shape::Circle(radius) => { radius * radius * 3 },\n        Shape::Rect(width, height) => { width * height }\n    }\n}\n// ANCHOR_END: shape\n\n// ANCHOR: rect_height\nspec fn rect_height(s: Shape) -> int\n    recommends s is Rect\n{\n    s->1\n}\n// ANCHOR_END: rect_height\n\n// ANCHOR: cuddly\nuse Life::*;\nspec fn cuddly(l: Life) -> bool {\n    ||| l matches Mammal { legs, .. } && legs == 4\n    ||| l matches Arthropod { legs, wings } && legs == 8 && wings == 0\n}\n// ANCHOR_END: cuddly\n\n// ANCHOR: kangaroo\nspec fn is_kangaroo(l: Life) -> bool {\n    &&& l matches Life::Mammal { legs, has_pocket }\n    &&& legs == 2\n    &&& has_pocket\n}\n\nspec fn walks_upright(l: Life) -> bool {\n    l matches Life::Mammal { legs, .. } ==> legs == 2\n}\n// ANCHOR_END: kangaroo\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/guide/datatypes.rs", "verified": true, "metadata": {"original_id": "verus_datatypes_d92f3245f800", "function_name": "", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_ec0669710e30", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize)  ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (a : & [int] , e : int) -> (n : usize) requires exists | i : int | 0 <= i < a . len () && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | 0 <= k < n ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] != e , exists | j : int | i <= j < a . len () && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_linear_search2/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "ec0669710e30", "function_name": "linear_search", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_853b2c483409", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)  ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i : usize = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i : usize = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_division (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | m : int | 0 <= m < arr1 . len () ==> (MIN <= # [trigger] arr1 [m] / # [trigger] arr2 [m] <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i : usize = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | k : int | 0 <= k < arr2 . len () ==> arr2 [k] != 0 , decreases arr1 . len () - i { assert (i < arr1 . len ()) ; assert (arr1 . len () == arr2 . len ()) ; assert (i < arr2 . len ()) ; assert (arr2 [i as int] != 0) ; let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_261_impl.rs", "verified": true, "metadata": {"original_id": "853b2c483409", "function_name": "element_wise_division", "bug_type": "missing_requires"}}
{"id": "task_c_missing_assert_be8112c0bae7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant n <= i <= list . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list . len () - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 <= j <= n , n < list @ . len () , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j , {    new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant n <= i <= list . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list . len () - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 <= j <= n , n < list @ . len () , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j , { assert (j < n) ; assert (n < list @ . len ()) ; assert (j < list @ . len ()) ; new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn split_and_append (list : & Vec < i32 > , n : usize) -> (new_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , n as int)) , { let mut new_list = Vec :: new () ; let mut i = n ; while i < list . len () invariant n <= i <= list . len () , new_list @ == list @ . subrange (n as int , i as int) , decreases list . len () - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = 0 ; while j < n invariant 0 <= j <= n , n < list @ . len () , new_list @ == list @ . subrange (n as int , list @ . len () as int) . add (list @ . subrange (0 , j as int)) , decreases n - j , { assert (j < n) ; assert (n < list @ . len ()) ; assert (j < list @ . len ()) ; new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_586_impl.rs", "verified": true, "metadata": {"original_id": "be8112c0bae7", "function_name": "split_and_append", "bug_type": "missing_assert"}}
{"id": "task_c_missing_ensures_9660478ada30", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e ,  { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i <= j < a . len () as int) && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (i == a . len ()) ; assert (forall | k : int | (0 <= k < i as int) ==> a [k] != e) ; assert (forall | k : int | (0 <= k < a . len () as int) ==> a [k] != e) ; assert (exists | j : int | (0 <= j < a . len () as int) && a [j] == e) ; assert (false) ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i <= j < a . len () as int) && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (i == a . len ()) ; assert (forall | k : int | (0 <= k < i as int) ==> a [k] != e) ; assert (forall | k : int | (0 <= k < a . len () as int) ==> a [k] != e) ; assert (exists | j : int | (0 <= j < a . len () as int) && a [j] == e) ; assert (false) ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i <= j < a . len () as int) && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (i == a . len ()) ; assert (forall | k : int | (0 <= k < i as int) ==> a [k] != e) ; assert (forall | k : int | (0 <= k < a . len () as int) ==> a [k] != e) ; assert (exists | j : int | (0 <= j < a . len () as int) && a [j] == e) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/CloverBench/verified/linear_search2_impl.rs", "verified": true, "metadata": {"original_id": "9660478ada30", "function_name": "linear_search", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_f4d1b5cf461c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn is_lower_case_exec (c : char) -> (result : bool) ensures result == is_lower_case (c) { c >= 'a' && c <= 'z' }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (inner_expr_to_uppercase (str1 , i))) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) , { let c = str1 [idx] ; if is_lower_case_exec (c) { let upper_c = ((c as u8) - 32) as char ; result . push (upper_c) ; } else { result . push (c) ; } idx = idx + 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn is_lower_case_exec (c : char) -> (result : bool) ensures result == is_lower_case (c) { c >= 'a' && c <= 'z' }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (inner_expr_to_uppercase (str1 , i))) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) , decreases str1 . len () - idx { let c = str1 [idx] ; if is_lower_case_exec (c) { let upper_c = ((c as u8) - 32) as char ; result . push (upper_c) ; } else { result . push (c) ; } idx = idx + 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn is_lower_case_exec (c : char) -> (result : bool) ensures result == is_lower_case (c) { c >= 'a' && c <= 'z' }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (inner_expr_to_uppercase (str1 , i))) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) , decreases str1 . len () - idx { let c = str1 [idx] ; if is_lower_case_exec (c) { let upper_c = ((c as u8) - 32) as char ; result . push (upper_c) ; } else { result . push (c) ; } idx = idx + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_624_impl.rs", "verified": true, "metadata": {"original_id": "f4d1b5cf461c", "function_name": "to_uppercase", "bug_type": "missing_decreases"}}
{"id": "task_a_d065fab5e527", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)   { let mut index = 0 ; while index < arr1 . len ()  { if index < arr2 . len () && arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () \nensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) \ndecreases arr1 . len () - index \ninvariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut index = 0 ; while index < arr1 . len () invariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - index , { if index < arr2 . len () && arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_809_impl.rs", "verified": true, "metadata": {"original_id": "d065fab5e527", "function_name": "is_smaller", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_ensures_9954dce0f34e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32)  { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/replace_impl.rs", "verified": true, "metadata": {"original_id": "9954dce0f34e", "function_name": "replace", "bug_type": "missing_ensures"}}
{"id": "task_b_88c16fc0969c", "task": "task_b", "input_text": "fn triple (x : i32) -> (result : i32)\nrequires triple_precond (x as int) , - 700000000 <= x <= 700000000\nensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3, triple_postcond (x as int , result as int)", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn mul_div_lemma (x : int) ensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3 { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 700000000 <= x <= 700000000 ensures triple_postcond (x as int , result as int) { proof { mul_div_lemma (x as int) ; } x * 3 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn mul_div_lemma (x : int) ensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3 { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 700000000 <= x <= 700000000 ensures triple_postcond (x as int , result as int) { proof { mul_div_lemma (x as int) ; } x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_98/verina_basic_98_iter_2_current.rs", "verified": true, "metadata": {"original_id": "88c16fc0969c", "function_name": "triple", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_89a5767201e4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32)  { if a >= b { a } else { b } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32) ensures c >= a && c >= b { if a >= b { a } else { b } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : i32 , b : i32) -> (c : i32) ensures c >= a && c >= b { if a >= b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_Programs_tmp_tmp99966ew4_mymax/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "89a5767201e4", "function_name": "max", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_8854013dacc5", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)  { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_808_iter_1_current.rs", "verified": true, "metadata": {"original_id": "8854013dacc5", "function_name": "contains_k", "bug_type": "missing_ensures"}}
{"id": "task_b_2ea1bb6c0ea6", "task": "task_b", "input_text": "fn arithmetic_weird () -> (result : i32)\nensures result < 10", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { 5 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn arithmetic_weird () -> (result : i32) ensures result < 10 { 5 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/arithmetic_weird_impl.rs", "verified": true, "metadata": {"original_id": "2ea1bb6c0ea6", "function_name": "arithmetic_weird", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_assert_verus_syntax_attr_05f355728c93", "task": "task_c", "input_text": "#![feature(proc_macro_hygiene)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nfn main() {}\n\n/// functions may be declared exec (default), proof, or spec, which contain\n/// exec code, proof code, and spec code, respectively.\n///   - exec code: compiled, may have requires/ensures\n///   - proof code: erased before compilation, may have requires/ensures\n///   - spec code: erased before compilation, no requires/ensures, but may have recommends\n/// exec and proof functions may name their return values inside parentheses, before the return type\n#[verus_spec(sum =>\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n)]\nfn my_exec_fun(x: u32, y: u32) -> u32\n{\n    x + y\n}\n\nverus! {\n\nproof fn my_proof_fun(x: int, y: int) -> (sum: int)\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n{\n    x + y\n}\n\nspec fn my_spec_fun(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n    x + y\n}\n\n} // verus!\n\n/// exec code cannot directly call proof functions or spec functions.\n/// However, exec code can contain proof blocks (proof { ... }),\n/// which contain proof code.\n/// This proof code can call proof functions and spec functions.\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n)]\nfn test_my_funs(x: u32, y: u32)\n{\n    // my_proof_fun(x, y); // not allowed in exec code\n    // let u = my_spec_fun(x, y); // not allowed exec code\n    proof! {\n        let u = my_spec_fun(x as int, y as int);  // allowed in proof code\n        my_proof_fun(u / 2, y as int);  // allowed in proof code\n    }\n}\n\nverus! {\n\n/// spec functions with pub or pub(...) must specify whether the body of the function\n/// should also be made publicly visible (open function) or not visible (closed function).\npub open spec fn my_pub_spec_fun1(x: int, y: int) -> int {\n    // function and body visible to all\n    x / 2 + y / 2\n}\n\n/* TODO\npub open(crate) spec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {\n    // function visible to all, body visible to crate\n    x / 2 + y / 2\n}\n*/\n\n// TODO(main_new) pub(crate) is not being handled correctly\n// pub(crate) open spec fn my_pub_spec_fun3(x: int, y: int) -> int {\n//     // function and body visible to crate\n//     x / 2 + y / 2\n// }\npub closed spec fn my_pub_spec_fun4(x: int, y: int) -> int {\n    // function visible to all, body visible to module\n    x / 2 + y / 2\n}\n\npub(crate) closed spec fn my_pub_spec_fun5(x: int, y: int) -> int {\n    // function visible to crate, body visible to module\n    x / 2 + y / 2\n}\n\n} // verus!\n\n/// Recursive functions must have decreases clauses so that Verus can verify that the functions\n/// terminate.\n#[verus_spec(\n    requires\n        0 < x < 100,\n        y < 100 - x,\n    decreases x,\n)]\nfn test_rec(x: u64, y: u64)\n{\n    if x > 1 {\n        test_rec(x - 1, y + 1);\n    }\n}\n\nverus! {\n\n/// Multiple decreases clauses are ordered lexicographically, so that later clauses may\n/// increase when earlier clauses decrease.\nspec fn test_rec2(x: int, y: int) -> int\n    decreases x, y,\n{\n    if y > 0 {\n        1 + test_rec2(x, y - 1)\n    } else if x > 0 {\n        2 + test_rec2(x - 1, 100)\n    } else {\n        3\n    }\n}\n\n/// To help prove termination, recursive spec functions may have embedded proof blocks\n/// that can make assertions, use broadcasts, and call lemmas.\nspec fn test_rec_proof_block(x: int, y: int) -> int\n    decreases x,\n{\n    if x < 1 {\n        0\n    } else {\n        proof {\n\n        }\n        test_rec_proof_block(x - 1, y + 1) + 1\n    }\n}\n\n/// Decreases and recommends may specify additional clauses:\n///   - decreases .. \"when\" restricts the function definition to a condition\n///     that makes the function terminate\n///   - decreases .. \"via\" specifies a proof function that proves the termination\n///     (although proof blocks are usually simpler; see above)\n///   - recommends .. \"when\" specifies a proof function that proves the\n///     recommendations of the functions invoked in the body\nspec fn add0(a: nat, b: nat) -> nat\n    recommends\n        a > 0,\n    via add0_recommends\n{\n    a + b\n}\n\nspec fn dec0(a: int) -> int\n    decreases a,\n    when a > 0\n    via dec0_decreases\n{\n    if a > 0 {\n        dec0(a - 1)\n    } else {\n        0\n    }\n}\n\n#[via_fn]\nproof fn add0_recommends(a: nat, b: nat) {\n    // proof\n}\n\n#[via_fn]\nproof fn dec0_decreases(a: int) {\n    // proof\n}\n\n} // verus!\n\n/// variables may be exec, tracked, or ghost\n///   - exec: compiled\n///   - tracked: erased before compilation, checked for lifetimes (advanced feature, discussed later)\n///   - ghost: erased before compilation, no lifetime checking, can create default value of any type\n/// Different variable modes may be used in different code modes:\n///   - variables in exec code are always exec\n///   - variables in proof code are ghost by default (tracked variables must be marked \"tracked\")\n///   - variables in spec code are always ghost\n/// For example:\n#[verus_spec(\n    requires\n        a < 100,\n        b < 100,\n)]\nfn test_my_funs2(\n    a: u32,  // exec variable\n    b: u32,  // exec variable\n)\n{\n    let s = a + b;  // s is an exec variable\n    proof! {\n        let u = a + b;  // u is a ghost variable\n        my_proof_fun(u / 2, b as int);  // my_proof_fun(x, y) takes ghost parameters x and y\n    }\n}\n\nverus! {\n\n/// assume and assert are treated as proof code even outside of proof blocks.\n/// \"assert by\" may be used to provide proof code that proves the assertion.\n#[verifier::opaque]\nspec fn f1(i: int) -> int {\n    i + 1\n}\n\n} // verus!\n\n#[verus_spec()]\nfn assert_by_test() {\n    proof! {\n          // reveal f1's definition just inside this block\n        }\n\n    }\n}\n\n/// \"assert by\" can also invoke specialized provers for bit-vector reasoning or nonlinear arithmetic.\n#[verus_spec()]\nfn assert_by_provers(x: u32) {\n    proof! {\n\n    }\n}\n\nverus! {\n\n/// \"let ghost\" currently requires the verus! macro\n/// Variables in exec code may be exec, ghost, or tracked.\nfn test_ghost(x: u32, y: u32)\n    requires\n        x < 100,\n        y < 100,\n{\n    let ghost u: int = my_spec_fun(x as int, y as int);\n    let ghost mut v = u + 1;\n\n    proof {\n        v = v + 1;  // proof code may assign to ghost mut variables\n    }\n    let ghost w = {\n        let temp = v + 1;\n        temp + 1\n    };\n\n}\n\n/// Ghost(...) expressions and patterns currently require the verus! macro\n/// Ghost(...) and Tracked(...) patterns can unwrap Ghost<...> and Tracked<...> values:\nfn test_ghost_unwrap(\n    x: u32,\n    Ghost(y): Ghost<u32>,\n)  // unwrap so that y has typ u32, not Ghost<u32>\n    requires\n        x < 100,\n        y < 100,\n{\n    // Ghost(u) pattern unwraps Ghost<...> values and gives u and v type int:\n    let Ghost(u): Ghost<int> = Ghost(my_spec_fun(x as int, y as int));\n    let Ghost(mut v): Ghost<int> = Ghost(u + 1);\n\n    proof {\n        v = v + 1;  // assign directly to ghost mut v\n    }\n    let Ghost(w): Ghost<int> = Ghost(\n        {\n            // proof block that returns a ghost value\n            let temp = v + 1;\n            temp + 1\n        },\n    );\n\n}\n\n} // verus!\n\n/// Trait functions may have specifications\ntrait T {\n    #[verus_spec(r =>\n        requires\n            0 <= i < 10,\n            0 <= j < 10,\n        ensures\n            i <= r,\n            j <= r,\n    )]\n    fn my_uninterpreted_fun2(&self, i: u8, j: u8) -> u8;\n}\n\n#[verus_spec(ret =>\n    with\n        Tracked(y): Tracked<&mut u32>, Ghost(w): Ghost<u64> -> z: Ghost<u32>\n    requires\n        x < 100,\n        *old(y) < 100,\n    ensures\n        *y == x,\n        ret == x,\n        z == x,\n)]\nfn test_mut_tracked(x: u32) -> u32 {\n    proof!{\n        *y = x;\n    }\n    #[verus_spec(with |=Ghost(x))]\n    x\n}\n\nfn test_cal_mut_tracked(x: u32) {\n    proof_decl!{\n        let ghost mut z;\n        let tracked mut y = 0u32;\n        z = 0u32;\n    }\n    #[verus_spec(with Tracked(&mut y), Ghost(0) => Ghost(z))]\n    let _ = test_mut_tracked(0u32);\n\n    (#[verus_spec(with Tracked(&mut y), Ghost(0))]\n    test_mut_tracked(0u32));\n\n    return;\n}", "target_text": "#![feature(proc_macro_hygiene)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nfn main() {}\n\n/// functions may be declared exec (default), proof, or spec, which contain\n/// exec code, proof code, and spec code, respectively.\n///   - exec code: compiled, may have requires/ensures\n///   - proof code: erased before compilation, may have requires/ensures\n///   - spec code: erased before compilation, no requires/ensures, but may have recommends\n/// exec and proof functions may name their return values inside parentheses, before the return type\n#[verus_spec(sum =>\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n)]\nfn my_exec_fun(x: u32, y: u32) -> u32\n{\n    x + y\n}\n\nverus! {\n\nproof fn my_proof_fun(x: int, y: int) -> (sum: int)\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n{\n    x + y\n}\n\nspec fn my_spec_fun(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n    x + y\n}\n\n} // verus!\n\n/// exec code cannot directly call proof functions or spec functions.\n/// However, exec code can contain proof blocks (proof { ... }),\n/// which contain proof code.\n/// This proof code can call proof functions and spec functions.\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n)]\nfn test_my_funs(x: u32, y: u32)\n{\n    // my_proof_fun(x, y); // not allowed in exec code\n    // let u = my_spec_fun(x, y); // not allowed exec code\n    proof! {\n        let u = my_spec_fun(x as int, y as int);  // allowed in proof code\n        my_proof_fun(u / 2, y as int);  // allowed in proof code\n    }\n}\n\nverus! {\n\n/// spec functions with pub or pub(...) must specify whether the body of the function\n/// should also be made publicly visible (open function) or not visible (closed function).\npub open spec fn my_pub_spec_fun1(x: int, y: int) -> int {\n    // function and body visible to all\n    x / 2 + y / 2\n}\n\n/* TODO\npub open(crate) spec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {\n    // function visible to all, body visible to crate\n    x / 2 + y / 2\n}\n*/\n\n// TODO(main_new) pub(crate) is not being handled correctly\n// pub(crate) open spec fn my_pub_spec_fun3(x: int, y: int) -> int {\n//     // function and body visible to crate\n//     x / 2 + y / 2\n// }\npub closed spec fn my_pub_spec_fun4(x: int, y: int) -> int {\n    // function visible to all, body visible to module\n    x / 2 + y / 2\n}\n\npub(crate) closed spec fn my_pub_spec_fun5(x: int, y: int) -> int {\n    // function visible to crate, body visible to module\n    x / 2 + y / 2\n}\n\n} // verus!\n\n/// Recursive functions must have decreases clauses so that Verus can verify that the functions\n/// terminate.\n#[verus_spec(\n    requires\n        0 < x < 100,\n        y < 100 - x,\n    decreases x,\n)]\nfn test_rec(x: u64, y: u64)\n{\n    if x > 1 {\n        test_rec(x - 1, y + 1);\n    }\n}\n\nverus! {\n\n/// Multiple decreases clauses are ordered lexicographically, so that later clauses may\n/// increase when earlier clauses decrease.\nspec fn test_rec2(x: int, y: int) -> int\n    decreases x, y,\n{\n    if y > 0 {\n        1 + test_rec2(x, y - 1)\n    } else if x > 0 {\n        2 + test_rec2(x - 1, 100)\n    } else {\n        3\n    }\n}\n\n/// To help prove termination, recursive spec functions may have embedded proof blocks\n/// that can make assertions, use broadcasts, and call lemmas.\nspec fn test_rec_proof_block(x: int, y: int) -> int\n    decreases x,\n{\n    if x < 1 {\n        0\n    } else {\n        proof {\n            assert(x - 1 >= 0);\n        }\n        test_rec_proof_block(x - 1, y + 1) + 1\n    }\n}\n\n/// Decreases and recommends may specify additional clauses:\n///   - decreases .. \"when\" restricts the function definition to a condition\n///     that makes the function terminate\n///   - decreases .. \"via\" specifies a proof function that proves the termination\n///     (although proof blocks are usually simpler; see above)\n///   - recommends .. \"when\" specifies a proof function that proves the\n///     recommendations of the functions invoked in the body\nspec fn add0(a: nat, b: nat) -> nat\n    recommends\n        a > 0,\n    via add0_recommends\n{\n    a + b\n}\n\nspec fn dec0(a: int) -> int\n    decreases a,\n    when a > 0\n    via dec0_decreases\n{\n    if a > 0 {\n        dec0(a - 1)\n    } else {\n        0\n    }\n}\n\n#[via_fn]\nproof fn add0_recommends(a: nat, b: nat) {\n    // proof\n}\n\n#[via_fn]\nproof fn dec0_decreases(a: int) {\n    // proof\n}\n\n} // verus!\n\n/// variables may be exec, tracked, or ghost\n///   - exec: compiled\n///   - tracked: erased before compilation, checked for lifetimes (advanced feature, discussed later)\n///   - ghost: erased before compilation, no lifetime checking, can create default value of any type\n/// Different variable modes may be used in different code modes:\n///   - variables in exec code are always exec\n///   - variables in proof code are ghost by default (tracked variables must be marked \"tracked\")\n///   - variables in spec code are always ghost\n/// For example:\n#[verus_spec(\n    requires\n        a < 100,\n        b < 100,\n)]\nfn test_my_funs2(\n    a: u32,  // exec variable\n    b: u32,  // exec variable\n)\n{\n    let s = a + b;  // s is an exec variable\n    proof! {\n        let u = a + b;  // u is a ghost variable\n        my_proof_fun(u / 2, b as int);  // my_proof_fun(x, y) takes ghost parameters x and y\n    }\n}\n\nverus! {\n\n/// assume and assert are treated as proof code even outside of proof blocks.\n/// \"assert by\" may be used to provide proof code that proves the assertion.\n#[verifier::opaque]\nspec fn f1(i: int) -> int {\n    i + 1\n}\n\n} // verus!\n\n#[verus_spec()]\nfn assert_by_test() {\n    proof! {\n        assert(f1(3) > 3) by {\n            reveal(f1);  // reveal f1's definition just inside this block\n        }\n        assert(f1(3) > 3);\n    }\n}\n\n/// \"assert by\" can also invoke specialized provers for bit-vector reasoning or nonlinear arithmetic.\n#[verus_spec()]\nfn assert_by_provers(x: u32) {\n    proof! {\n        assert(x ^ x == 0u32) by (bit_vector);\n        assert(2 <= x && x < 10 ==> x * x > x) by (nonlinear_arith);\n    }\n}\n\nverus! {\n\n/// \"let ghost\" currently requires the verus! macro\n/// Variables in exec code may be exec, ghost, or tracked.\nfn test_ghost(x: u32, y: u32)\n    requires\n        x < 100,\n        y < 100,\n{\n    let ghost u: int = my_spec_fun(x as int, y as int);\n    let ghost mut v = u + 1;\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // proof code may assign to ghost mut variables\n    }\n    let ghost w = {\n        let temp = v + 1;\n        temp + 1\n    };\n    assert(w == x + y + 4);\n}\n\n/// Ghost(...) expressions and patterns currently require the verus! macro\n/// Ghost(...) and Tracked(...) patterns can unwrap Ghost<...> and Tracked<...> values:\nfn test_ghost_unwrap(\n    x: u32,\n    Ghost(y): Ghost<u32>,\n)  // unwrap so that y has typ u32, not Ghost<u32>\n    requires\n        x < 100,\n        y < 100,\n{\n    // Ghost(u) pattern unwraps Ghost<...> values and gives u and v type int:\n    let Ghost(u): Ghost<int> = Ghost(my_spec_fun(x as int, y as int));\n    let Ghost(mut v): Ghost<int> = Ghost(u + 1);\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // assign directly to ghost mut v\n    }\n    let Ghost(w): Ghost<int> = Ghost(\n        {\n            // proof block that returns a ghost value\n            let temp = v + 1;\n            temp + 1\n        },\n    );\n    assert(w == x + y + 4);\n}\n\n} // verus!\n\n/// Trait functions may have specifications\ntrait T {\n    #[verus_spec(r =>\n        requires\n            0 <= i < 10,\n            0 <= j < 10,\n        ensures\n            i <= r,\n            j <= r,\n    )]\n    fn my_uninterpreted_fun2(&self, i: u8, j: u8) -> u8;\n}\n\n#[verus_spec(ret =>\n    with\n        Tracked(y): Tracked<&mut u32>, Ghost(w): Ghost<u64> -> z: Ghost<u32>\n    requires\n        x < 100,\n        *old(y) < 100,\n    ensures\n        *y == x,\n        ret == x,\n        z == x,\n)]\nfn test_mut_tracked(x: u32) -> u32 {\n    proof!{\n        *y = x;\n    }\n    #[verus_spec(with |=Ghost(x))]\n    x\n}\n\nfn test_cal_mut_tracked(x: u32) {\n    proof_decl!{\n        let ghost mut z;\n        let tracked mut y = 0u32;\n        z = 0u32;\n    }\n    #[verus_spec(with Tracked(&mut y), Ghost(0) => Ghost(z))]\n    let _ = test_mut_tracked(0u32);\n\n    (#[verus_spec(with Tracked(&mut y), Ghost(0))]\n    test_mut_tracked(0u32));\n\n    return;\n}", "full_verified_code": "#![feature(proc_macro_hygiene)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nfn main() {}\n\n/// functions may be declared exec (default), proof, or spec, which contain\n/// exec code, proof code, and spec code, respectively.\n///   - exec code: compiled, may have requires/ensures\n///   - proof code: erased before compilation, may have requires/ensures\n///   - spec code: erased before compilation, no requires/ensures, but may have recommends\n/// exec and proof functions may name their return values inside parentheses, before the return type\n#[verus_spec(sum =>\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n)]\nfn my_exec_fun(x: u32, y: u32) -> u32\n{\n    x + y\n}\n\nverus! {\n\nproof fn my_proof_fun(x: int, y: int) -> (sum: int)\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n{\n    x + y\n}\n\nspec fn my_spec_fun(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n    x + y\n}\n\n} // verus!\n\n/// exec code cannot directly call proof functions or spec functions.\n/// However, exec code can contain proof blocks (proof { ... }),\n/// which contain proof code.\n/// This proof code can call proof functions and spec functions.\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n)]\nfn test_my_funs(x: u32, y: u32)\n{\n    // my_proof_fun(x, y); // not allowed in exec code\n    // let u = my_spec_fun(x, y); // not allowed exec code\n    proof! {\n        let u = my_spec_fun(x as int, y as int);  // allowed in proof code\n        my_proof_fun(u / 2, y as int);  // allowed in proof code\n    }\n}\n\nverus! {\n\n/// spec functions with pub or pub(...) must specify whether the body of the function\n/// should also be made publicly visible (open function) or not visible (closed function).\npub open spec fn my_pub_spec_fun1(x: int, y: int) -> int {\n    // function and body visible to all\n    x / 2 + y / 2\n}\n\n/* TODO\npub open(crate) spec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {\n    // function visible to all, body visible to crate\n    x / 2 + y / 2\n}\n*/\n\n// TODO(main_new) pub(crate) is not being handled correctly\n// pub(crate) open spec fn my_pub_spec_fun3(x: int, y: int) -> int {\n//     // function and body visible to crate\n//     x / 2 + y / 2\n// }\npub closed spec fn my_pub_spec_fun4(x: int, y: int) -> int {\n    // function visible to all, body visible to module\n    x / 2 + y / 2\n}\n\npub(crate) closed spec fn my_pub_spec_fun5(x: int, y: int) -> int {\n    // function visible to crate, body visible to module\n    x / 2 + y / 2\n}\n\n} // verus!\n\n/// Recursive functions must have decreases clauses so that Verus can verify that the functions\n/// terminate.\n#[verus_spec(\n    requires\n        0 < x < 100,\n        y < 100 - x,\n    decreases x,\n)]\nfn test_rec(x: u64, y: u64)\n{\n    if x > 1 {\n        test_rec(x - 1, y + 1);\n    }\n}\n\nverus! {\n\n/// Multiple decreases clauses are ordered lexicographically, so that later clauses may\n/// increase when earlier clauses decrease.\nspec fn test_rec2(x: int, y: int) -> int\n    decreases x, y,\n{\n    if y > 0 {\n        1 + test_rec2(x, y - 1)\n    } else if x > 0 {\n        2 + test_rec2(x - 1, 100)\n    } else {\n        3\n    }\n}\n\n/// To help prove termination, recursive spec functions may have embedded proof blocks\n/// that can make assertions, use broadcasts, and call lemmas.\nspec fn test_rec_proof_block(x: int, y: int) -> int\n    decreases x,\n{\n    if x < 1 {\n        0\n    } else {\n        proof {\n            assert(x - 1 >= 0);\n        }\n        test_rec_proof_block(x - 1, y + 1) + 1\n    }\n}\n\n/// Decreases and recommends may specify additional clauses:\n///   - decreases .. \"when\" restricts the function definition to a condition\n///     that makes the function terminate\n///   - decreases .. \"via\" specifies a proof function that proves the termination\n///     (although proof blocks are usually simpler; see above)\n///   - recommends .. \"when\" specifies a proof function that proves the\n///     recommendations of the functions invoked in the body\nspec fn add0(a: nat, b: nat) -> nat\n    recommends\n        a > 0,\n    via add0_recommends\n{\n    a + b\n}\n\nspec fn dec0(a: int) -> int\n    decreases a,\n    when a > 0\n    via dec0_decreases\n{\n    if a > 0 {\n        dec0(a - 1)\n    } else {\n        0\n    }\n}\n\n#[via_fn]\nproof fn add0_recommends(a: nat, b: nat) {\n    // proof\n}\n\n#[via_fn]\nproof fn dec0_decreases(a: int) {\n    // proof\n}\n\n} // verus!\n\n/// variables may be exec, tracked, or ghost\n///   - exec: compiled\n///   - tracked: erased before compilation, checked for lifetimes (advanced feature, discussed later)\n///   - ghost: erased before compilation, no lifetime checking, can create default value of any type\n/// Different variable modes may be used in different code modes:\n///   - variables in exec code are always exec\n///   - variables in proof code are ghost by default (tracked variables must be marked \"tracked\")\n///   - variables in spec code are always ghost\n/// For example:\n#[verus_spec(\n    requires\n        a < 100,\n        b < 100,\n)]\nfn test_my_funs2(\n    a: u32,  // exec variable\n    b: u32,  // exec variable\n)\n{\n    let s = a + b;  // s is an exec variable\n    proof! {\n        let u = a + b;  // u is a ghost variable\n        my_proof_fun(u / 2, b as int);  // my_proof_fun(x, y) takes ghost parameters x and y\n    }\n}\n\nverus! {\n\n/// assume and assert are treated as proof code even outside of proof blocks.\n/// \"assert by\" may be used to provide proof code that proves the assertion.\n#[verifier::opaque]\nspec fn f1(i: int) -> int {\n    i + 1\n}\n\n} // verus!\n\n#[verus_spec()]\nfn assert_by_test() {\n    proof! {\n        assert(f1(3) > 3) by {\n            reveal(f1);  // reveal f1's definition just inside this block\n        }\n        assert(f1(3) > 3);\n    }\n}\n\n/// \"assert by\" can also invoke specialized provers for bit-vector reasoning or nonlinear arithmetic.\n#[verus_spec()]\nfn assert_by_provers(x: u32) {\n    proof! {\n        assert(x ^ x == 0u32) by (bit_vector);\n        assert(2 <= x && x < 10 ==> x * x > x) by (nonlinear_arith);\n    }\n}\n\nverus! {\n\n/// \"let ghost\" currently requires the verus! macro\n/// Variables in exec code may be exec, ghost, or tracked.\nfn test_ghost(x: u32, y: u32)\n    requires\n        x < 100,\n        y < 100,\n{\n    let ghost u: int = my_spec_fun(x as int, y as int);\n    let ghost mut v = u + 1;\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // proof code may assign to ghost mut variables\n    }\n    let ghost w = {\n        let temp = v + 1;\n        temp + 1\n    };\n    assert(w == x + y + 4);\n}\n\n/// Ghost(...) expressions and patterns currently require the verus! macro\n/// Ghost(...) and Tracked(...) patterns can unwrap Ghost<...> and Tracked<...> values:\nfn test_ghost_unwrap(\n    x: u32,\n    Ghost(y): Ghost<u32>,\n)  // unwrap so that y has typ u32, not Ghost<u32>\n    requires\n        x < 100,\n        y < 100,\n{\n    // Ghost(u) pattern unwraps Ghost<...> values and gives u and v type int:\n    let Ghost(u): Ghost<int> = Ghost(my_spec_fun(x as int, y as int));\n    let Ghost(mut v): Ghost<int> = Ghost(u + 1);\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // assign directly to ghost mut v\n    }\n    let Ghost(w): Ghost<int> = Ghost(\n        {\n            // proof block that returns a ghost value\n            let temp = v + 1;\n            temp + 1\n        },\n    );\n    assert(w == x + y + 4);\n}\n\n} // verus!\n\n/// Trait functions may have specifications\ntrait T {\n    #[verus_spec(r =>\n        requires\n            0 <= i < 10,\n            0 <= j < 10,\n        ensures\n            i <= r,\n            j <= r,\n    )]\n    fn my_uninterpreted_fun2(&self, i: u8, j: u8) -> u8;\n}\n\n#[verus_spec(ret =>\n    with\n        Tracked(y): Tracked<&mut u32>, Ghost(w): Ghost<u64> -> z: Ghost<u32>\n    requires\n        x < 100,\n        *old(y) < 100,\n    ensures\n        *y == x,\n        ret == x,\n        z == x,\n)]\nfn test_mut_tracked(x: u32) -> u32 {\n    proof!{\n        *y = x;\n    }\n    #[verus_spec(with |=Ghost(x))]\n    x\n}\n\nfn test_cal_mut_tracked(x: u32) {\n    proof_decl!{\n        let ghost mut z;\n        let tracked mut y = 0u32;\n        z = 0u32;\n    }\n    #[verus_spec(with Tracked(&mut y), Ghost(0) => Ghost(z))]\n    let _ = test_mut_tracked(0u32);\n\n    (#[verus_spec(with Tracked(&mut y), Ghost(0))]\n    test_mut_tracked(0u32));\n\n    return;\n}", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/syntax_attr.rs", "verified": true, "metadata": {"original_id": "verus_syntax_attr_05f355728c93", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_c_missing_ensures_06d9796e8a51", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 ,  { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 ,  { let mut largest = 1u32 ; let mut i = 2u32 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1u32 ; let mut i = 2u32 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1u32 ; let mut i = 2u32 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/largest_prime_factor_impl.rs", "verified": true, "metadata": {"original_id": "06d9796e8a51", "function_name": "largest_prime_factor", "bug_type": "missing_ensures"}}
{"id": "task_b_1623ebcdb64b", "task": "task_b", "input_text": "fn mcontained (v : & [i32] , w : & [i32] , n : usize , m : usize) -> (b : bool)\nrequires n <= m && n >= 0 , strict_sorted (v) , strict_sorted (w) , v . len () >= n && w . len () >= m\nensures b ==> (forall | k : int | # ! [trigger v [k]] 0 <= k < n ==> (exists | j : int | # ! [trigger w [j]] 0 <= j < m && v [k] == w [j]))", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn strict_sorted (arr : & [i32]) -> bool { forall | k : int , l : int | 0 <= k < l < arr . len () ==> arr [k] < arr [l] }\n# [verifier :: loop_isolation (false)] fn mcontained (v : & [i32] , w : & [i32] , n : usize , m : usize) -> (b : bool) requires n <= m && n >= 0 , strict_sorted (v) , strict_sorted (w) , v . len () >= n && w . len () >= m ensures b ==> (forall | k : int | # ! [trigger v [k]] 0 <= k < n ==> (exists | j : int | # ! [trigger w [j]] 0 <= j < m && v [k] == w [j])) { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn strict_sorted (arr : & [i32]) -> bool { forall | k : int , l : int | 0 <= k < l < arr . len () ==> arr [k] < arr [l] }\n# [verifier :: loop_isolation (false)] fn mcontained (v : & [i32] , w : & [i32] , n : usize , m : usize) -> (b : bool) requires n <= m && n >= 0 , strict_sorted (v) , strict_sorted (w) , v . len () >= n && w . len () >= m ensures b ==> (forall | k : int | # ! [trigger v [k]] 0 <= k < n ==> (exists | j : int | # ! [trigger w [j]] 0 <= j < m && v [k] == w [j])) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/WIP/WIP__mcontained_iter_0_original.rs", "verified": true, "metadata": {"original_id": "1623ebcdb64b", "function_name": "mcontained", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_5e38c6e4aff3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (v : & mut Vec < u64 >)  { let len = v . len () ; let mut i = 0 ; while i < len / 2 invariant v . len () == len , len == old (v) . len () , forall | j : int | 0 <= j < i ==> v [j] == old (v) [len - j - 1] , forall | j : int | len - i <= j < len ==> v [j] == old (v) [len - j - 1] , forall | j : int | i <= j < len - i ==> v [j] == old (v) [j] , decreases len / 2 - i , { let temp = v [i] ; let temp2 = v [len - i - 1] ; v . set (i , temp2) ; v . set (len - i - 1 , temp) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (v : & mut Vec < u64 >) ensures v . len () == old (v) . len () , forall | i : int | 0 <= i < old (v) . len () ==> v [i] == old (v) [old (v) . len () - i - 1] , { let len = v . len () ; let mut i = 0 ; while i < len / 2 invariant v . len () == len , len == old (v) . len () , forall | j : int | 0 <= j < i ==> v [j] == old (v) [len - j - 1] , forall | j : int | len - i <= j < len ==> v [j] == old (v) [len - j - 1] , forall | j : int | i <= j < len - i ==> v [j] == old (v) [j] , decreases len / 2 - i , { let temp = v [i] ; let temp2 = v [len - i - 1] ; v . set (i , temp2) ; v . set (len - i - 1 , temp) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (v : & mut Vec < u64 >) ensures v . len () == old (v) . len () , forall | i : int | 0 <= i < old (v) . len () ==> v [i] == old (v) [old (v) . len () - i - 1] , { let len = v . len () ; let mut i = 0 ; while i < len / 2 invariant v . len () == len , len == old (v) . len () , forall | j : int | 0 <= j < i ==> v [j] == old (v) [len - j - 1] , forall | j : int | len - i <= j < len ==> v [j] == old (v) [len - j - 1] , forall | j : int | i <= j < len - i ==> v [j] == old (v) [j] , decreases len / 2 - i , { let temp = v [i] ; let temp2 = v [len - i - 1] ; v . set (i , temp2) ; v . set (len - i - 1 , temp) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/unverified/reverse_iter_3_current.rs", "verified": true, "metadata": {"original_id": "5e38c6e4aff3", "function_name": "reverse", "bug_type": "missing_ensures"}}
{"id": "task_a_9f43baeac6bf", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)   { let mut i = 0 ; while i < v . len ()  { if v [i] % 2 == 1 { return i ; } i += 1 ; } return 0 ; }\n\n} // verus!", "target_text": "requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 \nensures odd_index < v . len () \ndecreases v . len () - i\ninvariant 0 <= i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 , ensures odd_index < v . len () , { let mut i = 0 ; while i < v . len () invariant 0 <= i <= v . len () , exists | q : int | i <= q < v . len () && v [q] % 2 == 1 , decreases v . len () - i { if v [i] % 2 == 1 { return i ; } i += 1 ; } return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/Misc/choose_odd_impl.rs", "verified": true, "metadata": {"original_id": "9f43baeac6bf", "function_name": "choose_odd", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_decreases_0af91bffe18f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | j : int | 0 <= j < arr2 . len () ==> # [trigger] arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] / arr2 [j]) <= MAX) , { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | j : int | 0 <= j < arr2 . len () ==> # [trigger] arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] / arr2 [j]) <= MAX) , decreases arr1 . len () - i { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | j : int | 0 <= j < arr2 . len () ==> # [trigger] arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] / arr2 [j]) <= MAX) , decreases arr1 . len () - i { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_618_iter_3_current.rs", "verified": true, "metadata": {"original_id": "0af91bffe18f", "function_name": "element_wise_divide", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_ce07ee509f10", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 2 * N , { sum . set (0 , 2 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s2if_impl.rs", "verified": true, "metadata": {"original_id": "ce07ee509f10", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_09faa3d174a3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high  { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high invariant 0 <= low <= high <= a . len () , decreases high - low , { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search (a : & Vec < i32 > , circle : i32) -> (n : usize) requires true , ensures 0 <= n <= a . len () , { let mut low : usize = 0 ; let mut high : usize = a . len () ; while low < high invariant 0 <= low <= high <= a . len () , decreases high - low , { let mid = low + (high - low) / 2 ; if a [mid] == circle { return mid ; } else if a [mid] < circle { low = mid + 1 ; } else { high = mid ; } } low }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Correctness_tmp_tmpwqvg5q_4_Sorting_Tangent/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "09faa3d174a3", "function_name": "binary_search", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_286ab52cb934", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >) requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX , ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >) requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX , ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy_from (a : & Vec < i32 > , i : usize , acc : & mut Vec < i32 >) requires i <= a . len () , old (acc) . len () + (a . len () - i) <= MAX , ensures acc . len () == old (acc) . len () + (a . len () - i) , forall | j : int | 0 <= j < old (acc) . len () ==> acc [j] == old (acc) [j] , forall | j : int | old (acc) . len () <= j < acc . len () ==> acc [j] == a [(j - old (acc) . len () + i) as int] , decreases a . len () - i { if i < a . len () { acc . push (a [i]) ; copy_from (a , i + 1 , acc) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_82/verina_basic_82_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "286ab52cb934", "function_name": "copy_from", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_552ff365c53b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool)  { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 'Z' || text [j] == 'z')) , { if text [i] == 'Z' || text [i] == 'z' { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) , { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 'Z' || text [j] == 'z')) , { if text [i] == 'Z' || text [i] == 'z' { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & Vec < char >) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 'Z' || text [i] == 'z')) , { for i in 0 .. text . len () invariant ! (exists | j : int | 0 <= j < i && (text [j] == 'Z' || text [j] == 'z')) , { if text [i] == 'Z' || text [i] == 'z' { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "552ff365c53b", "function_name": "contains_z", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_3f064b15d620", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len ()  { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& shared , elem) { shared . push (elem) ; } } shared }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& shared , elem) { shared . push (elem) ; } } shared }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut shared = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < shared . len () ==> (list1 @ . contains (shared [k]) && list2 @ . contains (shared [k])) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < shared . len () ==> shared [k1] != shared [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& shared , elem) { shared . push (elem) ; } } shared }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_2_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "3f064b15d620", "function_name": "shared_elements", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_447ea6b32677", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32)  ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_53/verina_advanced_53_iter_0_original.rs", "verified": true, "metadata": {"original_id": "447ea6b32677", "function_name": "minimum_right_shifts", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_954cb6321571", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant result . len () == i , i <= a . len () , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant result . len () == i , i <= a . len () , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , decreases a . len () - i , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant result . len () == i , i <= a . len () , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , decreases a . len () - i , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/array_product_impl.rs", "verified": true, "metadata": {"original_id": "954cb6321571", "function_name": "array_product", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_4ec85337b928", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 ,  { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Diffy/unverified/res2o_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "4ec85337b928", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_1b206db906d0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize)  ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] <= N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/ms2_impl.rs", "verified": true, "metadata": {"original_id": "1b206db906d0", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_b_8f26ff6b2328", "task": "task_b", "input_text": "fn up_while_less (N : i32) -> (i : i32)\nrequires 0 <= N \nensures i == N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn up_while_less (N : i32) -> (i : i32) requires 0 <= N , ensures i == N , { let mut i = 0 ; while i < N invariant 0 <= i <= N , decreases N - i , { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_LoopInvariant/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "8f26ff6b2328", "function_name": "up_while_less", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_verus_external_68f8d7000c35", "task": "task_b", "input_text": "fn test(n: u64, s: Ghost<int>)\nrequires n > 10 && s@ >= n", "target_text": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[verifier::external_body]\nfn test(n: u64, s: Ghost<int>)\n    requires\n        n > 10 && s@ >= n,\n{\n    println!(\"hello {}\", n);\n}\n\nfn main() {\n    test(15, Ghost(200));\n}\n\n} // verus!\n", "full_verified_code": "use verus_builtin::*;\nuse verus_builtin_macros::*;\n\nverus! {\n\n#[verifier::external_body]\nfn test(n: u64, s: Ghost<int>)\n    requires\n        n > 10 && s@ >= n,\n{\n    println!(\"hello {}\", n);\n}\n\nfn main() {\n    test(15, Ghost(200));\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/external.rs", "verified": true, "metadata": {"original_id": "verus_external_68f8d7000c35", "function_name": "", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_1e5fdb50a7b8", "task": "task_b", "input_text": "fn strlen (string : & Vec < char >) -> (length : usize)\nensures length == string . len () ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize) ensures length == string . len () , { string . len () }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn strlen (string : & Vec < char >) -> (length : usize) ensures length == string . len () , { string . len () }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/023-strlen_impl.rs", "verified": true, "metadata": {"original_id": "1e5fdb50a7b8", "function_name": "strlen", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_657e7c8ca61d", "task": "task_b", "input_text": "fn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool)\nensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_k (arr : & Vec < i32 > , k : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == k)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != k , { if arr [i] == k { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_808_impl.rs", "verified": true, "metadata": {"original_id": "657e7c8ca61d", "function_name": "contains_k", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_ensures_f8a4ea34e547", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive (v : & [i32]) -> (b : bool)  { for i in 0 .. v . len () invariant forall | u : int | 0 <= u < i ==> v [u] >= 0 { if v [i] < 0 { return false ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive (v : & [i32]) -> (b : bool) ensures b == positive (v @) { for i in 0 .. v . len () invariant forall | u : int | 0 <= u < i ==> v [u] >= 0 { if v [i] < 0 { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn positive (s : Seq < i32 >) -> bool { forall | u : int | 0 <= u < s . len () ==> s [u] >= 0 }\nfn mpositive (v : & [i32]) -> (b : bool) ensures b == positive (v @) { for i in 0 .. v . len () invariant forall | u : int | 0 <= u < i ==> v [u] >= 0 { if v [i] < 0 { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "f8a4ea34e547", "function_name": "mpositive", "bug_type": "missing_ensures"}}
{"id": "task_b_8f052db50046", "task": "task_b", "input_text": "fn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize)\nrequires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem \nensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/binary_search_recursive_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8f052db50046", "function_name": "binary_search_recursive", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_fa22a39ad343", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 ,  { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] , decreases arr . len () - 1 - idx { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] , decreases arr . len () - 1 - idx { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] , decreases arr . len () - 1 - idx { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_567_impl.rs", "verified": true, "metadata": {"original_id": "fa22a39ad343", "function_name": "is_sorted", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_74e74503ed04", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len ()  { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> ((i % 2) == (arr [i] % 2)) , decreases arr . len () - idx , { if (idx % 2) != (arr [idx] % 2) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_790_iter_2_current.rs", "verified": true, "metadata": {"original_id": "74e74503ed04", "function_name": "is_even_at_even_index", "bug_type": "missing_invariant"}}
{"id": "task_a_8fce6e46a3e5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >)  { let mut c = Vec :: new () ; for i in 0 .. a . len ()  { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& c , element) { c . push (element) ; } } c }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] \ninvariant forall | j : int | 0 <= j < i ==> a @ [j] != x , forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | x : int , y : int | 0 <= x < y < c . len () ==> c [x] != c [y] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut c = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | x : int , y : int | 0 <= x < y < c . len () ==> c [x] != c [y] , { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& c , element) { c . push (element) ; } } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "8fce6e46a3e5", "function_name": "remove_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_c_missing_ensures_f9dae54162f8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool)  { c >= '0' && c <= '9' }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : char) -> bool { c >= '0' && c <= '9' }\nfn is_digit (c : char) -> (result : bool) ensures result == is_digit_spec (c) , { c >= '0' && c <= '9' }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_61/verina_basic_61_impl.rs", "verified": true, "metadata": {"original_id": "f9dae54162f8", "function_name": "is_digit", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_71383fe86069", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >)  ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i , { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i , { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < u8 > >) -> (result : Vec < u8 >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i , { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/unverified/task_id_424_impl.rs", "verified": true, "metadata": {"original_id": "71383fe86069", "function_name": "extract_rear_chars", "bug_type": "missing_requires"}}
{"id": "task_b_d885bab00260", "task": "task_b", "input_text": "fn modp (n : u32 , p : u32) -> (r : u32)\nrequires p > 0 , p > 0 \nensures mul == ((a as int) * (b as int)) % (p as int) , r == modp_rec (n as nat , p as nat) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) decreases n , { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let result = ((a as u64) * (b as u64)) % (p as u64) ; result as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith) requires p > 0 , ensures r == modp_rec (n as nat , p as nat) , { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n invariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) , decreases n - i , { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn modp_rec (n : nat , p : nat) -> (result : nat) decreases n , { if n == 0 { 1nat % p } else { (modp_rec ((n - 1) as nat , p) * 2) % p } }\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let result = ((a as u64) * (b as u64)) % (p as u64) ; result as u32 }\n# [verifier :: loop_isolation (false)] fn modp (n : u32 , p : u32) -> (r : u32) by (nonlinear_arith) requires p > 0 , ensures r == modp_rec (n as nat , p as nat) , { let mut result : u32 = 1 % p ; let mut i : u32 = 0 ; while i < n invariant p > 0 , i <= n , result == modp_rec (i as nat , p as nat) , decreases n - i , { result = modmul (result , 2 , p) ; i = i + 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/049-modp_impl.rs", "verified": true, "metadata": {"original_id": "d885bab00260", "function_name": "modp", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_invariant_48576af6ea0f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len ()  { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/replace_impl.rs", "verified": true, "metadata": {"original_id": "48576af6ea0f", "function_name": "replace", "bug_type": "missing_invariant"}}
{"id": "task_a_bae2c7702c04", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "bae2c7702c04", "function_name": "contains", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_c_missing_requires_b74dc91e1167", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32)  ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , decreases lst . len () - i , { if lst [i] > max_val { max_val = lst [i] ; } i += 1 ; } max_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , decreases lst . len () - i , { if lst [i] > max_val { max_val = lst [i] ; } i += 1 ; } max_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , decreases lst . len () - i , { if lst [i] > max_val { max_val = lst [i] ; } i += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_39/verina_advanced_39_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b74dc91e1167", "function_name": "max_of_list", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_cea8626b15a4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (v : & mut Vec < u64 >) ensures v . len () == old (v) . len () , forall | i : int | 0 <= i < old (v) . len () ==> v [i] == old (v) [old (v) . len () - i - 1] , { let len = v . len () ; let mut i = 0 ; while i < len / 2  { let temp = v [i] ; let temp2 = v [len - i - 1] ; v . set (i , temp2) ; v . set (len - i - 1 , temp) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (v : & mut Vec < u64 >) ensures v . len () == old (v) . len () , forall | i : int | 0 <= i < old (v) . len () ==> v [i] == old (v) [old (v) . len () - i - 1] , { let len = v . len () ; let mut i = 0 ; while i < len / 2 invariant v . len () == len , len == old (v) . len () , forall | j : int | 0 <= j < i ==> v [j] == old (v) [len - j - 1] , forall | j : int | len - i <= j < len ==> v [j] == old (v) [len - j - 1] , forall | j : int | i <= j < len - i ==> v [j] == old (v) [j] , decreases len / 2 - i , { let temp = v [i] ; let temp2 = v [len - i - 1] ; v . set (i , temp2) ; v . set (len - i - 1 , temp) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (v : & mut Vec < u64 >) ensures v . len () == old (v) . len () , forall | i : int | 0 <= i < old (v) . len () ==> v [i] == old (v) [old (v) . len () - i - 1] , { let len = v . len () ; let mut i = 0 ; while i < len / 2 invariant v . len () == len , len == old (v) . len () , forall | j : int | 0 <= j < i ==> v [j] == old (v) [len - j - 1] , forall | j : int | len - i <= j < len ==> v [j] == old (v) [len - j - 1] , forall | j : int | i <= j < len - i ==> v [j] == old (v) [j] , decreases len / 2 - i , { let temp = v [i] ; let temp2 = v [len - i - 1] ; v . set (i , temp2) ; v . set (len - i - 1 , temp) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/unverified/reverse_impl.rs", "verified": true, "metadata": {"original_id": "cea8626b15a4", "function_name": "reverse", "bug_type": "missing_invariant"}}
{"id": "task_a_7b4e306fcb99", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)   { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\n\n} // verus!", "target_text": "requires i < old (a) . len () , j < old (a) . len () \nensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; let temp_j = a [j] ; a . set (i , temp_j) ; a . set (j , temp) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_52/verina_basic_52_impl.rs", "verified": true, "metadata": {"original_id": "7b4e306fcb99", "function_name": "swap", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_1f053d22680c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool)  { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , decreases text . len () - i , { if text [i] == 90 || text [i] == 122 { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , decreases text . len () - i , { if text [i] == 90 || text [i] == 122 { return true ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains_z (text : & [u8]) -> (result : bool) ensures result == (exists | i : int | 0 <= i < text . len () && (text [i] == 90 || text [i] == 122)) , { let mut i = 0 ; while i < text . len () invariant 0 <= i <= text . len () , forall | j : int | 0 <= j < i ==> ! (text [j] == 90 || text [j] == 122) , decreases text . len () - i , { if text [i] == 90 || text [i] == 122 { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_454_impl.rs", "verified": true, "metadata": {"original_id": "1f053d22680c", "function_name": "contains_z", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_3b03a820eadf", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (numbers : Seq < int > , result : usize) -> bool { true }\nspec fn longest_increasing_subsequence_precond (numbers : Seq < int >) -> bool { true }\nfn longest_increasing_subsequence (numbers : Vec < i32 >) -> (result : usize)  ensures longest_increasing_subsequence_postcond (numbers @ . map (| i : int , x : i32 | x as int) , result) { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (numbers : Seq < int > , result : usize) -> bool { true }\nspec fn longest_increasing_subsequence_precond (numbers : Seq < int >) -> bool { true }\nfn longest_increasing_subsequence (numbers : Vec < i32 >) -> (result : usize) requires longest_increasing_subsequence_precond (numbers @ . map (| i : int , x : i32 | x as int)) , numbers . len () < 1000000 , ensures longest_increasing_subsequence_postcond (numbers @ . map (| i : int , x : i32 | x as int) , result) { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (numbers : Seq < int > , result : usize) -> bool { true }\nspec fn longest_increasing_subsequence_precond (numbers : Seq < int >) -> bool { true }\nfn longest_increasing_subsequence (numbers : Vec < i32 >) -> (result : usize) requires longest_increasing_subsequence_precond (numbers @ . map (| i : int , x : i32 | x as int)) , numbers . len () < 1000000 , ensures longest_increasing_subsequence_postcond (numbers @ . map (| i : int , x : i32 | x as int) , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_32/verina_advanced_32_iter_0_original.rs", "verified": true, "metadata": {"original_id": "3b03a820eadf", "function_name": "longest_increasing_subsequence", "bug_type": "missing_requires"}}
{"id": "task_a_e472af234805", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { sum . set (0 , 3 * N) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 3 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/s2lif_impl.rs", "verified": true, "metadata": {"original_id": "e472af234805", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_b_e5c0ef0e2c64", "task": "task_b", "input_text": "fn minMethod (a : i32 , b : i32) -> (c : i32)\nensures c <= a && c <= b , c == a || c == b , c == min (a as int , b as int) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min (a : int , b : int) -> int { if a < b { a } else { b } }\nfn minMethod (a : i32 , b : i32) -> (c : i32) ensures c <= a && c <= b , c == a || c == b , c == min (a as int , b as int) , { if a < b { a } else { b } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn min (a : int , b : int) -> int { if a < b { a } else { b } }\nfn minMethod (a : i32 , b : i32) -> (c : i32) ensures c <= a && c <= b , c == a || c == b , c == min (a as int , b as int) , { if a < b { a } else { b } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Dafny_tmp_tmpv_d3qi10_2_min/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "e5c0ef0e2c64", "function_name": "minMethod", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_0459c1a200ec", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1  { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len ()  { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires first . len () > 0 \nensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) \ndecreases first . len () - 1 - i, second . len () - j\ninvariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < first . len () - 1 invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , decreases first . len () - 1 - i { result . push (first [i]) ; i += 1 ; } let mut j = 0 ; while j < second . len () invariant j <= second . len () , result @ == first @ . subrange (0 , first . len () - 1) . add (second @ . subrange (0 , j as int)) , decreases second . len () - j { result . push (second [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/VerusProofSynthesisBench/MBPP/task_id_240_iter_2_current.rs", "verified": true, "metadata": {"original_id": "0459c1a200ec", "function_name": "replace_last_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_b_09cab6dc4c8a", "task": "task_b", "input_text": "pub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)\nrequires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 3 * N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 3 * N , { sum . set (0 , 3 * N) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s2lif_impl.rs", "verified": true, "metadata": {"original_id": "09cab6dc4c8a", "function_name": "myfun", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_16834247ba4d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)  { }\n\n} // verus!", "target_text": "requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/havoc_inline_post_iter_1_current.rs", "verified": true, "metadata": {"original_id": "16834247ba4d", "function_name": "havoc_inline_post", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_bbba8f4e1bfa", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)   { let mut i = 0 ; while i < N  { a [i as usize] = 0 ; i = i + 1 ; } }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 \nensures forall | k : int | 0 <= k < N ==> a [k] == 0 \ndecreases N - i \ninvariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i , { a [i as usize] = 0 ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/verified/condg_impl.rs", "verified": true, "metadata": {"original_id": "bbba8f4e1bfa", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_decreases_aef9dfb8e0b7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut i = a . len () - 1 ; loop invariant 0 <= i < a . len () , forall | j : int | i < j < a . len () ==> a [j] != elem , { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; } proof { assert (forall | j : int | 0 <= j < a . len () ==> a [j] != elem) ; assert (exists | k : int | 0 <= k < a . len () && a [k] == elem) ; assert (false) ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut i = a . len () - 1 ; loop invariant 0 <= i < a . len () , forall | j : int | i < j < a . len () ==> a [j] != elem , decreases i { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; } proof { assert (forall | j : int | 0 <= j < a . len () ==> a [j] != elem) ; assert (exists | k : int | 0 <= k < a . len () && a [k] == elem) ; assert (false) ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn last_position (a : & [i32] , elem : i32) -> (result : usize) requires a . len () > 0 , exists | k : int | 0 <= k < a . len () && a [k] == elem , ensures 0 <= result < a . len () , forall | i : int | result < i < a . len () ==> a [i] != elem , a [result as int] == elem , { let mut i = a . len () - 1 ; loop invariant 0 <= i < a . len () , forall | j : int | i < j < a . len () ==> a [j] != elem , decreases i { if a [i] == elem { return i ; } if i == 0 { break ; } i -= 1 ; } proof { assert (forall | j : int | 0 <= j < a . len () ==> a [j] != elem) ; assert (exists | k : int | 0 <= k < a . len () && a [k] == elem) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/preconditions_removed/last_position_iter_2_current.rs", "verified": true, "metadata": {"original_id": "aef9dfb8e0b7", "function_name": "last_position", "bug_type": "missing_decreases"}}
{"id": "task_a_7966dba4ed0c", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bounded_loop (bound : u32 , r : u32 , n : u32) -> (result : u32)  { return 0 ; }\n\n} // verus!", "target_text": "requires bound <= 100 , r <= 10 , n <= 100 \ndecreases bound", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bounded_loop (bound : u32 , r : u32 , n : u32) -> (result : u32) requires bound <= 100 , r <= 10 , n <= 100 , decreases bound { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_65/verina_basic_65_iter_0_original.rs", "verified": true, "metadata": {"original_id": "7966dba4ed0c", "function_name": "bounded_loop", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_a_c5774525eb88", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)   { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "target_text": "requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 6 * N ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 6 * N , { sum . set (0 , 6 * (N as i32)) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Diffy/verified/s52if_iter_1_current.rs", "verified": true, "metadata": {"original_id": "c5774525eb88", "function_name": "myfun", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_invariant_24f503f98de4", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p  { let mut j = p + 1 ; while j < arr . len ()  { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant p + 1 <= j <= arr . len () , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/barrier_impl.rs", "verified": true, "metadata": {"original_id": "24f503f98de4", "function_name": "barrier", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_0f4160e689c7", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)  { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2)) , { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2)) , { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2)) , { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_790_iter_1_current.rs", "verified": true, "metadata": {"original_id": "0f4160e689c7", "function_name": "is_even_at_even_index", "bug_type": "missing_ensures"}}
{"id": "task_b_9d319f499bb1", "task": "task_b", "input_text": "fn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >)\nrequires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , double_array_elements_precond (s) \nensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , double_array_elements_postcond (s , result) , result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >) requires double_array_elements_precond (s) , ensures double_array_elements_postcond (s , result) , { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nspec fn double_array_elements_postcond (s : Vec < i32 > , result : Vec < i32 >) -> bool { result . len () == s . len () && forall | i : int | # ! [auto] 0 <= i < s . len () ==> result [i] == 2 * s [i] }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_next = s ; s_next . set (i , 2 * s_old [i]) ; proof { assert (s_next . len () == s_old . len ()) ; assert (forall | j : int | # ! [auto] 0 <= j < i ==> s_next [j] == 2 * s_old [j]) ; assert (s_next [i as int] == 2 * s_old [i as int]) ; assert (forall | j : int | # ! [auto] 0 <= j < (i + 1) ==> s_next [j] == 2 * s_old [j]) ; assert (forall | j : int | # ! [auto] (i + 1) <= j < s_next . len () ==> s_next [j] == s_old [j]) ; } double_array_elements_aux (s_old , s_next , i + 1) } }\nfn double_array_elements (s : Vec < i32 >) -> (result : Vec < i32 >) requires double_array_elements_precond (s) , ensures double_array_elements_postcond (s , result) , { let s_copy = s . clone () ; double_array_elements_aux (s , s_copy , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_58/verina_basic_58_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "9d319f499bb1", "function_name": "double_array_elements", "has_invariants": false, "has_asserts": true}}
{"id": "task_b_3dbb5ee1f5b2", "task": "task_b", "input_text": "fn task_code (sequence : Vec < i32 >) -> (result : i32)\nrequires task_code_precond (sequence @ . map (| i , x | x as int))\nensures task_code_postcond (sequence @ . map (| i , x | x as int) , result as int , task_code_precond (sequence @ . map (| i , x | x as int)))", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn task_code_postcond (sequence : Seq < int > , result : int , h_precond : bool) -> bool { if sequence . len () == 0 { result == 0 } else { true } }\nspec fn task_code_precond (sequence : Seq < int >) -> bool { true }\nfn task_code (sequence : Vec < i32 >) -> (result : i32) requires task_code_precond (sequence @ . map (| i , x | x as int)) ensures task_code_postcond (sequence @ . map (| i , x | x as int) , result as int , task_code_precond (sequence @ . map (| i , x | x as int))) { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn task_code_postcond (sequence : Seq < int > , result : int , h_precond : bool) -> bool { if sequence . len () == 0 { result == 0 } else { true } }\nspec fn task_code_precond (sequence : Seq < int >) -> bool { true }\nfn task_code (sequence : Vec < i32 >) -> (result : i32) requires task_code_precond (sequence @ . map (| i , x | x as int)) ensures task_code_postcond (sequence @ . map (| i , x | x as int) , result as int , task_code_precond (sequence @ . map (| i , x | x as int))) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_75/verina_advanced_75.rs", "verified": true, "metadata": {"original_id": "3dbb5ee1f5b2", "function_name": "task_code", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_decreases_afa8ad47d9ce", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , { let mut j = p + 1 ; while j < arr . len () invariant 0 <= i <= p , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant 0 <= i <= p , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn barrier (arr : & [i32] , p : usize) -> (result : bool) requires arr . len () > 0 , 0 <= p < arr . len () , ensures result == forall | k : int , l : int | 0 <= k <= p && p < l < arr . len () ==> arr [k] < arr [l] , { let mut i = 0 ; while i <= p invariant 0 <= i <= p + 1 , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , decreases p + 1 - i { let mut j = p + 1 ; while j < arr . len () invariant 0 <= i <= p , p + 1 <= j <= arr . len () , forall | k : int , l : int | 0 <= k < i && p < l < arr . len () ==> arr [k] < arr [l] , forall | l : int | p < l < j ==> arr [i as int] < arr [l] , decreases arr . len () - j { if arr [i] >= arr [j] { return false ; } j += 1 ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/invariants_removed/barrier_iter_3_current.rs", "verified": true, "metadata": {"original_id": "afa8ad47d9ce", "function_name": "barrier", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_6ece0c03585d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32)  { 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_tmp_tmp0wu8wmfr_tests_F1a/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "6ece0c03585d", "function_name": "F", "bug_type": "missing_ensures"}}
{"id": "task_b_6fb842169152", "task": "task_b", "input_text": "fn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >)\nensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn insert_before_each (arr : & Vec < i32 > , elem : i32) -> (result : Vec < i32 >) ensures result @ . len () == (2 * arr . len ()) , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < arr . len () ==> # [trigger] result [2 * k + 1] == arr [k] , { let mut result = Vec :: new () ; for i in 0 .. arr . len () invariant result @ . len () == 2 * i , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k] == elem , forall | k : int | 0 <= k < i ==> # [trigger] result [2 * k + 1] == arr [k] , { result . push (elem) ; result . push (arr [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_251_impl.rs", "verified": true, "metadata": {"original_id": "6fb842169152", "function_name": "insert_before_each", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_fbed276fae94", "task": "task_b", "input_text": "fn longest_increasing_subsequence (numbers : Vec < i32 >) -> (result : usize)\nrequires longest_increasing_subsequence_precond (numbers @ . map (| i : int , x : i32 | x as int)) , numbers . len () < 1000000 \nensures longest_increasing_subsequence_postcond (numbers @ . map (| i : int , x : i32 | x as int) , result)", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (numbers : Seq < int > , result : usize) -> bool { true }\nspec fn longest_increasing_subsequence_precond (numbers : Seq < int >) -> bool { true }\nfn longest_increasing_subsequence (numbers : Vec < i32 >) -> (result : usize) requires longest_increasing_subsequence_precond (numbers @ . map (| i : int , x : i32 | x as int)) , numbers . len () < 1000000 , ensures longest_increasing_subsequence_postcond (numbers @ . map (| i : int , x : i32 | x as int) , result) { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subsequence_postcond (numbers : Seq < int > , result : usize) -> bool { true }\nspec fn longest_increasing_subsequence_precond (numbers : Seq < int >) -> bool { true }\nfn longest_increasing_subsequence (numbers : Vec < i32 >) -> (result : usize) requires longest_increasing_subsequence_precond (numbers @ . map (| i : int , x : i32 | x as int)) , numbers . len () < 1000000 , ensures longest_increasing_subsequence_postcond (numbers @ . map (| i : int , x : i32 | x as int) , result) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_32/verina_advanced_32.rs", "verified": true, "metadata": {"original_id": "fbed276fae94", "function_name": "longest_increasing_subsequence", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_f79524a8b984", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e ,  { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_69/verina_basic_69_impl.rs", "verified": true, "metadata": {"original_id": "f79524a8b984", "function_name": "linear_search_aux", "bug_type": "missing_ensures"}}
{"id": "task_a_ee4d5b5fba77", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32)   { if x < 0 { - x } else { x } }\n\n} // verus!", "target_text": "requires x != MIN \nensures result >= 0 , result == x || result == - x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs (x : i32) -> (result : i32) requires x != MIN , ensures result >= 0 , result == x || result == - x , { if x < 0 { - x } else { x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/abs_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ee4d5b5fba77", "function_name": "abs", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_2aae472d4d7b", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn solution_precond (nums : Seq < u32 >) -> bool { 1 <= nums . len () && nums . len () <= 100 && forall | i : int | 0 <= i < nums . len () ==> 1 <= nums [i] && nums [i] <= 100 }\n# [verifier :: exec_allows_no_decreases_clause] fn solution (nums : Vec < u32 >) -> (result : u32)  { return 0 ; }\n\n} // verus!", "target_text": "requires solution_precond (nums @) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn solution_precond (nums : Seq < u32 >) -> bool { 1 <= nums . len () && nums . len () <= 100 && forall | i : int | 0 <= i < nums . len () ==> 1 <= nums [i] && nums [i] <= 100 }\n# [verifier :: exec_allows_no_decreases_clause] fn solution (nums : Vec < u32 >) -> (result : u32) requires solution_precond (nums @) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_74/verina_advanced_74.rs", "verified": true, "metadata": {"original_id": "2aae472d4d7b", "function_name": "solution", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_decreases_660690dd0133", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sum_powers_helper (n : u32 , k : u32 , acc : u32) -> u32 { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sum_powers_helper (n : u32 , k : u32 , acc : u32) -> u32 decreases n , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sum_powers_helper (n : u32 , k : u32 , acc : u32) -> u32 decreases n , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_18/verina_advanced_18.rs", "verified": true, "metadata": {"original_id": "660690dd0133", "function_name": "sum_powers_helper", "bug_type": "missing_decreases"}}
{"id": "task_a_008c4f9269bc", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len ()  { let c = str1 [i] ; if (c == ' ') || (c == ',') || (c == '.') { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) \ndecreases str1 . len () - i \ninvariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i , { let c = str1 [i] ; if (c == ' ') || (c == ',') || (c == '.') { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_732_impl.rs", "verified": true, "metadata": {"original_id": "008c4f9269bc", "function_name": "replace_with_colon", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_invariant_3d2be12da2e3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >) requires a . len () <= 100 , ensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] , { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { b . push (a [i]) ; i = i + 1 ; } b }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >) requires a . len () <= 100 , ensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] , { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] , decreases a . len () - i , { b . push (a [i]) ; i = i + 1 ; } b }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn copy (a : & Vec < u64 >) -> (b : Vec < u64 >) requires a . len () <= 100 , ensures b @ . len () == a @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> b [i] == a [i] , { let mut b = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , b @ . len () == i , forall | j : int | (0 <= j && j < i) ==> b [j] == a [j] , decreases a . len () - i , { b . push (a [i]) ; i = i + 1 ; } b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/verified/array_copy_strong_impl.rs", "verified": true, "metadata": {"original_id": "3d2be12da2e3", "function_name": "copy", "bug_type": "missing_invariant"}}
{"id": "task_a_d9f4e31ca8da", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith)   { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n\n} // verus!", "target_text": "requires p > 0 \nensures mul == ((a as int) * (b as int)) % (p as int) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn modmul (a : u32 , b : u32 , p : u32) -> (mul : u32) by (nonlinear_arith) requires p > 0 , ensures mul == ((a as int) * (b as int)) % (p as int) , { let product = (a as u64) * (b as u64) ; (product % (p as u64)) as u32 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/049-modp_impl.rs", "verified": true, "metadata": {"original_id": "d9f4e31ca8da", "function_name": "modmul", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_requires_d5bc24f83307", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool)  ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/largest_prime_factor_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d5bc24f83307", "function_name": "is_prime", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_9ecf147a7a6c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) ,  { let result = arr [k - 1] ; proof { let witness_idx = k as int - 1 ; assert (0 <= witness_idx < arr @ . len ()) by { assert (k >= 1 && k <= arr @ . len ()) ; assert (k as int >= 1) ; assert (k as int - 1 >= 0) ; assert (k as int <= arr @ . len ()) ; assert (k as int - 1 < arr @ . len ()) ; } ; assert (arr @ [witness_idx] == result) ; assert (result as int == arr @ [k as int - 1] as int) ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) , ensures kth_element_postcond (arr @ , k as nat , result as int) , { let result = arr [k - 1] ; proof { let witness_idx = k as int - 1 ; assert (0 <= witness_idx < arr @ . len ()) by { assert (k >= 1 && k <= arr @ . len ()) ; assert (k as int >= 1) ; assert (k as int - 1 >= 0) ; assert (k as int <= arr @ . len ()) ; assert (k as int - 1 < arr @ . len ()) ; } ; assert (arr @ [witness_idx] == result) ; assert (result as int == arr @ [k as int - 1] as int) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn kth_element_postcond (arr : Seq < i32 > , k : nat , result : int) -> bool { exists | i : int | 0 <= i < arr . len () && # [trigger] arr [i] == result && result == arr [k as int - 1] as int }\nspec fn kth_element_precond (arr : Seq < i32 > , k : nat) -> bool { k >= 1 && k <= arr . len () }\nfn kth_element (arr : & Vec < i32 > , k : usize) -> (result : i32) requires kth_element_precond (arr @ , k as nat) , ensures kth_element_postcond (arr @ , k as nat , result as int) , { let result = arr [k - 1] ; proof { let witness_idx = k as int - 1 ; assert (0 <= witness_idx < arr @ . len ()) by { assert (k >= 1 && k <= arr @ . len ()) ; assert (k as int >= 1) ; assert (k as int - 1 >= 0) ; assert (k as int <= arr @ . len ()) ; assert (k as int - 1 < arr @ . len ()) ; } ; assert (arr @ [witness_idx] == result) ; assert (result as int == arr @ [k as int - 1] as int) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_4/verina_basic_4_iter_1_current.rs", "verified": true, "metadata": {"original_id": "9ecf147a7a6c", "function_name": "kth_element", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_e399a7691672", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn search_insert_precond (xs : Seq < int > , target : int) -> bool { is_sorted (xs) }\nspec fn search_insert_postcond (xs : Seq < int > , target : int , result : int) -> bool { let in_bounds = result <= xs . len () ; let all_before_less = all_before_less (xs , target , result) ; let inserted_correctly = result < xs . len () ==> target <= xs [result] ; in_bounds && all_before_less && inserted_correctly }\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nspec fn all_before_less (xs : Seq < int > , target : int , result : int) -> bool { forall | i : int | 0 <= i < result ==> xs [i] < target }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\nfn search_insert (xs : & Vec < int > , target : int) -> (result : usize) requires search_insert_precond (xs @ , target) , ensures search_insert_postcond (xs @ , target , result as int) , { helper (xs , target , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_69/verina_advanced_69_iter_1_current.rs", "verified": true, "metadata": {"original_id": "e399a7691672", "function_name": "search_insert", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_93828301e6ef", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >)  ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_60/verina_basic_60_impl.rs", "verified": true, "metadata": {"original_id": "93828301e6ef", "function_name": "find_even_numbers", "bug_type": "missing_requires"}}
{"id": "task_a_verus_overflow_8c4772399c7c", "task": "task_a", "input_text": "// examples of using `CheckedU32` and `CheckedU64`\nuse vstd::prelude::*;\nuse vstd::arithmetic::overflow::*;\n\nverus! {\n\nfn checked_u64_constants()\n{\n    let w = CheckedU64::new(0xFFFFFFFFFFFFFFFF);\n    let x = w.add_value(1);\n\n    let y = CheckedU64::new(0x8000000000000000);\n    let z = y.mul_value(2);\n\n}\n\nfn checked_u64_calculations(a: u64, b: u64, c: u64, d: u64) -> (result: Option<u64>)\n     {\n            Some(v) => v == a * b + c * d,\n            None => a * b + c * d > u64::MAX,\n        }\n{\n    let a_times_b = CheckedU64::new(a).mul_value(b);\n    let c_times_d = CheckedU64::new(c).mul_value(d);\n    let sum_of_products = a_times_b.add_checked(&c_times_d);\n    if sum_of_products.is_overflowed() {\n\n        None\n    }\n    else {\n        let i: u64 = sum_of_products.unwrap();\n\n        Some(i)\n    }\n}\n\nfn checked_u32_constants()\n{\n    let w = CheckedU32::new(0xFFFFFFFF);\n    let x = w.add_value(9);\n\n    let y = CheckedU32::new(0x40000000);\n    let z = y.mul_value(8);\n\n}\n\nfn checked_u32_calculations(a: u32, b: u32, c: u32, d: u32, e: u32) -> (result: Option<u32>)\n     {\n            Some(v) => v == a * b + c * d + e,\n            None => a * b + c * d + e > u32::MAX,\n        }\n{\n    let a_times_b = CheckedU32::new(a).mul_value(b);\n    let c_times_d = CheckedU32::new(c).mul_value(d);\n    let sum_of_products = a_times_b.add_checked(&c_times_d);\n    let f = sum_of_products.add_value(e);\n    f.to_option()\n}\n\n} // verus!\nfn main() {}\n", "target_text": "ensures match result, match result", "full_verified_code": "// examples of using `CheckedU32` and `CheckedU64`\nuse vstd::prelude::*;\nuse vstd::arithmetic::overflow::*;\n\nverus! {\n\nfn checked_u64_constants()\n{\n    let w = CheckedU64::new(0xFFFFFFFFFFFFFFFF);\n    let x = w.add_value(1);\n    assert(x.is_overflowed());\n    assert(x.view() == 0x10000000000000000);\n\n    let y = CheckedU64::new(0x8000000000000000);\n    let z = y.mul_value(2);\n    assert(z.is_overflowed());\n    assert(z.view() == 0x10000000000000000);\n}\n\nfn checked_u64_calculations(a: u64, b: u64, c: u64, d: u64) -> (result: Option<u64>)\n    ensures\n        match result {\n            Some(v) => v == a * b + c * d,\n            None => a * b + c * d > u64::MAX,\n        }\n{\n    let a_times_b = CheckedU64::new(a).mul_value(b);\n    let c_times_d = CheckedU64::new(c).mul_value(d);\n    let sum_of_products = a_times_b.add_checked(&c_times_d);\n    if sum_of_products.is_overflowed() {\n        assert(a * b + c * d > u64::MAX);\n        None\n    }\n    else {\n        let i: u64 = sum_of_products.unwrap();\n        assert(i == a * b + c * d);\n        Some(i)\n    }\n}\n\nfn checked_u32_constants()\n{\n    let w = CheckedU32::new(0xFFFFFFFF);\n    let x = w.add_value(9);\n    assert(x.is_overflowed());\n    assert(x.view() == 0x100000008);\n\n    let y = CheckedU32::new(0x40000000);\n    let z = y.mul_value(8);\n    assert(z.is_overflowed());\n    assert(z.view() == 0x200000000);\n}\n\nfn checked_u32_calculations(a: u32, b: u32, c: u32, d: u32, e: u32) -> (result: Option<u32>)\n    ensures\n        match result {\n            Some(v) => v == a * b + c * d + e,\n            None => a * b + c * d + e > u32::MAX,\n        }\n{\n    let a_times_b = CheckedU32::new(a).mul_value(b);\n    let c_times_d = CheckedU32::new(c).mul_value(d);\n    let sum_of_products = a_times_b.add_checked(&c_times_d);\n    let f = sum_of_products.add_value(e);\n    f.to_option()\n}\n\n} // verus!\nfn main() {}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/overflow.rs", "verified": true, "metadata": {"original_id": "verus_overflow_8c4772399c7c", "function_name": "", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_ensures_377c0479642d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 ,  { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn conditional_average (vals_1 : & Vec < u64 > , vals_2 : & Vec < u64 > , conds_1 : & Vec < bool > , conds_2 : & Vec < bool > , avgs : & mut Vec < u64 >) requires vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , ensures avgs . len () == vals_1 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) { avgs . clear () ; let mut i = 0 ; while i < vals_1 . len () invariant i <= vals_1 . len () , avgs . len () == i , vals_1 . len () == vals_2 . len () , vals_1 . len () == conds_1 . len () , vals_1 . len () == conds_2 . len () , forall | idx : int | 0 <= idx < vals_1 . len () ==> conds_1 [idx] || conds_2 [idx] , forall | idx : int | 0 <= idx < vals_1 . len () ==> vals_1 [idx] < 1000 , forall | idx : int | 0 <= idx < vals_2 . len () ==> vals_2 [idx] < 1000 , forall | idx : int | 0 <= idx < i ==> ((conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == (vals_1 [idx] + vals_2 [idx]) / 2) && (conds_1 [idx] && ! conds_2 [idx] ==> avgs [idx] == vals_1 [idx]) && (! conds_1 [idx] && conds_2 [idx] ==> avgs [idx] == vals_2 [idx])) decreases vals_1 . len () - i { let avg_val = if conds_1 [i] && conds_2 [i] { (vals_1 [i] + vals_2 [i]) / 2 } else if conds_1 [i] && ! conds_2 [i] { vals_1 [i] } else { vals_2 [i] } ; avgs . push (avg_val) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/unverified/conditional_average_impl.rs", "verified": true, "metadata": {"original_id": "377c0479642d", "function_name": "conditional_average", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_8fce4613ffdc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32)  ensures k_out >= 0 , { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (n : i32 , k : i32) -> (k_out : i32) requires n > 0 , k > n , n <= 100 , k <= 200 , ensures k_out >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15/verus_code.rs", "verified": true, "metadata": {"original_id": "8fce4613ffdc", "function_name": "main_method", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_e9d9e1bb47f8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs_diff (a : i32 , b : i32) -> (result : i32)  ensures result >= 0 , { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs_diff (a : i32 , b : i32) -> (result : i32) requires a >= - 1000000 && a <= 1000000 , b >= - 1000000 && b <= 1000000 , ensures result >= 0 , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn abs_diff (a : i32 , b : i32) -> (result : i32) requires a >= - 1000000 && a <= 1000000 , b >= - 1000000 && b <= 1000000 , ensures result >= 0 , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_63/verina_basic_63.rs", "verified": true, "metadata": {"original_id": "e9d9e1bb47f8", "function_name": "abs_diff", "bug_type": "missing_requires"}}
{"id": "task_b_verus_multiset_7be5a28cd704", "task": "task_b", "input_text": "fn main()\nensures to be true\n    unsorted.lemma_sort_by_ensures(leq);\n    let expected_result: Seq<int> = seq![1, 2, 3, 4, 5];\n    assert(sorted_by(expected_result, leq));\n    // These two assertions trigger quantifiers relating sequence contents to multiset counts\n    assert(unsorted =~= seq![3].push(1).push(5).push(2).push(4));\n    assert(expected_result =~= seq![1].push(2).push(3).push(4).push(5));\n    assert(expected_result.to_multiset() =~= unsorted.to_multiset());\n    //Proves that any two sequences that are sorted and have the same elements are equal.\n    lemma_sorted_unique(expected_result, unsorted.sort_by(leq), leq);\n    assert(sorted =~= expected_result);\n}\n\n} // verus!\nfn main()", "target_text": "// examples of using the multiset, sorted_by lemmas in seq lib\nuse vstd::prelude::*;\nuse vstd::relations::sorted_by;\nuse vstd::seq_lib::*;\n\nverus! {\n\nproof fn multiset_ext_eq() {\n    broadcast use group_to_multiset_ensures;\n    let a: Seq<int> = seq![1, 2, 3];\n    let b: Seq<int> = seq![1, 3, 2];\n    assert(a =~= seq![1].push(2).push(3));\n    assert(b =~= seq![1].push(3).push(2));\n    assert(a.to_multiset() =~= b.to_multiset());\n}\n\nproof fn multiset_ext_eq2() {\n    broadcast use group_to_multiset_ensures;\n    let a: Seq<int> = seq![3, 2, 1, 1, 2, 3];\n    let b: Seq<int> = seq![1, 2, 3, 1, 2, 3];\n    // These two assertions trigger quantifiers relating sequence contents to multiset counts\n    assert(a =~= seq![3].push(2).push(1).push(1).push(2).push(3));\n    assert(b =~= seq![1].push(2).push(3).push(1).push(2).push(3));\n    assert(a.to_multiset() =~= b.to_multiset());\n}\n\nproof fn sorted_by_leq() {\n    broadcast use group_to_multiset_ensures;\n    let leq = |x: int, y: int| x <= y;\n    let unsorted = seq![3, 1, 5, 2, 4];\n    let sorted = unsorted.sort_by(leq);\n    //Tells the verifier what the sort_by function ensures to be true\n    unsorted.lemma_sort_by_ensures(leq);\n    let expected_result: Seq<int> = seq![1, 2, 3, 4, 5];\n    assert(sorted_by(expected_result, leq));\n    // These two assertions trigger quantifiers relating sequence contents to multiset counts\n    assert(unsorted =~= seq![3].push(1).push(5).push(2).push(4));\n    assert(expected_result =~= seq![1].push(2).push(3).push(4).push(5));\n    assert(expected_result.to_multiset() =~= unsorted.to_multiset());\n    //Proves that any two sequences that are sorted and have the same elements are equal.\n    lemma_sorted_unique(expected_result, unsorted.sort_by(leq), leq);\n    assert(sorted =~= expected_result);\n}\n\n} // verus!\nfn main() {}\n", "full_verified_code": "// examples of using the multiset, sorted_by lemmas in seq lib\nuse vstd::prelude::*;\nuse vstd::relations::sorted_by;\nuse vstd::seq_lib::*;\n\nverus! {\n\nproof fn multiset_ext_eq() {\n    broadcast use group_to_multiset_ensures;\n    let a: Seq<int> = seq![1, 2, 3];\n    let b: Seq<int> = seq![1, 3, 2];\n    assert(a =~= seq![1].push(2).push(3));\n    assert(b =~= seq![1].push(3).push(2));\n    assert(a.to_multiset() =~= b.to_multiset());\n}\n\nproof fn multiset_ext_eq2() {\n    broadcast use group_to_multiset_ensures;\n    let a: Seq<int> = seq![3, 2, 1, 1, 2, 3];\n    let b: Seq<int> = seq![1, 2, 3, 1, 2, 3];\n    // These two assertions trigger quantifiers relating sequence contents to multiset counts\n    assert(a =~= seq![3].push(2).push(1).push(1).push(2).push(3));\n    assert(b =~= seq![1].push(2).push(3).push(1).push(2).push(3));\n    assert(a.to_multiset() =~= b.to_multiset());\n}\n\nproof fn sorted_by_leq() {\n    broadcast use group_to_multiset_ensures;\n    let leq = |x: int, y: int| x <= y;\n    let unsorted = seq![3, 1, 5, 2, 4];\n    let sorted = unsorted.sort_by(leq);\n    //Tells the verifier what the sort_by function ensures to be true\n    unsorted.lemma_sort_by_ensures(leq);\n    let expected_result: Seq<int> = seq![1, 2, 3, 4, 5];\n    assert(sorted_by(expected_result, leq));\n    // These two assertions trigger quantifiers relating sequence contents to multiset counts\n    assert(unsorted =~= seq![3].push(1).push(5).push(2).push(4));\n    assert(expected_result =~= seq![1].push(2).push(3).push(4).push(5));\n    assert(expected_result.to_multiset() =~= unsorted.to_multiset());\n    //Proves that any two sequences that are sorted and have the same elements are equal.\n    lemma_sorted_unique(expected_result, unsorted.sort_by(leq), leq);\n    assert(sorted =~= expected_result);\n}\n\n} // verus!\nfn main() {}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/multiset.rs", "verified": true, "metadata": {"original_id": "verus_multiset_7be5a28cd704", "function_name": "", "has_invariants": false, "has_asserts": true}}
{"id": "task_a_2bb8ba1e41e5", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_lowercase (str1 : & [u8]) -> (result : Vec < u8 >)  { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { shift32_spec (str1 [i]) } else { str1 [i] }) , { if (str1 [index] >= 65 && str1 [index] <= 90) { lower_case . push ((str1 [index] + 32) as u8) ; } else { lower_case . push (str1 [index]) ; } index += 1 ; } lower_case }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i])\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i])", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_upper_case (c : u8) -> bool { c >= 65 && c <= 90 }\nspec fn shift32_spec (c : u8) -> u8 { (c + 32) as u8 }\nfn to_lowercase (str1 : & [u8]) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , { let mut lower_case : Vec < u8 > = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , lower_case . len () == index , forall | i : int | 0 <= i < index ==> lower_case [i] == (if is_upper_case (# [trigger] str1 [i]) { shift32_spec (str1 [i]) } else { str1 [i] }) , decreases str1 . len () - index { if (str1 [index] >= 65 && str1 [index] <= 90) { lower_case . push ((str1 [index] + 32) as u8) ; } else { lower_case . push (str1 [index]) ; } index += 1 ; } lower_case }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_477_iter_2_current.rs", "verified": true, "metadata": {"original_id": "2bb8ba1e41e5", "function_name": "to_lowercase", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_requires_ec8162a547bb", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32)  ensures sum <= 2 * N , { 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/unverified/cell_2_sum_iter_1_current.rs", "verified": true, "metadata": {"original_id": "ec8162a547bb", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_382c27bf63f9", "task": "task_c", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (nums : Vec < i32 > , target : i32) -> (ret : i32)  ensures ret < nums @ . len () , ret >= 0 ==> nums @ [ret as int] == target , ret >= 0 ==> forall | i : int | 0 <= i < ret as int ==> # [trigger] nums @ [i] != target , ret < 0 ==> forall | i : int | 0 <= i < nums @ . len () as int ==> # [trigger] nums @ [i] != target , { let mut i = 0 ; while i < nums . len () invariant 0 <= i <= nums @ . len () , forall | j : int | 0 <= j < i ==> # [trigger] nums @ [j] != target , i <= nums @ . len () && nums @ . len () < 0x8000_0000 , decreases nums @ . len () - i { if nums [i] == target { assert (nums @ [i as int] == target) ; assert (i < nums @ . len ()) ; assert (i < 0x8000_0000) ; return i as i32 ; } i += 1 ; } assert (forall | j : int | 0 <= j < nums @ . len () ==> nums @ [j] != target) ; return - 1 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (nums : Vec < i32 > , target : i32) -> (ret : i32) requires nums @ . len () < 0x8000_0000 , ensures ret < nums @ . len () , ret >= 0 ==> nums @ [ret as int] == target , ret >= 0 ==> forall | i : int | 0 <= i < ret as int ==> # [trigger] nums @ [i] != target , ret < 0 ==> forall | i : int | 0 <= i < nums @ . len () as int ==> # [trigger] nums @ [i] != target , { let mut i = 0 ; while i < nums . len () invariant 0 <= i <= nums @ . len () , forall | j : int | 0 <= j < i ==> # [trigger] nums @ [j] != target , i <= nums @ . len () && nums @ . len () < 0x8000_0000 , decreases nums @ . len () - i { if nums [i] == target { assert (nums @ [i as int] == target) ; assert (i < nums @ . len ()) ; assert (i < 0x8000_0000) ; return i as i32 ; } i += 1 ; } assert (forall | j : int | 0 <= j < nums @ . len () ==> nums @ [j] != target) ; return - 1 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn linear_search (nums : Vec < i32 > , target : i32) -> (ret : i32) requires nums @ . len () < 0x8000_0000 , ensures ret < nums @ . len () , ret >= 0 ==> nums @ [ret as int] == target , ret >= 0 ==> forall | i : int | 0 <= i < ret as int ==> # [trigger] nums @ [i] != target , ret < 0 ==> forall | i : int | 0 <= i < nums @ . len () as int ==> # [trigger] nums @ [i] != target , { let mut i = 0 ; while i < nums . len () invariant 0 <= i <= nums @ . len () , forall | j : int | 0 <= j < i ==> # [trigger] nums @ [j] != target , i <= nums @ . len () && nums @ . len () < 0x8000_0000 , decreases nums @ . len () - i { if nums [i] == target { assert (nums @ [i as int] == target) ; assert (i < nums @ . len ()) ; assert (i < 0x8000_0000) ; return i as i32 ; } i += 1 ; } assert (forall | j : int | 0 <= j < nums @ . len () ==> nums @ [j] != target) ; return - 1 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Misc/verified/linearsearch_impl.rs", "verified": true, "metadata": {"original_id": "382c27bf63f9", "function_name": "linear_search", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_1159a858e02d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Max (x : u32 , y : u32) -> (r : u32)  { if x >= y { x } else { y } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Max (x : u32 , y : u32) -> (r : u32) ensures r >= x && r >= y , r == x || r == y , { if x >= y { x } else { y } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn Max (x : u32 , y : u32) -> (r : u32) ensures r >= x && r >= y , r == x || r == y , { if x >= y { x } else { y } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "1159a858e02d", "function_name": "Max", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_27115a7684a0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32)  ensures r as int == 3 * (x as int) { x + x + x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { x + x + x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_over (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { x + x + x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "27115a7684a0", "function_name": "triple_over", "bug_type": "missing_requires"}}
{"id": "task_b_b39f2ab4789c", "task": "task_b", "input_text": "fn update_elements (a : & mut Vec < i32 >)\nrequires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX \nensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX , ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX , ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_update_array/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "b39f2ab4789c", "function_name": "update_elements", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_decreases_18e19141fc74", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx < arr . len () , forall | i : int , j : int | 0 <= i < j < idx + 1 ==> (arr [i] <= arr [j]) , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_567_iter_2_current.rs", "verified": true, "metadata": {"original_id": "18e19141fc74", "function_name": "is_sorted", "bug_type": "missing_decreases"}}
{"id": "task_b_ec6952035112", "task": "task_b", "input_text": "fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32)\nrequires minimum_right_shifts_precond (nums @ . map (| i , x | x as int))\nensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int)", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; for shifts in 0 .. n { if is_sorted_aux (& current) { return shifts as i32 ; } current = right_shift_once (& current) ; } - 1 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; for shifts in 0 .. n { if is_sorted_aux (& current) { return shifts as i32 ; } current = right_shift_once (& current) ; } - 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_53/verina_advanced_53_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "ec6952035112", "function_name": "minimum_right_shifts", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_verus_chapter-1-22_fa6ac1200b1d", "task": "task_b", "input_text": "fn check_is_sorted_tree(tree: &Tree) -> (ret: TreeSortedness)\nrequires tree.is_sorted(), tree.is_sorted()\nensures sequence_is_sorted(tree@), tree.is_sorted() == !ret.is_Unsorted(),\n        tree.is_Nil() == ret.is_Empty(),\n        if let TreeSortedness::Bounded(l, r) = ret, ret == tree@.contains(needle as int), sequence_is_sorted(tree@),\n    decreases tree  // guessed by Dafny , ret == tree@.contains(needle as int),\n    decreases tree", "target_text": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\n#[is_variant]\n#[derive(PartialEq, Eq)]  // TODO(utaal): Structural is not implemented for Box\nenum Tree {\n    Nil,\n    Node { value: i64, left: Box<Tree>, right: Box<Tree> },\n}\n\nimpl Tree {\n    spec fn view(&self) -> Seq<int>\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => seq![],\n            Tree::Node { value, left, right } => left@.add(seq![value as int]).add(right@),\n        }\n    }\n\n    spec fn is_sorted(&self) -> bool\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => true,\n            Tree::Node { value, left, right } => {\n                &&& sequences_ordered_at_interface(left@, seq![value as int])\n                &&& sequences_ordered_at_interface(seq![value as int], right@)\n                &&& left.is_sorted()\n                &&& right.is_sorted()\n            },\n        }\n    }// #[verifier::proof] fn sorted_tree_means_sorted_sequence(&self)\n    // TODO(utaal): is self being Spec too restrictive?\n\n}\n\nspec fn sequences_ordered_at_interface(seq1: Seq<int>, seq2: Seq<int>) -> bool {\n    if seq1.len() == 0 || seq2.len() == 0 {\n        true\n    } else {\n        seq1.last() <= seq2[0]\n    }\n}\n\nspec fn sequence_is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\n// TODO: change the default for --multiple-errors\n// we can have --jon-mode :p\n// TODO: shall multiple errors in the same method be sorted?\nproof fn sorted_tree_means_sorted_sequence(tree: Tree)\n    requires\n        tree.is_sorted(),\n    ensures\n        sequence_is_sorted(tree@),\n    decreases tree  // guessed by Dafny ,\n{\n    // reveal_with_fuel(sorted_tree_means_sorted_sequence, 3); // TODO(utaal) ICE revealing current method with fuel panics in AIR\n    if let Tree::Node { left, right, value: _ } = tree {\n        sorted_tree_means_sorted_sequence(*left);  // guessed by Dafny\n        sorted_tree_means_sorted_sequence(*right);  // guessed by Dafny\n    }\n}\n\n#[is_variant]\n#[derive(Eq, PartialEq, Structural)]\nenum TreeSortedness {\n    Unsorted,\n    Empty,\n    Bounded(i64, i64),\n}\n\nfn check_is_sorted_tree(tree: &Tree) -> (ret: TreeSortedness)\n    ensures\n        tree.is_sorted() == !ret.is_Unsorted(),\n        tree.is_Nil() == ret.is_Empty(),\n        if let TreeSortedness::Bounded(l, r) = ret {\n            l == tree@[0] && r == tree@.last()\n        } else {\n            true\n        },\n// TODO: suboptimal span for error message:\n// error: postcondition not satisfied\n//   --> rust_verify/example/summer_school.rs:82:13\n//    |\n// 82 |             TreeSortedness::Unsorted => true,\n//    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => TreeSortedness::Empty,\n        Tree::Node { left, value, right } => {\n            let left_sortedness = check_is_sorted_tree(left);\n            let left_bound;\n            match left_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => left_bound = *value,\n                TreeSortedness::Bounded(ll, lr) => if !(lr <= *value) {\n                    // assert(!sequences_ordered_at_interface(left@, seq![*value as int]));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(left@[0] == ll);\n                    // assert(left@.last() == lr);\n                    // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n                    left_bound = ll;\n                },\n            }\n            // assert(left.is_Nil() ==> left_sortedness.is_Empty());\n            // assert(left_sortedness.is_Empty() ==> left.is_Nil());\n\n            let right_sortedness = check_is_sorted_tree(right);\n            let right_bound;\n            match right_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => right_bound = *value,\n                TreeSortedness::Bounded(rl, rr) => if !(*value <= rl) {\n                    // assert(!sequences_ordered_at_interface(seq![*value as int], right@));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(*value <= rl);\n                    // assert(right@.last() == rr);\n                    // assert(right@[0] == rl);\n                    // assert(seq![*value as int].last() == *value as int);\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    right_bound = rr;\n                },\n            }\n            proof {\n                sorted_tree_means_sorted_sequence(**left);\n                sorted_tree_means_sorted_sequence(**right);\n            }\n            // assert(equal(tree@, left@.add(seq![*value as int]).add(right@)));\n            // assert(tree@.len() > 0);\n            // assert(left.is_sorted());\n            // assert(right.is_sorted());\n            // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n            // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n            // assert(tree.is_sorted());\n            // TODO cannot use proof variable inside forall/assert_by statements (left)\n            // #[verifier::spec] let left = left;\n            // assert_by(left_bound == tree@[0], {\n            //     if left.is_Nil() {\n            //         assert(left_sortedness.is_Empty());\n            //         assert(*value as int == tree@[0]);\n            //         assert(left_bound == *value);\n            //         assert(left_bound == tree@[0]);\n            //     } else {\n            //         assert(left_bound == tree@[0]);\n            //     }\n            // });\n            assert(right_bound == tree@.last());\n            TreeSortedness::Bounded(left_bound, right_bound)\n        },\n    }\n}\n\nfn find_in_binary_tree(tree: &Tree, needle: i64) -> (ret: bool)\n    requires\n        tree.is_sorted(),\n    ensures\n        ret == tree@.contains(needle as int),\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => false,\n        Tree::Node { left, value, right } => {\n            if needle == *value {\n                assert(tree@[left@.len() as int] == needle);  // trigger\n                true\n            } else if needle < *value {\n                let ret = find_in_binary_tree(left, needle);\n                if ret {\n                    //let idx = choose(|idx: nat| idx < left@.len() && left@.index(nat) == needle); // TODO(utaal): bad error message for stray nat?\n                    proof {\n                        let idx = choose|idx: int| 0 <= idx < left@.len() && left@[idx] == needle;\n                        assert(tree@[idx] == needle);  // trigger\n                    }\n                } else {\n                    proof {\n                        sorted_tree_means_sorted_sequence(**right);\n                    }\n                    //                    assert_forall_by(|idx: nat| {\n                    //                        requires(idx < tree@.len());\n                    //                        ensures(tree@.index(idx) != needle);\n                    //                        if idx < left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else if idx==left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else {\n                    //                          assert(tree@.index(idx) == right@.index(idx + left@.len() + 1));    // TODO(utaal): surprising complaint \"expected struct `verus_builtin::int`, found struct `verus_builtin::nat`\"\n                    //                          #[verifier::spec] let right_idx: int = idx - (left@.len() as int + 1);\n                    //                          assert(tree@.index(idx) == right@.index(right_idx));\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@)); // TODO(utal): How about *value as int is just value@? And then maybe even auto_view that? How cool would that be?\n                    //                          assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    //                          assert(sequence_is_sorted(right@));\n                    //                          if 0 < right_idx {\n                    //                            assert(right@.index(0) <= right@.index(right_idx));\n                    //                          }\n                    //                          assert((*value as int) <= right@.index(right_idx));\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        }\n                    //                    });\n                }\n                //                assert(ret == tree@.contains(needle));\n\n                ret\n            } else {\n                let ret = find_in_binary_tree(right, needle);\n                proof {\n                    if ret {\n                        let idx = choose|idx: int| 0 <= idx < right@.len() && right@[idx] == needle;\n                        assert(tree@[left@.len() + 1 + idx] == needle);  // trigger\n                    } else {\n                        sorted_tree_means_sorted_sequence(**left);\n                    }\n                }\n                //                assert(ret == tree@.contains(needle));    // TODO(jonh): symmetric case incomplete\n                ret\n            }\n        },\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "full_verified_code": "// rust_verify/tests/example.rs expect-warnings\n#[allow(unused_imports)]\nuse prelude::*;\n#[allow(unused_imports)]\nuse seq::*;\nuse vstd::prelude::*;\n#[allow(unused_imports)]\nuse vstd::*;\n\nverus! {\n\n#[is_variant]\n#[derive(PartialEq, Eq)]  // TODO(utaal): Structural is not implemented for Box\nenum Tree {\n    Nil,\n    Node { value: i64, left: Box<Tree>, right: Box<Tree> },\n}\n\nimpl Tree {\n    spec fn view(&self) -> Seq<int>\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => seq![],\n            Tree::Node { value, left, right } => left@.add(seq![value as int]).add(right@),\n        }\n    }\n\n    spec fn is_sorted(&self) -> bool\n        decreases self,\n    {\n        match *self {\n            Tree::Nil => true,\n            Tree::Node { value, left, right } => {\n                &&& sequences_ordered_at_interface(left@, seq![value as int])\n                &&& sequences_ordered_at_interface(seq![value as int], right@)\n                &&& left.is_sorted()\n                &&& right.is_sorted()\n            },\n        }\n    }// #[verifier::proof] fn sorted_tree_means_sorted_sequence(&self)\n    // TODO(utaal): is self being Spec too restrictive?\n\n}\n\nspec fn sequences_ordered_at_interface(seq1: Seq<int>, seq2: Seq<int>) -> bool {\n    if seq1.len() == 0 || seq2.len() == 0 {\n        true\n    } else {\n        seq1.last() <= seq2[0]\n    }\n}\n\nspec fn sequence_is_sorted(s: Seq<int>) -> bool {\n    forall|i: int, j: int| 0 <= i < j < s.len() ==> s[i] <= s[j]\n}\n\n// TODO: change the default for --multiple-errors\n// we can have --jon-mode :p\n// TODO: shall multiple errors in the same method be sorted?\nproof fn sorted_tree_means_sorted_sequence(tree: Tree)\n    requires\n        tree.is_sorted(),\n    ensures\n        sequence_is_sorted(tree@),\n    decreases tree  // guessed by Dafny ,\n{\n    // reveal_with_fuel(sorted_tree_means_sorted_sequence, 3); // TODO(utaal) ICE revealing current method with fuel panics in AIR\n    if let Tree::Node { left, right, value: _ } = tree {\n        sorted_tree_means_sorted_sequence(*left);  // guessed by Dafny\n        sorted_tree_means_sorted_sequence(*right);  // guessed by Dafny\n    }\n}\n\n#[is_variant]\n#[derive(Eq, PartialEq, Structural)]\nenum TreeSortedness {\n    Unsorted,\n    Empty,\n    Bounded(i64, i64),\n}\n\nfn check_is_sorted_tree(tree: &Tree) -> (ret: TreeSortedness)\n    ensures\n        tree.is_sorted() == !ret.is_Unsorted(),\n        tree.is_Nil() == ret.is_Empty(),\n        if let TreeSortedness::Bounded(l, r) = ret {\n            l == tree@[0] && r == tree@.last()\n        } else {\n            true\n        },\n// TODO: suboptimal span for error message:\n// error: postcondition not satisfied\n//   --> rust_verify/example/summer_school.rs:82:13\n//    |\n// 82 |             TreeSortedness::Unsorted => true,\n//    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => TreeSortedness::Empty,\n        Tree::Node { left, value, right } => {\n            let left_sortedness = check_is_sorted_tree(left);\n            let left_bound;\n            match left_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => left_bound = *value,\n                TreeSortedness::Bounded(ll, lr) => if !(lr <= *value) {\n                    // assert(!sequences_ordered_at_interface(left@, seq![*value as int]));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(left@[0] == ll);\n                    // assert(left@.last() == lr);\n                    // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n                    left_bound = ll;\n                },\n            }\n            // assert(left.is_Nil() ==> left_sortedness.is_Empty());\n            // assert(left_sortedness.is_Empty() ==> left.is_Nil());\n\n            let right_sortedness = check_is_sorted_tree(right);\n            let right_bound;\n            match right_sortedness {\n                TreeSortedness::Unsorted => return TreeSortedness::Unsorted,\n                TreeSortedness::Empty => right_bound = *value,\n                TreeSortedness::Bounded(rl, rr) => if !(*value <= rl) {\n                    // assert(!sequences_ordered_at_interface(seq![*value as int], right@));\n                    // assert(!tree.is_sorted());\n                    return TreeSortedness::Unsorted;\n                } else {\n                    // assert(*value <= rl);\n                    // assert(right@.last() == rr);\n                    // assert(right@[0] == rl);\n                    // assert(seq![*value as int].last() == *value as int);\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    right_bound = rr;\n                },\n            }\n            proof {\n                sorted_tree_means_sorted_sequence(**left);\n                sorted_tree_means_sorted_sequence(**right);\n            }\n            // assert(equal(tree@, left@.add(seq![*value as int]).add(right@)));\n            // assert(tree@.len() > 0);\n            // assert(left.is_sorted());\n            // assert(right.is_sorted());\n            // assert(sequences_ordered_at_interface(left@, seq![*value as int]));\n            // assert(sequences_ordered_at_interface(seq![*value as int], right@));\n            // assert(tree.is_sorted());\n            // TODO cannot use proof variable inside forall/assert_by statements (left)\n            // #[verifier::spec] let left = left;\n            // assert_by(left_bound == tree@[0], {\n            //     if left.is_Nil() {\n            //         assert(left_sortedness.is_Empty());\n            //         assert(*value as int == tree@[0]);\n            //         assert(left_bound == *value);\n            //         assert(left_bound == tree@[0]);\n            //     } else {\n            //         assert(left_bound == tree@[0]);\n            //     }\n            // });\n            assert(right_bound == tree@.last());\n            TreeSortedness::Bounded(left_bound, right_bound)\n        },\n    }\n}\n\nfn find_in_binary_tree(tree: &Tree, needle: i64) -> (ret: bool)\n    requires\n        tree.is_sorted(),\n    ensures\n        ret == tree@.contains(needle as int),\n    decreases tree,\n{\n    match tree {\n        Tree::Nil => false,\n        Tree::Node { left, value, right } => {\n            if needle == *value {\n                assert(tree@[left@.len() as int] == needle);  // trigger\n                true\n            } else if needle < *value {\n                let ret = find_in_binary_tree(left, needle);\n                if ret {\n                    //let idx = choose(|idx: nat| idx < left@.len() && left@.index(nat) == needle); // TODO(utaal): bad error message for stray nat?\n                    proof {\n                        let idx = choose|idx: int| 0 <= idx < left@.len() && left@[idx] == needle;\n                        assert(tree@[idx] == needle);  // trigger\n                    }\n                } else {\n                    proof {\n                        sorted_tree_means_sorted_sequence(**right);\n                    }\n                    //                    assert_forall_by(|idx: nat| {\n                    //                        requires(idx < tree@.len());\n                    //                        ensures(tree@.index(idx) != needle);\n                    //                        if idx < left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else if idx==left@.len() {\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        } else {\n                    //                          assert(tree@.index(idx) == right@.index(idx + left@.len() + 1));    // TODO(utaal): surprising complaint \"expected struct `verus_builtin::int`, found struct `verus_builtin::nat`\"\n                    //                          #[verifier::spec] let right_idx: int = idx - (left@.len() as int + 1);\n                    //                          assert(tree@.index(idx) == right@.index(right_idx));\n                    // assert(sequences_ordered_at_interface(seq![*value as int], right@)); // TODO(utal): How about *value as int is just value@? And then maybe even auto_view that? How cool would that be?\n                    //                          assert(sequences_ordered_at_interface(seq![*value as int], right@));\n                    //                          assert(sequence_is_sorted(right@));\n                    //                          if 0 < right_idx {\n                    //                            assert(right@.index(0) <= right@.index(right_idx));\n                    //                          }\n                    //                          assert((*value as int) <= right@.index(right_idx));\n                    //                          assert(tree@.index(idx) != needle);\n                    //                        }\n                    //                    });\n                }\n                //                assert(ret == tree@.contains(needle));\n\n                ret\n            } else {\n                let ret = find_in_binary_tree(right, needle);\n                proof {\n                    if ret {\n                        let idx = choose|idx: int| 0 <= idx < right@.len() && right@[idx] == needle;\n                        assert(tree@[left@.len() + 1 + idx] == needle);  // trigger\n                    } else {\n                        sorted_tree_means_sorted_sequence(**left);\n                    }\n                }\n                //                assert(ret == tree@.contains(needle));    // TODO(jonh): symmetric case incomplete\n                ret\n            }\n        },\n    }\n}\n\nfn main() {\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/summer_school/chapter-1-22.rs", "verified": true, "metadata": {"original_id": "verus_chapter-1-22_fa6ac1200b1d", "function_name": "", "has_invariants": false, "has_asserts": true}}
{"id": "task_c_missing_ensures_7551c5191921", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3  { 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3 ensures triple_postcond (x as int , result as int) { 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && result / 3 * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nfn triple (x : u32) -> (result : u32) requires triple_precond (x as int) , x <= MAX / 3 ensures triple_postcond (x as int , result as int) { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_100/verina_basic_100_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7551c5191921", "function_name": "triple", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_f3d7341b238d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn concat_precond (a : & Vec < i32 > , b : & Vec < i32 >) -> bool { true }\nspec fn concat_postcond (a : & Vec < i32 > , b : & Vec < i32 > , result : & Vec < i32 >) -> bool { result . len () == a . len () + b . len () && (forall | k : int | 0 <= k < a . len () ==> result [k] == a [k]) && (forall | k : int | 0 <= k < b . len () ==> result [k + a . len ()] == b [k]) }\nfn concat (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : Vec < i32 >) requires concat_precond (a , b) , a . len () + b . len () <= MAX , ensures concat_postcond (a , b , & result) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == a [k] , { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k < j ==> result [k + a . len ()] == b [k] , { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn concat_precond (a : & Vec < i32 > , b : & Vec < i32 >) -> bool { true }\nspec fn concat_postcond (a : & Vec < i32 > , b : & Vec < i32 > , result : & Vec < i32 >) -> bool { result . len () == a . len () + b . len () && (forall | k : int | 0 <= k < a . len () ==> result [k] == a [k]) && (forall | k : int | 0 <= k < b . len () ==> result [k + a . len ()] == b [k]) }\nfn concat (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : Vec < i32 >) requires concat_precond (a , b) , a . len () + b . len () <= MAX , ensures concat_postcond (a , b , & result) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == a [k] , decreases a . len () - i { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k < j ==> result [k + a . len ()] == b [k] , decreases b . len () - j { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn concat_precond (a : & Vec < i32 > , b : & Vec < i32 >) -> bool { true }\nspec fn concat_postcond (a : & Vec < i32 > , b : & Vec < i32 > , result : & Vec < i32 >) -> bool { result . len () == a . len () + b . len () && (forall | k : int | 0 <= k < a . len () ==> result [k] == a [k]) && (forall | k : int | 0 <= k < b . len () ==> result [k + a . len ()] == b [k]) }\nfn concat (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : Vec < i32 >) requires concat_precond (a , b) , a . len () + b . len () <= MAX , ensures concat_postcond (a , b , & result) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == a [k] , decreases a . len () - i { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k < j ==> result [k + a . len ()] == b [k] , decreases b . len () - j { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_83/verina_basic_83_iter_2_current.rs", "verified": true, "metadata": {"original_id": "f3d7341b238d", "function_name": "concat", "bug_type": "missing_decreases"}}
{"id": "task_b_8256f1cd1471", "task": "task_b", "input_text": "pub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)\nrequires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] <= 3 * N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , b : & mut Vec < i32 > , c : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (b) . len () == N , old (c) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] <= 3 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Diffy/verified/res2o_iter_1_current.rs", "verified": true, "metadata": {"original_id": "8256f1cd1471", "function_name": "myfun", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_4f89247f1c4b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e ,  { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) ,  { linear_search_aux (a , e , 0) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) , ensures linear_search_postcond (a , e , result) , { linear_search_aux (a , e , 0) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) , ensures linear_search_postcond (a , e , result) , { linear_search_aux (a , e , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_69/verina_basic_69_iter_1_current.rs", "verified": true, "metadata": {"original_id": "4f89247f1c4b", "function_name": "linear_search", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_48576af6ea0f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/replace_impl.rs", "verified": true, "metadata": {"original_id": "48576af6ea0f", "function_name": "replace", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_e13ed677bb0c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MaxA (a : & [i32]) -> (m : i32)  ensures forall | i : int | 0 <= i < a . len () ==> a [i] <= m , exists | i : int | 0 <= i < a . len () && a [i] == m , { let mut max = a [0] ; let mut index = 1 ; while index < a . len () invariant 0 <= index <= a . len () , forall | i : int | 0 <= i < index ==> a [i] <= max , exists | i : int | 0 <= i < index && a [i] == max , decreases a . len () - index , { if a [index] > max { max = a [index] ; } index += 1 ; } max }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MaxA (a : & [i32]) -> (m : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a [i] <= m , exists | i : int | 0 <= i < a . len () && a [i] == m , { let mut max = a [0] ; let mut index = 1 ; while index < a . len () invariant 0 <= index <= a . len () , forall | i : int | 0 <= i < index ==> a [i] <= max , exists | i : int | 0 <= i < index && a [i] == max , decreases a . len () - index , { if a [index] > max { max = a [index] ; } index += 1 ; } max }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn MaxA (a : & [i32]) -> (m : i32) requires a . len () > 0 , ensures forall | i : int | 0 <= i < a . len () ==> a [i] <= m , exists | i : int | 0 <= i < a . len () && a [i] == m , { let mut max = a [0] ; let mut index = 1 ; while index < a . len () invariant 0 <= index <= a . len () , forall | i : int | 0 <= i < index ==> a [i] <= max , exists | i : int | 0 <= i < index && a [i] == max , decreases a . len () - index , { if a [index] > max { max = a [index] ; } index += 1 ; } max }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "e13ed677bb0c", "function_name": "MaxA", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_06d9796e8a51", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1u32 ; let mut i = 2u32 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1u32 ; let mut i = 2u32 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1u32 ; let mut i = 2u32 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/largest_prime_factor_impl.rs", "verified": true, "metadata": {"original_id": "06d9796e8a51", "function_name": "largest_prime_factor", "bug_type": "missing_decreases"}}
{"id": "task_b_6d83f1c8cca4", "task": "task_b", "input_text": "fn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)\nrequires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) \nensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] % arr2 [j] , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] % arr2 [j]) <= MAX) , decreases arr1 . len () - i { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_module (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] % arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] % arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] % arr2 [j] , forall | j : int | 0 <= j < arr2 . len () ==> arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] % arr2 [j]) <= MAX) , decreases arr1 . len () - i { let mod_result = arr1 [i] % arr2 [i] ; result . push (mod_result) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_616_iter_3_current.rs", "verified": true, "metadata": {"original_id": "6d83f1c8cca4", "function_name": "element_wise_module", "has_invariants": true, "has_asserts": false}}
{"id": "task_a_verified-ironkv_set_lib_ext_v_5235a371a694", "task": "task_a", "input_text": "\nuse vstd::prelude::*;\nuse vstd::seq_lib::*;\nuse vstd::set_lib::*;\n\nverus! {\n/// This fold uses a fixed zero rather than accumulating results in that\n/// argument. This means proofs don't need to generalize over the accumulator,\n/// unlike the Set::fold currently in Verus.\npub open spec fn set_fold<A, B>(s: Set<A>, zero: B, f: spec_fn(B, A) -> B) -> B\n    recommends s.finite()\n    {\n    if s.finite() {\n        if s.len() == 0 {\n            zero\n        } else {\n            let a = s.choose();\n            f(set_fold(s.remove(a), zero, f), a)\n        }\n    } else {\n        zero\n    }\n}\n\npub open spec fn flatten_sets<A>(sets: Set<Set<A>>) -> Set<A>\n{\n    // extra parens are for rust-analyzer\n    Set::new(|a: A| (exists |s: Set<A>| sets.contains(s) && s.contains(a)))\n}\n\npub proof fn flatten_sets_spec<A>(sets: Set<Set<A>>)\n\n{\n}\n\npub proof fn lemma_flatten_sets_insert<A>(sets: Set<Set<A>>, s: Set<A>)\n\n{\n    assert_sets_equal!(flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s));\n}\n\npub proof fn lemma_flatten_sets_union<A>(sets1: Set<Set<A>>, sets2: Set<Set<A>>)\n\n{\n    assert_sets_equal!(flatten_sets(sets1.union(sets2)) ==\n        flatten_sets(sets1).union(flatten_sets(sets2)));\n}\n\npub proof fn lemma_flatten_sets_union_auto<A>()\n\n{\n    }\n\npub proof fn set_map_union<A, B>(s1: Set<A>, s2: Set<A>, f: spec_fn(A) -> B)\n\n{\n    assert_sets_equal!((s1 + s2).map(f) == s1.map(f) + s2.map(f), y => {\n        if s1.map(f).contains(y) {\n            let x = choose |x| s1.contains(x) && f(x) == y;\n\n        } else if s2.map(f).contains(y) {\n            let x = choose |x| s2.contains(x) && f(x) == y;\n\n        }\n    });\n}\n\npub proof fn set_map_union_auto<A, B>()\n\n{\n    }\n\npub proof fn seq_map_values_concat<A, B>(s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B)\n\n{\n    assert_seqs_equal!((s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f), i => {\n        if i < s1.len() {\n\n        } else {\n\n        }\n    });\n}\n\npub proof fn seq_map_values_concat_auto<A, B>()\n\n{\n    }\n\npub open spec fn flatten_set_seq<A>(sets: Seq<Set<A>>) -> Set<A>\n{\n    sets.fold_left(Set::<A>::empty(), |s1: Set<A>, s2: Set<A>| s1.union(s2))\n}\n\npub proof fn lemma_flatten_set_seq_spec<A>(sets: Seq<Set<A>>)\n\n    {\n    if sets.len() == 0 {\n    } else {\n        lemma_flatten_set_seq_spec(sets.drop_last());\n        else {\n\n            }\n        }\n        else {\n\n            }\n        }\n    }\n}\n\npub proof fn lemma_seq_push_to_set<A>(s: Seq<A>, x: A)\n\n{\n    assert_sets_equal!(s.push(x).to_set() == s.to_set().insert(x), elem => {\n        if elem == x {\n\n                let i = choose |i: int| 0 <= i < s.len() && s[i] == elem;\n\n            }\n        }\n    });\n}\n\npub proof fn lemma_set_map_insert<A, B>(s: Set<A>, f: spec_fn(A) -> B, x: A)\n\n{\n    assert_sets_equal!(s.insert(x).map(f) == s.map(f).insert(f(x)), y => {\n        if y == f(x) {\n             // OBSERVE\n            //\n        } else {\n            if s.insert(x).map(f).contains(y) {\n                let x0 = choose |x0| s.contains(x0) && y == f(x0);\n\n            } else {\n                if s.map(f).insert(f(x)).contains(y) {\n                    let x0 = choose |x0| s.contains(x0) && y == f(x0);\n\n                }\n            }\n        }\n    });\n}\n\n// TODO(verus): This consequence should somehow be broadcast from map_values/map\npub proof fn lemma_seq_map_equiv<A, B>(f: spec_fn(A) -> B, g: spec_fn(int, A) -> B)\n\n{\n    }\n\npub proof fn lemma_to_set_distributes_over_addition<A>(s: Seq<A>, t: Seq<A>)\n\n{\n    let left = (s+t).to_set();\n    let right = s.to_set() + t.to_set();\n    else {\n            let ti = choose |ti| 0<=ti<t.len() && t[ti] == x;\n\n        }\n    }\n    assert_sets_equal!(left, right);\n}\n\npub proof fn lemma_to_set_union_auto<A>()\n\n{\n    }\n\nspec fn map_fold<A, B>(s: Set<A>, f: spec_fn(A) -> B) -> Set<B>\n    recommends s.finite()\n{\n    set_fold(s, Set::empty(), |s1: Set<B>, a: A| s1.insert(f(a)))\n}\n\nproof fn map_fold_ok<A, B>(s: Set<A>, f: spec_fn(A) -> B)\n\n    {\n    if s.len() == 0 {\n        return;\n    } else {\n        let a = s.choose();\n        map_fold_ok(s.remove(a), f);\n        return;\n    }\n}\n\nproof fn map_fold_finite<A, B>(s: Set<A>, f: spec_fn(A) -> B)\n\n    {\n    if s.len() == 0 {\n        return;\n    } else {\n        let a = s.choose();\n        map_fold_finite(s.remove(a), f);\n        return;\n    }\n}\n\npub proof fn map_finite<A, B>(s: Set<A>, f: spec_fn(A) -> B)\n\n{\n    map_fold_ok(s, f);\n    map_fold_finite(s, f);\n}\n\npub proof fn map_set_finite_auto<A, B>()\n\n{\n    }\n\npub proof fn lemma_to_set_singleton_auto<A>()\n\n{\n    }\n\npub proof fn lemma_map_values_singleton_auto<A, B>()\n\n{\n}\n\npub proof fn lemma_map_set_singleton_auto<A, B>()\n\n{\n    }\n\npub proof fn lemma_map_seq_singleton_auto<A, B>()\n\n{\n}\n\npub proof fn flatten_sets_singleton_auto<A>()\n\n{\n}\n\n// TODO(Tej): We strongly suspect there is a trigger loop in these auto\n// lemmas somewhere, but it's not easy to see from the profiler yet.\n\n}\n", "target_text": "requires forall |i: int, a: A| #[trigger] g(i, a) == f(a), s.finite(), s.finite(), s.finite()\nensures (forall |e| #[trigger] flatten_sets(sets).contains(e) ==> exists |s| sets.contains(s) && s.contains(e)),\n        (forall |s: Set<A>| #[trigger] sets.contains(s) ==> s.subset_of(flatten_sets(sets))), flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s), flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2)), forall |sets1: Set<Set<A>>, sets2: Set<Set<A>>|\n        #[trigger] flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2)), (s1 + s2).map(f) == s1.map(f) + s2.map(f), forall |s1: Set<A>, s2: Set<A>, f: spec_fn(A) -> B|\n        #[trigger] (s1 + s2).map(f) == s1.map(f) + s2.map(f), (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f), forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n    #[trigger] (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f), (forall |x:A| #[trigger] flatten_set_seq(sets).contains(x) ==>\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x)),\n        (forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) ==>\n            flatten_set_seq(sets).contains(x)), s.push(x).to_set() == s.to_set().insert(x), s.insert(x).map(f) == s.map(f).insert(f(x)), forall |s: Seq<A>| s.map_values(f) == s.map(g), (s+t).to_set() == s.to_set() + t.to_set(), forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set(), map_fold(s, f) =~= s.map(f), map_fold(s, f).finite(), s.map(f).finite(), forall |s: Set<A>, f: spec_fn(A) -> B| s.finite() ==> #[trigger] (s.map(f).finite()), forall |x: A| #[trigger] seq![x].to_set() == set![x], forall |x: A, f: spec_fn(A) -> B| #[trigger] seq![x].map_values(f) =~= seq![f(x)], forall |x: A, f: spec_fn(A) -> B| #[trigger] set![x].map(f) == set![f(x)], forall |x: A, f: spec_fn(A) -> B| #[trigger] seq![x].map_values(f) =~= seq![f(x)], forall |x: Set<A>| #[trigger] flatten_sets(set![x]) =~= x, (forall |x:A| #[trigger] flatten_set_seq(sets).contains(x) ==>\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x)),\n        (forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) ==>\n            flatten_set_seq(sets).contains(x))\n    decreases sets.len(), map_fold(s, f) =~= s.map(f)\n    decreases s.len(), map_fold(s, f).finite()\n    decreases s.len()\ndecreases s.len(), sets.len(), s.len(), s.len()", "full_verified_code": "\nuse vstd::prelude::*;\nuse vstd::seq_lib::*;\nuse vstd::set_lib::*;\n\nverus! {\n/// This fold uses a fixed zero rather than accumulating results in that\n/// argument. This means proofs don't need to generalize over the accumulator,\n/// unlike the Set::fold currently in Verus.\npub open spec fn set_fold<A, B>(s: Set<A>, zero: B, f: spec_fn(B, A) -> B) -> B\n    recommends s.finite()\n    decreases s.len()\n{\n    if s.finite() {\n        if s.len() == 0 {\n            zero\n        } else {\n            let a = s.choose();\n            f(set_fold(s.remove(a), zero, f), a)\n        }\n    } else {\n        zero\n    }\n}\n\npub open spec fn flatten_sets<A>(sets: Set<Set<A>>) -> Set<A>\n{\n    // extra parens are for rust-analyzer\n    Set::new(|a: A| (exists |s: Set<A>| sets.contains(s) && s.contains(a)))\n}\n\npub proof fn flatten_sets_spec<A>(sets: Set<Set<A>>)\n    ensures\n        (forall |e| #[trigger] flatten_sets(sets).contains(e) ==> exists |s| sets.contains(s) && s.contains(e)),\n        (forall |s: Set<A>| #[trigger] sets.contains(s) ==> s.subset_of(flatten_sets(sets)))\n{\n}\n\npub proof fn lemma_flatten_sets_insert<A>(sets: Set<Set<A>>, s: Set<A>)\n    ensures flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s)\n{\n    assert_sets_equal!(flatten_sets(sets.insert(s)) == flatten_sets(sets).union(s));\n}\n\npub proof fn lemma_flatten_sets_union<A>(sets1: Set<Set<A>>, sets2: Set<Set<A>>)\n    ensures flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2))\n{\n    assert_sets_equal!(flatten_sets(sets1.union(sets2)) ==\n        flatten_sets(sets1).union(flatten_sets(sets2)));\n}\n\npub proof fn lemma_flatten_sets_union_auto<A>()\n    ensures forall |sets1: Set<Set<A>>, sets2: Set<Set<A>>|\n        #[trigger] flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2))\n{\n    assert forall |sets1: Set<Set<A>>, sets2: Set<Set<A>>|\n        #[trigger] flatten_sets(sets1.union(sets2)) == flatten_sets(sets1).union(flatten_sets(sets2)) by {\n        lemma_flatten_sets_union(sets1, sets2);\n    }\n}\n\npub proof fn set_map_union<A, B>(s1: Set<A>, s2: Set<A>, f: spec_fn(A) -> B)\n    ensures (s1 + s2).map(f) == s1.map(f) + s2.map(f)\n{\n    assert_sets_equal!((s1 + s2).map(f) == s1.map(f) + s2.map(f), y => {\n        if s1.map(f).contains(y) {\n            let x = choose |x| s1.contains(x) && f(x) == y;\n            assert((s1 + s2).contains(x));\n        } else if s2.map(f).contains(y) {\n            let x = choose |x| s2.contains(x) && f(x) == y;\n            assert((s1 + s2).contains(x));\n        }\n    });\n}\n\npub proof fn set_map_union_auto<A, B>()\n    ensures forall |s1: Set<A>, s2: Set<A>, f: spec_fn(A) -> B|\n        #[trigger] (s1 + s2).map(f) == s1.map(f) + s2.map(f)\n{\n    assert forall |s1: Set<A>, s2: Set<A>, f: spec_fn(A) -> B|\n        #[trigger] ((s1 + s2).map(f)) == s1.map(f) + s2.map(f) by {\n        set_map_union(s1, s2, f);\n    }\n}\n\npub proof fn seq_map_values_concat<A, B>(s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B)\n    ensures (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f)\n{\n    assert_seqs_equal!((s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f), i => {\n        if i < s1.len() {\n            assert((s1+s2)[i] == s1[i]);\n        } else {\n            assert((s1+s2)[i] == s2[i - s1.len()]);\n        }\n    });\n}\n\npub proof fn seq_map_values_concat_auto<A, B>()\nensures forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n    #[trigger] (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f)\n{\n    assert forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n        #[trigger] ((s1 + s2).map_values(f)) == s1.map_values(f) + s2.map_values(f) by {\n        seq_map_values_concat(s1, s2, f);\n    }\n}\n\npub open spec fn flatten_set_seq<A>(sets: Seq<Set<A>>) -> Set<A>\n{\n    sets.fold_left(Set::<A>::empty(), |s1: Set<A>, s2: Set<A>| s1.union(s2))\n}\n\npub proof fn lemma_flatten_set_seq_spec<A>(sets: Seq<Set<A>>)\n    ensures\n        (forall |x:A| #[trigger] flatten_set_seq(sets).contains(x) ==>\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x)),\n        (forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) ==>\n            flatten_set_seq(sets).contains(x))\n    decreases sets.len()\n{\n    if sets.len() == 0 {\n    } else {\n        lemma_flatten_set_seq_spec(sets.drop_last());\n        assert forall |x:A| flatten_set_seq(sets).contains(x) implies\n            exists |i: int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) by {\n            if sets.last().contains(x) {\n            } else {\n                assert(flatten_set_seq(sets.drop_last()).contains(x));\n            }\n        }\n        assert forall |x:A, i:int| 0 <= i < sets.len() && #[trigger] sets[i].contains(x) implies\n            flatten_set_seq(sets).contains(x) by {\n            if i == sets.len() - 1 {\n                assert(sets.last().contains(x));\n                assert(flatten_set_seq(sets) == flatten_set_seq(sets.drop_last()).union(sets.last()));\n            } else {\n                assert(0 <= i < sets.drop_last().len() && sets.drop_last()[i].contains(x));\n            }\n        }\n    }\n}\n\n\npub proof fn lemma_seq_push_to_set<A>(s: Seq<A>, x: A)\n    ensures s.push(x).to_set() == s.to_set().insert(x)\n{\n    assert_sets_equal!(s.push(x).to_set() == s.to_set().insert(x), elem => {\n        if elem == x {\n            assert(s.push(x)[s.len() as int] == x);\n            assert(s.push(x).contains(x))\n        } else {\n            if s.to_set().insert(x).contains(elem) {\n                assert(s.to_set().contains(elem));\n                let i = choose |i: int| 0 <= i < s.len() && s[i] == elem;\n                assert(s.push(x)[i] == elem);\n            }\n        }\n    });\n}\n\npub proof fn lemma_set_map_insert<A, B>(s: Set<A>, f: spec_fn(A) -> B, x: A)\n    ensures s.insert(x).map(f) == s.map(f).insert(f(x))\n{\n    assert_sets_equal!(s.insert(x).map(f) == s.map(f).insert(f(x)), y => {\n        if y == f(x) {\n            assert(s.insert(x).contains(x)); // OBSERVE\n            // assert(s.map(f).insert(f(x)).contains(f(x)));\n        } else {\n            if s.insert(x).map(f).contains(y) {\n                let x0 = choose |x0| s.contains(x0) && y == f(x0);\n                assert(s.map(f).contains(y));\n            } else {\n                if s.map(f).insert(f(x)).contains(y) {\n                    let x0 = choose |x0| s.contains(x0) && y == f(x0);\n                    assert(s.map(f).contains(y));\n                    assert(s.insert(x).contains(x0));\n                }\n            }\n        }\n    });\n}\n\n// TODO(verus): This consequence should somehow be broadcast from map_values/map\npub proof fn lemma_seq_map_equiv<A, B>(f: spec_fn(A) -> B, g: spec_fn(int, A) -> B)\nrequires\n    forall |i: int, a: A| #[trigger] g(i, a) == f(a)\nensures\n    forall |s: Seq<A>| s.map_values(f) == s.map(g)\n{\n    assert forall |s: Seq<A>| s.map_values(f) == s.map(g) by {\n        assert_seqs_equal!(s.map_values(f), s.map(g));\n    }\n}\n\npub proof fn lemma_to_set_distributes_over_addition<A>(s: Seq<A>, t: Seq<A>)\nensures (s+t).to_set() == s.to_set() + t.to_set()\n{\n    let left = (s+t).to_set();\n    let right = s.to_set() + t.to_set();\n    assert forall |x| right.contains(x) implies left.contains(x) by {\n        assert(s.to_set()+t.to_set() == s.to_set().union(t.to_set()));\n        if s.to_set().contains(x) {\n            let si = choose |si| 0<=si<s.len() && s[si] == x;\n            assert((s+t)[si] == x);\n        } else {\n            let ti = choose |ti| 0<=ti<t.len() && t[ti] == x;\n            assert((s+t)[s.len() + ti] == x);\n        }\n    }\n    assert_sets_equal!(left, right);\n}\n\n\npub proof fn lemma_to_set_union_auto<A>()\n    ensures forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set()\n{\n    assert forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set() by {\n        lemma_to_set_distributes_over_addition(s, t);\n    }\n}\n\nspec fn map_fold<A, B>(s: Set<A>, f: spec_fn(A) -> B) -> Set<B>\n    recommends s.finite()\n{\n    set_fold(s, Set::empty(), |s1: Set<B>, a: A| s1.insert(f(a)))\n}\n\nproof fn map_fold_ok<A, B>(s: Set<A>, f: spec_fn(A) -> B)\n    requires s.finite()\n    ensures map_fold(s, f) =~= s.map(f)\n    decreases s.len()\n{\n    if s.len() == 0 {\n        return;\n    } else {\n        let a = s.choose();\n        map_fold_ok(s.remove(a), f);\n        return;\n    }\n}\n\nproof fn map_fold_finite<A, B>(s: Set<A>, f: spec_fn(A) -> B)\n    requires s.finite()\n    ensures map_fold(s, f).finite()\n    decreases s.len()\n{\n    if s.len() == 0 {\n        return;\n    } else {\n        let a = s.choose();\n        map_fold_finite(s.remove(a), f);\n        return;\n    }\n}\n\npub proof fn map_finite<A, B>(s: Set<A>, f: spec_fn(A) -> B)\nrequires\n    s.finite(),\nensures\n    s.map(f).finite(),\n{\n    map_fold_ok(s, f);\n    map_fold_finite(s, f);\n}\n\npub proof fn map_set_finite_auto<A, B>()\nensures\n    forall |s: Set<A>, f: spec_fn(A) -> B| s.finite() ==> #[trigger] (s.map(f).finite()),\n{\n    assert forall |s: Set<A>, f: spec_fn(A) -> B| s.finite() implies #[trigger] s.map(f).finite() by {\n        map_finite(s, f);\n    }\n}\n\npub proof fn lemma_to_set_singleton_auto<A>()\nensures\n    forall |x: A| #[trigger] seq![x].to_set() == set![x],\n{\n    assert forall |x: A| #[trigger] seq![x].to_set() =~= set![x] by {\n        assert(seq![x][0] == x);\n    }\n}\n\npub proof fn lemma_map_values_singleton_auto<A, B>()\nensures\n    forall |x: A, f: spec_fn(A) -> B| #[trigger] seq![x].map_values(f) =~= seq![f(x)],\n{\n}\n\npub proof fn lemma_map_set_singleton_auto<A, B>()\nensures\n    forall |x: A, f: spec_fn(A) -> B| #[trigger] set![x].map(f) == set![f(x)],\n{\n    assert forall |x: A, f: spec_fn(A) -> B| #[trigger] set![x].map(f) =~= set![f(x)] by {\n        assert(set![x].contains(x));\n    }\n}\n\npub proof fn lemma_map_seq_singleton_auto<A, B>()\nensures\n    forall |x: A, f: spec_fn(A) -> B| #[trigger] seq![x].map_values(f) =~= seq![f(x)],\n{\n}\n\n\npub proof fn flatten_sets_singleton_auto<A>()\nensures\n    forall |x: Set<A>| #[trigger] flatten_sets(set![x]) =~= x,\n{\n}\n\n// TODO(Tej): We strongly suspect there is a trigger loop in these auto\n// lemmas somewhere, but it's not easy to see from the profiler yet.\n\n}\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verified-ironkv/ironsht/src/verus_extra/set_lib_ext_v.rs", "verified": true, "metadata": {"original_id": "verified-ironkv_set_lib_ext_v_5235a371a694", "function_name": "", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_c_missing_ensures_7809d6963c00", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : & [i32]) -> (res : i32) requires a . len () > 0 ,  { let mut max_val = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 0 < idx <= a . len () , exists | i : int | 0 <= i < idx && max_val == a [i] , forall | i : int | 0 <= i < idx ==> a [i] <= max_val , decreases a . len () - idx , { if a [idx] > max_val { max_val = a [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : & [i32]) -> (res : i32) requires a . len () > 0 , ensures exists | i : int | 0 <= i < a . len () && res == a [i] , forall | i : int | 0 <= i < a . len () ==> a [i] <= res , { let mut max_val = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 0 < idx <= a . len () , exists | i : int | 0 <= i < idx && max_val == a [i] , forall | i : int | 0 <= i < idx ==> a [i] <= max_val , decreases a . len () - idx , { if a [idx] > max_val { max_val = a [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn max (a : & [i32]) -> (res : i32) requires a . len () > 0 , ensures exists | i : int | 0 <= i < a . len () && res == a [i] , forall | i : int | 0 <= i < a . len () ==> a [i] <= res , { let mut max_val = a [0] ; let mut idx = 1 ; while idx < a . len () invariant 0 < idx <= a . len () , exists | i : int | 0 <= i < idx && max_val == a [i] , forall | i : int | 0 <= i < idx ==> a [i] <= max_val , decreases a . len () - idx , { if a [idx] > max_val { max_val = a [idx] ; } idx += 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/vericoding_dafny_to_verus_specs/numpy_specs/np_max_impl.rs", "verified": true, "metadata": {"original_id": "7809d6963c00", "function_name": "max", "bug_type": "missing_ensures"}}
{"id": "task_b_7abf24a196b4", "task": "task_b", "input_text": "fn is_peak_valley (lst : Vec < i32 >) -> (result : bool)\nrequires is_peak_valley_precond (lst @)\nensures is_peak_valley_postcond (lst @ , result)", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_peak_valley_precond (lst : Seq < i32 >) -> bool { true }\nspec fn is_peak_valley_postcond (lst : Seq < i32 > , result : bool) -> bool { (lst . len () <= 2 ==> ! result) }\nfn is_peak_valley (lst : Vec < i32 >) -> (result : bool) requires is_peak_valley_precond (lst @) ensures is_peak_valley_postcond (lst @ , result) { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_22/verina_advanced_22_iter_0_original.rs", "verified": true, "metadata": {"original_id": "7abf24a196b4", "function_name": "is_peak_valley", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_invariant_798a03f8287d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len ()  { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , j : int | 0 <= k < j < result . len () ==> result [k] != result [j] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn intersection (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) ensures forall | i : int | 0 <= i < result . len () ==> (arr1 @ . contains (# [trigger] result [i]) && arr2 @ . contains (# [trigger] result [i] ,)) , forall | i : int , j : int | 0 <= i < j < result . len () ==> result [i] != result [j] , { let mut result = Vec :: new () ; for i in 0 .. arr1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (arr1 @ . contains (# [trigger] result [k]) && arr2 @ . contains (# [trigger] result [k] ,)) , forall | k : int , j : int | 0 <= k < j < result . len () ==> result [k] != result [j] , { let elem = arr1 [i] ; if contains (arr2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "798a03f8287d", "function_name": "intersection", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_c7e6da5e5ec9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 ,  { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 ,  { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> bool { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } largest }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/largest_prime_factor_impl.rs", "verified": true, "metadata": {"original_id": "c7e6da5e5ec9", "function_name": "largest_prime_factor", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_ccb6e3e74b2d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn secondSmallestAux (s : & Vec < i32 > , i : usize , minIdx : usize , secondIdx : usize) -> (result : i32) requires s . len () > 1 , i <= s . len () , minIdx < s . len () , secondIdx < s . len () , minIdx != secondIdx , minIdx < i , secondIdx < i , ensures exists | j : int | 0 <= j < s . len () && s [j] == result , decreases s . len () - i , { if i == s . len () { if s [minIdx] <= s [secondIdx] { s [secondIdx] } else { s [minIdx] } } else { let current = s [i] ; let min_val = s [minIdx] ; let second_val = s [secondIdx] ; if current < min_val { secondSmallestAux (s , i + 1 , i , minIdx) } else if current < second_val { secondSmallestAux (s , i + 1 , minIdx , i) } else { secondSmallestAux (s , i + 1 , minIdx , secondIdx) } } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_40/verina_basic_40_impl.rs", "verified": true, "metadata": {"original_id": "ccb6e3e74b2d", "function_name": "secondSmallestAux", "bug_type": "missing_decreases"}}
{"id": "task_b_20597967dd20", "task": "task_b", "input_text": "fn replace_chars (str1 : & [u8] , old_char : u8 , new_char : u8) -> (result : Vec < u8 >)\nensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == (if str1 [i] == old_char", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_chars (str1 : & [u8] , old_char : u8 , new_char : u8) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == (if str1 [i] == old_char { new_char } else { str1 [i] }) , { let mut result_str = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , result_str . len () == index , forall | i : int | 0 <= i < index ==> result_str @ [i] == (if str1 [i] == old_char { new_char } else { str1 [i] }) , decreases str1 . len () - index { if str1 [index] == old_char { result_str . push (new_char) ; } else { result_str . push (str1 [index]) ; } index += 1 ; } result_str }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_chars (str1 : & [u8] , old_char : u8 , new_char : u8) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == (if str1 [i] == old_char { new_char } else { str1 [i] }) , { let mut result_str = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , result_str . len () == index , forall | i : int | 0 <= i < index ==> result_str @ [i] == (if str1 [i] == old_char { new_char } else { str1 [i] }) , decreases str1 . len () - index { if str1 [index] == old_char { result_str . push (new_char) ; } else { result_str . push (str1 [index]) ; } index += 1 ; } result_str }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_474_iter_2_current.rs", "verified": true, "metadata": {"original_id": "20597967dd20", "function_name": "replace_chars", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_requires_19a0ce8547b0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize)  ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn max_dafny_lsp (a : & [i32]) -> (x : usize) requires a . len () > 0 , ensures 0 <= x < a . len () , forall | k : int | 0 <= k < a . len () ==> a [k] <= a [x as int] , { let mut max_idx = 0 ; let mut i = 1 ; while i < a . len () invariant 0 <= max_idx < a . len () , 1 <= i <= a . len () , forall | k : int | 0 <= k < i ==> a [k] <= a [max_idx as int] , decreases a . len () - i , { if a [i] > a [max_idx] { max_idx = i ; } i += 1 ; } max_idx }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/max_dafny_lsp_iter_2_current.rs", "verified": true, "metadata": {"original_id": "19a0ce8547b0", "function_name": "max_dafny_lsp", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_2879ebdad2ed", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSorta (a : & mut Vec < int > , c : usize , f : usize)  ensures a . len () == old (a) . len () , { }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSorta (a : & mut Vec < int > , c : usize , f : usize) requires 0 <= c <= f <= old (a) . len () , ensures a . len () == old (a) . len () , { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubbleSorta (a : & mut Vec < int > , c : usize , f : usize) requires 0 <= c <= f <= old (a) . len () , ensures a . len () == old (a) . len () , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseBubbleSort/verus_code.rs", "verified": true, "metadata": {"original_id": "2879ebdad2ed", "function_name": "bubbleSorta", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_c6f8ad5e9d11", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool)  { }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn havoc_inline_post (v : & mut Vec < u32 > , a : u32 , b : bool) requires forall | k : int | 0 <= k < old (v) . len () ==> old (v) [k] > 0 , a > 0 , b == false , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/autoverus/Misc/verified/havoc_inline_post.rs", "verified": true, "metadata": {"original_id": "c6f8ad5e9d11", "function_name": "havoc_inline_post", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_db82da583b3b", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn xor_strings (a : Vec < char > , b : Vec < char >) -> (result : Vec < char >)  ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == (if a [i] == b [i] { '0' } else { '1' }) { let mut result : Vec < char > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == (if a [j] == b [j] { '0' } else { '1' }) decreases a . len () - i { let bit = if a [i] == b [i] { '0' } else { '1' } ; result . push (bit) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn xor_strings (a : Vec < char > , b : Vec < char >) -> (result : Vec < char >) requires a . len () == b . len () , forall | i : int | 0 <= i && i < a . len () ==> (a [i] == '0' || a [i] == '1') , forall | i : int | 0 <= i && i < b . len () ==> (b [i] == '0' || b [i] == '1') ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == (if a [i] == b [i] { '0' } else { '1' }) { let mut result : Vec < char > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == (if a [j] == b [j] { '0' } else { '1' }) decreases a . len () - i { let bit = if a [i] == b [i] { '0' } else { '1' } ; result . push (bit) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn xor_strings (a : Vec < char > , b : Vec < char >) -> (result : Vec < char >) requires a . len () == b . len () , forall | i : int | 0 <= i && i < a . len () ==> (a [i] == '0' || a [i] == '1') , forall | i : int | 0 <= i && i < b . len () ==> (b [i] == '0' || b [i] == '1') ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == (if a [i] == b [i] { '0' } else { '1' }) { let mut result : Vec < char > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == (if a [j] == b [j] { '0' } else { '1' }) decreases a . len () - i { let bit = if a [i] == b [i] { '0' } else { '1' } ; result . push (bit) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/string_xor_impl.rs", "verified": true, "metadata": {"original_id": "db82da583b3b", "function_name": "xor_strings", "bug_type": "missing_requires"}}
{"id": "task_b_a390392acdae", "task": "task_b", "input_text": "fn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool)\nrequires has_common_element_precond (a @ , b @) \nensures has_common_element_postcond (a @ , b @ , result) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_9/verina_basic_9_impl.rs", "verified": true, "metadata": {"original_id": "a390392acdae", "function_name": "has_common_element", "has_invariants": true, "has_asserts": false}}
{"id": "task_a_ad595921fb84", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant forall | j : int | 0 <= j < i ==> a [j] != x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a [j] != x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/remove_elements_impl.rs", "verified": true, "metadata": {"original_id": "ad595921fb84", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_c_missing_requires_81ce8fdfe6ea", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (m : i32 , fuel : u32) -> (result : bool)  { if fuel == 0 { false } else if m == 1 { true } else if m % 2 == 1 { false } else { aux (m / 2 , fuel - 1) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (m : i32 , fuel : u32) -> (result : bool) requires m > 0 , decreases fuel { if fuel == 0 { false } else if m == 1 { true } else if m % 2 == 1 { false } else { aux (m / 2 , fuel - 1) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn aux (m : i32 , fuel : u32) -> (result : bool) requires m > 0 , decreases fuel { if fuel == 0 { false } else if m == 1 { true } else if m % 2 == 1 { false } else { aux (m / 2 , fuel - 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_23/verina_advanced_23_impl.rs", "verified": true, "metadata": {"original_id": "81ce8fdfe6ea", "function_name": "aux", "bug_type": "missing_requires"}}
{"id": "task_a_c9dce987a094", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)   { let mut i = 2 ; while i < n  { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i\ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/invariants_removed/is_non_prime_iter_3_current.rs", "verified": true, "metadata": {"original_id": "c9dce987a094", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_ensures_verus_log_43fc5e898ac9", "task": "task_c", "input_text": "//! This file implements logs with entries of type `T` using a custom\n//! resource algebra.\n//!\n//! To use it, use LogResource::<T>::alloc(), which will create a\n//! fresh log and return a `LogResource<T>` representing full\n//! authority to append to the log. Here's example code for this:\n//!\n//! ```\n//! let tracked full_auth = LogResource::<int>::alloc();\n//! assert(full_auth@ is FullAuthority);\n//! assert(full_auth@.log().len() == 0);\n//! ```\n//!\n//! You can use the full authority you obtain via `alloc()` to append\n//! to the log, as in the following example:\n//!\n//! ```\n//! proof { full_auth.append(42); }\n//! proof { full_auth.append(86); }\n//! assert(full_auth@.log().len() == 2);\n//! assert(full_auth@.log()[0] == 42);\n//! assert(full_auth@.log()[1] == 86);\n//! ```\n//!\n//! If desired, you can split a `LogResource` representing full\n//! authority into two half authorities using `split`. You may want to\n//! do this if you're stashing half the authority in an invariant.\n//! Here's an example use of `LogResource::split()`; note that it\n//! consumes the resource.\n//!\n//! ```\n//! let tracked (half_auth1, half_auth2) = full_auth.split();\n//! assert(half_auth1@ == half_auth2@);\n//! assert(half_auth1@ is HalfAuthority);\n//! ```\n//!\n//! You can use two half authorities to append to the log using\n//! `append_using_two_halves` as in the following example:\n//!\n//! ```\n//! proof { half_auth1.append_using_two_halves(&mut half_auth2, 17); }\n//! assert(half_auth1@.log().len() == 3);\n//! assert(half_auth1@.log()[2] == 17);\n//! assert(half_auth2@ == half_auth1@);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\npub enum LogResourceValue<T> {\n    PrefixKnowledge { prefix: Seq<T> },\n    HalfAuthority { log: Seq<T> },\n    FullAuthority { log: Seq<T> },\n    Invalid,\n}\n\npub open spec fn is_prefix<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n    &&& s1.len() <= s2.len()\n    &&& forall|i| 0 <= i < s1.len() ==> s1[i] == s2[i]\n}\n\nimpl<T> PCM for LogResourceValue<T> {\n    open spec fn valid(self) -> bool {\n        &&& !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (\n                Self::PrefixKnowledge { prefix: prefix1 },\n                Self::PrefixKnowledge { prefix: prefix2 },\n            ) => if is_prefix(prefix1, prefix2) {\n                other\n            } else {\n                if is_prefix(prefix2, prefix1) {\n                    self\n                } else {\n                    Self::Invalid\n                }\n            },\n            (Self::PrefixKnowledge { prefix }, Self::HalfAuthority { log }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                other\n            } else {\n                Self::Invalid\n            },\n            (Self::HalfAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                self\n            } else {\n                Self::Invalid\n            },\n            (Self::PrefixKnowledge { prefix }, Self::FullAuthority { log }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                other\n            } else {\n                Self::Invalid\n            },\n            (Self::FullAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                self\n            } else {\n                Self::Invalid\n            },\n            (Self::HalfAuthority { log: log1 }, Self::HalfAuthority { log: log2 }) => if log1\n                == log2 {\n                Self::FullAuthority { log: log1 }\n            } else {\n                Self::Invalid\n            },\n            (_, _) => Self::Invalid,\n        }\n    }\n\n    open spec fn unit() -> Self {\n        Self::PrefixKnowledge { prefix: Seq::<T>::empty() }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n        assert(forall|log1: Seq<T>, log2: Seq<T>|\n            is_prefix(log1, log2) && is_prefix(log2, log1) ==> log1 =~= log2);\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n        assert(forall|log1: Seq<T>, log2: Seq<T>|\n            is_prefix(log1, log2) && is_prefix(log2, log1) <==> log1 =~= log2);\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn op_unit(a: Self) {\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\nimpl<T> LogResourceValue<T> {\n    pub open spec fn log(self) -> Seq<T> {\n        match self {\n            LogResourceValue::PrefixKnowledge { prefix } => prefix,\n            LogResourceValue::HalfAuthority { log } => log,\n            LogResourceValue::FullAuthority { log } => log,\n            LogResourceValue::Invalid => Seq::<T>::empty(),\n        }\n    }\n\n    proof fn op_unit(a: Self) {\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct LogResource<T> {\n    r: Resource<LogResourceValue<T>>,\n}\n\nimpl<T> LogResource<T> {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> LogResourceValue<T> {\n        self.r.value()\n    }\n\n    pub proof fn alloc() -> (tracked result: LogResource<T>)\n\n    {\n        let v = LogResourceValue::<T>::FullAuthority { log: Seq::<T>::empty() };\n        let tracked r = Resource::<LogResourceValue::<T>>::alloc(v);\n        Self { r }\n    }\n\n    pub proof fn split(tracked self) -> (tracked halves: (Self, Self))\n        requires\n            self@ is FullAuthority,\n        {\n                let (half1, half2) = halves;\n                &&& half1@ is HalfAuthority\n                &&& half2@ is HalfAuthority\n                &&& half1.id() == half2.id() == self.id()\n                &&& half1@.log() == self@.log()\n                &&& half2@ == half1@\n            }),\n    {\n        let half_value = LogResourceValue::<T>::HalfAuthority { log: self@.log() };\n        let tracked (half1, half2) = self.r.split(half_value, half_value);\n        (Self { r: half1 }, Self { r: half2 })\n    }\n\n    pub proof fn append(tracked &mut self, v: T)\n        requires\n            old(self)@ is FullAuthority,\n\n    {\n        let value = LogResourceValue::<T>::FullAuthority { log: self@.log() + seq![v] };\n        update_mut(&mut self.r, value);\n    }\n\n    pub proof fn append_using_two_halves(tracked &mut self, tracked other: &mut Self, v: T)\n        requires\n            old(self)@ is HalfAuthority,\n            old(other)@ is HalfAuthority,\n            old(self).id() == old(other).id(),\n\n    {\n        self.r.validate_2(&other.r);\n        let new_log = self@.log() + seq![v];\n        let new_value = LogResourceValue::<T>::HalfAuthority { log: new_log };\n        update_and_redistribute(&mut self.r, &mut other.r, new_value, new_value);\n    }\n\n    pub proof fn extract_prefix_knowledge(tracked &self) -> (tracked out: Self)\n\n    {\n        let v = LogResourceValue::<T>::PrefixKnowledge { prefix: self@.log() };\n        let tracked r = copy_duplicable_part(&self.r, v);\n        Self { r }\n    }\n\n    pub proof fn deduce_prefix_relation(tracked &mut self, tracked other: &Self)\n        requires\n            old(self).id() == other.id(),\n\n    {\n        self.r.validate_2(&other.r)\n    }\n}\n\npub fn main() {\n    let tracked full_auth = LogResource::<int>::alloc();\n    assert(full_auth@ is FullAuthority);\n    assert(full_auth@.log().len() == 0);\n    proof {\n        full_auth.append(42);\n    }\n    proof {\n        full_auth.append(86);\n    }\n    assert(full_auth@.log().len() == 2);\n    assert(full_auth@.log()[0] == 42);\n    assert(full_auth@.log()[1] == 86);\n    let tracked (half_auth1, half_auth2) = full_auth.split();\n    assert(half_auth1@ == half_auth2@);\n    assert(half_auth1@ is HalfAuthority);\n    proof {\n        half_auth1.append_using_two_halves(&mut half_auth2, 17);\n    }\n    assert(half_auth1@.log().len() == 3);\n    assert(half_auth1@.log()[2] == 17);\n    assert(half_auth2@ == half_auth1@);\n}\n\n} // verus!\n", "target_text": "//! This file implements logs with entries of type `T` using a custom\n//! resource algebra.\n//!\n//! To use it, use LogResource::<T>::alloc(), which will create a\n//! fresh log and return a `LogResource<T>` representing full\n//! authority to append to the log. Here's example code for this:\n//!\n//! ```\n//! let tracked full_auth = LogResource::<int>::alloc();\n//! assert(full_auth@ is FullAuthority);\n//! assert(full_auth@.log().len() == 0);\n//! ```\n//!\n//! You can use the full authority you obtain via `alloc()` to append\n//! to the log, as in the following example:\n//!\n//! ```\n//! proof { full_auth.append(42); }\n//! proof { full_auth.append(86); }\n//! assert(full_auth@.log().len() == 2);\n//! assert(full_auth@.log()[0] == 42);\n//! assert(full_auth@.log()[1] == 86);\n//! ```\n//!\n//! If desired, you can split a `LogResource` representing full\n//! authority into two half authorities using `split`. You may want to\n//! do this if you're stashing half the authority in an invariant.\n//! Here's an example use of `LogResource::split()`; note that it\n//! consumes the resource.\n//!\n//! ```\n//! let tracked (half_auth1, half_auth2) = full_auth.split();\n//! assert(half_auth1@ == half_auth2@);\n//! assert(half_auth1@ is HalfAuthority);\n//! ```\n//!\n//! You can use two half authorities to append to the log using\n//! `append_using_two_halves` as in the following example:\n//!\n//! ```\n//! proof { half_auth1.append_using_two_halves(&mut half_auth2, 17); }\n//! assert(half_auth1@.log().len() == 3);\n//! assert(half_auth1@.log()[2] == 17);\n//! assert(half_auth2@ == half_auth1@);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\npub enum LogResourceValue<T> {\n    PrefixKnowledge { prefix: Seq<T> },\n    HalfAuthority { log: Seq<T> },\n    FullAuthority { log: Seq<T> },\n    Invalid,\n}\n\npub open spec fn is_prefix<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n    &&& s1.len() <= s2.len()\n    &&& forall|i| 0 <= i < s1.len() ==> s1[i] == s2[i]\n}\n\nimpl<T> PCM for LogResourceValue<T> {\n    open spec fn valid(self) -> bool {\n        &&& !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (\n                Self::PrefixKnowledge { prefix: prefix1 },\n                Self::PrefixKnowledge { prefix: prefix2 },\n            ) => if is_prefix(prefix1, prefix2) {\n                other\n            } else {\n                if is_prefix(prefix2, prefix1) {\n                    self\n                } else {\n                    Self::Invalid\n                }\n            },\n            (Self::PrefixKnowledge { prefix }, Self::HalfAuthority { log }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                other\n            } else {\n                Self::Invalid\n            },\n            (Self::HalfAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                self\n            } else {\n                Self::Invalid\n            },\n            (Self::PrefixKnowledge { prefix }, Self::FullAuthority { log }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                other\n            } else {\n                Self::Invalid\n            },\n            (Self::FullAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                self\n            } else {\n                Self::Invalid\n            },\n            (Self::HalfAuthority { log: log1 }, Self::HalfAuthority { log: log2 }) => if log1\n                == log2 {\n                Self::FullAuthority { log: log1 }\n            } else {\n                Self::Invalid\n            },\n            (_, _) => Self::Invalid,\n        }\n    }\n\n    open spec fn unit() -> Self {\n        Self::PrefixKnowledge { prefix: Seq::<T>::empty() }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n        assert(forall|log1: Seq<T>, log2: Seq<T>|\n            is_prefix(log1, log2) && is_prefix(log2, log1) ==> log1 =~= log2);\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n        assert(forall|log1: Seq<T>, log2: Seq<T>|\n            is_prefix(log1, log2) && is_prefix(log2, log1) <==> log1 =~= log2);\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn op_unit(a: Self) {\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\nimpl<T> LogResourceValue<T> {\n    pub open spec fn log(self) -> Seq<T> {\n        match self {\n            LogResourceValue::PrefixKnowledge { prefix } => prefix,\n            LogResourceValue::HalfAuthority { log } => log,\n            LogResourceValue::FullAuthority { log } => log,\n            LogResourceValue::Invalid => Seq::<T>::empty(),\n        }\n    }\n\n    proof fn op_unit(a: Self) {\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct LogResource<T> {\n    r: Resource<LogResourceValue<T>>,\n}\n\nimpl<T> LogResource<T> {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> LogResourceValue<T> {\n        self.r.value()\n    }\n\n    pub proof fn alloc() -> (tracked result: LogResource<T>)\n        ensures\n            result@ is FullAuthority,\n            result@.log() == Seq::<T>::empty(),\n    {\n        let v = LogResourceValue::<T>::FullAuthority { log: Seq::<T>::empty() };\n        let tracked r = Resource::<LogResourceValue::<T>>::alloc(v);\n        Self { r }\n    }\n\n    pub proof fn split(tracked self) -> (tracked halves: (Self, Self))\n        requires\n            self@ is FullAuthority,\n        ensures\n            ({\n                let (half1, half2) = halves;\n                &&& half1@ is HalfAuthority\n                &&& half2@ is HalfAuthority\n                &&& half1.id() == half2.id() == self.id()\n                &&& half1@.log() == self@.log()\n                &&& half2@ == half1@\n            }),\n    {\n        let half_value = LogResourceValue::<T>::HalfAuthority { log: self@.log() };\n        let tracked (half1, half2) = self.r.split(half_value, half_value);\n        (Self { r: half1 }, Self { r: half2 })\n    }\n\n    pub proof fn append(tracked &mut self, v: T)\n        requires\n            old(self)@ is FullAuthority,\n        ensures\n            self@ is FullAuthority,\n            self.id() == old(self).id(),\n            self@.log() == old(self)@.log() + seq![v],\n    {\n        let value = LogResourceValue::<T>::FullAuthority { log: self@.log() + seq![v] };\n        update_mut(&mut self.r, value);\n    }\n\n    pub proof fn append_using_two_halves(tracked &mut self, tracked other: &mut Self, v: T)\n        requires\n            old(self)@ is HalfAuthority,\n            old(other)@ is HalfAuthority,\n            old(self).id() == old(other).id(),\n        ensures\n            self@ is HalfAuthority,\n            self.id() == other.id() == old(self).id(),\n            self@.log() == old(self)@.log() + seq![v],\n            other@ == self@,\n    {\n        self.r.validate_2(&other.r);\n        let new_log = self@.log() + seq![v];\n        let new_value = LogResourceValue::<T>::HalfAuthority { log: new_log };\n        update_and_redistribute(&mut self.r, &mut other.r, new_value, new_value);\n    }\n\n    pub proof fn extract_prefix_knowledge(tracked &self) -> (tracked out: Self)\n        ensures\n            out@ is PrefixKnowledge,\n            out.id() == self.id(),\n            out@.log() == self@.log(),\n    {\n        let v = LogResourceValue::<T>::PrefixKnowledge { prefix: self@.log() };\n        let tracked r = copy_duplicable_part(&self.r, v);\n        Self { r }\n    }\n\n    pub proof fn deduce_prefix_relation(tracked &mut self, tracked other: &Self)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self@ == old(self)@,\n            is_prefix(self@.log(), other@.log()) || is_prefix(other@.log(), self@.log()),\n            self@ is HalfAuthority ==> is_prefix(other@.log(), self@.log()),\n            self@ is FullAuthority ==> is_prefix(other@.log(), self@.log()),\n            other@ is HalfAuthority ==> is_prefix(self@.log(), other@.log()),\n            other@ is FullAuthority ==> is_prefix(self@.log(), other@.log()),\n    {\n        self.r.validate_2(&other.r)\n    }\n}\n\npub fn main() {\n    let tracked full_auth = LogResource::<int>::alloc();\n    assert(full_auth@ is FullAuthority);\n    assert(full_auth@.log().len() == 0);\n    proof {\n        full_auth.append(42);\n    }\n    proof {\n        full_auth.append(86);\n    }\n    assert(full_auth@.log().len() == 2);\n    assert(full_auth@.log()[0] == 42);\n    assert(full_auth@.log()[1] == 86);\n    let tracked (half_auth1, half_auth2) = full_auth.split();\n    assert(half_auth1@ == half_auth2@);\n    assert(half_auth1@ is HalfAuthority);\n    proof {\n        half_auth1.append_using_two_halves(&mut half_auth2, 17);\n    }\n    assert(half_auth1@.log().len() == 3);\n    assert(half_auth1@.log()[2] == 17);\n    assert(half_auth2@ == half_auth1@);\n}\n\n} // verus!\n", "full_verified_code": "//! This file implements logs with entries of type `T` using a custom\n//! resource algebra.\n//!\n//! To use it, use LogResource::<T>::alloc(), which will create a\n//! fresh log and return a `LogResource<T>` representing full\n//! authority to append to the log. Here's example code for this:\n//!\n//! ```\n//! let tracked full_auth = LogResource::<int>::alloc();\n//! assert(full_auth@ is FullAuthority);\n//! assert(full_auth@.log().len() == 0);\n//! ```\n//!\n//! You can use the full authority you obtain via `alloc()` to append\n//! to the log, as in the following example:\n//!\n//! ```\n//! proof { full_auth.append(42); }\n//! proof { full_auth.append(86); }\n//! assert(full_auth@.log().len() == 2);\n//! assert(full_auth@.log()[0] == 42);\n//! assert(full_auth@.log()[1] == 86);\n//! ```\n//!\n//! If desired, you can split a `LogResource` representing full\n//! authority into two half authorities using `split`. You may want to\n//! do this if you're stashing half the authority in an invariant.\n//! Here's an example use of `LogResource::split()`; note that it\n//! consumes the resource.\n//!\n//! ```\n//! let tracked (half_auth1, half_auth2) = full_auth.split();\n//! assert(half_auth1@ == half_auth2@);\n//! assert(half_auth1@ is HalfAuthority);\n//! ```\n//!\n//! You can use two half authorities to append to the log using\n//! `append_using_two_halves` as in the following example:\n//!\n//! ```\n//! proof { half_auth1.append_using_two_halves(&mut half_auth2, 17); }\n//! assert(half_auth1@.log().len() == 3);\n//! assert(half_auth1@.log()[2] == 17);\n//! assert(half_auth2@ == half_auth1@);\n//! ```\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse std::result::*;\nuse vstd::pcm::*;\nuse vstd::pcm_lib::*;\nuse vstd::prelude::*;\n\nverus! {\n\npub enum LogResourceValue<T> {\n    PrefixKnowledge { prefix: Seq<T> },\n    HalfAuthority { log: Seq<T> },\n    FullAuthority { log: Seq<T> },\n    Invalid,\n}\n\npub open spec fn is_prefix<T>(s1: Seq<T>, s2: Seq<T>) -> bool {\n    &&& s1.len() <= s2.len()\n    &&& forall|i| 0 <= i < s1.len() ==> s1[i] == s2[i]\n}\n\nimpl<T> PCM for LogResourceValue<T> {\n    open spec fn valid(self) -> bool {\n        &&& !(self is Invalid)\n    }\n\n    open spec fn op(self, other: Self) -> Self {\n        match (self, other) {\n            (\n                Self::PrefixKnowledge { prefix: prefix1 },\n                Self::PrefixKnowledge { prefix: prefix2 },\n            ) => if is_prefix(prefix1, prefix2) {\n                other\n            } else {\n                if is_prefix(prefix2, prefix1) {\n                    self\n                } else {\n                    Self::Invalid\n                }\n            },\n            (Self::PrefixKnowledge { prefix }, Self::HalfAuthority { log }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                other\n            } else {\n                Self::Invalid\n            },\n            (Self::HalfAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                self\n            } else {\n                Self::Invalid\n            },\n            (Self::PrefixKnowledge { prefix }, Self::FullAuthority { log }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                other\n            } else {\n                Self::Invalid\n            },\n            (Self::FullAuthority { log }, Self::PrefixKnowledge { prefix }) => if is_prefix(\n                prefix,\n                log,\n            ) {\n                self\n            } else {\n                Self::Invalid\n            },\n            (Self::HalfAuthority { log: log1 }, Self::HalfAuthority { log: log2 }) => if log1\n                == log2 {\n                Self::FullAuthority { log: log1 }\n            } else {\n                Self::Invalid\n            },\n            (_, _) => Self::Invalid,\n        }\n    }\n\n    open spec fn unit() -> Self {\n        Self::PrefixKnowledge { prefix: Seq::<T>::empty() }\n    }\n\n    proof fn closed_under_incl(a: Self, b: Self) {\n    }\n\n    proof fn commutative(a: Self, b: Self) {\n        assert(forall|log1: Seq<T>, log2: Seq<T>|\n            is_prefix(log1, log2) && is_prefix(log2, log1) ==> log1 =~= log2);\n    }\n\n    proof fn associative(a: Self, b: Self, c: Self) {\n        assert(forall|log1: Seq<T>, log2: Seq<T>|\n            is_prefix(log1, log2) && is_prefix(log2, log1) <==> log1 =~= log2);\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn op_unit(a: Self) {\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\nimpl<T> LogResourceValue<T> {\n    pub open spec fn log(self) -> Seq<T> {\n        match self {\n            LogResourceValue::PrefixKnowledge { prefix } => prefix,\n            LogResourceValue::HalfAuthority { log } => log,\n            LogResourceValue::FullAuthority { log } => log,\n            LogResourceValue::Invalid => Seq::<T>::empty(),\n        }\n    }\n\n    proof fn op_unit(a: Self) {\n        assert(forall|log| is_prefix(log, Seq::<T>::empty()) ==> log =~= Seq::<T>::empty());\n    }\n\n    proof fn unit_valid() {\n    }\n}\n\npub struct LogResource<T> {\n    r: Resource<LogResourceValue<T>>,\n}\n\nimpl<T> LogResource<T> {\n    pub closed spec fn id(self) -> Loc {\n        self.r.loc()\n    }\n\n    pub closed spec fn view(self) -> LogResourceValue<T> {\n        self.r.value()\n    }\n\n    pub proof fn alloc() -> (tracked result: LogResource<T>)\n        ensures\n            result@ is FullAuthority,\n            result@.log() == Seq::<T>::empty(),\n    {\n        let v = LogResourceValue::<T>::FullAuthority { log: Seq::<T>::empty() };\n        let tracked r = Resource::<LogResourceValue::<T>>::alloc(v);\n        Self { r }\n    }\n\n    pub proof fn split(tracked self) -> (tracked halves: (Self, Self))\n        requires\n            self@ is FullAuthority,\n        ensures\n            ({\n                let (half1, half2) = halves;\n                &&& half1@ is HalfAuthority\n                &&& half2@ is HalfAuthority\n                &&& half1.id() == half2.id() == self.id()\n                &&& half1@.log() == self@.log()\n                &&& half2@ == half1@\n            }),\n    {\n        let half_value = LogResourceValue::<T>::HalfAuthority { log: self@.log() };\n        let tracked (half1, half2) = self.r.split(half_value, half_value);\n        (Self { r: half1 }, Self { r: half2 })\n    }\n\n    pub proof fn append(tracked &mut self, v: T)\n        requires\n            old(self)@ is FullAuthority,\n        ensures\n            self@ is FullAuthority,\n            self.id() == old(self).id(),\n            self@.log() == old(self)@.log() + seq![v],\n    {\n        let value = LogResourceValue::<T>::FullAuthority { log: self@.log() + seq![v] };\n        update_mut(&mut self.r, value);\n    }\n\n    pub proof fn append_using_two_halves(tracked &mut self, tracked other: &mut Self, v: T)\n        requires\n            old(self)@ is HalfAuthority,\n            old(other)@ is HalfAuthority,\n            old(self).id() == old(other).id(),\n        ensures\n            self@ is HalfAuthority,\n            self.id() == other.id() == old(self).id(),\n            self@.log() == old(self)@.log() + seq![v],\n            other@ == self@,\n    {\n        self.r.validate_2(&other.r);\n        let new_log = self@.log() + seq![v];\n        let new_value = LogResourceValue::<T>::HalfAuthority { log: new_log };\n        update_and_redistribute(&mut self.r, &mut other.r, new_value, new_value);\n    }\n\n    pub proof fn extract_prefix_knowledge(tracked &self) -> (tracked out: Self)\n        ensures\n            out@ is PrefixKnowledge,\n            out.id() == self.id(),\n            out@.log() == self@.log(),\n    {\n        let v = LogResourceValue::<T>::PrefixKnowledge { prefix: self@.log() };\n        let tracked r = copy_duplicable_part(&self.r, v);\n        Self { r }\n    }\n\n    pub proof fn deduce_prefix_relation(tracked &mut self, tracked other: &Self)\n        requires\n            old(self).id() == other.id(),\n        ensures\n            self@ == old(self)@,\n            is_prefix(self@.log(), other@.log()) || is_prefix(other@.log(), self@.log()),\n            self@ is HalfAuthority ==> is_prefix(other@.log(), self@.log()),\n            self@ is FullAuthority ==> is_prefix(other@.log(), self@.log()),\n            other@ is HalfAuthority ==> is_prefix(self@.log(), other@.log()),\n            other@ is FullAuthority ==> is_prefix(self@.log(), other@.log()),\n    {\n        self.r.validate_2(&other.r)\n    }\n}\n\npub fn main() {\n    let tracked full_auth = LogResource::<int>::alloc();\n    assert(full_auth@ is FullAuthority);\n    assert(full_auth@.log().len() == 0);\n    proof {\n        full_auth.append(42);\n    }\n    proof {\n        full_auth.append(86);\n    }\n    assert(full_auth@.log().len() == 2);\n    assert(full_auth@.log()[0] == 42);\n    assert(full_auth@.log()[1] == 86);\n    let tracked (half_auth1, half_auth2) = full_auth.split();\n    assert(half_auth1@ == half_auth2@);\n    assert(half_auth1@ is HalfAuthority);\n    proof {\n        half_auth1.append_using_two_halves(&mut half_auth2, 17);\n    }\n    assert(half_auth1@.log().len() == 3);\n    assert(half_auth1@.log()[2] == 17);\n    assert(half_auth2@ == half_auth1@);\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/pcm/log.rs", "verified": true, "metadata": {"original_id": "verus_log_43fc5e898ac9", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_a_d2dfd0f1cbe2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >)   { let mut result = Vec :: new () ; let mut i = n ; while i > 0  { i -= 1 ; result . push (list [i]) ; } let mut j = n ; while j < list . len ()  { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "requires list @ . len () > 0 , 0 < n < list @ . len () \nensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) \ndecreases i, list @ . len () - j\ninvariant 0 <= i <= n , n < list @ . len () , result @ . len () == n - i , forall | j : int | 0 <= j < result @ . len () ==> result @ [j] == list @ [n - 1 - j] , n <= j <= list @ . len () , result @ . len () == n + (j - n) , forall | k : int | 0 <= k < n ==> result @ [k] == list @ [n - 1 - k] , forall | k : int | n <= k < result @ . len () ==> result @ [k] == list @ [n + (k - n)] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse_to_k (list : & Vec < i32 > , n : usize) -> (reversed_list : Vec < i32 >) requires list @ . len () > 0 , 0 < n < list @ . len () , ensures reversed_list @ == list @ . subrange (0 , n as int) . reverse () . add (list @ . subrange (n as int , list . len () as int) ,) , { let mut result = Vec :: new () ; let mut i = n ; while i > 0 invariant 0 <= i <= n , n < list @ . len () , result @ . len () == n - i , forall | j : int | 0 <= j < result @ . len () ==> result @ [j] == list @ [n - 1 - j] , decreases i { i -= 1 ; result . push (list [i]) ; } let mut j = n ; while j < list . len () invariant n <= j <= list @ . len () , result @ . len () == n + (j - n) , forall | k : int | 0 <= k < n ==> result @ [k] == list @ [n - 1 - k] , forall | k : int | n <= k < result @ . len () ==> result @ [k] == list @ [n + (k - n)] , decreases list @ . len () - j { result . push (list [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_644_iter_2_current.rs", "verified": true, "metadata": {"original_id": "d2dfd0f1cbe2", "function_name": "reverse_to_k", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_ensures_33fd6d051667", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_sorted_precond (arr : Seq < int >) -> bool { true }\nspec fn unique_sorted_postcond (arr : Seq < int > , result : Seq < int >) -> bool { true }\nfn unique_sorted (arr : Vec < int >) -> (result : Vec < int >) requires unique_sorted_precond (arr @)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_sorted_precond (arr : Seq < int >) -> bool { true }\nspec fn unique_sorted_postcond (arr : Seq < int > , result : Seq < int >) -> bool { true }\nfn unique_sorted (arr : Vec < int >) -> (result : Vec < int >) requires unique_sorted_precond (arr @) ensures unique_sorted_postcond (arr @ , result @) { return Vec :: new () ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn unique_sorted_precond (arr : Seq < int >) -> bool { true }\nspec fn unique_sorted_postcond (arr : Seq < int > , result : Seq < int >) -> bool { true }\nfn unique_sorted (arr : Vec < int >) -> (result : Vec < int >) requires unique_sorted_precond (arr @) ensures unique_sorted_postcond (arr @ , result @) { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_81/verina_advanced_81_iter_0_original.rs", "verified": true, "metadata": {"original_id": "33fd6d051667", "function_name": "unique_sorted", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_faca488e1a60", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn move_zeros_to_end_precond (arr : Seq < i32 >) -> bool { true }\nspec fn move_zeros_to_end_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { let first_zero_idx = first_zero_index (result) ; &&& is_perm (result , arr) &&& result . subrange (0 , first_zero_idx) == filter_non_zeros (arr) &&& result . subrange (first_zero_idx , result . len () as int) == filter_zeros (arr) }\nspec fn is_perm < T > (s1 : Seq < T > , s2 : Seq < T >) -> bool { s1 . to_multiset () == s2 . to_multiset () }\nspec fn first_zero_index (s : Seq < i32 >) -> int { 0 }\nspec fn filter_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x == 0) }\nspec fn filter_non_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x != 0) }\n# [verifier :: external_body] fn move_zeros_to_end (arr : Vec < i32 >) -> (result : Vec < i32 >) requires move_zeros_to_end_precond (arr @) ,  { return Vec :: new () ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn move_zeros_to_end_precond (arr : Seq < i32 >) -> bool { true }\nspec fn move_zeros_to_end_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { let first_zero_idx = first_zero_index (result) ; &&& is_perm (result , arr) &&& result . subrange (0 , first_zero_idx) == filter_non_zeros (arr) &&& result . subrange (first_zero_idx , result . len () as int) == filter_zeros (arr) }\nspec fn is_perm < T > (s1 : Seq < T > , s2 : Seq < T >) -> bool { s1 . to_multiset () == s2 . to_multiset () }\nspec fn first_zero_index (s : Seq < i32 >) -> int { 0 }\nspec fn filter_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x == 0) }\nspec fn filter_non_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x != 0) }\n# [verifier :: external_body] fn move_zeros_to_end (arr : Vec < i32 >) -> (result : Vec < i32 >) requires move_zeros_to_end_precond (arr @) , ensures move_zeros_to_end_postcond (arr @ , result @) , { return Vec :: new () ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn move_zeros_to_end_precond (arr : Seq < i32 >) -> bool { true }\nspec fn move_zeros_to_end_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { let first_zero_idx = first_zero_index (result) ; &&& is_perm (result , arr) &&& result . subrange (0 , first_zero_idx) == filter_non_zeros (arr) &&& result . subrange (first_zero_idx , result . len () as int) == filter_zeros (arr) }\nspec fn is_perm < T > (s1 : Seq < T > , s2 : Seq < T >) -> bool { s1 . to_multiset () == s2 . to_multiset () }\nspec fn first_zero_index (s : Seq < i32 >) -> int { 0 }\nspec fn filter_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x == 0) }\nspec fn filter_non_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x != 0) }\n# [verifier :: external_body] fn move_zeros_to_end (arr : Vec < i32 >) -> (result : Vec < i32 >) requires move_zeros_to_end_precond (arr @) , ensures move_zeros_to_end_postcond (arr @ , result @) , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_35/verina_basic_35_iter_0_original.rs", "verified": true, "metadata": {"original_id": "faca488e1a60", "function_name": "move_zeros_to_end", "bug_type": "missing_ensures"}}
{"id": "task_a_2318d895fdb8", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_sum_to_n (n : nat) -> (ret : nat) { if (n == 0) { 0 } else { n + spec_sum_to_n ((n - 1) as nat) } }\nfn sum_to_n (n : u32) -> (sum : Option < u32 >)  { return None ; }\n\n} // verus!", "target_text": "ensures sum . is_some () ==> sum . unwrap () == spec_sum_to_n (n as nat) \ndecreases n ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_sum_to_n (n : nat) -> (ret : nat) decreases n , { if (n == 0) { 0 } else { n + spec_sum_to_n ((n - 1) as nat) } }\nfn sum_to_n (n : u32) -> (sum : Option < u32 >) ensures sum . is_some () ==> sum . unwrap () == spec_sum_to_n (n as nat) , { return None ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/060-sum_to_n_iter_0_original.rs", "verified": true, "metadata": {"original_id": "2318d895fdb8", "function_name": "sum_to_n", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_c_missing_requires_verus_syntax_attr_05f355728c93", "task": "task_c", "input_text": "#![feature(proc_macro_hygiene)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nfn main() {}\n\n/// functions may be declared exec (default), proof, or spec, which contain\n/// exec code, proof code, and spec code, respectively.\n///   - exec code: compiled, may have requires/ensures\n///   - proof code: erased before compilation, may have requires/ensures\n///   - spec code: erased before compilation, no requires/ensures, but may have recommends\n/// exec and proof functions may name their return values inside parentheses, before the return type\n#[verus_spec(sum =>\n\n    ensures\n        sum < 200,\n)]\nfn my_exec_fun(x: u32, y: u32) -> u32\n{\n    x + y\n}\n\nverus! {\n\nproof fn my_proof_fun(x: int, y: int) -> (sum: int)\n\n    ensures\n        sum < 200,\n{\n    x + y\n}\n\nspec fn my_spec_fun(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n    x + y\n}\n\n} // verus!\n\n/// exec code cannot directly call proof functions or spec functions.\n/// However, exec code can contain proof blocks (proof { ... }),\n/// which contain proof code.\n/// This proof code can call proof functions and spec functions.\n#[verus_spec(\n\n{\n    // my_proof_fun(x, y); // not allowed in exec code\n    // let u = my_spec_fun(x, y); // not allowed exec code\n    proof! {\n        let u = my_spec_fun(x as int, y as int);  // allowed in proof code\n        my_proof_fun(u / 2, y as int);  // allowed in proof code\n    }\n}\n\nverus! {\n\n/// spec functions with pub or pub(...) must specify whether the body of the function\n/// should also be made publicly visible (open function) or not visible (closed function).\npub open spec fn my_pub_spec_fun1(x: int, y: int) -> int {\n    // function and body visible to all\n    x / 2 + y / 2\n}\n\n/* TODO\npub open(crate) spec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {\n    // function visible to all, body visible to crate\n    x / 2 + y / 2\n}\n*/\n\n// TODO(main_new) pub(crate) is not being handled correctly\n// pub(crate) open spec fn my_pub_spec_fun3(x: int, y: int) -> int {\n//     // function and body visible to crate\n//     x / 2 + y / 2\n// }\npub closed spec fn my_pub_spec_fun4(x: int, y: int) -> int {\n    // function visible to all, body visible to module\n    x / 2 + y / 2\n}\n\npub(crate) closed spec fn my_pub_spec_fun5(x: int, y: int) -> int {\n    // function visible to crate, body visible to module\n    x / 2 + y / 2\n}\n\n} // verus!\n\n/// Recursive functions must have decreases clauses so that Verus can verify that the functions\n/// terminate.\n#[verus_spec(\n\n{\n    if x > 1 {\n        test_rec(x - 1, y + 1);\n    }\n}\n\nverus! {\n\n/// Multiple decreases clauses are ordered lexicographically, so that later clauses may\n/// increase when earlier clauses decrease.\nspec fn test_rec2(x: int, y: int) -> int\n    decreases x, y,\n{\n    if y > 0 {\n        1 + test_rec2(x, y - 1)\n    } else if x > 0 {\n        2 + test_rec2(x - 1, 100)\n    } else {\n        3\n    }\n}\n\n/// To help prove termination, recursive spec functions may have embedded proof blocks\n/// that can make assertions, use broadcasts, and call lemmas.\nspec fn test_rec_proof_block(x: int, y: int) -> int\n    decreases x,\n{\n    if x < 1 {\n        0\n    } else {\n        proof {\n            assert(x - 1 >= 0);\n        }\n        test_rec_proof_block(x - 1, y + 1) + 1\n    }\n}\n\n/// Decreases and recommends may specify additional clauses:\n///   - decreases .. \"when\" restricts the function definition to a condition\n///     that makes the function terminate\n///   - decreases .. \"via\" specifies a proof function that proves the termination\n///     (although proof blocks are usually simpler; see above)\n///   - recommends .. \"when\" specifies a proof function that proves the\n///     recommendations of the functions invoked in the body\nspec fn add0(a: nat, b: nat) -> nat\n    recommends\n        a > 0,\n    via add0_recommends\n{\n    a + b\n}\n\nspec fn dec0(a: int) -> int\n    decreases a,\n    when a > 0\n    via dec0_decreases\n{\n    if a > 0 {\n        dec0(a - 1)\n    } else {\n        0\n    }\n}\n\n#[via_fn]\nproof fn add0_recommends(a: nat, b: nat) {\n    // proof\n}\n\n#[via_fn]\nproof fn dec0_decreases(a: int) {\n    // proof\n}\n\n} // verus!\n\n/// variables may be exec, tracked, or ghost\n///   - exec: compiled\n///   - tracked: erased before compilation, checked for lifetimes (advanced feature, discussed later)\n///   - ghost: erased before compilation, no lifetime checking, can create default value of any type\n/// Different variable modes may be used in different code modes:\n///   - variables in exec code are always exec\n///   - variables in proof code are ghost by default (tracked variables must be marked \"tracked\")\n///   - variables in spec code are always ghost\n/// For example:\n#[verus_spec(\n\n{\n    let s = a + b;  // s is an exec variable\n    proof! {\n        let u = a + b;  // u is a ghost variable\n        my_proof_fun(u / 2, b as int);  // my_proof_fun(x, y) takes ghost parameters x and y\n    }\n}\n\nverus! {\n\n/// assume and assert are treated as proof code even outside of proof blocks.\n/// \"assert by\" may be used to provide proof code that proves the assertion.\n#[verifier::opaque]\nspec fn f1(i: int) -> int {\n    i + 1\n}\n\n} // verus!\n\n#[verus_spec()]\nfn assert_by_test() {\n    proof! {\n        assert(f1(3) > 3) by {\n            reveal(f1);  // reveal f1's definition just inside this block\n        }\n        assert(f1(3) > 3);\n    }\n}\n\n/// \"assert by\" can also invoke specialized provers for bit-vector reasoning or nonlinear arithmetic.\n#[verus_spec()]\nfn assert_by_provers(x: u32) {\n    proof! {\n        assert(x ^ x == 0u32) by (bit_vector);\n        assert(2 <= x && x < 10 ==> x * x > x) by (nonlinear_arith);\n    }\n}\n\nverus! {\n\n/// \"let ghost\" currently\n{\n    let ghost u: int = my_spec_fun(x as int, y as int);\n    let ghost mut v = u + 1;\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // proof code may assign to ghost mut variables\n    }\n    let ghost w = {\n        let temp = v + 1;\n        temp + 1\n    };\n    assert(w == x + y + 4);\n}\n\n/// Ghost(...) expressions and patterns currently require the verus! macro\n/// Ghost(...) and Tracked(...) patterns can unwrap Ghost<...> and Tracked<...> values:\nfn test_ghost_unwrap(\n    x: u32,\n    Ghost(y): Ghost<u32>,\n)  // unwrap so that y has typ u32, not Ghost<u32>\n\n{\n    // Ghost(u) pattern unwraps Ghost<...> values and gives u and v type int:\n    let Ghost(u): Ghost<int> = Ghost(my_spec_fun(x as int, y as int));\n    let Ghost(mut v): Ghost<int> = Ghost(u + 1);\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // assign directly to ghost mut v\n    }\n    let Ghost(w): Ghost<int> = Ghost(\n        {\n            // proof block that returns a ghost value\n            let temp = v + 1;\n            temp + 1\n        },\n    );\n    assert(w == x + y + 4);\n}\n\n} // verus!\n\n/// Trait functions may have specifications\ntrait T {\n    #[verus_spec(r =>\n\n        ensures\n            i <= r,\n            j <= r,\n    )]\n    fn my_uninterpreted_fun2(&self, i: u8, j: u8) -> u8;\n}\n\n#[verus_spec(ret =>\n    with\n        Tracked(y): Tracked<&mut u32>, Ghost(w): Ghost<u64> -> z: Ghost<u32>\n\n    ensures\n        *y == x,\n        ret == x,\n        z == x,\n)]\nfn test_mut_tracked(x: u32) -> u32 {\n    proof!{\n        *y = x;\n    }\n    #[verus_spec(with |=Ghost(x))]\n    x\n}\n\nfn test_cal_mut_tracked(x: u32) {\n    proof_decl!{\n        let ghost mut z;\n        let tracked mut y = 0u32;\n        z = 0u32;\n    }\n    #[verus_spec(with Tracked(&mut y), Ghost(0) => Ghost(z))]\n    let _ = test_mut_tracked(0u32);\n\n    (#[verus_spec(with Tracked(&mut y), Ghost(0))]\n    test_mut_tracked(0u32));\n\n    return;\n}", "target_text": "#![feature(proc_macro_hygiene)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nfn main() {}\n\n/// functions may be declared exec (default), proof, or spec, which contain\n/// exec code, proof code, and spec code, respectively.\n///   - exec code: compiled, may have requires/ensures\n///   - proof code: erased before compilation, may have requires/ensures\n///   - spec code: erased before compilation, no requires/ensures, but may have recommends\n/// exec and proof functions may name their return values inside parentheses, before the return type\n#[verus_spec(sum =>\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n)]\nfn my_exec_fun(x: u32, y: u32) -> u32\n{\n    x + y\n}\n\nverus! {\n\nproof fn my_proof_fun(x: int, y: int) -> (sum: int)\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n{\n    x + y\n}\n\nspec fn my_spec_fun(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n    x + y\n}\n\n} // verus!\n\n/// exec code cannot directly call proof functions or spec functions.\n/// However, exec code can contain proof blocks (proof { ... }),\n/// which contain proof code.\n/// This proof code can call proof functions and spec functions.\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n)]\nfn test_my_funs(x: u32, y: u32)\n{\n    // my_proof_fun(x, y); // not allowed in exec code\n    // let u = my_spec_fun(x, y); // not allowed exec code\n    proof! {\n        let u = my_spec_fun(x as int, y as int);  // allowed in proof code\n        my_proof_fun(u / 2, y as int);  // allowed in proof code\n    }\n}\n\nverus! {\n\n/// spec functions with pub or pub(...) must specify whether the body of the function\n/// should also be made publicly visible (open function) or not visible (closed function).\npub open spec fn my_pub_spec_fun1(x: int, y: int) -> int {\n    // function and body visible to all\n    x / 2 + y / 2\n}\n\n/* TODO\npub open(crate) spec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {\n    // function visible to all, body visible to crate\n    x / 2 + y / 2\n}\n*/\n\n// TODO(main_new) pub(crate) is not being handled correctly\n// pub(crate) open spec fn my_pub_spec_fun3(x: int, y: int) -> int {\n//     // function and body visible to crate\n//     x / 2 + y / 2\n// }\npub closed spec fn my_pub_spec_fun4(x: int, y: int) -> int {\n    // function visible to all, body visible to module\n    x / 2 + y / 2\n}\n\npub(crate) closed spec fn my_pub_spec_fun5(x: int, y: int) -> int {\n    // function visible to crate, body visible to module\n    x / 2 + y / 2\n}\n\n} // verus!\n\n/// Recursive functions must have decreases clauses so that Verus can verify that the functions\n/// terminate.\n#[verus_spec(\n    requires\n        0 < x < 100,\n        y < 100 - x,\n    decreases x,\n)]\nfn test_rec(x: u64, y: u64)\n{\n    if x > 1 {\n        test_rec(x - 1, y + 1);\n    }\n}\n\nverus! {\n\n/// Multiple decreases clauses are ordered lexicographically, so that later clauses may\n/// increase when earlier clauses decrease.\nspec fn test_rec2(x: int, y: int) -> int\n    decreases x, y,\n{\n    if y > 0 {\n        1 + test_rec2(x, y - 1)\n    } else if x > 0 {\n        2 + test_rec2(x - 1, 100)\n    } else {\n        3\n    }\n}\n\n/// To help prove termination, recursive spec functions may have embedded proof blocks\n/// that can make assertions, use broadcasts, and call lemmas.\nspec fn test_rec_proof_block(x: int, y: int) -> int\n    decreases x,\n{\n    if x < 1 {\n        0\n    } else {\n        proof {\n            assert(x - 1 >= 0);\n        }\n        test_rec_proof_block(x - 1, y + 1) + 1\n    }\n}\n\n/// Decreases and recommends may specify additional clauses:\n///   - decreases .. \"when\" restricts the function definition to a condition\n///     that makes the function terminate\n///   - decreases .. \"via\" specifies a proof function that proves the termination\n///     (although proof blocks are usually simpler; see above)\n///   - recommends .. \"when\" specifies a proof function that proves the\n///     recommendations of the functions invoked in the body\nspec fn add0(a: nat, b: nat) -> nat\n    recommends\n        a > 0,\n    via add0_recommends\n{\n    a + b\n}\n\nspec fn dec0(a: int) -> int\n    decreases a,\n    when a > 0\n    via dec0_decreases\n{\n    if a > 0 {\n        dec0(a - 1)\n    } else {\n        0\n    }\n}\n\n#[via_fn]\nproof fn add0_recommends(a: nat, b: nat) {\n    // proof\n}\n\n#[via_fn]\nproof fn dec0_decreases(a: int) {\n    // proof\n}\n\n} // verus!\n\n/// variables may be exec, tracked, or ghost\n///   - exec: compiled\n///   - tracked: erased before compilation, checked for lifetimes (advanced feature, discussed later)\n///   - ghost: erased before compilation, no lifetime checking, can create default value of any type\n/// Different variable modes may be used in different code modes:\n///   - variables in exec code are always exec\n///   - variables in proof code are ghost by default (tracked variables must be marked \"tracked\")\n///   - variables in spec code are always ghost\n/// For example:\n#[verus_spec(\n    requires\n        a < 100,\n        b < 100,\n)]\nfn test_my_funs2(\n    a: u32,  // exec variable\n    b: u32,  // exec variable\n)\n{\n    let s = a + b;  // s is an exec variable\n    proof! {\n        let u = a + b;  // u is a ghost variable\n        my_proof_fun(u / 2, b as int);  // my_proof_fun(x, y) takes ghost parameters x and y\n    }\n}\n\nverus! {\n\n/// assume and assert are treated as proof code even outside of proof blocks.\n/// \"assert by\" may be used to provide proof code that proves the assertion.\n#[verifier::opaque]\nspec fn f1(i: int) -> int {\n    i + 1\n}\n\n} // verus!\n\n#[verus_spec()]\nfn assert_by_test() {\n    proof! {\n        assert(f1(3) > 3) by {\n            reveal(f1);  // reveal f1's definition just inside this block\n        }\n        assert(f1(3) > 3);\n    }\n}\n\n/// \"assert by\" can also invoke specialized provers for bit-vector reasoning or nonlinear arithmetic.\n#[verus_spec()]\nfn assert_by_provers(x: u32) {\n    proof! {\n        assert(x ^ x == 0u32) by (bit_vector);\n        assert(2 <= x && x < 10 ==> x * x > x) by (nonlinear_arith);\n    }\n}\n\nverus! {\n\n/// \"let ghost\" currently requires the verus! macro\n/// Variables in exec code may be exec, ghost, or tracked.\nfn test_ghost(x: u32, y: u32)\n    requires\n        x < 100,\n        y < 100,\n{\n    let ghost u: int = my_spec_fun(x as int, y as int);\n    let ghost mut v = u + 1;\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // proof code may assign to ghost mut variables\n    }\n    let ghost w = {\n        let temp = v + 1;\n        temp + 1\n    };\n    assert(w == x + y + 4);\n}\n\n/// Ghost(...) expressions and patterns currently require the verus! macro\n/// Ghost(...) and Tracked(...) patterns can unwrap Ghost<...> and Tracked<...> values:\nfn test_ghost_unwrap(\n    x: u32,\n    Ghost(y): Ghost<u32>,\n)  // unwrap so that y has typ u32, not Ghost<u32>\n    requires\n        x < 100,\n        y < 100,\n{\n    // Ghost(u) pattern unwraps Ghost<...> values and gives u and v type int:\n    let Ghost(u): Ghost<int> = Ghost(my_spec_fun(x as int, y as int));\n    let Ghost(mut v): Ghost<int> = Ghost(u + 1);\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // assign directly to ghost mut v\n    }\n    let Ghost(w): Ghost<int> = Ghost(\n        {\n            // proof block that returns a ghost value\n            let temp = v + 1;\n            temp + 1\n        },\n    );\n    assert(w == x + y + 4);\n}\n\n} // verus!\n\n/// Trait functions may have specifications\ntrait T {\n    #[verus_spec(r =>\n        requires\n            0 <= i < 10,\n            0 <= j < 10,\n        ensures\n            i <= r,\n            j <= r,\n    )]\n    fn my_uninterpreted_fun2(&self, i: u8, j: u8) -> u8;\n}\n\n#[verus_spec(ret =>\n    with\n        Tracked(y): Tracked<&mut u32>, Ghost(w): Ghost<u64> -> z: Ghost<u32>\n    requires\n        x < 100,\n        *old(y) < 100,\n    ensures\n        *y == x,\n        ret == x,\n        z == x,\n)]\nfn test_mut_tracked(x: u32) -> u32 {\n    proof!{\n        *y = x;\n    }\n    #[verus_spec(with |=Ghost(x))]\n    x\n}\n\nfn test_cal_mut_tracked(x: u32) {\n    proof_decl!{\n        let ghost mut z;\n        let tracked mut y = 0u32;\n        z = 0u32;\n    }\n    #[verus_spec(with Tracked(&mut y), Ghost(0) => Ghost(z))]\n    let _ = test_mut_tracked(0u32);\n\n    (#[verus_spec(with Tracked(&mut y), Ghost(0))]\n    test_mut_tracked(0u32));\n\n    return;\n}", "full_verified_code": "#![feature(proc_macro_hygiene)]\n#![allow(unused_imports)]\n\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::{modes::*, prelude::*, seq::*, *};\n\nfn main() {}\n\n/// functions may be declared exec (default), proof, or spec, which contain\n/// exec code, proof code, and spec code, respectively.\n///   - exec code: compiled, may have requires/ensures\n///   - proof code: erased before compilation, may have requires/ensures\n///   - spec code: erased before compilation, no requires/ensures, but may have recommends\n/// exec and proof functions may name their return values inside parentheses, before the return type\n#[verus_spec(sum =>\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n)]\nfn my_exec_fun(x: u32, y: u32) -> u32\n{\n    x + y\n}\n\nverus! {\n\nproof fn my_proof_fun(x: int, y: int) -> (sum: int)\n    requires\n        x < 100,\n        y < 100,\n    ensures\n        sum < 200,\n{\n    x + y\n}\n\nspec fn my_spec_fun(x: int, y: int) -> int\n    recommends\n        x < 100,\n        y < 100,\n{\n    x + y\n}\n\n} // verus!\n\n/// exec code cannot directly call proof functions or spec functions.\n/// However, exec code can contain proof blocks (proof { ... }),\n/// which contain proof code.\n/// This proof code can call proof functions and spec functions.\n#[verus_spec(\n    requires\n        x < 100,\n        y < 100,\n)]\nfn test_my_funs(x: u32, y: u32)\n{\n    // my_proof_fun(x, y); // not allowed in exec code\n    // let u = my_spec_fun(x, y); // not allowed exec code\n    proof! {\n        let u = my_spec_fun(x as int, y as int);  // allowed in proof code\n        my_proof_fun(u / 2, y as int);  // allowed in proof code\n    }\n}\n\nverus! {\n\n/// spec functions with pub or pub(...) must specify whether the body of the function\n/// should also be made publicly visible (open function) or not visible (closed function).\npub open spec fn my_pub_spec_fun1(x: int, y: int) -> int {\n    // function and body visible to all\n    x / 2 + y / 2\n}\n\n/* TODO\npub open(crate) spec fn my_pub_spec_fun2(x: u32, y: u32) -> u32 {\n    // function visible to all, body visible to crate\n    x / 2 + y / 2\n}\n*/\n\n// TODO(main_new) pub(crate) is not being handled correctly\n// pub(crate) open spec fn my_pub_spec_fun3(x: int, y: int) -> int {\n//     // function and body visible to crate\n//     x / 2 + y / 2\n// }\npub closed spec fn my_pub_spec_fun4(x: int, y: int) -> int {\n    // function visible to all, body visible to module\n    x / 2 + y / 2\n}\n\npub(crate) closed spec fn my_pub_spec_fun5(x: int, y: int) -> int {\n    // function visible to crate, body visible to module\n    x / 2 + y / 2\n}\n\n} // verus!\n\n/// Recursive functions must have decreases clauses so that Verus can verify that the functions\n/// terminate.\n#[verus_spec(\n    requires\n        0 < x < 100,\n        y < 100 - x,\n    decreases x,\n)]\nfn test_rec(x: u64, y: u64)\n{\n    if x > 1 {\n        test_rec(x - 1, y + 1);\n    }\n}\n\nverus! {\n\n/// Multiple decreases clauses are ordered lexicographically, so that later clauses may\n/// increase when earlier clauses decrease.\nspec fn test_rec2(x: int, y: int) -> int\n    decreases x, y,\n{\n    if y > 0 {\n        1 + test_rec2(x, y - 1)\n    } else if x > 0 {\n        2 + test_rec2(x - 1, 100)\n    } else {\n        3\n    }\n}\n\n/// To help prove termination, recursive spec functions may have embedded proof blocks\n/// that can make assertions, use broadcasts, and call lemmas.\nspec fn test_rec_proof_block(x: int, y: int) -> int\n    decreases x,\n{\n    if x < 1 {\n        0\n    } else {\n        proof {\n            assert(x - 1 >= 0);\n        }\n        test_rec_proof_block(x - 1, y + 1) + 1\n    }\n}\n\n/// Decreases and recommends may specify additional clauses:\n///   - decreases .. \"when\" restricts the function definition to a condition\n///     that makes the function terminate\n///   - decreases .. \"via\" specifies a proof function that proves the termination\n///     (although proof blocks are usually simpler; see above)\n///   - recommends .. \"when\" specifies a proof function that proves the\n///     recommendations of the functions invoked in the body\nspec fn add0(a: nat, b: nat) -> nat\n    recommends\n        a > 0,\n    via add0_recommends\n{\n    a + b\n}\n\nspec fn dec0(a: int) -> int\n    decreases a,\n    when a > 0\n    via dec0_decreases\n{\n    if a > 0 {\n        dec0(a - 1)\n    } else {\n        0\n    }\n}\n\n#[via_fn]\nproof fn add0_recommends(a: nat, b: nat) {\n    // proof\n}\n\n#[via_fn]\nproof fn dec0_decreases(a: int) {\n    // proof\n}\n\n} // verus!\n\n/// variables may be exec, tracked, or ghost\n///   - exec: compiled\n///   - tracked: erased before compilation, checked for lifetimes (advanced feature, discussed later)\n///   - ghost: erased before compilation, no lifetime checking, can create default value of any type\n/// Different variable modes may be used in different code modes:\n///   - variables in exec code are always exec\n///   - variables in proof code are ghost by default (tracked variables must be marked \"tracked\")\n///   - variables in spec code are always ghost\n/// For example:\n#[verus_spec(\n    requires\n        a < 100,\n        b < 100,\n)]\nfn test_my_funs2(\n    a: u32,  // exec variable\n    b: u32,  // exec variable\n)\n{\n    let s = a + b;  // s is an exec variable\n    proof! {\n        let u = a + b;  // u is a ghost variable\n        my_proof_fun(u / 2, b as int);  // my_proof_fun(x, y) takes ghost parameters x and y\n    }\n}\n\nverus! {\n\n/// assume and assert are treated as proof code even outside of proof blocks.\n/// \"assert by\" may be used to provide proof code that proves the assertion.\n#[verifier::opaque]\nspec fn f1(i: int) -> int {\n    i + 1\n}\n\n} // verus!\n\n#[verus_spec()]\nfn assert_by_test() {\n    proof! {\n        assert(f1(3) > 3) by {\n            reveal(f1);  // reveal f1's definition just inside this block\n        }\n        assert(f1(3) > 3);\n    }\n}\n\n/// \"assert by\" can also invoke specialized provers for bit-vector reasoning or nonlinear arithmetic.\n#[verus_spec()]\nfn assert_by_provers(x: u32) {\n    proof! {\n        assert(x ^ x == 0u32) by (bit_vector);\n        assert(2 <= x && x < 10 ==> x * x > x) by (nonlinear_arith);\n    }\n}\n\nverus! {\n\n/// \"let ghost\" currently requires the verus! macro\n/// Variables in exec code may be exec, ghost, or tracked.\nfn test_ghost(x: u32, y: u32)\n    requires\n        x < 100,\n        y < 100,\n{\n    let ghost u: int = my_spec_fun(x as int, y as int);\n    let ghost mut v = u + 1;\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // proof code may assign to ghost mut variables\n    }\n    let ghost w = {\n        let temp = v + 1;\n        temp + 1\n    };\n    assert(w == x + y + 4);\n}\n\n/// Ghost(...) expressions and patterns currently require the verus! macro\n/// Ghost(...) and Tracked(...) patterns can unwrap Ghost<...> and Tracked<...> values:\nfn test_ghost_unwrap(\n    x: u32,\n    Ghost(y): Ghost<u32>,\n)  // unwrap so that y has typ u32, not Ghost<u32>\n    requires\n        x < 100,\n        y < 100,\n{\n    // Ghost(u) pattern unwraps Ghost<...> values and gives u and v type int:\n    let Ghost(u): Ghost<int> = Ghost(my_spec_fun(x as int, y as int));\n    let Ghost(mut v): Ghost<int> = Ghost(u + 1);\n    assert(v == x + y + 1);\n    proof {\n        v = v + 1;  // assign directly to ghost mut v\n    }\n    let Ghost(w): Ghost<int> = Ghost(\n        {\n            // proof block that returns a ghost value\n            let temp = v + 1;\n            temp + 1\n        },\n    );\n    assert(w == x + y + 4);\n}\n\n} // verus!\n\n/// Trait functions may have specifications\ntrait T {\n    #[verus_spec(r =>\n        requires\n            0 <= i < 10,\n            0 <= j < 10,\n        ensures\n            i <= r,\n            j <= r,\n    )]\n    fn my_uninterpreted_fun2(&self, i: u8, j: u8) -> u8;\n}\n\n#[verus_spec(ret =>\n    with\n        Tracked(y): Tracked<&mut u32>, Ghost(w): Ghost<u64> -> z: Ghost<u32>\n    requires\n        x < 100,\n        *old(y) < 100,\n    ensures\n        *y == x,\n        ret == x,\n        z == x,\n)]\nfn test_mut_tracked(x: u32) -> u32 {\n    proof!{\n        *y = x;\n    }\n    #[verus_spec(with |=Ghost(x))]\n    x\n}\n\nfn test_cal_mut_tracked(x: u32) {\n    proof_decl!{\n        let ghost mut z;\n        let tracked mut y = 0u32;\n        z = 0u32;\n    }\n    #[verus_spec(with Tracked(&mut y), Ghost(0) => Ghost(z))]\n    let _ = test_mut_tracked(0u32);\n\n    (#[verus_spec(with Tracked(&mut y), Ghost(0))]\n    test_mut_tracked(0u32));\n\n    return;\n}", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/syntax_attr.rs", "verified": true, "metadata": {"original_id": "verus_syntax_attr_05f355728c93", "function_name": "", "bug_type": "missing_requires"}}
{"id": "task_a_81d10428ea86", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize)   { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len ()  { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "target_text": "requires list . len () > 0 \nensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () \ndecreases list . len () - j \ninvariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn smallest_list_length (list : & Vec < Vec < i32 > >) -> (min : usize) requires list . len () > 0 , ensures min >= 0 , forall | i : int | 0 <= i < list . len () ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < list . len () && min == # [trigger] list [i] . len () , { let mut min = list [0] . len () ; let mut j = 1 ; while j < list . len () invariant 1 <= j <= list . len () , forall | i : int | 0 <= i < j ==> min <= # [trigger] list [i] . len () , exists | i : int | 0 <= i < j && min == # [trigger] list [i] . len () , decreases list . len () - j , { if list [j] . len () < min { min = list [j] . len () ; } j += 1 ; } min }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_95_impl.rs", "verified": true, "metadata": {"original_id": "81d10428ea86", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_b_5b15e39211d0", "task": "task_b", "input_text": "fn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >)\nrequires a . len () <= 100 && b . len () <= 100 \nensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >) requires a . len () <= 100 && b . len () <= 100 , ensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | j : int | (0 <= j && j < i) ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , result . len () == a . len () + j , forall | k : int | (0 <= k && k < a . len ()) ==> result [k] == a [k] , forall | k : int | (a . len () <= k && k < result . len ()) ==> result [k] == b [k - a . len ()] , decreases b . len () - j , { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn concat (a : & Vec < u64 > , b : & Vec < u64 >) -> (c : Vec < u64 >) requires a . len () <= 100 && b . len () <= 100 , ensures c @ . len () == a @ . len () + b @ . len () , forall | i : int | (0 <= i && i < a . len ()) ==> c [i] == a [i] , forall | i : int | (a . len () <= i && i < c . len ()) ==> c [i] == b [i - a . len ()] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | j : int | (0 <= j && j < i) ==> result [j] == a [j] , decreases a . len () - i , { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , result . len () == a . len () + j , forall | k : int | (0 <= k && k < a . len ()) ==> result [k] == a [k] , forall | k : int | (a . len () <= k && k < result . len ()) ==> result [k] == b [k - a . len ()] , decreases b . len () - j , { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/verified/array_concat_strong_impl.rs", "verified": true, "metadata": {"original_id": "5b15e39211d0", "function_name": "concat", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_decreases_269518014d5f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_prime_check (n : u32 , i : u32 , fuel : u32) -> (result : bool) requires n >= 2 , n <= 0xFFFF , i >= 2 , fuel <= n , { return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_prime_check (n : u32 , i : u32 , fuel : u32) -> (result : bool) requires n >= 2 , n <= 0xFFFF , i >= 2 , fuel <= n , decreases fuel , { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_prime_check (n : u32 , i : u32 , fuel : u32) -> (result : bool) requires n >= 2 , n <= 0xFFFF , i >= 2 , fuel <= n , decreases fuel , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_28/verina_basic_28.rs", "verified": true, "metadata": {"original_id": "269518014d5f", "function_name": "is_prime_check", "bug_type": "missing_decreases"}}
{"id": "task_b_8cbc230833eb", "task": "task_b", "input_text": "fn triple_if (x : u32) -> (r : u32)\nrequires x <= 0x55555555u32 \nensures r as int == 3 * (x as int)", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_if (x : u32) -> (r : u32) requires x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { if x == 0 { 0 } else { x + x + x } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "8cbc230833eb", "function_name": "triple_if", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_invariant_3a52176b7e06", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool) requires a . len () > 0 ensures result <==> (forall | i : int | 0 <= i < a . len () ==> n > a [i]) { for i in 0 .. a . len ()  { if n <= a [i] { return false ; } } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool) requires a . len () > 0 ensures result <==> (forall | i : int | 0 <= i < a . len () ==> n > a [i]) { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> n > a [j] { if n <= a [i] { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (n : i32 , a : & Vec < i32 >) -> (result : bool) requires a . len () > 0 ensures result <==> (forall | i : int | 0 <= i < a . len () ==> n > a [i]) { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> n > a [j] { if n <= a [i] { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_10/verina_basic_10_iter_1_current.rs", "verified": true, "metadata": {"original_id": "3a52176b7e06", "function_name": "is_greater", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_5a13781737ff", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >)  { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant result . len () == i , i <= a . len () , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i { result . push (a [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant result . len () == i , i <= a . len () , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i { result . push (a [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_copy (a : Vec < i32 >) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < a . len () ==> result [i] == a [i] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant result . len () == i , i <= a . len () , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i { result . push (a [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/array_copy_impl.rs", "verified": true, "metadata": {"original_id": "5a13781737ff", "function_name": "array_copy", "bug_type": "missing_ensures"}}
{"id": "task_a_157ebe39e327", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize)   { let mut min_length = lists [0] . len () ; let mut idx = 1 ; while idx < lists . len ()  { if lists [idx] . len () < min_length { min_length = lists [idx] . len () ; } idx += 1 ; } min_length }\n\n} // verus!", "target_text": "requires lists . len () > 0 \nensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () \ndecreases lists . len () - idx\ninvariant 0 <= idx <= lists . len () , exists | i : int | # ! [auto] 0 <= i < idx && min_length == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < idx ==> min_length <= lists [i] . len () ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn smallest_list_length (lists : Vec < Vec < i32 > >) -> (result : usize) requires lists . len () > 0 , ensures exists | i : int | # ! [auto] 0 <= i < lists . len () && result == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < lists . len () ==> result <= lists [i] . len () , { let mut min_length = lists [0] . len () ; let mut idx = 1 ; while idx < lists . len () invariant 0 <= idx <= lists . len () , exists | i : int | # ! [auto] 0 <= i < idx && min_length == lists [i] . len () , forall | i : int | # ! [auto] 0 <= i < idx ==> min_length <= lists [i] . len () , decreases lists . len () - idx { if lists [idx] . len () < min_length { min_length = lists [idx] . len () ; } idx += 1 ; } min_length }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/smallest_list_length_impl.rs", "verified": true, "metadata": {"original_id": "157ebe39e327", "function_name": "smallest_list_length", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_ensures_vostd_function_properties_ac5ffca188ef", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd::relations::*;\n\nverus! {\n\n/// A function is bijective from `domain` to `codomain`\n/// if it is injective on `domain` and its image equals `codomain`.\npub open spec fn bijective_on<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>) -> bool {\n    injective_on(f, domain) && domain.map(f) =~= codomain\n}\n\n/// `g` is a left inverse of `f` on `domain` if `g(f(x)) == x` for all `x` in `domain`,\n/// and `f(x)` lies in `codomain`.\npub open spec fn left_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    domain.all(|x: A| codomain.contains(f(x)) && g(f(x)) == x)\n}\n\n/// `g` is a right inverse of `f` on `codomain` if `f(g(y)) == y` for all `y` in `codomain`,\n/// and `g(y)` lies in `domain`.\npub open spec fn right_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    codomain.all(|y: B| domain.contains(g(y)) && f(g(y)) == y)\n}\n\n/// `g` is a two-sided inverse of `f` if it is both a left and right inverse.\npub open spec fn inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    left_inverse_on(f, g, domain, codomain) && right_inverse_on(f, g, domain, codomain)\n}\n\n/// Constructs a left inverse function `g` of `f` when `f` is injective on `domain`.\n/// For each `b` in the image, returns the unique `a` such that `f(a) = b`.\npub open spec fn construct_left_inverse<A, B>(f: spec_fn(A) -> B, domain: Set<A>) -> spec_fn(B) -> A\n    recommends\n        injective_on(f, domain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// Constructs the inverse of a bijective function `f` from `domain` to `codomain`.\n/// For each `b` in `codomain`, returns the unique `a` in `domain` such that `f(a) == b`.\npub open spec fn construct_inverse<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> spec_fn(B) -> A\n    recommends\n        bijective_on(f, domain, codomain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// If `f` is injective on `domain`, then `construct_left_inverse(f, domain)`\n/// is a left inverse of `f` on that domain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x`.\npub proof fn lemma_construct_left_inverse_sound<A, B>(f: spec_fn(A) -> B, domain: Set<A>)\n    requires\n        injective_on(f, domain),\n\n{\n}\n\n/// If `f` is bijective from `domain` to `codomain`, then `construct_inverse(f, domain, codomain)`\n/// is a two-sided inverse of `f` on that domain and codomain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x` and for all `y \u2208 codomain`, we have `f(g(y)) == y`.\npub proof fn lemma_construct_inverse_sound<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n\n{\n}\n\n/// A function is injective on the whole type implies that it is injective on any sub-domain.\npub proof fn lemma_injective_implies_injective_on<T, U>(f: spec_fn(T) -> U, dom: Set<T>)\n    requires\n        injective(f),\n\n{\n}\n\n/// If `f` has a two-sided inverse `g` on `domain` and `codomain`, then `f` is bijective on that domain and codomain.\npub proof fn lemma_two_sided_inverse_implies_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        inverse_on(f, g, domain, codomain),\n\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its left inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_left_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain),\n\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_right_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        right_inverse_on(f, g, domain, codomain),\n\n{\n    // Prove that g is injective on codomain\n    assert forall|x| #[trigger] codomain.map(g).contains(x) == domain.contains(x) by {\n        if domain.contains(x) {\n            assert(codomain.contains(f(x)));\n        }\n    }\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is either its left or right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain) || right_inverse_on(f, g, domain, codomain),\n\n{\n    if left_inverse_on(f, g, domain, codomain) {\n        lemma_left_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    } else {\n        lemma_right_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    }\n}\n\n/// Mapping a finite set with an injective function results in a set of the same cardinality.\npub proof fn lemma_injective_map_cardinality<T, U>(f: spec_fn(T) -> U, dom: Set<T>, s: Set<T>)\n    requires\n        injective_on(f, dom),\n        s.finite(),\n        s <= dom,\n\n{\n    if s.is_empty() {\n        assert(s.map(f) =~= Set::empty());\n    } else {\n        let x = s.choose();\n        lemma_injective_map_cardinality(f, dom, s.remove(x));\n        assert(s.map(f) =~= s.remove(x).map(f).insert(f(x)));\n    }\n}\n\npub proof fn lemma_bijective_cardinality<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>)\n    requires\n        bijective_on(f, domain, codomain),\n        domain.finite(),\n\n{\n    lemma_injective_map_cardinality(f, domain, domain);\n}\n\npub proof fn lemma_bijective_subset_still_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n    s: Set<A>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        s <= domain,\n\n{\n}\n\n} // verus!\n", "target_text": "use vstd::prelude::*;\nuse vstd::relations::*;\n\nverus! {\n\n/// A function is bijective from `domain` to `codomain`\n/// if it is injective on `domain` and its image equals `codomain`.\npub open spec fn bijective_on<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>) -> bool {\n    injective_on(f, domain) && domain.map(f) =~= codomain\n}\n\n/// `g` is a left inverse of `f` on `domain` if `g(f(x)) == x` for all `x` in `domain`,\n/// and `f(x)` lies in `codomain`.\npub open spec fn left_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    domain.all(|x: A| codomain.contains(f(x)) && g(f(x)) == x)\n}\n\n/// `g` is a right inverse of `f` on `codomain` if `f(g(y)) == y` for all `y` in `codomain`,\n/// and `g(y)` lies in `domain`.\npub open spec fn right_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    codomain.all(|y: B| domain.contains(g(y)) && f(g(y)) == y)\n}\n\n/// `g` is a two-sided inverse of `f` if it is both a left and right inverse.\npub open spec fn inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    left_inverse_on(f, g, domain, codomain) && right_inverse_on(f, g, domain, codomain)\n}\n\n/// Constructs a left inverse function `g` of `f` when `f` is injective on `domain`.\n/// For each `b` in the image, returns the unique `a` such that `f(a) = b`.\npub open spec fn construct_left_inverse<A, B>(f: spec_fn(A) -> B, domain: Set<A>) -> spec_fn(B) -> A\n    recommends\n        injective_on(f, domain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// Constructs the inverse of a bijective function `f` from `domain` to `codomain`.\n/// For each `b` in `codomain`, returns the unique `a` in `domain` such that `f(a) == b`.\npub open spec fn construct_inverse<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> spec_fn(B) -> A\n    recommends\n        bijective_on(f, domain, codomain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// If `f` is injective on `domain`, then `construct_left_inverse(f, domain)`\n/// is a left inverse of `f` on that domain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x`.\npub proof fn lemma_construct_left_inverse_sound<A, B>(f: spec_fn(A) -> B, domain: Set<A>)\n    requires\n        injective_on(f, domain),\n    ensures\n        left_inverse_on(f, construct_left_inverse(f, domain), domain, domain.map(f)),\n{\n}\n\n/// If `f` is bijective from `domain` to `codomain`, then `construct_inverse(f, domain, codomain)`\n/// is a two-sided inverse of `f` on that domain and codomain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x` and for all `y \u2208 codomain`, we have `f(g(y)) == y`.\npub proof fn lemma_construct_inverse_sound<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n    ensures\n        inverse_on(f, construct_inverse(f, domain, codomain), domain, codomain),\n{\n}\n\n/// A function is injective on the whole type implies that it is injective on any sub-domain.\npub proof fn lemma_injective_implies_injective_on<T, U>(f: spec_fn(T) -> U, dom: Set<T>)\n    requires\n        injective(f),\n    ensures\n        injective_on(f, dom),\n{\n}\n\n/// If `f` has a two-sided inverse `g` on `domain` and `codomain`, then `f` is bijective on that domain and codomain.\npub proof fn lemma_two_sided_inverse_implies_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(f, domain, codomain),\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its left inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_left_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_right_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        right_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n    // Prove that g is injective on codomain\n    assert forall|x| #[trigger] codomain.map(g).contains(x) == domain.contains(x) by {\n        if domain.contains(x) {\n            assert(codomain.contains(f(x)));\n        }\n    }\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is either its left or right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain) || right_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n    if left_inverse_on(f, g, domain, codomain) {\n        lemma_left_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    } else {\n        lemma_right_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    }\n}\n\n/// Mapping a finite set with an injective function results in a set of the same cardinality.\npub proof fn lemma_injective_map_cardinality<T, U>(f: spec_fn(T) -> U, dom: Set<T>, s: Set<T>)\n    requires\n        injective_on(f, dom),\n        s.finite(),\n        s <= dom,\n    ensures\n        s.len() == s.map(f).len(),\n        s.map(f).finite(),\n    decreases s.len(),\n{\n    if s.is_empty() {\n        assert(s.map(f) =~= Set::empty());\n    } else {\n        let x = s.choose();\n        lemma_injective_map_cardinality(f, dom, s.remove(x));\n        assert(s.map(f) =~= s.remove(x).map(f).insert(f(x)));\n    }\n}\n\npub proof fn lemma_bijective_cardinality<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>)\n    requires\n        bijective_on(f, domain, codomain),\n        domain.finite(),\n    ensures\n        codomain.finite(),\n        domain.len() == codomain.len(),\n{\n    lemma_injective_map_cardinality(f, domain, domain);\n}\n\npub proof fn lemma_bijective_subset_still_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n    s: Set<A>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        s <= domain,\n    ensures\n        bijective_on(f, s, s.map(f)),\n{\n}\n\n} // verus!\n", "full_verified_code": "use vstd::prelude::*;\nuse vstd::relations::*;\n\nverus! {\n\n/// A function is bijective from `domain` to `codomain`\n/// if it is injective on `domain` and its image equals `codomain`.\npub open spec fn bijective_on<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>) -> bool {\n    injective_on(f, domain) && domain.map(f) =~= codomain\n}\n\n/// `g` is a left inverse of `f` on `domain` if `g(f(x)) == x` for all `x` in `domain`,\n/// and `f(x)` lies in `codomain`.\npub open spec fn left_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    domain.all(|x: A| codomain.contains(f(x)) && g(f(x)) == x)\n}\n\n/// `g` is a right inverse of `f` on `codomain` if `f(g(y)) == y` for all `y` in `codomain`,\n/// and `g(y)` lies in `domain`.\npub open spec fn right_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    codomain.all(|y: B| domain.contains(g(y)) && f(g(y)) == y)\n}\n\n/// `g` is a two-sided inverse of `f` if it is both a left and right inverse.\npub open spec fn inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    left_inverse_on(f, g, domain, codomain) && right_inverse_on(f, g, domain, codomain)\n}\n\n/// Constructs a left inverse function `g` of `f` when `f` is injective on `domain`.\n/// For each `b` in the image, returns the unique `a` such that `f(a) = b`.\npub open spec fn construct_left_inverse<A, B>(f: spec_fn(A) -> B, domain: Set<A>) -> spec_fn(B) -> A\n    recommends\n        injective_on(f, domain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// Constructs the inverse of a bijective function `f` from `domain` to `codomain`.\n/// For each `b` in `codomain`, returns the unique `a` in `domain` such that `f(a) == b`.\npub open spec fn construct_inverse<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> spec_fn(B) -> A\n    recommends\n        bijective_on(f, domain, codomain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// If `f` is injective on `domain`, then `construct_left_inverse(f, domain)`\n/// is a left inverse of `f` on that domain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x`.\npub proof fn lemma_construct_left_inverse_sound<A, B>(f: spec_fn(A) -> B, domain: Set<A>)\n    requires\n        injective_on(f, domain),\n    ensures\n        left_inverse_on(f, construct_left_inverse(f, domain), domain, domain.map(f)),\n{\n}\n\n/// If `f` is bijective from `domain` to `codomain`, then `construct_inverse(f, domain, codomain)`\n/// is a two-sided inverse of `f` on that domain and codomain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x` and for all `y \u2208 codomain`, we have `f(g(y)) == y`.\npub proof fn lemma_construct_inverse_sound<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n    ensures\n        inverse_on(f, construct_inverse(f, domain, codomain), domain, codomain),\n{\n}\n\n/// A function is injective on the whole type implies that it is injective on any sub-domain.\npub proof fn lemma_injective_implies_injective_on<T, U>(f: spec_fn(T) -> U, dom: Set<T>)\n    requires\n        injective(f),\n    ensures\n        injective_on(f, dom),\n{\n}\n\n/// If `f` has a two-sided inverse `g` on `domain` and `codomain`, then `f` is bijective on that domain and codomain.\npub proof fn lemma_two_sided_inverse_implies_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(f, domain, codomain),\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its left inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_left_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_right_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        right_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n    // Prove that g is injective on codomain\n    assert forall|x| #[trigger] codomain.map(g).contains(x) == domain.contains(x) by {\n        if domain.contains(x) {\n            assert(codomain.contains(f(x)));\n        }\n    }\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is either its left or right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain) || right_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n    if left_inverse_on(f, g, domain, codomain) {\n        lemma_left_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    } else {\n        lemma_right_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    }\n}\n\n/// Mapping a finite set with an injective function results in a set of the same cardinality.\npub proof fn lemma_injective_map_cardinality<T, U>(f: spec_fn(T) -> U, dom: Set<T>, s: Set<T>)\n    requires\n        injective_on(f, dom),\n        s.finite(),\n        s <= dom,\n    ensures\n        s.len() == s.map(f).len(),\n        s.map(f).finite(),\n    decreases s.len(),\n{\n    if s.is_empty() {\n        assert(s.map(f) =~= Set::empty());\n    } else {\n        let x = s.choose();\n        lemma_injective_map_cardinality(f, dom, s.remove(x));\n        assert(s.map(f) =~= s.remove(x).map(f).insert(f(x)));\n    }\n}\n\npub proof fn lemma_bijective_cardinality<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>)\n    requires\n        bijective_on(f, domain, codomain),\n        domain.finite(),\n    ensures\n        codomain.finite(),\n        domain.len() == codomain.len(),\n{\n    lemma_injective_map_cardinality(f, domain, domain);\n}\n\npub proof fn lemma_bijective_subset_still_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n    s: Set<A>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        s <= domain,\n    ensures\n        bijective_on(f, s, s.map(f)),\n{\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/vstd_extra/src/function_properties.rs", "verified": true, "metadata": {"original_id": "vostd_function_properties_ac5ffca188ef", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_83b2365e77cf", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nfn decode_char (c : u8) -> (r : u8)  ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nfn decode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn decode_char_spec (c : int) -> (result : int) recommends 65 <= c <= 90 , { (c - 65 + 26 - 5) % 26 + 65 }\nfn decode_char (c : u8) -> (r : u8) requires 65 <= c <= 90 , ensures r == decode_char_spec (c as int) , 65 <= r <= 90 , { let shifted = (c - 65 + 21) % 26 + 65 ; shifted }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/050-encode_shift_impl.rs", "verified": true, "metadata": {"original_id": "83b2365e77cf", "function_name": "decode_char", "bug_type": "missing_requires"}}
{"id": "task_a_7c9959dba619", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { let mut idx = 0 ; while idx < arr . len ()  { if number <= arr [idx] { return false ; } idx += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ndecreases arr . len () - idx \ninvariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> number > arr [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut idx = 0 ; while idx < arr . len () invariant 0 <= idx <= arr . len () , forall | i : int | 0 <= i < idx ==> number > arr [i] , decreases arr . len () - idx , { if number <= arr [idx] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_433_iter_2_current.rs", "verified": true, "metadata": {"original_id": "7c9959dba619", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_ensures_9ca61254863f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 ,  { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/invariants_removed/is_non_prime_impl.rs", "verified": true, "metadata": {"original_id": "9ca61254863f", "function_name": "is_non_prime", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_e611bcbaf723", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N  { a . set (i as usize , 0) ; i = i + 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i , { a . set (i as usize , 0) ; i = i + 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , ensures forall | k : int | 0 <= k < N ==> a [k] == 0 , { let mut i = 0 ; while i < N invariant 0 <= i <= N , a . len () == N , forall | k : int | 0 <= k < i ==> a [k] == 0 , decreases N - i , { a . set (i as usize , 0) ; i = i + 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/condg_impl.rs", "verified": true, "metadata": {"original_id": "e611bcbaf723", "function_name": "myfun", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_68a400c8bb6f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX ,  { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len () invariant s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= i <= s1 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result @ [3 * j] == s1 @ [j] && result @ [3 * j + 1] == s2 @ [j] && result @ [3 * j + 2] == s3 @ [j]) , decreases s1 @ . len () - i { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len () invariant s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= i <= s1 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result @ [3 * j] == s1 @ [j] && result @ [3 * j + 1] == s2 @ [j] && result @ [3 * j + 2] == s3 @ [j]) , decreases s1 @ . len () - i { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s1 . len () invariant s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= i <= s1 @ . len () , result @ . len () == i * 3 , forall | j : int | 0 <= j < i ==> (result @ [3 * j] == s1 @ [j] && result @ [3 * j + 1] == s2 @ [j] && result @ [3 * j + 2] == s3 @ [j]) , decreases s1 @ . len () - i { result . push (s1 [i]) ; result . push (s2 [i]) ; result . push (s3 [i]) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_578_impl.rs", "verified": true, "metadata": {"original_id": "68a400c8bb6f", "function_name": "interleave", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_40acf87cc45e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , { if lst [i] > max_val { max_val = lst [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , decreases lst . len () - i , { if lst [i] > max_val { max_val = lst [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn max_of_list_postcond (lst : Seq < u32 > , result : u32) -> bool { (exists | i : int | 0 <= i < lst . len () && lst [i] == result) && (forall | i : int | 0 <= i < lst . len () ==> lst [i] <= result) }\nspec fn max_of_list_precond (lst : Seq < u32 >) -> bool { lst . len () > 0 }\nfn max_of_list (lst : & Vec < u32 >) -> (result : u32) requires max_of_list_precond (lst @) , ensures max_of_list_postcond (lst @ , result) , { let mut max_val = lst [0] ; let mut i = 1 ; while i < lst . len () invariant 0 < i <= lst . len () , exists | j : int | 0 <= j < i && lst @ [j] == max_val , forall | j : int | 0 <= j < i ==> lst @ [j] <= max_val , decreases lst . len () - i , { if lst [i] > max_val { max_val = lst [i] ; } i = i + 1 ; } max_val }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_39/verina_advanced_39_iter_2_current.rs", "verified": true, "metadata": {"original_id": "40acf87cc45e", "function_name": "max_of_list", "bug_type": "missing_decreases"}}
{"id": "task_b_0ffd97c39815", "task": "task_b", "input_text": "fn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)\nensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "0ffd97c39815", "function_name": "contains", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_decreases_b5dcdc870050", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize) requires idx <= nums . len () , curr_len <= nums . len () , max_len <= nums . len () ensures result <= nums . len () { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize) requires idx <= nums . len () , curr_len <= nums . len () , max_len <= nums . len () ensures result <= nums . len () decreases nums . len () - idx { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn longest_increasing_streak_aux (nums : & Vec < i32 > , idx : usize , prev : Option < i32 > , curr_len : usize , max_len : usize) -> (result : usize) requires idx <= nums . len () , curr_len <= nums . len () , max_len <= nums . len () ensures result <= nums . len () decreases nums . len () - idx { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_30/verina_advanced_30.rs", "verified": true, "metadata": {"original_id": "b5dcdc870050", "function_name": "longest_increasing_streak_aux", "bug_type": "missing_decreases"}}
{"id": "task_a_72a77d0be868", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn canyon_search (a : & [i32] , b : & [i32]) -> (d : u32)   { return 0 ; }\n\n} // verus!", "target_text": "requires a . len () != 0 && b . len () != 0 , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , forall | i : int , j : int | 0 <= i < j < b . len () ==> b [i] <= b [j] \nensures true ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn canyon_search (a : & [i32] , b : & [i32]) -> (d : u32) requires a . len () != 0 && b . len () != 0 , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , forall | i : int , j : int | 0 <= i < j < b . len () ==> b [i] <= b [j] , ensures true , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_canyon_search/verus_code_iter_0_original.rs", "verified": true, "metadata": {"original_id": "72a77d0be868", "function_name": "canyon_search", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_invariant_2a8db183c2ea", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len ()  { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_60/verina_basic_60_iter_2_current.rs", "verified": true, "metadata": {"original_id": "2a8db183c2ea", "function_name": "find_even_numbers", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_ad62c8ff5efd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) ,  { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_9/verina_basic_9_impl.rs", "verified": true, "metadata": {"original_id": "ad62c8ff5efd", "function_name": "has_common_element", "bug_type": "missing_ensures"}}
{"id": "task_b_d4dbcfd2b9f0", "task": "task_b", "input_text": "pub fn clone_arg (arg : & Arg) -> (out : Arg)\nensures out @ == v @, out @ == arg @", "target_text": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type Arg = Vec < u8 > ;\n# [doc = \" Clone a Vec<u8>.\"] # [doc = \"\"] # [doc = \" Implemented as a loop, so might not be as efficient as the\"] # [doc = \" `Vec::clone` method.\"] pub fn clone_vec_u8 (v : & Vec < u8 >) -> (out : Vec < u8 >) ensures out @ == v @ { let mut out : Arg = Vec :: with_capacity (v . len ()) ; let mut i = 0 ; while i < v . len () invariant i <= v . len () , i == out . len () , forall | j | # ! [auto] 0 <= j < i ==> out @ [j] == v @ [j] , decreases v . len () - i , { out . push (v [i]) ; i = i + 1 ; } proof { assert_seqs_equal ! (out @, v @) ; } out }\npub fn clone_arg (arg : & Arg) -> (out : Arg) ensures out @ == arg @ { clone_vec_u8 (arg) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\nuse vstd :: map :: * ;\nuse vstd :: modes :: * ;\nuse vstd :: multiset :: * ;\nuse vstd :: seq :: * ;\nuse vstd :: set :: * ;\nuse vstd :: pervasive :: * ;\nuse vstd :: seq_lib :: * ;\nuse vstd :: { seq :: * , seq_lib :: * } ;\nuse vstd :: bytes :: * ;\nuse vstd :: calc_macro :: * ;\nuse vstd :: set_lib :: * ;\nuse vstd :: slice :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub type Arg = Vec < u8 > ;\n# [doc = \" Clone a Vec<u8>.\"] # [doc = \"\"] # [doc = \" Implemented as a loop, so might not be as efficient as the\"] # [doc = \" `Vec::clone` method.\"] pub fn clone_vec_u8 (v : & Vec < u8 >) -> (out : Vec < u8 >) ensures out @ == v @ { let mut out : Arg = Vec :: with_capacity (v . len ()) ; let mut i = 0 ; while i < v . len () invariant i <= v . len () , i == out . len () , forall | j | # ! [auto] 0 <= j < i ==> out @ [j] == v @ [j] , decreases v . len () - i , { out . push (v [i]) ; i = i + 1 ; } proof { assert_seqs_equal ! (out @, v @) ; } out }\npub fn clone_arg (arg : & Arg) -> (out : Arg) ensures out @ == arg @ { clone_vec_u8 (arg) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "ironsht_inlined.rs", "verified": true, "metadata": {"original_id": "d4dbcfd2b9f0", "function_name": "clone_arg", "has_invariants": true, "has_asserts": false}}
{"id": "task_a_a899b374f623", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool)  { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n\n} // verus!", "target_text": "ensures result == in_array (a @ , x) \ninvariant ! exists | j : int | 0 <= j < i && a @ [j] == x ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant ! exists | j : int | 0 <= j < i && a @ [j] == x , { if a [i] == x { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_duplicates_iter_1_current.rs", "verified": true, "metadata": {"original_id": "a899b374f623", "function_name": "in_array_exec", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_a_f2a35c61be7a", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn first_duplicate_precond (lst : Seq < i32 >) -> bool { true }\nfn first_duplicate (lst : Vec < i32 >) -> (result : i32)  { return 0 ; }\n\n} // verus!", "target_text": "requires first_duplicate_precond (lst @)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn first_duplicate_precond (lst : Seq < i32 >) -> bool { true }\nfn first_duplicate (lst : Vec < i32 >) -> (result : i32) requires first_duplicate_precond (lst @) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_12/verina_advanced_12_iter_0_original.rs", "verified": true, "metadata": {"original_id": "f2a35c61be7a", "function_name": "first_duplicate", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_decreases_c7b2a9edc407", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == if i <= pos { i as int } else { (i as int) - 1 } , forall | j : int | 0 <= j < result . len () && j < pos ==> result [j] == a [j] , forall | j : int | pos <= j < result . len () ==> result [j] == a [j + 1] , { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == if i <= pos { i as int } else { (i as int) - 1 } , forall | j : int | 0 <= j < result . len () && j < pos ==> result [j] == a [j] , forall | j : int | pos <= j < result . len () ==> result [j] == a [j + 1] , decreases a . len () - i { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn remove_element (a : & [i32] , pos : usize) -> (result : Vec < i32 >) requires 0 <= pos < a . len () , ensures result . len () == a . len () - 1 , forall | i : int | 0 <= i < pos ==> result [i] == a [i] , forall | i : int | pos <= i < result . len () ==> result [i] == a [i + 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == if i <= pos { i as int } else { (i as int) - 1 } , forall | j : int | 0 <= j < result . len () && j < pos ==> result [j] == a [j] , forall | j : int | pos <= j < result . len () ==> result [j] == a [j + 1] , decreases a . len () - i { if i != pos { result . push (a [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/remove_element_impl.rs", "verified": true, "metadata": {"original_id": "c7b2a9edc407", "function_name": "remove_element", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_assert_b39d5d780de1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x {  lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int) requires n % 3 == 0 ensures n / 3 * 3 == n { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { assert ((3 * x) % 3 == 0) ; lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int) requires n % 3 == 0 ensures n / 3 * 3 == n { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nspec fn triple_precond (x : int) -> bool { true }\nproof fn lemma_three_times_div (x : int) ensures (3 * x) / 3 == x , ((3 * x) / 3) * 3 == 3 * x { assert ((3 * x) % 3 == 0) ; lemma_div_mul_cancel (3 * x) ; }\nproof fn lemma_div_mul_cancel (n : int) requires n % 3 == 0 ensures n / 3 * 3 == n { }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 1000000 <= x <= 1000000 ensures triple_postcond (x as int , result as int) { proof { lemma_three_times_div (x as int) ; } 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_99/verina_basic_99_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "b39d5d780de1", "function_name": "triple", "bug_type": "missing_assert"}}
{"id": "task_c_missing_decreases_11cd54e75abe", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> (ret : bool) { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , { if n % i == 0 { return false ; } i = i + 1 ; } return true ; }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } return largest ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> (ret : bool) { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i , { if n % i == 0 { return false ; } i = i + 1 ; } return true ; }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i , { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } return largest ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_prime_pred (n : u32) -> (ret : bool) { forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0 }\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i , { if n % i == 0 { return false ; } i = i + 1 ; } return true ; }\n# [verifier :: loop_isolation (false)] fn largest_prime_factor (n : u32) -> (result : u32) requires 2 <= n <= MAX - 1 , ensures 1 <= result <= n , result == 1 || (result > 1 && is_prime_pred (result)) { let mut largest = 1 ; let mut i = 2 ; while i <= n invariant 2 <= i <= n + 1 , 1 <= largest <= n , largest == 1 || (largest > 1 && is_prime_pred (largest)) , decreases n + 1 - i , { if n % i == 0 && is_prime (i) { largest = i ; } i = i + 1 ; } return largest ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/HumanEval-RustBench/additional/largest_prime_factor_impl.rs", "verified": true, "metadata": {"original_id": "11cd54e75abe", "function_name": "largest_prime_factor", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_ensures_4be28fcf4ca8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn move_zeros_to_end_precond (arr : Seq < i32 >) -> bool { true }\nspec fn move_zeros_to_end_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { let first_zero_idx = first_zero_index (result) ; &&& is_perm (result , arr) &&& result . subrange (0 , first_zero_idx) == filter_non_zeros (arr) &&& result . subrange (first_zero_idx , result . len () as int) == filter_zeros (arr) }\nspec fn is_perm < T > (s1 : Seq < T > , s2 : Seq < T >) -> bool { s1 . to_multiset () == s2 . to_multiset () }\nspec fn filter_non_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x != 0) }\nspec fn first_zero_index (s : Seq < i32 >) -> int { 0 }\nspec fn filter_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x == 0) }\n# [verifier :: external_body] fn move_zeros_to_end (arr : Vec < i32 >) -> (result : Vec < i32 >) requires move_zeros_to_end_precond (arr @) ,  { return Vec :: new () ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn move_zeros_to_end_precond (arr : Seq < i32 >) -> bool { true }\nspec fn move_zeros_to_end_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { let first_zero_idx = first_zero_index (result) ; &&& is_perm (result , arr) &&& result . subrange (0 , first_zero_idx) == filter_non_zeros (arr) &&& result . subrange (first_zero_idx , result . len () as int) == filter_zeros (arr) }\nspec fn is_perm < T > (s1 : Seq < T > , s2 : Seq < T >) -> bool { s1 . to_multiset () == s2 . to_multiset () }\nspec fn filter_non_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x != 0) }\nspec fn first_zero_index (s : Seq < i32 >) -> int { 0 }\nspec fn filter_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x == 0) }\n# [verifier :: external_body] fn move_zeros_to_end (arr : Vec < i32 >) -> (result : Vec < i32 >) requires move_zeros_to_end_precond (arr @) , ensures move_zeros_to_end_postcond (arr @ , result @) , { return Vec :: new () ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn move_zeros_to_end_precond (arr : Seq < i32 >) -> bool { true }\nspec fn move_zeros_to_end_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { let first_zero_idx = first_zero_index (result) ; &&& is_perm (result , arr) &&& result . subrange (0 , first_zero_idx) == filter_non_zeros (arr) &&& result . subrange (first_zero_idx , result . len () as int) == filter_zeros (arr) }\nspec fn is_perm < T > (s1 : Seq < T > , s2 : Seq < T >) -> bool { s1 . to_multiset () == s2 . to_multiset () }\nspec fn filter_non_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x != 0) }\nspec fn first_zero_index (s : Seq < i32 >) -> int { 0 }\nspec fn filter_zeros (s : Seq < i32 >) -> Seq < i32 > { s . filter (| x : i32 | x == 0) }\n# [verifier :: external_body] fn move_zeros_to_end (arr : Vec < i32 >) -> (result : Vec < i32 >) requires move_zeros_to_end_precond (arr @) , ensures move_zeros_to_end_postcond (arr @ , result @) , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_35/verina_basic_35_iter_0_original.rs", "verified": true, "metadata": {"original_id": "4be28fcf4ca8", "function_name": "move_zeros_to_end", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_a439577991c0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >)  ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | j : int | 0 <= j < arr2 . len () ==> # [trigger] arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] / arr2 [j]) <= MAX) , decreases arr1 . len () - i { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | j : int | 0 <= j < arr2 . len () ==> # [trigger] arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] / arr2 [j]) <= MAX) , decreases arr1 . len () - i { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_divide (arr1 : & Vec < u32 > , arr2 : & Vec < u32 >) -> (result : Vec < u32 >) requires arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < arr2 . len () ==> arr2 [i] != 0 , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] / arr2 [i]) <= MAX) , ensures result @ . len () == arr1 @ . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] / arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , arr1 . len () == arr2 . len () , result @ . len () == i , forall | j : int | 0 <= j < i ==> # [trigger] result [j] == # [trigger] (arr1 [j] / arr2 [j]) , forall | j : int | 0 <= j < arr2 . len () ==> # [trigger] arr2 [j] != 0 , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] / arr2 [j]) <= MAX) , decreases arr1 . len () - i { let quotient = arr1 [i] / arr2 [i] ; result . push (quotient) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_618_impl.rs", "verified": true, "metadata": {"original_id": "a439577991c0", "function_name": "element_wise_divide", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_84f1fcf3e5ee", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> arr @ . contains (result @ [k]) , forall | x : i32 | result @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { let val = arr [i] ; if val % 2 == 0 { result . push (val) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> arr @ . contains (result @ [k]) , forall | x : i32 | result @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) decreases arr . len () - i { let val = arr [i] ; if val % 2 == 0 { result . push (val) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even_spec (x : int) -> bool { x % 2 == 0 }\nfn find_even_numbers (arr : & [i32]) -> (even_numbers : Vec < i32 >) requires arr . len () <= MAX , ensures forall | k : int | 0 <= k < even_numbers @ . len () ==> is_even_spec (even_numbers @ [k] as int) , forall | k : int | 0 <= k < even_numbers @ . len () ==> arr @ . contains (even_numbers @ [k]) , forall | x : i32 | even_numbers @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | k : int | 0 <= k < result @ . len () ==> is_even_spec (result @ [k] as int) , forall | k : int | 0 <= k < result @ . len () ==> arr @ . contains (result @ [k]) , forall | x : i32 | result @ . contains (x) ==> (arr @ . contains (x) && is_even_spec (x as int)) decreases arr . len () - i { let val = arr [i] ; if val % 2 == 0 { result . push (val) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_even_list/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "84f1fcf3e5ee", "function_name": "find_even_numbers", "bug_type": "missing_decreases"}}
{"id": "task_b_aa069d0f8570", "task": "task_b", "input_text": "fn longest_increasing_subseq_length (xs : & Vec < i32 >) -> (result : usize)\nrequires longest_increasing_subseq_length_precond (xs @) \nensures longest_increasing_subseq_length_postcond (xs @ , result as nat) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subseq_length_precond (xs : Seq < i32 >) -> bool { true }\nspec fn longest_increasing_subseq_length_postcond (xs : Seq < i32 > , result : nat) -> bool { result <= xs . len () }\nfn longest_increasing_subseq_length (xs : & Vec < i32 >) -> (result : usize) requires longest_increasing_subseq_length_precond (xs @) , ensures longest_increasing_subseq_length_postcond (xs @ , result as nat) , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_increasing_subseq_length_precond (xs : Seq < i32 >) -> bool { true }\nspec fn longest_increasing_subseq_length_postcond (xs : Seq < i32 > , result : nat) -> bool { result <= xs . len () }\nfn longest_increasing_subseq_length (xs : & Vec < i32 >) -> (result : usize) requires longest_increasing_subseq_length_precond (xs @) , ensures longest_increasing_subseq_length_postcond (xs @ , result as nat) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_31/verina_advanced_31.rs", "verified": true, "metadata": {"original_id": "aa069d0f8570", "function_name": "longest_increasing_subseq_length", "has_invariants": false, "has_asserts": false}}
{"id": "task_b_2ead9a18c535", "task": "task_b", "input_text": "fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)\nrequires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 \nensures sum [0] <= 5 * N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 5 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , N < 1000 , ensures sum [0] <= 5 * N , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/brs5_impl.rs", "verified": true, "metadata": {"original_id": "2ead9a18c535", "function_name": "myfun", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_3df3a1cef5df", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)  { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >)  { let mut result = Vec :: new () ; for i in 0 .. list1 . len ()  { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "target_text": "ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] \ninvariant forall | j : int | 0 <= j < i ==> arr [j] != key , forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\nfn shared_elements (list1 : & Vec < i32 > , list2 : & Vec < i32 >) -> (shared : Vec < i32 >) ensures forall | i : int | 0 <= i < shared . len () ==> (list1 @ . contains (# [trigger] shared [i]) && list2 @ . contains (# [trigger] shared [i] ,)) , forall | i : int , j : int | 0 <= i < j < shared . len () ==> shared [i] != shared [j] , { let mut result = Vec :: new () ; for i in 0 .. list1 . len () invariant forall | k : int | 0 <= k < result . len () ==> (list1 @ . contains (# [trigger] result [k]) && list2 @ . contains (# [trigger] result [k] ,)) , forall | k1 : int , k2 : int | 0 <= k1 < k2 < result . len () ==> result [k1] != result [k2] , { let elem = list1 [i] ; if contains (list2 , elem) && ! contains (& result , elem) { result . push (elem) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "3df3a1cef5df", "function_name": "shared_elements", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": false}}
{"id": "task_b_cc4d8d29f131", "task": "task_b", "input_text": "fn compute_avg (a : u32 , b : u32) -> (avg : u32)\nrequires a < 0x80000000 && b < 0x80000000\nensures avg == (a + b) / 2", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_avg/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "cc4d8d29f131", "function_name": "compute_avg", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_48576af6ea0f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32)  { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn replace (a : & mut Vec < i32 > , x : i32 , y : i32) ensures a . len () == old (a) . len () , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < old (a) . len () && old (a) [k] != x ==> a [k] == old (a) [k] , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , a . len () == old (a) . len () , forall | k : int | 0 <= k < i && old (a) [k] == x ==> a [k] == y , forall | k : int | 0 <= k < i && old (a) [k] != x ==> a [k] == old (a) [k] , forall | k : int | i <= k < a . len () ==> a [k] == old (a) [k] , decreases a . len () - i { if a [i] == x { a . set (i , y) ; } i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/replace_impl.rs", "verified": true, "metadata": {"original_id": "48576af6ea0f", "function_name": "replace", "bug_type": "missing_ensures"}}
{"id": "task_a_584be3ed198e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn create_all_state (increment : i32 , total_number : i32 , level : i32 , current_list : & mut Vec < i32 > , total_list : & mut Vec < Vec < i32 > > ,)  { }\n\n} // verus!", "target_text": "requires increment >= 1 , 0 <= level <= total_number , total_number + 1 <= MAX ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn create_all_state (increment : i32 , total_number : i32 , level : i32 , current_list : & mut Vec < i32 > , total_list : & mut Vec < Vec < i32 > > ,) requires increment >= 1 , 0 <= level <= total_number , total_number + 1 <= MAX , { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/interprocedural/AlgorithmsRust/all_combination_of_size_k_iter_0_original.rs", "verified": true, "metadata": {"original_id": "584be3ed198e", "function_name": "create_all_state", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_invariant_da09a0a8af91", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index = 0 ; let mut i = 1 ; while i < x . len ()  { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index = 0 ; let mut i = 1 ; while i < x . len () invariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] , decreases x . len () - i { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun1 (x : & Vec < i32 >) -> (max_index : usize) requires x . len () >= 1 , ensures forall | k : int | 0 <= k < x . len () ==> x [max_index as int] >= x [k] , max_index < x . len () , { let mut max_index = 0 ; let mut i = 1 ; while i < x . len () invariant max_index < x . len () , i <= x . len () , forall | k : int | 0 <= k < i ==> x [max_index as int] >= x [k] , decreases x . len () - i { if x [i] > x [max_index] { max_index = i ; } i = i + 1 ; } max_index }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/Misc/verified/max_index_iter_2_current.rs", "verified": true, "metadata": {"original_id": "da09a0a8af91", "function_name": "myfun1", "bug_type": "missing_invariant"}}
{"id": "task_b_5d99f488f836", "task": "task_b", "input_text": "fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize)\nrequires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 \nensures sum [0] == 4 * N ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum [0] = 4 * (N as i32) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : usize) requires N > 0 , old (a) . len () == N , old (sum) . len () == 1 , N < 1000 , ensures sum [0] == 4 * N , { sum [0] = 4 * (N as i32) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/SVComp-Array-fpi-nonl/s32if_impl.rs", "verified": true, "metadata": {"original_id": "5d99f488f836", "function_name": "myfun", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_invariant_42032eb12d0e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn append_with_element (a : & Vec < i32 > , b : i32) -> (result : Vec < i32 >) ensures result . len () == a . len () + 1 , forall | i : int | # ! [auto] 0 <= i && i < result . len () ==> result [i] == (if i < a . len () { a [i] } else { b }) , { let mut result : Vec < i32 > = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i = i + 1 ; } result . push (b) ; result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn append_with_element (a : & Vec < i32 > , b : i32) -> (result : Vec < i32 >) ensures result . len () == a . len () + 1 , forall | i : int | # ! [auto] 0 <= i && i < result . len () ==> result [i] == (if i < a . len () { a [i] } else { b }) , { let mut result : Vec < i32 > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i { result . push (a [i]) ; i = i + 1 ; } result . push (b) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn append_with_element (a : & Vec < i32 > , b : i32) -> (result : Vec < i32 >) ensures result . len () == a . len () + 1 , forall | i : int | # ! [auto] 0 <= i && i < result . len () ==> result [i] == (if i < a . len () { a [i] } else { b }) , { let mut result : Vec < i32 > = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i && i <= a . len () , result . len () == i , forall | j : int | 0 <= j && j < i ==> result [j] == a [j] , decreases a . len () - i { result . push (a [i]) ; i = i + 1 ; } result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/array_append_iter_2_current.rs", "verified": true, "metadata": {"original_id": "42032eb12d0e", "function_name": "append_with_element", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_d8df50f35fcd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool)  ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/080-is_happy_impl.rs", "verified": true, "metadata": {"original_id": "d8df50f35fcd", "function_name": "three_distinct", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_f36d321f2a42", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize)  ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/binary_search_recursive_iter_1_current.rs", "verified": true, "metadata": {"original_id": "f36d321f2a42", "function_name": "binary_search_recursive", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_1f3be13c8af3", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn m1 (x : i32 , y : i32) -> (z : i32) requires 0 < x < y ,  { 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn m1 (x : i32 , y : i32) -> (z : i32) requires 0 < x < y , ensures z >= 0 && z <= y && z != x , { 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn m1 (x : i32 , y : i32) -> (z : i32) requires 0 < x < y , ensures z >= 0 && z <= y && z != x , { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/CVS-Projto1_tmp_tmpb1o0bu8z_Hoare/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "1f3be13c8af3", "function_name": "m1", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_6ef2c7616a96", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () ,  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant result . len () == idx , idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx && i < arr1 . len () && i < arr2 . len () ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (idx < arr2 . len ()) ; result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant result . len () == idx , idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx && i < arr1 . len () && i < arr2 . len () ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (idx < arr2 . len ()) ; result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bit_wise_xor (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> result [i] == # [trigger] arr1 [i] ^ # [trigger] arr2 [i] , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < arr1 . len () invariant result . len () == idx , idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx && i < arr1 . len () && i < arr2 . len () ==> result [i] == arr1 [i] ^ arr2 [i] , decreases arr1 . len () - idx , { assert (idx < arr1 . len ()) ; assert (idx < arr2 . len ()) ; result . push (arr1 [idx] ^ arr2 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_399_impl.rs", "verified": true, "metadata": {"original_id": "6ef2c7616a96", "function_name": "bit_wise_xor", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_018f574bcab8", "task": "task_c", "input_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn f (seq : Seq < u64 > , i : int) -> (result : bool) { seq [i] == i + 2 }\nfn get_element_check_property (arr : Vec < u64 > , i : usize) -> (ret : u64)  ensures ret == i + 2 , ret == arr @ [i as int] , { assert (f (arr @ , i as int)) ; arr [i] }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn f (seq : Seq < u64 > , i : int) -> (result : bool) { seq [i] == i + 2 }\nfn get_element_check_property (arr : Vec < u64 > , i : usize) -> (ret : u64) requires arr . len () > 0 , 0 < i < arr @ . len () , forall | i : int | f (arr @ , i) , ensures ret == i + 2 , ret == arr @ [i as int] , { assert (f (arr @ , i as int)) ; arr [i] }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n# [allow (unused_imports)] use vstd :: prelude :: * ;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn f (seq : Seq < u64 > , i : int) -> (result : bool) { seq [i] == i + 2 }\nfn get_element_check_property (arr : Vec < u64 > , i : usize) -> (ret : u64) requires arr . len () > 0 , 0 < i < arr @ . len () , forall | i : int | f (arr @ , i) , ensures ret == i + 2 , ret == arr @ [i as int] , { assert (f (arr @ , i as int)) ; arr [i] }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/Misc/trigger_impl.rs", "verified": true, "metadata": {"original_id": "018f574bcab8", "function_name": "get_element_check_property", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_41cbaa48a2de", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] , decreases arr . len () - index , { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] , decreases arr . len () - index , { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] , decreases arr . len () - index , { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/autoverus/MBPP/verified/task_id_433_impl.rs", "verified": true, "metadata": {"original_id": "41cbaa48a2de", "function_name": "is_greater", "bug_type": "missing_ensures"}}
{"id": "task_a_c1eec920f16e", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >)   { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\n\n} // verus!", "target_text": "requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] \nensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i\ndecreases s . len () - i", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn double_array_elements_precond (s : Vec < i32 >) -> bool { forall | i : int | # ! [auto] 0 <= i < s . len () ==> s [i] <= MAX / 2 && s [i] >= MIN / 2 }\nfn double_array_elements_aux (s_old : Vec < i32 > , s : Vec < i32 > , i : usize) -> (result : Vec < i32 >) requires s . len () == s_old . len () , i <= s . len () , double_array_elements_precond (s_old) , forall | j : int | # ! [auto] 0 <= j < i ==> s [j] == 2 * s_old [j] , forall | j : int | # ! [auto] i <= j < s . len () ==> s [j] == s_old [j] , ensures result . len () == s . len () , forall | j : int | # ! [auto] 0 <= j < s . len () ==> result [j] == 2 * s_old [j] , decreases s . len () - i { if i == s . len () { return s ; } else { let mut s_new = s ; s_new . set (i , 2 * s_old [i]) ; double_array_elements_aux (s_old , s_new , i + 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_58/verina_basic_58_iter_1_current.rs", "verified": true, "metadata": {"original_id": "c1eec920f16e", "function_name": "double_array_elements_aux", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_b_39e37c7acd6a", "task": "task_b", "input_text": "fn cal_div () -> (r : (u32 , u32)\nensures r . 0 == 27 , r . 1 == 2 ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cal_div () -> (r : (u32 , u32)) ensures r . 0 == 27 , r . 1 == 2 , { (27 , 2) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn cal_div () -> (r : (u32 , u32)) ensures r . 0 == 27 , r . 1 == 2 , { (27 , 2) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/CloverBench/verified/cal_div_iter_1_current.rs", "verified": true, "metadata": {"original_id": "39e37c7acd6a", "function_name": "cal_div", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_requires_c8304568ff0a", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool)  ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn three_distinct_spec (s : Seq < char > , i : int) -> (ret : bool) recommends 0 < i && i + 1 < s . len () , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\nfn three_distinct (s : & Vec < char > , i : usize) -> (is : bool) requires 0 < i && i + 1 < s . len () , ensures is <==> three_distinct_spec (s @ , i as int) , { (s [i - 1] != s [i]) && (s [i] != s [i + 1]) && (s [i - 1] != s [i + 1]) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/080-is_happy_iter_2_current.rs", "verified": true, "metadata": {"original_id": "c8304568ff0a", "function_name": "three_distinct", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_46af5580e5a0", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len ()  { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len ()  { row . push (a [i] [j] + b [i] [j]) ; } c . push (row) ; } c }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | # ! [auto] 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { row . push (a [i] [j] + b [i] [j]) ; } c . push (row) ; } c }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn index_wise_addition (a : & Vec < Vec < i32 > > , b : & Vec < Vec < i32 > >) -> (c : Vec < Vec < i32 > >) requires a . len () == b . len () , forall | i : int | # ! [auto] 0 <= i < a . len () ==> a [i] . len () == b [i] . len () , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] <= MAX , forall | i : int | # ! [trigger a [i] , b [i]] 0 <= i < a . len () ==> forall | j : int | 0 <= j < a [i] . len () ==> a [i] [j] + b [i] [j] >= MIN , ensures c . len () == a . len () , forall | i : int | # ! [auto] 0 <= i < c . len () ==> c [i] . len () == a [i] . len () , forall | i : int | # ! [trigger a [i] , b [i] , c [i]] 0 <= i < c . len () ==> forall | j : int | # ! [auto] 0 <= j < c [i] . len () ==> c [i] [j] == a [i] [j] + b [i] [j] , { let mut c : Vec < Vec < i32 > > = Vec :: new () ; for i in 0 .. a . len () invariant c . len () == i , forall | k : int | # ! [auto] 0 <= k < i ==> c [k] . len () == a [k] . len () , forall | k : int | # ! [trigger a [k] , b [k] , c [k]] 0 <= k < i ==> forall | j : int | # ! [auto] 0 <= j < c [k] . len () ==> c [k] [j] == a [k] [j] + b [k] [j] , { let mut row : Vec < i32 > = Vec :: new () ; for j in 0 .. a [i] . len () invariant row . len () == j , forall | l : int | # ! [auto] 0 <= l < j ==> row [l] == a [i as int] [l] + b [i as int] [l] , { row . push (a [i] [j] + b [i] [j]) ; } c . push (row) ; } c }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/invariants_removed/index_wise_addition_iter_2_current.rs", "verified": true, "metadata": {"original_id": "46af5580e5a0", "function_name": "index_wise_addition", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_26115561dc1d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result ==> (forall | k : int | 2 <= k < n ==> # [trigger] (n as int % k) != 0) , ! result ==> exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2u32 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return false ; } i = i + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/largest_prime_factor_iter_2_current.rs", "verified": true, "metadata": {"original_id": "26115561dc1d", "function_name": "is_prime", "bug_type": "missing_decreases"}}
{"id": "task_b_bbc941e4aa4d", "task": "task_b", "input_text": "fn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool)\nrequires arr . len () > 0 \nensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_sorted (arr : & Vec < i32 >) -> (is_sorted : bool) requires arr . len () > 0 , ensures is_sorted == (forall | i : int , j : int | 0 <= i < j < arr . len () ==> (arr [i] <= arr [j])) , { let mut idx = 0 ; while idx < arr . len () - 1 invariant 0 <= idx <= arr . len () - 1 , forall | i : int , j : int | 0 <= i < j <= idx ==> arr [i] <= arr [j] , decreases arr . len () - 1 - idx , { if arr [idx] > arr [idx + 1] { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/verified/task_id_567_impl.rs", "verified": true, "metadata": {"original_id": "bbc941e4aa4d", "function_name": "is_sorted", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_ensures_9b7d9443feb8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize) requires 0 <= j < old (a) . len () ,  { a . set (j , 60) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize) requires 0 <= j < old (a) . len () , ensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] , { a . set (j , 60) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn test_array_elements (a : & mut Vec < i32 > , j : usize) requires 0 <= j < old (a) . len () , ensures a [j as int] == 60 , forall | k : int | 0 <= k < old (a) . len () && k != j ==> a [k] == old (a) [k] , { a . set (j , 60) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_test_array/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "9b7d9443feb8", "function_name": "test_array_elements", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_7157a8cdb4f1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted (xs : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < xs . len () ==> xs [i] < xs [j] }\nfn helper (ys : & Vec < int > , target : int , idx : usize) -> (result : usize) requires idx <= ys . len () , is_sorted (ys @) , forall | i : int | 0 <= i < idx ==> ys @ [i] < target , ensures idx <= result <= ys . len () , forall | i : int | idx <= i < result ==> ys @ [i] < target , result < ys . len () ==> target <= ys @ [result as int] , decreases ys . len () - idx , { if idx == ys . len () { return idx ; } if target <= ys [idx] { return idx ; } else { return helper (ys , target , idx + 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_advanced_69/verina_advanced_69_iter_1_current.rs", "verified": true, "metadata": {"original_id": "7157a8cdb4f1", "function_name": "helper", "bug_type": "missing_decreases"}}
{"id": "task_a_16a922d07ab2", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize)   { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "target_text": "requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key \nensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo\ndecreases hi - lo", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn binary_search_precond (a : Seq < i32 > , key : i32) -> bool { forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] }\nfn binary_search_loop (a : & Vec < i32 > , key : i32 , lo : usize , hi : usize) -> (result : usize) requires lo <= hi <= a . len () , binary_search_precond (a @ , key) , forall | i : int | 0 <= i < lo ==> a [i] < key , forall | i : int | hi <= i < a . len () ==> a [i] >= key , ensures result <= a . len () , forall | i : int | 0 <= i < result ==> a [i] < key , forall | i : int | result <= i < a . len () ==> a [i] >= key , decreases hi - lo { if lo == hi { return lo ; } let mid = lo + (hi - lo) / 2 ; if a [mid] < key { binary_search_loop (a , key , mid + 1 , hi) } else { binary_search_loop (a , key , lo , mid) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_51/verina_basic_51_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "16a922d07ab2", "function_name": "binary_search_loop", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": true}}
{"id": "task_c_missing_assert_8d4192fb2564", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , decreases a . len () - i , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; }   result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , decreases a . len () - i , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } assert (i == a . len ()) ; assert (result . len () == i) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn array_product (a : Vec < i32 > , b : Vec < i32 >) -> (result : Vec < i64 >) by (nonlinear_arith) requires a . len () == b . len () , ensures result . len () == a . len () , forall | i : int | # ! [auto] 0 <= i && i < a . len () ==> result [i] == (a [i] as i64) * (b [i] as i64) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , result . len () == i , forall | j : int | # ! [auto] 0 <= j && j < i ==> result [j] == (a [j] as i64) * (b [j] as i64) , decreases a . len () - i , { let product = (a [i] as i64) * (b [i] as i64) ; result . push (product) ; i += 1 ; } assert (i == a . len ()) ; assert (result . len () == i) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/ground_truth/array_product_impl.rs", "verified": true, "metadata": {"original_id": "8d4192fb2564", "function_name": "array_product", "bug_type": "missing_assert"}}
{"id": "task_b_14a947f9a02f", "task": "task_b", "input_text": "fn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >)\nensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i , { let c = str1 [i] ; if c == ' ' || c == ',' || c == '.' { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_with_colon (str1 : & Vec < char > , k : int) -> (result : char) { if is_space_comma_dot_spec (str1 [k]) { ':' } else { str1 [k] } }\nspec fn is_space_comma_dot_spec (c : char) -> (result : bool) { (c == ' ') || (c == ',') || (c == '.') }\nfn replace_with_colon (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | k : int | 0 <= k < result . len () ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < str1 . len () invariant 0 <= i <= str1 . len () , result . len () == i , forall | k : int | 0 <= k < i ==> # [trigger] result [k] == inner_expr_replace_with_colon (str1 , k) , decreases str1 . len () - i , { let c = str1 [i] ; if c == ' ' || c == ',' || c == '.' { result . push (':') ; } else { result . push (c) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_732_impl.rs", "verified": true, "metadata": {"original_id": "14a947f9a02f", "function_name": "replace_with_colon", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_assert_vostd_function_properties_ac5ffca188ef", "task": "task_c", "input_text": "use vstd::prelude::*;\nuse vstd::relations::*;\n\nverus! {\n\n/// A function is bijective from `domain` to `codomain`\n/// if it is injective on `domain` and its image equals `codomain`.\npub open spec fn bijective_on<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>) -> bool {\n    injective_on(f, domain) && domain.map(f) =~= codomain\n}\n\n/// `g` is a left inverse of `f` on `domain` if `g(f(x)) == x` for all `x` in `domain`,\n/// and `f(x)` lies in `codomain`.\npub open spec fn left_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    domain.all(|x: A| codomain.contains(f(x)) && g(f(x)) == x)\n}\n\n/// `g` is a right inverse of `f` on `codomain` if `f(g(y)) == y` for all `y` in `codomain`,\n/// and `g(y)` lies in `domain`.\npub open spec fn right_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    codomain.all(|y: B| domain.contains(g(y)) && f(g(y)) == y)\n}\n\n/// `g` is a two-sided inverse of `f` if it is both a left and right inverse.\npub open spec fn inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    left_inverse_on(f, g, domain, codomain) && right_inverse_on(f, g, domain, codomain)\n}\n\n/// Constructs a left inverse function `g` of `f` when `f` is injective on `domain`.\n/// For each `b` in the image, returns the unique `a` such that `f(a) = b`.\npub open spec fn construct_left_inverse<A, B>(f: spec_fn(A) -> B, domain: Set<A>) -> spec_fn(B) -> A\n    recommends\n        injective_on(f, domain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// Constructs the inverse of a bijective function `f` from `domain` to `codomain`.\n/// For each `b` in `codomain`, returns the unique `a` in `domain` such that `f(a) == b`.\npub open spec fn construct_inverse<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> spec_fn(B) -> A\n    recommends\n        bijective_on(f, domain, codomain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// If `f` is injective on `domain`, then `construct_left_inverse(f, domain)`\n/// is a left inverse of `f` on that domain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x`.\npub proof fn lemma_construct_left_inverse_sound<A, B>(f: spec_fn(A) -> B, domain: Set<A>)\n    requires\n        injective_on(f, domain),\n    ensures\n        left_inverse_on(f, construct_left_inverse(f, domain), domain, domain.map(f)),\n{\n}\n\n/// If `f` is bijective from `domain` to `codomain`, then `construct_inverse(f, domain, codomain)`\n/// is a two-sided inverse of `f` on that domain and codomain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x` and for all `y \u2208 codomain`, we have `f(g(y)) == y`.\npub proof fn lemma_construct_inverse_sound<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n    ensures\n        inverse_on(f, construct_inverse(f, domain, codomain), domain, codomain),\n{\n}\n\n/// A function is injective on the whole type implies that it is injective on any sub-domain.\npub proof fn lemma_injective_implies_injective_on<T, U>(f: spec_fn(T) -> U, dom: Set<T>)\n    requires\n        injective(f),\n    ensures\n        injective_on(f, dom),\n{\n}\n\n/// If `f` has a two-sided inverse `g` on `domain` and `codomain`, then `f` is bijective on that domain and codomain.\npub proof fn lemma_two_sided_inverse_implies_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(f, domain, codomain),\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its left inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_left_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_right_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        right_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n    // Prove that g is injective on codomain\n    }\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is either its left or right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain) || right_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n    if left_inverse_on(f, g, domain, codomain) {\n        lemma_left_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    } else {\n        lemma_right_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    }\n}\n\n/// Mapping a finite set with an injective function results in a set of the same cardinality.\npub proof fn lemma_injective_map_cardinality<T, U>(f: spec_fn(T) -> U, dom: Set<T>, s: Set<T>)\n    requires\n        injective_on(f, dom),\n        s.finite(),\n        s <= dom,\n    ensures\n        s.len() == s.map(f).len(),\n        s.map(f).finite(),\n    decreases s.len(),\n{\n    if s.is_empty() {\n\n    } else {\n        let x = s.choose();\n        lemma_injective_map_cardinality(f, dom, s.remove(x));\n\n    }\n}\n\npub proof fn lemma_bijective_cardinality<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>)\n    requires\n        bijective_on(f, domain, codomain),\n        domain.finite(),\n    ensures\n        codomain.finite(),\n        domain.len() == codomain.len(),\n{\n    lemma_injective_map_cardinality(f, domain, domain);\n}\n\npub proof fn lemma_bijective_subset_still_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n    s: Set<A>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        s <= domain,\n    ensures\n        bijective_on(f, s, s.map(f)),\n{\n}\n\n} // verus!\n", "target_text": "use vstd::prelude::*;\nuse vstd::relations::*;\n\nverus! {\n\n/// A function is bijective from `domain` to `codomain`\n/// if it is injective on `domain` and its image equals `codomain`.\npub open spec fn bijective_on<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>) -> bool {\n    injective_on(f, domain) && domain.map(f) =~= codomain\n}\n\n/// `g` is a left inverse of `f` on `domain` if `g(f(x)) == x` for all `x` in `domain`,\n/// and `f(x)` lies in `codomain`.\npub open spec fn left_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    domain.all(|x: A| codomain.contains(f(x)) && g(f(x)) == x)\n}\n\n/// `g` is a right inverse of `f` on `codomain` if `f(g(y)) == y` for all `y` in `codomain`,\n/// and `g(y)` lies in `domain`.\npub open spec fn right_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    codomain.all(|y: B| domain.contains(g(y)) && f(g(y)) == y)\n}\n\n/// `g` is a two-sided inverse of `f` if it is both a left and right inverse.\npub open spec fn inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    left_inverse_on(f, g, domain, codomain) && right_inverse_on(f, g, domain, codomain)\n}\n\n/// Constructs a left inverse function `g` of `f` when `f` is injective on `domain`.\n/// For each `b` in the image, returns the unique `a` such that `f(a) = b`.\npub open spec fn construct_left_inverse<A, B>(f: spec_fn(A) -> B, domain: Set<A>) -> spec_fn(B) -> A\n    recommends\n        injective_on(f, domain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// Constructs the inverse of a bijective function `f` from `domain` to `codomain`.\n/// For each `b` in `codomain`, returns the unique `a` in `domain` such that `f(a) == b`.\npub open spec fn construct_inverse<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> spec_fn(B) -> A\n    recommends\n        bijective_on(f, domain, codomain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// If `f` is injective on `domain`, then `construct_left_inverse(f, domain)`\n/// is a left inverse of `f` on that domain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x`.\npub proof fn lemma_construct_left_inverse_sound<A, B>(f: spec_fn(A) -> B, domain: Set<A>)\n    requires\n        injective_on(f, domain),\n    ensures\n        left_inverse_on(f, construct_left_inverse(f, domain), domain, domain.map(f)),\n{\n}\n\n/// If `f` is bijective from `domain` to `codomain`, then `construct_inverse(f, domain, codomain)`\n/// is a two-sided inverse of `f` on that domain and codomain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x` and for all `y \u2208 codomain`, we have `f(g(y)) == y`.\npub proof fn lemma_construct_inverse_sound<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n    ensures\n        inverse_on(f, construct_inverse(f, domain, codomain), domain, codomain),\n{\n}\n\n/// A function is injective on the whole type implies that it is injective on any sub-domain.\npub proof fn lemma_injective_implies_injective_on<T, U>(f: spec_fn(T) -> U, dom: Set<T>)\n    requires\n        injective(f),\n    ensures\n        injective_on(f, dom),\n{\n}\n\n/// If `f` has a two-sided inverse `g` on `domain` and `codomain`, then `f` is bijective on that domain and codomain.\npub proof fn lemma_two_sided_inverse_implies_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(f, domain, codomain),\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its left inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_left_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_right_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        right_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n    // Prove that g is injective on codomain\n    assert forall|x| #[trigger] codomain.map(g).contains(x) == domain.contains(x) by {\n        if domain.contains(x) {\n            assert(codomain.contains(f(x)));\n        }\n    }\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is either its left or right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain) || right_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n    if left_inverse_on(f, g, domain, codomain) {\n        lemma_left_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    } else {\n        lemma_right_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    }\n}\n\n/// Mapping a finite set with an injective function results in a set of the same cardinality.\npub proof fn lemma_injective_map_cardinality<T, U>(f: spec_fn(T) -> U, dom: Set<T>, s: Set<T>)\n    requires\n        injective_on(f, dom),\n        s.finite(),\n        s <= dom,\n    ensures\n        s.len() == s.map(f).len(),\n        s.map(f).finite(),\n    decreases s.len(),\n{\n    if s.is_empty() {\n        assert(s.map(f) =~= Set::empty());\n    } else {\n        let x = s.choose();\n        lemma_injective_map_cardinality(f, dom, s.remove(x));\n        assert(s.map(f) =~= s.remove(x).map(f).insert(f(x)));\n    }\n}\n\npub proof fn lemma_bijective_cardinality<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>)\n    requires\n        bijective_on(f, domain, codomain),\n        domain.finite(),\n    ensures\n        codomain.finite(),\n        domain.len() == codomain.len(),\n{\n    lemma_injective_map_cardinality(f, domain, domain);\n}\n\npub proof fn lemma_bijective_subset_still_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n    s: Set<A>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        s <= domain,\n    ensures\n        bijective_on(f, s, s.map(f)),\n{\n}\n\n} // verus!\n", "full_verified_code": "use vstd::prelude::*;\nuse vstd::relations::*;\n\nverus! {\n\n/// A function is bijective from `domain` to `codomain`\n/// if it is injective on `domain` and its image equals `codomain`.\npub open spec fn bijective_on<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>) -> bool {\n    injective_on(f, domain) && domain.map(f) =~= codomain\n}\n\n/// `g` is a left inverse of `f` on `domain` if `g(f(x)) == x` for all `x` in `domain`,\n/// and `f(x)` lies in `codomain`.\npub open spec fn left_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    domain.all(|x: A| codomain.contains(f(x)) && g(f(x)) == x)\n}\n\n/// `g` is a right inverse of `f` on `codomain` if `f(g(y)) == y` for all `y` in `codomain`,\n/// and `g(y)` lies in `domain`.\npub open spec fn right_inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    codomain.all(|y: B| domain.contains(g(y)) && f(g(y)) == y)\n}\n\n/// `g` is a two-sided inverse of `f` if it is both a left and right inverse.\npub open spec fn inverse_on<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> bool {\n    left_inverse_on(f, g, domain, codomain) && right_inverse_on(f, g, domain, codomain)\n}\n\n/// Constructs a left inverse function `g` of `f` when `f` is injective on `domain`.\n/// For each `b` in the image, returns the unique `a` such that `f(a) = b`.\npub open spec fn construct_left_inverse<A, B>(f: spec_fn(A) -> B, domain: Set<A>) -> spec_fn(B) -> A\n    recommends\n        injective_on(f, domain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// Constructs the inverse of a bijective function `f` from `domain` to `codomain`.\n/// For each `b` in `codomain`, returns the unique `a` in `domain` such that `f(a) == b`.\npub open spec fn construct_inverse<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n) -> spec_fn(B) -> A\n    recommends\n        bijective_on(f, domain, codomain),\n{\n    |b: B| choose|a: A| domain.contains(a) && f(a) == b\n}\n\n/// If `f` is injective on `domain`, then `construct_left_inverse(f, domain)`\n/// is a left inverse of `f` on that domain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x`.\npub proof fn lemma_construct_left_inverse_sound<A, B>(f: spec_fn(A) -> B, domain: Set<A>)\n    requires\n        injective_on(f, domain),\n    ensures\n        left_inverse_on(f, construct_left_inverse(f, domain), domain, domain.map(f)),\n{\n}\n\n/// If `f` is bijective from `domain` to `codomain`, then `construct_inverse(f, domain, codomain)`\n/// is a two-sided inverse of `f` on that domain and codomain.\n/// That is, for all `x \u2208 domain`, we have `g(f(x)) == x` and for all `y \u2208 codomain`, we have `f(g(y)) == y`.\npub proof fn lemma_construct_inverse_sound<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n    ensures\n        inverse_on(f, construct_inverse(f, domain, codomain), domain, codomain),\n{\n}\n\n/// A function is injective on the whole type implies that it is injective on any sub-domain.\npub proof fn lemma_injective_implies_injective_on<T, U>(f: spec_fn(T) -> U, dom: Set<T>)\n    requires\n        injective(f),\n    ensures\n        injective_on(f, dom),\n{\n}\n\n/// If `f` has a two-sided inverse `g` on `domain` and `codomain`, then `f` is bijective on that domain and codomain.\npub proof fn lemma_two_sided_inverse_implies_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(f, domain, codomain),\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its left inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_left_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is its right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_right_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        right_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n    // Prove that g is injective on codomain\n    assert forall|x| #[trigger] codomain.map(g).contains(x) == domain.contains(x) by {\n        if domain.contains(x) {\n            assert(codomain.contains(f(x)));\n        }\n    }\n}\n\n/// If `f` is a bijection from `domain` to `codomain`, and `g` is either its left or right inverse,\n/// then `g` is a bijection from `codomain` to `domain`.\npub proof fn lemma_inverse_of_bijection_is_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    g: spec_fn(B) -> A,\n    domain: Set<A>,\n    codomain: Set<B>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        left_inverse_on(f, g, domain, codomain) || right_inverse_on(f, g, domain, codomain),\n    ensures\n        bijective_on(g, codomain, domain),\n{\n    if left_inverse_on(f, g, domain, codomain) {\n        lemma_left_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    } else {\n        lemma_right_inverse_of_bijection_is_bijective(f, g, domain, codomain);\n    }\n}\n\n/// Mapping a finite set with an injective function results in a set of the same cardinality.\npub proof fn lemma_injective_map_cardinality<T, U>(f: spec_fn(T) -> U, dom: Set<T>, s: Set<T>)\n    requires\n        injective_on(f, dom),\n        s.finite(),\n        s <= dom,\n    ensures\n        s.len() == s.map(f).len(),\n        s.map(f).finite(),\n    decreases s.len(),\n{\n    if s.is_empty() {\n        assert(s.map(f) =~= Set::empty());\n    } else {\n        let x = s.choose();\n        lemma_injective_map_cardinality(f, dom, s.remove(x));\n        assert(s.map(f) =~= s.remove(x).map(f).insert(f(x)));\n    }\n}\n\npub proof fn lemma_bijective_cardinality<A, B>(f: spec_fn(A) -> B, domain: Set<A>, codomain: Set<B>)\n    requires\n        bijective_on(f, domain, codomain),\n        domain.finite(),\n    ensures\n        codomain.finite(),\n        domain.len() == codomain.len(),\n{\n    lemma_injective_map_cardinality(f, domain, domain);\n}\n\npub proof fn lemma_bijective_subset_still_bijective<A, B>(\n    f: spec_fn(A) -> B,\n    domain: Set<A>,\n    codomain: Set<B>,\n    s: Set<A>,\n)\n    requires\n        bijective_on(f, domain, codomain),\n        s <= domain,\n    ensures\n        bijective_on(f, s, s.map(f)),\n{\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/vstd_extra/src/function_properties.rs", "verified": true, "metadata": {"original_id": "vostd_function_properties_ac5ffca188ef", "function_name": "", "bug_type": "missing_assert"}}
{"id": "task_c_missing_invariant_6e320ade8f8f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len ()  { if a [i] == e { return i ; } i += 1 ; } proof { assert (i == a . len ()) ; assert (forall | k : int | (0 <= k < i as int) ==> a [k] != e) ; assert (forall | k : int | (0 <= k < a . len () as int) ==> a [k] != e) ; assert (exists | j : int | (0 <= j < a . len () as int) && a [j] == e) ; assert (false) ; } 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i <= j < a . len () as int) && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (i == a . len ()) ; assert (forall | k : int | (0 <= k < i as int) ==> a [k] != e) ; assert (forall | k : int | (0 <= k < a . len () as int) ==> a [k] != e) ; assert (exists | j : int | (0 <= j < a . len () as int) && a [j] == e) ; assert (false) ; } 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i <= j < a . len () as int) && a [j] == e , decreases a . len () - i { if a [i] == e { return i ; } i += 1 ; } proof { assert (i == a . len ()) ; assert (forall | k : int | (0 <= k < i as int) ==> a [k] != e) ; assert (forall | k : int | (0 <= k < a . len () as int) ==> a [k] != e) ; assert (exists | j : int | (0 <= j < a . len () as int) && a [j] == e) ; assert (false) ; } 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/CloverBench/verified/linear_search2_iter_3_current.rs", "verified": true, "metadata": {"original_id": "6e320ade8f8f", "function_name": "linear_search", "bug_type": "missing_invariant"}}
{"id": "task_b_fa9d0a6c75ee", "task": "task_b", "input_text": "fn is_integer (text : & [u8]) -> (result : bool)\nensures res == is_digit_spec (c) , result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut idx = 0 ; while idx < text . len () invariant forall | i : int | 0 <= i < idx ==> is_digit_spec (text [i]) , decreases text . len () - idx , { if ! is_digit (text [idx]) { return false ; } idx += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_digit_spec (c : u8) -> bool { c >= 48 && c <= 57 }\nfn is_digit (c : u8) -> (res : bool) ensures res == is_digit_spec (c) , { c >= 48 && c <= 57 }\nfn is_integer (text : & [u8]) -> (result : bool) ensures result == (forall | i : int | 0 <= i < text . len () ==> (# [trigger] is_digit_spec (text [i]))) , { let mut idx = 0 ; while idx < text . len () invariant forall | i : int | 0 <= i < idx ==> is_digit_spec (text [i]) , decreases text . len () - idx , { if ! is_digit (text [idx]) { return false ; } idx += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_113_iter_2_current.rs", "verified": true, "metadata": {"original_id": "fa9d0a6c75ee", "function_name": "is_integer", "has_invariants": true, "has_asserts": false}}
{"id": "task_a_fe5feb0b3a26", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool)   { a == b }\n\n} // verus!", "target_text": "requires true \nensures a == b ==> eq == true , a != b ==> eq == false ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compare_nat (a : nat , b : nat) -> (eq : bool) requires true , ensures a == b ==> eq == true , a != b ==> eq == false , { a == b }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_compare/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "fe5feb0b3a26", "function_name": "compare_nat", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_invariant_6a023c766fb2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/VerusProofSynthesisBench/MBPP/task_id_2_impl.rs", "verified": true, "metadata": {"original_id": "6a023c766fb2", "function_name": "contains", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_fe04a85d49ae", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len ()  { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len ()  { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) && ! in_array (b @ , result [k]) , forall | p : int , q : int | 0 <= p < q < result . len () ==> result [p] != result [q] , { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn in_array (a : Seq < i32 > , x : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i] == x }\nfn in_array_exec (a : & Vec < i32 > , x : i32) -> (result : bool) ensures result == in_array (a @ , x) , { for i in 0 .. a . len () invariant forall | j : int | 0 <= j < i ==> a @ [j] != x , { if a [i] == x { return true ; } } false }\n# [verifier :: loop_isolation (false)] fn remove_elements (a : & Vec < i32 > , b : & Vec < i32 >) -> (c : Vec < i32 >) ensures forall | k : int | # ! [auto] 0 <= k < c . len () ==> in_array (a @ , c [k]) && ! in_array (b @ , c [k]) , forall | i : int , j : int | 0 <= i < j < c . len () ==> c [i] != c [j] , { let mut result = Vec :: new () ; for i in 0 .. a . len () invariant forall | k : int | # ! [auto] 0 <= k < result . len () ==> in_array (a @ , result [k]) && ! in_array (b @ , result [k]) , forall | p : int , q : int | 0 <= p < q < result . len () ==> result [p] != result [q] , { let element = a [i] ; if ! in_array_exec (b , element) && ! in_array_exec (& result , element) { result . push (element) ; } } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/remove_elements_iter_1_current.rs", "verified": true, "metadata": {"original_id": "fe04a85d49ae", "function_name": "remove_elements", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_decreases_5c6350a13060", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let new_char = if str1 [idx] == ' ' { ch } else { str1 [idx] } ; result . push (new_char) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx , { let new_char = if str1 [idx] == ' ' { ch } else { str1 [idx] } ; result . push (new_char) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_replace_blanks_with_chars (str1 : & Vec < char > , ch : char , i : int) -> (result : char) { if str1 [i] == ' ' { ch } else { str1 [i] } }\nfn replace_blanks_with_chars (str1 : & Vec < char > , ch : char) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result @ . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_replace_blanks_with_chars (str1 , ch , i) , decreases str1 . len () - idx , { let new_char = if str1 [idx] == ' ' { ch } else { str1 [idx] } ; result . push (new_char) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_230_impl.rs", "verified": true, "metadata": {"original_id": "5c6350a13060", "function_name": "replace_blanks_with_chars", "bug_type": "missing_decreases"}}
{"id": "task_b_a2378f16ca4f", "task": "task_b", "input_text": "fn reverse (a : & [i32]) -> (result : Vec < i32 >)\nensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , decreases j { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn reverse (a : & [i32]) -> (result : Vec < i32 >) ensures result . len () == a . len () , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , { let mut result = Vec :: new () ; let mut j = a . len () ; while j > 0 invariant result . len () == a . len () - j , forall | i : int | 0 <= i && i < result . len () ==> result [i] == a [a . len () - 1 - i] , decreases j { j = j - 1 ; result . push (a [j]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/reverse_impl.rs", "verified": true, "metadata": {"original_id": "a2378f16ca4f", "function_name": "reverse", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_decreases_16ff0c84e53e", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn binary_search (a : & [int] , key : int) -> (n : usize) requires forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , ensures 0 <= n <= a . len () , forall | i : int | 0 <= i < n ==> a [i] < key , n == a . len () ==> forall | i : int | 0 <= i < a . len () ==> a [i] < key , forall | i : int | n <= i < a . len () ==> a [i] >= key , { let mut left : usize = 0 ; let mut right : usize = a . len () ; while left < right invariant 0 <= left <= right <= a . len () , forall | i : int | 0 <= i < left ==> a [i] < key , forall | i : int | right <= i < a . len () ==> a [i] >= key , decreases right - left { let mid = left + (right - left) / 2 ; if a [mid] < key { left = mid + 1 ; } else { right = mid ; } } left }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_binary_search/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "16ff0c84e53e", "function_name": "binary_search", "bug_type": "missing_decreases"}}
{"id": "task_b_80e5ef23e3da", "task": "task_b", "input_text": "fn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >)\nrequires v . len () <= 100 \nensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn append (v : & Vec < u64 > , elem : u64) -> (c : Vec < u64 >) requires v . len () <= 100 , ensures c @ . len () == v @ . len () + 1 , forall | i : int | (0 <= i && i < v . len ()) ==> c [i] == v [i] , c @ . last () == elem , { let mut result = v . clone () ; result . push (elem) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/verified/array_append_strong_impl.rs", "verified": true, "metadata": {"original_id": "80e5ef23e3da", "function_name": "append", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_269518014d5f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_prime_check (n : u32 , i : u32 , fuel : u32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "requires n >= 2 , n <= 0xFFFF , i >= 2 , fuel <= n \ndecreases fuel ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_prime_check (n : u32 , i : u32 , fuel : u32) -> (result : bool) requires n >= 2 , n <= 0xFFFF , i >= 2 , fuel <= n , decreases fuel , { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_28/verina_basic_28.rs", "verified": true, "metadata": {"original_id": "269518014d5f", "function_name": "is_prime_check", "has_requires": true, "has_ensures": false, "has_invariants": false, "has_decreases": true}}
{"id": "task_c_missing_requires_0b80a21ebf16", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize)  ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_recursive (v : & [i32] , elem : i32 , c : isize , f : isize) -> (p : isize) requires v . len () <= 100_000 , forall | i : int , j : int | 0 <= i < j < v . len () ==> v [i] <= v [j] , 0 <= c <= f + 1 <= v . len () , forall | k : int | 0 <= k < c ==> v [k] <= elem , forall | k : int | f < k < v . len () ==> v [k] > elem , ensures - 1 <= p < v . len () , forall | u : int | 0 <= u <= p ==> v [u] <= elem , forall | w : int | p < w < v . len () ==> v [w] > elem , decreases f - c + 1 { if c > f { return c - 1 ; } let mid = c + (f - c) / 2 ; if v [mid as usize] <= elem { binary_search_recursive (v , elem , mid + 1 , f) } else { binary_search_recursive (v , elem , c , mid - 1) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/binary_search_recursive_impl.rs", "verified": true, "metadata": {"original_id": "0b80a21ebf16", "function_name": "binary_search_recursive", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_50ff4a81a595", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn mul_div_lemma (x : int) ensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3 { vstd :: arithmetic :: div_mod :: lemma_fundamental_div_mod (x * 3 , 3) ; assert ((x * 3) % 3 == 0) by (nonlinear_arith) ; assert ((x * 3) / 3 == x) by (nonlinear_arith) ; assert (((x * 3) / 3) * 3 == x * 3) by (nonlinear_arith) ; }\nfn triple (x : i32) -> (result : i32)  ensures triple_postcond (x as int , result as int) { proof { mul_div_lemma (x as int) ; } x * 3 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn mul_div_lemma (x : int) ensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3 { vstd :: arithmetic :: div_mod :: lemma_fundamental_div_mod (x * 3 , 3) ; assert ((x * 3) % 3 == 0) by (nonlinear_arith) ; assert ((x * 3) / 3 == x) by (nonlinear_arith) ; assert (((x * 3) / 3) * 3 == x * 3) by (nonlinear_arith) ; }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 700000000 <= x <= 700000000 ensures triple_postcond (x as int , result as int) { proof { mul_div_lemma (x as int) ; } x * 3 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn mul_div_lemma (x : int) ensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3 { vstd :: arithmetic :: div_mod :: lemma_fundamental_div_mod (x * 3 , 3) ; assert ((x * 3) % 3 == 0) by (nonlinear_arith) ; assert ((x * 3) / 3 == x) by (nonlinear_arith) ; assert (((x * 3) / 3) * 3 == x * 3) by (nonlinear_arith) ; }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 700000000 <= x <= 700000000 ensures triple_postcond (x as int , result as int) { proof { mul_div_lemma (x as int) ; } x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_98/verina_basic_98_iter_2_current.rs", "verified": true, "metadata": {"original_id": "50ff4a81a595", "function_name": "triple", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_e6a4215bddf9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len ()  { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant idx <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == idx * 3 , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn interleave (s1 : & Vec < i32 > , s2 : & Vec < i32 > , s3 : & Vec < i32 >) -> (res : Vec < i32 >) requires s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , 0 <= (s1 @ . len () * 3) <= MAX , ensures res @ . len () == s1 @ . len () * 3 , forall | i : int | 0 <= i < s1 @ . len () ==> (res [3 * i] == s1 [i] && res [3 * i + 1] == s2 [i] && res [3 * i + 2] == s3 [i]) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < s1 . len () invariant idx <= s1 . len () , s1 @ . len () == s2 @ . len () && s2 @ . len () == s3 @ . len () , result @ . len () == idx * 3 , forall | i : int | 0 <= i < idx ==> (result [3 * i] == s1 [i] && result [3 * i + 1] == s2 [i] && result [3 * i + 2] == s3 [i]) , decreases s1 . len () - idx { result . push (s1 [idx]) ; result . push (s2 [idx]) ; result . push (s3 [idx]) ; idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_578_impl.rs", "verified": true, "metadata": {"original_id": "e6a4215bddf9", "function_name": "interleave", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_ad62c8ff5efd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len ()  { let mut j = 0 ; while j < b . len ()  { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn has_common_element_precond (a : Seq < i32 > , b : Seq < i32 >) -> bool { a . len () > 0 && b . len () > 0 }\nspec fn has_common_element_postcond (a : Seq < i32 > , b : Seq < i32 > , result : bool) -> bool { (exists | i : int , j : int | 0 <= i < a . len () && 0 <= j < b . len () && a [i] == b [j]) <==> result }\nfn has_common_element (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : bool) requires has_common_element_precond (a @ , b @) , ensures has_common_element_postcond (a @ , b @ , result) , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | ii : int , j : int | 0 <= ii < i && 0 <= j < b @ . len () ==> a @ [ii] != b @ [j] , decreases a . len () - i { let mut j = 0 ; while j < b . len () invariant 0 <= i < a . len () , 0 <= j <= b . len () , forall | jj : int | 0 <= jj < j ==> a @ [i as int] != b @ [jj] , forall | ii : int , jj : int | 0 <= ii < i && 0 <= jj < b @ . len () ==> a @ [ii] != b @ [jj] , decreases b . len () - j { if a [i] == b [j] { return true ; } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_9/verina_basic_9_impl.rs", "verified": true, "metadata": {"original_id": "ad62c8ff5efd", "function_name": "has_common_element", "bug_type": "missing_invariant"}}
{"id": "task_b_63261adfa282", "task": "task_b", "input_text": "fn is_product_even (arr : & Vec < u32 >) -> (result : bool)\nensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> (result : bool) { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (# [trigger] arr [k]) { if arr [i] % 2 == 0 { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_even (n : u32) -> (result : bool) { (n % 2) == 0 }\nfn is_product_even (arr : & Vec < u32 >) -> (result : bool) ensures result <==> (exists | k : int | 0 <= k < arr . len () && is_even (# [trigger] arr [k])) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> ! is_even (# [trigger] arr [k]) { if arr [i] % 2 == 0 { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_804_impl.rs", "verified": true, "metadata": {"original_id": "63261adfa282", "function_name": "is_product_even", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_invariant_cc75af96086f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; let mut i = 0 ; while i < l . len () - 1  { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } i += 1 ; } is_non_decreasing || is_non_increasing }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; let mut i = 0 ; while i < l . len () - 1 invariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) , decreases l . len () - 1 - i { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } i += 1 ; } is_non_decreasing || is_non_increasing }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn monotonic (l : Vec < i32 >) -> (ret : bool) ensures ret <==> (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) <= l @ . index (j)) || (forall | i : int , j : int | 0 <= i < j < l @ . len () ==> l @ . index (i) >= l @ . index (j)) , { if l . len () <= 1 { return true ; } let mut is_non_decreasing = true ; let mut is_non_increasing = true ; let mut i = 0 ; while i < l . len () - 1 invariant 0 <= i <= l . len () - 1 , is_non_decreasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) <= l @ . index (m)) , is_non_increasing <==> (forall | k : int , m : int | 0 <= k < m < i + 1 ==> l @ . index (k) >= l @ . index (m)) , decreases l . len () - 1 - i { if l [i] > l [i + 1] { is_non_decreasing = false ; } if l [i] < l [i + 1] { is_non_increasing = false ; } i += 1 ; } is_non_decreasing || is_non_increasing }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/HumanEval-RustBench/057-monotonic_impl.rs", "verified": true, "metadata": {"original_id": "cc75af96086f", "function_name": "monotonic", "bug_type": "missing_invariant"}}
{"id": "task_a_305d04ab1d29", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32)   { (a + b) / 2 }\n\n} // verus!", "target_text": "requires a < 0x80000000 && b < 0x80000000\nensures avg == (a + b) / 2", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn compute_avg (a : u32 , b : u32) -> (avg : u32) requires a < 0x80000000 && b < 0x80000000 ensures avg == (a + b) / 2 { (a + b) / 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Clover_avg/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "305d04ab1d29", "function_name": "compute_avg", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_b_b12bea9078ca", "task": "task_b", "input_text": "fn contains (arr : & Vec < i32 > , key : i32) -> (result : bool)\nensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key , { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_249_iter_1_current.rs", "verified": true, "metadata": {"original_id": "b12bea9078ca", "function_name": "contains", "has_invariants": true, "has_asserts": false}}
{"id": "task_b_205b1d77fbcb", "task": "task_b", "input_text": "fn choose_odd (v : & Vec < u64 >) -> (odd_index : usize)\nrequires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1\nensures odd_index < v . len ()", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn choose_odd (v : & Vec < u64 >) -> (odd_index : usize) requires exists | q : int | 0 <= q < v . len () && v [q] % 2 == 1 ensures odd_index < v . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/unverified/choose_odd_iter_0_original.rs", "verified": true, "metadata": {"original_id": "205b1d77fbcb", "function_name": "choose_odd", "has_invariants": false, "has_asserts": false}}
{"id": "task_a_6dae6f771c10", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn merge_intervals (sorted_intervals : Vec < (usize , usize) >) -> (result : Vec < (usize , usize) >)  { return Vec :: new () ; }\n\n} // verus!", "target_text": "ensures result @ . len () <= sorted_intervals @ . len ()", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn merge_intervals (sorted_intervals : Vec < (usize , usize) >) -> (result : Vec < (usize , usize) >) ensures result @ . len () <= sorted_intervals @ . len () { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_38/verina_advanced_38_iter_0_original.rs", "verified": true, "metadata": {"original_id": "6dae6f771c10", "function_name": "merge_intervals", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_requires_4cb9b92967dd", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique_better (a : & [i32]) -> (result : Vec < i32 >)  ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { return Vec :: new () ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique_better (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { return Vec :: new () ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique_better (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/RustBench/ground_truth/unique_better.rs", "verified": true, "metadata": {"original_id": "4cb9b92967dd", "function_name": "unique_better", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_295fb6b7020c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sorted_seg (a : Seq < int > , i : int , j : int) -> bool recommends 0 <= i <= j <= a . len () { forall | l : int , k : int | i <= l <= k < j ==> a [l] <= a [k] }\nfn sel_sort (a : & mut Vec < int > , c : usize , f : usize)  ensures a . len () == old (a) . len () , sorted_seg (a @ , c as int , f as int) , { let mut i = c ; while i < f invariant c <= i <= f , f <= a . len () , a . len () == old (a) . len () , sorted_seg (a @ , c as int , i as int) , forall | k : int , l : int | c <= k < i && i <= l < f ==> a @ [k] <= a @ [l] , decreases f - i { let mut min_idx = i ; let mut j = i + 1 ; while j < f invariant i < f , i <= min_idx < j <= f , f <= a . len () , a . len () == old (a) . len () , forall | k : int | i <= k < j ==> a @ [min_idx as int] <= a @ [k] , decreases f - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sorted_seg (a : Seq < int > , i : int , j : int) -> bool recommends 0 <= i <= j <= a . len () { forall | l : int , k : int | i <= l <= k < j ==> a [l] <= a [k] }\nfn sel_sort (a : & mut Vec < int > , c : usize , f : usize) requires c <= f , f <= old (a) . len () , ensures a . len () == old (a) . len () , sorted_seg (a @ , c as int , f as int) , { let mut i = c ; while i < f invariant c <= i <= f , f <= a . len () , a . len () == old (a) . len () , sorted_seg (a @ , c as int , i as int) , forall | k : int , l : int | c <= k < i && i <= l < f ==> a @ [k] <= a @ [l] , decreases f - i { let mut min_idx = i ; let mut j = i + 1 ; while j < f invariant i < f , i <= min_idx < j <= f , f <= a . len () , a . len () == old (a) . len () , forall | k : int | i <= k < j ==> a @ [min_idx as int] <= a @ [k] , decreases f - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn sorted_seg (a : Seq < int > , i : int , j : int) -> bool recommends 0 <= i <= j <= a . len () { forall | l : int , k : int | i <= l <= k < j ==> a [l] <= a [k] }\nfn sel_sort (a : & mut Vec < int > , c : usize , f : usize) requires c <= f , f <= old (a) . len () , ensures a . len () == old (a) . len () , sorted_seg (a @ , c as int , f as int) , { let mut i = c ; while i < f invariant c <= i <= f , f <= a . len () , a . len () == old (a) . len () , sorted_seg (a @ , c as int , i as int) , forall | k : int , l : int | c <= k < i && i <= l < f ==> a @ [k] <= a @ [l] , decreases f - i { let mut min_idx = i ; let mut j = i + 1 ; while j < f invariant i < f , i <= min_idx < j <= f , f <= a . len () , a . len () == old (a) . len () , forall | k : int | i <= k < j ==> a @ [min_idx as int] <= a @ [k] , decreases f - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny-Exercises_tmp_tmpjm75muf__Session7Exercises_ExerciseSelSort/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "295fb6b7020c", "function_name": "sel_sort", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_697f62ffc502", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize)  ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e , decreases a . len () - i , { if a [i] == e { return i ; } i += 1 ; } assert (false) ; 0 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e , decreases a . len () - i , { if a [i] == e { return i ; } i += 1 ; } assert (false) ; 0 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn linear_search (a : & Vec < i32 > , e : i32) -> (n : usize) requires exists | i : int | (0 <= i < a . len () as int) && a [i] == e , ensures 0 <= n < a . len () , a [n as int] == e , forall | k : int | (0 <= k < n as int) ==> a [k] != e , { let mut i = 0 ; while i < a . len () invariant 0 <= i <= a . len () , forall | k : int | (0 <= k < i as int) ==> a [k] != e , exists | j : int | (i as int <= j < a . len () as int) && a [j] == e , decreases a . len () - i , { if a [i] == e { return i ; } i += 1 ; } assert (false) ; 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/CloverBench/verified/linear_search2_impl.rs", "verified": true, "metadata": {"original_id": "697f62ffc502", "function_name": "linear_search", "bug_type": "missing_requires"}}
{"id": "task_b_eaf2a2271d61", "task": "task_b", "input_text": "fn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize)\nensures pos <= dp . len ()", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize) ensures pos <= dp . len () { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn binary_search_position (dp : & Vec < i32 > , x : i32) -> (pos : usize) ensures pos <= dp . len () { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_24/verina_advanced_24_iter_0_original.rs", "verified": true, "metadata": {"original_id": "eaf2a2271d61", "function_name": "binary_search_position", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_481feda38498", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 ,  { 3 * x }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple (x : i64) -> (r : i64) requires - 1000000 <= x <= 1000000 , ensures r == 3 * x { 3 * x }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/Clover_triple/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "481feda38498", "function_name": "triple", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_632bcb3a872c", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 ,  { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] == 0 , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < usize > , sum : & mut Vec < usize > , N : usize) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] == 0 , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/Diffy/unverified/ms1_impl.rs", "verified": true, "metadata": {"original_id": "632bcb3a872c", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_ensures_1783d6bbb230", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >)  { }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >) ensures intervals @ . len () == old (intervals) @ . len () { }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn sort_intervals (intervals : & mut Vec < (usize , usize) >) ensures intervals @ . len () == old (intervals) @ . len () { }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/verus_specs/benches_no_bodies_20250809_091334/verina/verina_advanced_38/verina_advanced_38.rs", "verified": true, "metadata": {"original_id": "1783d6bbb230", "function_name": "sort_intervals", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_0c10f306fe6d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >)  ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn extract_rear_chars (s : & Vec < Vec < char > >) -> (result : Vec < char >) requires forall | i : int | 0 <= i < s . len () ==> # [trigger] s [i] . len () > 0 , ensures s . len () == result . len () , forall | i : int | 0 <= i < s . len () ==> result [i] == # [trigger] s [i] [s [i] . len () - 1] , { let mut result = Vec :: new () ; let mut i = 0 ; while i < s . len () invariant 0 <= i <= s . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == s [j] [s [j] . len () - 1] , forall | k : int | 0 <= k < s . len () ==> s [k] . len () > 0 , decreases s . len () - i { let last_char = s [i] [s [i] . len () - 1] ; result . push (last_char) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_424_iter_2_current.rs", "verified": true, "metadata": {"original_id": "0c10f306fe6d", "function_name": "extract_rear_chars", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_6ea439f50aee", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_52/verina_basic_52_iter_3_current.rs", "verified": true, "metadata": {"original_id": "6ea439f50aee", "function_name": "bubble_inner", "bug_type": "missing_decreases"}}
{"id": "task_c_missing_requires_a85e1baaacfe", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >)  ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX , ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn update_elements (a : & mut Vec < i32 >) requires old (a) . len () >= 8 , old (a) [4] + 3 <= MAX , ensures old (a) [4] + 3 == a [4] , a [7] == 516 , forall | i : int | 0 <= i < a . len () && i != 7 && i != 4 ==> a [i] == old (a) [i] , { a [4] = a [4] + 3 ; a [7] = 516 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Clover_update_array/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "a85e1baaacfe", "function_name": "update_elements", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_c5e0e1ff8db1", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool) requires seq . len () > 0 , ensures result == (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> (# [trigger] seq [i] . len () == # [trigger] seq [j] . len ())) , { let first_len = seq [0] . len () ; for k in 1 .. seq . len ()  { if seq [k] . len () != first_len { assert (seq [k as int] . len () != seq [0] . len ()) ; return false ; } } assert (forall | i : int | (0 <= i < seq . len ()) ==> seq [i] . len () == first_len) ; true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool) requires seq . len () > 0 , ensures result == (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> (# [trigger] seq [i] . len () == # [trigger] seq [j] . len ())) , { let first_len = seq [0] . len () ; for k in 1 .. seq . len () invariant forall | i : int | (0 <= i < k) ==> seq [i] . len () == first_len , { if seq [k] . len () != first_len { assert (seq [k as int] . len () != seq [0] . len ()) ; return false ; } } assert (forall | i : int | (0 <= i < seq . len ()) ==> seq [i] . len () == first_len) ; true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_sequence_equal_length (seq : & Vec < Vec < i32 > >) -> (result : bool) requires seq . len () > 0 , ensures result == (forall | i : int , j : int | (0 <= i < seq . len () && 0 <= j < seq . len ()) ==> (# [trigger] seq [i] . len () == # [trigger] seq [j] . len ())) , { let first_len = seq [0] . len () ; for k in 1 .. seq . len () invariant forall | i : int | (0 <= i < k) ==> seq [i] . len () == first_len , { if seq [k] . len () != first_len { assert (seq [k as int] . len () != seq [0] . len ()) ; return false ; } } assert (forall | i : int | (0 <= i < seq . len ()) ==> seq [i] . len () == first_len) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_70_impl.rs", "verified": true, "metadata": {"original_id": "c5e0e1ff8db1", "function_name": "all_sequence_equal_length", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_0060035f6dab", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize)  ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize)  ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize)  ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn bubble_inner (a : & mut Vec < i32 > , j : usize , i : usize) requires j <= i , i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i - j , { if j < i { if a [j] > a [j + 1] { swap (a , j , j + 1) ; } bubble_inner (a , j + 1 , i) ; } }\nfn swap (a : & mut Vec < i32 > , i : usize , j : usize) requires i < old (a) . len () , j < old (a) . len () , ensures a . len () == old (a) . len () , a [i as int] == old (a) [j as int] , a [j as int] == old (a) [i as int] , forall | k : int | 0 <= k < a . len () && k != i && k != j ==> a [k] == old (a) [k] , { let temp = a [i] ; a . set (i , a [j]) ; a . set (j , temp) ; }\nfn bubble_outer (a : & mut Vec < i32 > , i : usize) requires i + 1 < old (a) . len () , ensures a . len () == old (a) . len () , decreases i , { if i > 0 { bubble_inner (a , 0 , i) ; bubble_outer (a , i - 1) ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_52/verina_basic_52_iter_2_current.rs", "verified": true, "metadata": {"original_id": "0060035f6dab", "function_name": "bubble_outer", "bug_type": "missing_requires"}}
{"id": "task_c_missing_invariant_e221c587ea97", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_characters_same (char_arr : & [u8]) -> (result : bool) ensures result == (forall | i : int | 1 <= i < char_arr @ . len () ==> char_arr [0] == # [trigger] char_arr [i]) , { if char_arr . len () == 0 { return true ; } let first_char = char_arr [0] ; for i in 1 .. char_arr . len ()  { if char_arr [i] != first_char { assert (first_char != char_arr [i as int]) ; assert (char_arr [0] != char_arr [i as int]) ; assert (1 <= i < char_arr @ . len ()) ; assert (! (forall | k : int | 1 <= k < char_arr @ . len () ==> char_arr [0] == # [trigger] char_arr [k])) ; return false ; } assert (first_char == char_arr [i as int]) ; } assert (forall | j : int | 1 <= j < char_arr @ . len () ==> char_arr [0] == # [trigger] char_arr [j]) ; true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_characters_same (char_arr : & [u8]) -> (result : bool) ensures result == (forall | i : int | 1 <= i < char_arr @ . len () ==> char_arr [0] == # [trigger] char_arr [i]) , { if char_arr . len () == 0 { return true ; } let first_char = char_arr [0] ; for i in 1 .. char_arr . len () invariant first_char == char_arr [0] , forall | j : int | 1 <= j < i ==> first_char == # [trigger] char_arr [j] , { if char_arr [i] != first_char { assert (first_char != char_arr [i as int]) ; assert (char_arr [0] != char_arr [i as int]) ; assert (1 <= i < char_arr @ . len ()) ; assert (! (forall | k : int | 1 <= k < char_arr @ . len () ==> char_arr [0] == # [trigger] char_arr [k])) ; return false ; } assert (first_char == char_arr [i as int]) ; } assert (forall | j : int | 1 <= j < char_arr @ . len () ==> char_arr [0] == # [trigger] char_arr [j]) ; true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn all_characters_same (char_arr : & [u8]) -> (result : bool) ensures result == (forall | i : int | 1 <= i < char_arr @ . len () ==> char_arr [0] == # [trigger] char_arr [i]) , { if char_arr . len () == 0 { return true ; } let first_char = char_arr [0] ; for i in 1 .. char_arr . len () invariant first_char == char_arr [0] , forall | j : int | 1 <= j < i ==> first_char == # [trigger] char_arr [j] , { if char_arr [i] != first_char { assert (first_char != char_arr [i as int]) ; assert (char_arr [0] != char_arr [i as int]) ; assert (1 <= i < char_arr @ . len ()) ; assert (! (forall | k : int | 1 <= k < char_arr @ . len () ==> char_arr [0] == # [trigger] char_arr [k])) ; return false ; } assert (first_char == char_arr [i as int]) ; } assert (forall | j : int | 1 <= j < char_arr @ . len () ==> char_arr [0] == # [trigger] char_arr [j]) ; true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_741_impl.rs", "verified": true, "metadata": {"original_id": "e221c587ea97", "function_name": "all_characters_same", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_invariant_1639d516bb20", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn prime (n : nat) -> bool { n > 1 && (forall | nr : nat | 1 < nr < n ==> # [trigger] (n % nr) != 0) }\nfn test_primeness (n : u64) -> (result : bool) ensures result == prime (n as nat) { if n <= 1 { assert (! prime (n as nat)) ; return false ; } let mut i = 2u64 ; while i < n  { if n % i == 0 { assert (1 < (i as nat) < (n as nat)) ; assert ((n as nat) % (i as nat) == 0) ; assert (! prime (n as nat)) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | nr : nat | 2 <= nr < (n as nat) ==> # [trigger] ((n as nat) % nr) != 0) ; assert (forall | nr : nat | 1 < nr < (n as nat) ==> # [trigger] ((n as nat) % nr) != 0) ; assert (prime (n as nat)) ; return true ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn prime (n : nat) -> bool { n > 1 && (forall | nr : nat | 1 < nr < n ==> # [trigger] (n % nr) != 0) }\nfn test_primeness (n : u64) -> (result : bool) ensures result == prime (n as nat) { if n <= 1 { assert (! prime (n as nat)) ; return false ; } let mut i = 2u64 ; while i < n invariant 2 <= i <= n , n > 1 , forall | nr : nat | 2 <= nr < i ==> # [trigger] ((n as nat) % nr) != 0 , decreases n - i { if n % i == 0 { assert (1 < (i as nat) < (n as nat)) ; assert ((n as nat) % (i as nat) == 0) ; assert (! prime (n as nat)) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | nr : nat | 2 <= nr < (n as nat) ==> # [trigger] ((n as nat) % nr) != 0) ; assert (forall | nr : nat | 1 < nr < (n as nat) ==> # [trigger] ((n as nat) % nr) != 0) ; assert (prime (n as nat)) ; return true ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn prime (n : nat) -> bool { n > 1 && (forall | nr : nat | 1 < nr < n ==> # [trigger] (n % nr) != 0) }\nfn test_primeness (n : u64) -> (result : bool) ensures result == prime (n as nat) { if n <= 1 { assert (! prime (n as nat)) ; return false ; } let mut i = 2u64 ; while i < n invariant 2 <= i <= n , n > 1 , forall | nr : nat | 2 <= nr < i ==> # [trigger] ((n as nat) % nr) != 0 , decreases n - i { if n % i == 0 { assert (1 < (i as nat) < (n as nat)) ; assert ((n as nat) % (i as nat) == 0) ; assert (! prime (n as nat)) ; return false ; } i = i + 1 ; } assert (i == n) ; assert (forall | nr : nat | 2 <= nr < (n as nat) ==> # [trigger] ((n as nat) % nr) != 0) ; assert (forall | nr : nat | 1 < nr < (n as nat) ==> # [trigger] ((n as nat) % nr) != 0) ; assert (prime (n as nat)) ; return true ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/dafnybench_from_Quinn/DafnyPrograms_tmp_tmp74_f9k_c_prime-database/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "1639d516bb20", "function_name": "test_primeness", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_d4e198b885bc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e ,  { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) ,  { linear_search_aux (a , e , 0) }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) , ensures linear_search_postcond (a , e , result) , { linear_search_aux (a , e , 0) }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn linear_search_precond (a : & Vec < i32 > , e : i32) -> bool { exists | i : int | 0 <= i < a . len () && a [i as int] == e }\nspec fn linear_search_postcond (a : & Vec < i32 > , e : i32 , result : usize) -> bool { result < a . len () && a [result as int] == e && forall | k : int | 0 <= k < result ==> a [k] != e }\nfn linear_search_aux (a : & Vec < i32 > , e : i32 , n : usize) -> (result : usize) requires n <= a . len () , linear_search_precond (a , e) , forall | k : int | 0 <= k < n ==> a [k] != e , ensures linear_search_postcond (a , e , result) , decreases a . len () - n , { if n < a . len () { if a [n] == e { n } else { linear_search_aux (a , e , n + 1) } } else { 0 } }\nfn linear_search (a : & Vec < i32 > , e : i32) -> (result : usize) requires linear_search_precond (a , e) , ensures linear_search_postcond (a , e , result) , { linear_search_aux (a , e , 0) }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_69/verina_basic_69_impl.rs", "verified": true, "metadata": {"original_id": "d4e198b885bc", "function_name": "linear_search", "bug_type": "missing_ensures"}}
{"id": "task_a_0cd632baea02", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool)   { let mut idx = 0 ; while idx < arr1 . len ()  {  if arr1 [idx] <= arr2 [idx] { return false ; } idx = idx + 1 ; } true }\n\n} // verus!", "target_text": "requires arr1 . len () == arr2 . len () \nensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) \ndecreases arr1 . len () - idx\ninvariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i] > arr2 [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut idx = 0 ; while idx < arr1 . len () invariant 0 <= idx <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < idx ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - idx { assert (idx < arr2 . len ()) ; if arr1 [idx] <= arr2 [idx] { return false ; } idx = idx + 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_809_impl.rs", "verified": true, "metadata": {"original_id": "0cd632baea02", "function_name": "is_smaller", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_requires_4fcf7012d1ec", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >)  ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn find_even_numbers_precond (arr : Seq < i32 >) -> bool { true }\nspec fn find_even_numbers_postcond (arr : Seq < i32 > , result : Seq < i32 >) -> bool { forall | j : int | 0 <= j < result . len () ==> { &&& # [trigger] is_even (result [j] as int) &&& exists | k : int | 0 <= k < arr . len () && arr [k] == result [j] } }\nspec fn is_even (n : int) -> bool { n % 2 == 0 }\nfn is_even_exec (n : i32) -> (result : bool) ensures result == is_even (n as int) { n % 2 == 0 }\nfn find_even_numbers (arr : Vec < i32 >) -> (result : Vec < i32 >) requires find_even_numbers_precond (arr @) ensures find_even_numbers_postcond (arr @ , result @) { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr . len () invariant 0 <= i <= arr . len () , forall | j : int | 0 <= j < result @ . len () ==> { &&& is_even (result @ [j] as int) &&& exists | k : int | 0 <= k < arr @ . len () && arr @ [k] == result @ [j] } decreases arr . len () - i { if is_even_exec (arr [i]) { result . push (arr [i]) ; } i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_60/verina_basic_60_impl.rs", "verified": true, "metadata": {"original_id": "4fcf7012d1ec", "function_name": "find_even_numbers", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_0293a6a52a0f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 ,  { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i { if n % i == 0 { return true ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/invariants_removed/is_non_prime_iter_3_current.rs", "verified": true, "metadata": {"original_id": "0293a6a52a0f", "function_name": "is_non_prime", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_decreases_d065fab5e527", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut index = 0 ; while index < arr1 . len () invariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] , { if index < arr2 . len () && arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut index = 0 ; while index < arr1 . len () invariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - index , { if index < arr2 . len () && arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_smaller (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : bool) requires arr1 . len () == arr2 . len () , ensures result == (forall | i : int | 0 <= i < arr1 . len () ==> arr1 [i] > arr2 [i]) , { let mut index = 0 ; while index < arr1 . len () invariant 0 <= index <= arr1 . len () , arr1 . len () == arr2 . len () , forall | i : int | 0 <= i < index ==> arr1 [i] > arr2 [i] , decreases arr1 . len () - index , { if index < arr2 . len () && arr1 [index] <= arr2 [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/unverified/task_id_809_impl.rs", "verified": true, "metadata": {"original_id": "d065fab5e527", "function_name": "is_smaller", "bug_type": "missing_decreases"}}
{"id": "task_b_f39ac4f002ec", "task": "task_b", "input_text": "fn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool)\nensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2)) , { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_even_at_even_index (arr : & Vec < usize >) -> (result : bool) ensures result == forall | i : int | 0 <= i < arr . len () ==> ((i % 2) == (arr [i] % 2)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> ((j % 2) == (arr [j] % 2)) , { if (i % 2) != (arr [i] % 2) { return false ; } } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_790_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "f39ac4f002ec", "function_name": "is_even_at_even_index", "has_invariants": true, "has_asserts": false}}
{"id": "task_a_cb347e9a3400", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32)   { 0 }\n\n} // verus!", "target_text": "requires (x_init as int) * (y as int) <= MAX as int \nensures z == 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn main_method (x_init : u32 , y : u32) -> (z : u32) requires (x_init as int) * (y as int) <= MAX as int , ensures z == 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Generated_Code_rand/verus_code_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "cb347e9a3400", "function_name": "main_method", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_requires_36f349e67135", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn trap_rain_water_precond (height : Seq < u32 >) -> bool { true }\nspec fn trap_rain_water_postcond (height : Seq < u32 > , result : u32 , h_precond : bool) -> bool { result >= 0 && (height . len () == 0 ==> result == 0) && (height . len () == 1 ==> result == 0) }\nfn trap_rain_water (height : Vec < u32 >) -> (result : u32)  ensures trap_rain_water_postcond (height @ , result , trap_rain_water_precond (height @)) { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn trap_rain_water_precond (height : Seq < u32 >) -> bool { true }\nspec fn trap_rain_water_postcond (height : Seq < u32 > , result : u32 , h_precond : bool) -> bool { result >= 0 && (height . len () == 0 ==> result == 0) && (height . len () == 1 ==> result == 0) }\nfn trap_rain_water (height : Vec < u32 >) -> (result : u32) requires trap_rain_water_precond (height @) ensures trap_rain_water_postcond (height @ , result , trap_rain_water_precond (height @)) { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn trap_rain_water_precond (height : Seq < u32 >) -> bool { true }\nspec fn trap_rain_water_postcond (height : Seq < u32 > , result : u32 , h_precond : bool) -> bool { result >= 0 && (height . len () == 0 ==> result == 0) && (height . len () == 1 ==> result == 0) }\nfn trap_rain_water (height : Vec < u32 >) -> (result : u32) requires trap_rain_water_precond (height @) ensures trap_rain_water_postcond (height @ , result , trap_rain_water_precond (height @)) { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_77/verina_advanced_77_iter_0_original.rs", "verified": true, "metadata": {"original_id": "36f349e67135", "function_name": "trap_rain_water", "bug_type": "missing_requires"}}
{"id": "task_b_b1d23e5299d9", "task": "task_b", "input_text": "fn longest_prefix (a : & [i32] , b : & [i32]) -> (i : usize)\nensures i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) , i < a . len () && i < b . len () ==> a @ [i as int] != b @ [i as int]", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_equal_prefix (a : Seq < i32 > , b : Seq < i32 > , len : int) -> bool { forall | k : int | 0 <= k < len ==> a [k] == b [k] }\nfn longest_prefix (a : & [i32] , b : & [i32]) -> (i : usize) ensures i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) , i < a . len () && i < b . len () ==> a @ [i as int] != b @ [i as int] { let mut i : usize = 0 ; while i < a . len () && i < b . len () && a [i] == b [i] invariant i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) decreases a . len () - i { i = i + 1 ; } i }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn seq_equal_prefix (a : Seq < i32 > , b : Seq < i32 > , len : int) -> bool { forall | k : int | 0 <= k < len ==> a [k] == b [k] }\nfn longest_prefix (a : & [i32] , b : & [i32]) -> (i : usize) ensures i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) , i < a . len () && i < b . len () ==> a @ [i as int] != b @ [i as int] { let mut i : usize = 0 ; while i < a . len () && i < b . len () && a [i] == b [i] invariant i <= a . len () && i <= b . len () , seq_equal_prefix (a @ , b @ , i as int) decreases a . len () - i { i = i + 1 ; } i }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_longestPrefix/verus_code_iter_2_current.rs", "verified": true, "metadata": {"original_id": "b1d23e5299d9", "function_name": "longest_prefix", "has_invariants": true, "has_asserts": false}}
{"id": "task_c_missing_requires_ca4fd00d9375", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32)  ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool)  ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0usize ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold decreases numbers . len () - i { let mut j = 0usize ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0usize ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold decreases numbers . len () - i { let mut j = 0usize ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn abs_spec (i : int) -> int { if i < 0 { - i } else { i } }\nfn abs (i : i32) -> (res : i32) requires i != MIN , ensures i < 0 ==> res == - i , i >= 0 ==> res == i { if i < 0 { - i } else { i } }\n# [verifier :: loop_isolation (false)] fn has_close_elements (numbers : & [i32] , threshold : i32) -> (flag : bool) requires threshold > 0 , forall | i : int , j : int | 0 <= i && i < numbers . len () && 0 <= j && j < numbers . len () ==> numbers [i] - numbers [j] < MAX && - (numbers [i] - numbers [j]) < MAX ensures flag == exists | i : int , j : int | 0 <= i && 0 <= j && i < numbers . len () && j < numbers . len () && i != j && abs_spec (numbers [i] - numbers [j]) < threshold { let mut i = 0usize ; while i < numbers . len () invariant 0 <= i <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold decreases numbers . len () - i { let mut j = 0usize ; while j < numbers . len () invariant 0 <= i < numbers . len () , 0 <= j <= numbers . len () , forall | ii : int , jj : int | 0 <= ii && ii < i && 0 <= jj && jj < numbers . len () && ii != jj ==> abs_spec (numbers [ii] - numbers [jj]) >= threshold , forall | jj : int | 0 <= jj && jj < j && (i as int) != jj ==> abs_spec (numbers [i as int] - numbers [jj]) >= threshold decreases numbers . len () - j { if i != j { let diff = numbers [i] - numbers [j] ; let abs_diff = abs (diff) ; if abs_diff < threshold { return true ; } } j += 1 ; } i += 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/RustBench/ground_truth/has_close_elements_impl.rs", "verified": true, "metadata": {"original_id": "ca4fd00d9375", "function_name": "has_close_elements", "bug_type": "missing_requires"}}
{"id": "task_a_9834fd20a165", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_chars (str1 : & [u8] , old_char : u8 , new_char : u8) -> (result : Vec < u8 >)  { new_char } else { str1 [i] }) , { let mut result_str = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len ()  { new_char } else { str1 [i] }) , { if str1 [index] == old_char { result_str . push (new_char) ; } else { result_str . push (str1 [index]) ; } index += 1 ; } result_str }\n\n} // verus!", "target_text": "ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == (if str1 [i] == old_char\ndecreases str1 . len () - index\ninvariant 0 <= index <= str1 . len () , result_str . len () == index , forall | i : int | 0 <= i < index ==> result_str @ [i] == (if str1 [i] == old_char", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_chars (str1 : & [u8] , old_char : u8 , new_char : u8) -> (result : Vec < u8 >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> result @ [i] == (if str1 [i] == old_char { new_char } else { str1 [i] }) , { let mut result_str = Vec :: with_capacity (str1 . len ()) ; let mut index = 0 ; while index < str1 . len () invariant 0 <= index <= str1 . len () , result_str . len () == index , forall | i : int | 0 <= i < index ==> result_str @ [i] == (if str1 [i] == old_char { new_char } else { str1 [i] }) , decreases str1 . len () - index { if str1 [index] == old_char { result_str . push (new_char) ; } else { result_str . push (str1 [index]) ; } index += 1 ; } result_str }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/MBPP/unverified/task_id_474_impl.rs", "verified": true, "metadata": {"original_id": "9834fd20a165", "function_name": "replace_chars", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_b_90329c5173ed", "task": "task_b", "input_text": "fn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >)\nrequires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) \nensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) , decreases arr1 . len () - i , { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (MIN <= arr1 [i as int] - arr2 [i as int] <= MAX) ; let diff = arr1 [i] - arr2 [i] ; result . push (diff) ; i += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn element_wise_subtract (arr1 : & Vec < i32 > , arr2 : & Vec < i32 >) -> (result : Vec < i32 >) requires arr1 . len () == arr2 . len () , forall | i : int | (0 <= i < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [i] - arr2 [i]) <= MAX) , ensures result . len () == arr1 . len () , forall | i : int | 0 <= i < result . len () ==> # [trigger] result [i] == # [trigger] (arr1 [i] - arr2 [i]) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < arr1 . len () invariant i <= arr1 . len () , arr1 . len () == arr2 . len () , result . len () == i , forall | j : int | 0 <= j < i ==> result [j] == arr1 [j] - arr2 [j] , forall | j : int | (0 <= j < arr1 . len ()) ==> (MIN <= # [trigger] (arr1 [j] - arr2 [j]) <= MAX) , decreases arr1 . len () - i , { assert (i < arr1 . len ()) ; assert (i < arr2 . len ()) ; assert (MIN <= arr1 [i as int] - arr2 [i as int] <= MAX) ; let diff = arr1 [i] - arr2 [i] ; result . push (diff) ; i += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_273_impl.rs", "verified": true, "metadata": {"original_id": "90329c5173ed", "function_name": "element_wise_subtract", "has_invariants": true, "has_asserts": true}}
{"id": "task_c_missing_ensures_ba3c6ff39b39", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool)  { n % 2 == 1 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool) ensures result == odd (n as int) { n % 2 == 1 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn odd (n : int) -> bool { n % 2 == 1 }\nfn odd_exec (n : u32) -> (result : bool) ensures result == odd (n as int) { n % 2 == 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/DafnyProjects_tmp_tmp2acw_s4s_partitionOddEven/verus_code_iter_3_current.rs", "verified": true, "metadata": {"original_id": "ba3c6ff39b39", "function_name": "odd_exec", "bug_type": "missing_ensures"}}
{"id": "task_b_4ba28f7ce860", "task": "task_b", "input_text": "fn count_true (arr : & Vec < bool >) -> (count : u64)\nrequires 0 < i <= seq . len ()\nensures count_boolean (seq . take (i)) == count_boolean (seq . take (i - 1)) + if seq [i - 1], 0 <= count <= arr . len () , count_boolean (arr @) == count ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_boolean (seq : Seq < bool >) -> (result : int) decreases seq . len () , { if seq . len () == 0 { 0 } else { count_boolean (seq . drop_last ()) + if (seq . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_boolean_extend (seq : Seq < bool > , i : int) requires 0 < i <= seq . len () ensures count_boolean (seq . take (i)) == count_boolean (seq . take (i - 1)) + if seq [i - 1] { 1 as int } else { 0 as int } { let prefix_i = seq . take (i) ; let prefix_i_minus_1 = seq . take (i - 1) ; assert (prefix_i == prefix_i_minus_1 . push (seq [i - 1])) ; assert (prefix_i . drop_last () == prefix_i_minus_1) ; assert (prefix_i . last () == seq [i - 1]) ; }\nfn count_true (arr : & Vec < bool >) -> (count : u64) ensures 0 <= count <= arr . len () , count_boolean (arr @) == count , { let mut count = 0u64 ; let mut i = 0usize ; while i < arr . len () invariant 0 <= i <= arr . len () , 0 <= count <= i , count_boolean (arr @ . take (i as int)) == count , decreases arr . len () - i , { if arr [i] { count = count + 1 ; } i = i + 1 ; proof { lemma_count_boolean_extend (arr @ , i as int) ; } } assert (arr @ . take (arr . len () as int) == arr @) ; count }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_boolean (seq : Seq < bool >) -> (result : int) decreases seq . len () , { if seq . len () == 0 { 0 } else { count_boolean (seq . drop_last ()) + if (seq . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_boolean_extend (seq : Seq < bool > , i : int) requires 0 < i <= seq . len () ensures count_boolean (seq . take (i)) == count_boolean (seq . take (i - 1)) + if seq [i - 1] { 1 as int } else { 0 as int } { let prefix_i = seq . take (i) ; let prefix_i_minus_1 = seq . take (i - 1) ; assert (prefix_i == prefix_i_minus_1 . push (seq [i - 1])) ; assert (prefix_i . drop_last () == prefix_i_minus_1) ; assert (prefix_i . last () == seq [i - 1]) ; }\nfn count_true (arr : & Vec < bool >) -> (count : u64) ensures 0 <= count <= arr . len () , count_boolean (arr @) == count , { let mut count = 0u64 ; let mut i = 0usize ; while i < arr . len () invariant 0 <= i <= arr . len () , 0 <= count <= i , count_boolean (arr @ . take (i as int)) == count , decreases arr . len () - i , { if arr [i] { count = count + 1 ; } i = i + 1 ; proof { lemma_count_boolean_extend (arr @ , i as int) ; } } assert (arr @ . take (arr . len () as int) == arr @) ; count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_105_impl.rs", "verified": true, "metadata": {"original_id": "4ba28f7ce860", "function_name": "count_true", "has_invariants": true, "has_asserts": true}}
{"id": "task_c_missing_invariant_ccfb57f4fcbc", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn concat_precond (a : & Vec < i32 > , b : & Vec < i32 >) -> bool { true }\nspec fn concat_postcond (a : & Vec < i32 > , b : & Vec < i32 > , result : & Vec < i32 >) -> bool { result . len () == a . len () + b . len () && (forall | k : int | 0 <= k < a . len () ==> result [k] == a [k]) && (forall | k : int | 0 <= k < b . len () ==> result [k + a . len ()] == b [k]) }\nfn concat (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : Vec < i32 >) requires concat_precond (a , b) , a . len () + b . len () <= MAX , ensures concat_postcond (a , b , & result) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len ()  { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len ()  { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn concat_precond (a : & Vec < i32 > , b : & Vec < i32 >) -> bool { true }\nspec fn concat_postcond (a : & Vec < i32 > , b : & Vec < i32 > , result : & Vec < i32 >) -> bool { result . len () == a . len () + b . len () && (forall | k : int | 0 <= k < a . len () ==> result [k] == a [k]) && (forall | k : int | 0 <= k < b . len () ==> result [k + a . len ()] == b [k]) }\nfn concat (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : Vec < i32 >) requires concat_precond (a , b) , a . len () + b . len () <= MAX , ensures concat_postcond (a , b , & result) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == a [k] , decreases a . len () - i { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k < j ==> result [k + a . len ()] == b [k] , decreases b . len () - j { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn concat_precond (a : & Vec < i32 > , b : & Vec < i32 >) -> bool { true }\nspec fn concat_postcond (a : & Vec < i32 > , b : & Vec < i32 > , result : & Vec < i32 >) -> bool { result . len () == a . len () + b . len () && (forall | k : int | 0 <= k < a . len () ==> result [k] == a [k]) && (forall | k : int | 0 <= k < b . len () ==> result [k + a . len ()] == b [k]) }\nfn concat (a : & Vec < i32 > , b : & Vec < i32 >) -> (result : Vec < i32 >) requires concat_precond (a , b) , a . len () + b . len () <= MAX , ensures concat_postcond (a , b , & result) , { let mut result = Vec :: new () ; let mut i = 0 ; while i < a . len () invariant i <= a . len () , result . len () == i , forall | k : int | 0 <= k < i ==> result [k] == a [k] , decreases a . len () - i { result . push (a [i]) ; i += 1 ; } let mut j = 0 ; while j < b . len () invariant j <= b . len () , result . len () == a . len () + j , forall | k : int | 0 <= k < a . len () ==> result [k] == a [k] , forall | k : int | 0 <= k < j ==> result [k + a . len ()] == b [k] , decreases b . len () - j { result . push (b [j]) ; j += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/verina/verina_basic_83/verina_basic_83_impl.rs", "verified": true, "metadata": {"original_id": "ccfb57f4fcbc", "function_name": "concat", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_ensures_ae34894f2210", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >)  { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) , decreases str1 . len () - idx { let c = str1 [idx] ; if c >= 'a' && c <= 'z' { let uppercase_c = ((c as u8) - 32) as char ; result . push (uppercase_c) ; } else { result . push (c) ; } idx += 1 ; } result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (inner_expr_to_uppercase (str1 , i))) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) , decreases str1 . len () - idx { let c = str1 [idx] ; if c >= 'a' && c <= 'z' { let uppercase_c = ((c as u8) - 32) as char ; result . push (uppercase_c) ; } else { result . push (c) ; } idx += 1 ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn inner_expr_to_uppercase (str1 : & Vec < char > , i : int) -> (result : char) { if is_lower_case (# [trigger] str1 [i]) { shift_minus_32_spec (str1 [i]) } else { str1 [i] } }\nspec fn is_lower_case (c : char) -> (result : bool) { c >= 'a' && c <= 'z' }\nspec fn shift_minus_32_spec (c : char) -> (result : char) { ((c as u8) - 32) as char }\nfn to_uppercase (str1 : & Vec < char >) -> (result : Vec < char >) ensures str1 @ . len () == result @ . len () , forall | i : int | 0 <= i < str1 . len () ==> (result [i] == (inner_expr_to_uppercase (str1 , i))) , { let mut result = Vec :: new () ; let mut idx = 0 ; while idx < str1 . len () invariant idx <= str1 . len () , result . len () == idx , forall | i : int | 0 <= i < idx ==> result [i] == inner_expr_to_uppercase (str1 , i) , decreases str1 . len () - idx { let c = str1 [idx] ; if c >= 'a' && c <= 'z' { let uppercase_c = ((c as u8) - 32) as char ; result . push (uppercase_c) ; } else { result . push (c) ; } idx += 1 ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/VerusProofSynthesisBench/MBPP/task_id_624_iter_3_current.rs", "verified": true, "metadata": {"original_id": "ae34894f2210", "function_name": "to_uppercase", "bug_type": "missing_ensures"}}
{"id": "task_b_ee669c579ff9", "task": "task_b", "input_text": "fn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >)\nrequires first . len () > 0 \nensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; for i in 0 .. (first . len () - 1) invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , { assert (i < first . len ()) ; result . push (first [i]) ; } for i in 0 .. second . len () invariant i <= second . len () , result @ == first @ . subrange (0 , (first . len () - 1) as int) . add (second @ . subrange (0 , i as int)) , { assert (i < second . len ()) ; result . push (second [i]) ; } result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn replace_last_element (first : & Vec < i32 > , second : & Vec < i32 >) -> (replaced_list : Vec < i32 >) requires first . len () > 0 , ensures replaced_list @ == first @ . subrange (0 , first . len () - 1) . add (second @) , { let mut result = Vec :: new () ; for i in 0 .. (first . len () - 1) invariant i <= first . len () - 1 , result @ == first @ . subrange (0 , i as int) , { assert (i < first . len ()) ; result . push (first [i]) ; } for i in 0 .. second . len () invariant i <= second . len () , result @ == first @ . subrange (0 , (first . len () - 1) as int) . add (second @ . subrange (0 , i as int)) , { assert (i < second . len ()) ; result . push (second [i]) ; } result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_240_impl.rs", "verified": true, "metadata": {"original_id": "ee669c579ff9", "function_name": "replace_last_element", "has_invariants": true, "has_asserts": true}}
{"id": "task_c_missing_invariant_61406431865f", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn check_find_first_odd (arr : & Vec < u32 > , index : Option < usize >) -> (result : bool) { if let Some (idx) = index { &&& (forall | k : int | 0 <= k < idx ==> (arr [k] % 2 == 0)) &&& arr [idx as int] % 2 != 0 } else { forall | k : int | 0 <= k < arr . len () ==> (arr [k] % 2 == 0) } }\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures check_find_first_odd (arr , index) , { for i in 0 .. arr . len ()  { if arr [i] % 2 != 0 { assert (forall | k : int | 0 <= k < i ==> (arr [k] % 2 == 0)) ; assert (arr [i as int] % 2 != 0) ; return Some (i) ; } } None }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn check_find_first_odd (arr : & Vec < u32 > , index : Option < usize >) -> (result : bool) { if let Some (idx) = index { &&& (forall | k : int | 0 <= k < idx ==> (arr [k] % 2 == 0)) &&& arr [idx as int] % 2 != 0 } else { forall | k : int | 0 <= k < arr . len () ==> (arr [k] % 2 == 0) } }\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures check_find_first_odd (arr , index) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> (arr [k] % 2 == 0) { if arr [i] % 2 != 0 { assert (forall | k : int | 0 <= k < i ==> (arr [k] % 2 == 0)) ; assert (arr [i as int] % 2 != 0) ; return Some (i) ; } } None }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn check_find_first_odd (arr : & Vec < u32 > , index : Option < usize >) -> (result : bool) { if let Some (idx) = index { &&& (forall | k : int | 0 <= k < idx ==> (arr [k] % 2 == 0)) &&& arr [idx as int] % 2 != 0 } else { forall | k : int | 0 <= k < arr . len () ==> (arr [k] % 2 == 0) } }\nfn find_first_odd (arr : & Vec < u32 >) -> (index : Option < usize >) ensures check_find_first_odd (arr , index) , { for i in 0 .. arr . len () invariant forall | k : int | 0 <= k < i ==> (arr [k] % 2 == 0) { if arr [i] % 2 != 0 { assert (forall | k : int | 0 <= k < i ==> (arr [k] % 2 == 0)) ; assert (arr [i as int] % 2 != 0) ; return Some (i) ; } } None }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_807_impl.rs", "verified": true, "metadata": {"original_id": "61406431865f", "function_name": "find_first_odd", "bug_type": "missing_invariant"}}
{"id": "task_b_71f559984c48", "task": "task_b", "input_text": "fn unique (a : & [i32]) -> (result : Vec < i32 >)\nrequires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] \nensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { return Vec :: new () ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn unique (a : & [i32]) -> (result : Vec < i32 >) requires forall | i : int , j : int | # ! [trigger a [i] , a [j]] 0 <= i && i < j && j < a . len () ==> a [i] <= a [j] , ensures forall | i : int , j : int | # ! [trigger result [i] , result [j]] 0 <= i && i < j && j < result . len () ==> result [i] < result [j] , { return Vec :: new () ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/unique_iter_0_original.rs", "verified": true, "metadata": {"original_id": "71f559984c48", "function_name": "unique", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_a50a64f0e6c2", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF ,  { return 0 ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < u32 > , N : u32) -> (sum : u32) requires old (a) . len () == N , N <= 0x7FFF_FFFF , ensures sum <= 2 * N , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/autoverus/Misc/unverified/cell_2_sum_iter_0_original.rs", "verified": true, "metadata": {"original_id": "a50a64f0e6c2", "function_name": "myfun", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_requires_42fd355a8ad8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32)  ensures sum [0] == 0 , { sum . set (0 , 0) ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] == 0 , { sum . set (0 , 0) ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub fn myfun (a : & mut Vec < i32 > , sum : & mut Vec < i32 > , N : i32) requires old (a) . len () == N , old (sum) . len () == 1 , N > 0 , ensures sum [0] == 0 , { sum . set (0 , 0) ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/SVComp-Array-fpi/unverified/ms1_impl.rs", "verified": true, "metadata": {"original_id": "42fd355a8ad8", "function_name": "myfun", "bug_type": "missing_requires"}}
{"id": "task_a_9879df0d9b53", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >)   { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1  { new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len ()  { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "target_text": "requires list . len () > 0 , 0 < k < list @ . len () \nensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) \ndecreases k - 1 - i , list . len () - j \ninvariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ == list @ . subrange (0 , i as int) , k <= j <= list . len () , k <= list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn remove_kth_element (list : & Vec < i32 > , k : usize) -> (new_list : Vec < i32 >) requires list . len () > 0 , 0 < k < list @ . len () , ensures new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , list . len () as int) ,) , { let mut new_list = Vec :: new () ; let mut i = 0 ; while i < k - 1 invariant 0 <= i <= k - 1 , k - 1 <= list . len () , new_list @ == list @ . subrange (0 , i as int) , decreases k - 1 - i , { new_list . push (list [i]) ; i += 1 ; } let mut j = k ; while j < list . len () invariant k <= j <= list . len () , k <= list . len () , new_list @ == list @ . subrange (0 , k - 1 as int) . add (list @ . subrange (k as int , j as int)) , decreases list . len () - j , { new_list . push (list [j]) ; j += 1 ; } new_list }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP/task_id_610_impl.rs", "verified": true, "metadata": {"original_id": "9879df0d9b53", "function_name": "remove_kth_element", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_invariant_34d5b3a0ba0d", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len ()  { if arr [i] == key { return true ; } } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key { if arr [i] == key { return true ; } } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn contains (arr : & Vec < i32 > , key : i32) -> (result : bool) ensures result == (exists | i : int | 0 <= i < arr . len () && (arr [i] == key)) , { for i in 0 .. arr . len () invariant forall | j : int | 0 <= j < i ==> arr [j] != key { if arr [i] == key { return true ; } } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/autoverus/MBPP/verified/task_id_249_impl.rs", "verified": true, "metadata": {"original_id": "34d5b3a0ba0d", "function_name": "contains", "bug_type": "missing_invariant"}}
{"id": "task_a_ae19e8f7dd92", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn mul_div_lemma (x : int)  { vstd :: arithmetic :: div_mod :: lemma_fundamental_div_mod (x * 3 , 3) ;    }\nfn triple (x : i32) -> (result : i32)   {  x * 3 }\n\n} // verus!", "target_text": "requires triple_precond (x as int) , - 700000000 <= x <= 700000000\nensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3, triple_postcond (x as int , result as int)", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn triple_precond (x : int) -> bool { true }\nspec fn triple_postcond (x : int , result : int) -> bool { result / 3 == x && (result / 3) * 3 == result }\nproof fn mul_div_lemma (x : int) ensures (x * 3) % 3 == 0 , (x * 3) / 3 == x , ((x * 3) / 3) * 3 == x * 3 { vstd :: arithmetic :: div_mod :: lemma_fundamental_div_mod (x * 3 , 3) ; assert ((x * 3) % 3 == 0) by (nonlinear_arith) ; assert ((x * 3) / 3 == x) by (nonlinear_arith) ; assert (((x * 3) / 3) * 3 == x * 3) by (nonlinear_arith) ; }\nfn triple (x : i32) -> (result : i32) requires triple_precond (x as int) , - 700000000 <= x <= 700000000 ensures triple_postcond (x as int , result as int) { proof { mul_div_lemma (x as int) ; } x * 3 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_98/verina_basic_98_impl.rs", "verified": true, "metadata": {"original_id": "ae19e8f7dd92", "function_name": "triple", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_c_missing_requires_verus_atomics_4df37194f547", "task": "task_c", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::prelude::*;\nuse vstd::{pervasive::*, *};\n\nverus! {\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        field: AtomicBool<_, Option<T>, _>,\n    }\n\n    spec fn well_formed(&self) -> bool {\n        invariant on field with () is (b: bool, t: Option<T>) {\n            b === t is Some\n        }\n    }\n}\n\nfn take<T>(lock: &Lock<T>) -> (t: Tracked<T>)\n\n{\n    loop\n        invariant\n            lock.well_formed(),\n    {\n        let tracked ghost_value: Option<T>;\n        let result =\n            atomic_with_ghost!(\n            &lock.field => compare_exchange(true, false);\n            update prev -> next;\n            ghost g => {\n                if prev == true {\n                    ghost_value = g;\n                    g = Option::None;\n                } else {\n                    ghost_value = Option::None;\n                }\n            }\n        );\n        if let Result::Ok(_) = result {\n            return Tracked(\n                match ghost_value {\n                    Option::Some(s) => s,\n                    _ => { proof_from_false() },\n                },\n            );\n        }\n    }\n}\n\nstruct VEqualG {}\n\nimpl AtomicInvariantPredicate<(), u64, u64> for VEqualG {\n    closed spec fn atomic_inv(k: (), v: u64, g: u64) -> bool {\n        v == g\n    }\n}\n\nproof fn proof_int(x: u64) -> (tracked y: u64)\n    ensures\n        x == y,\n{\n    assume(false);\n    proof_from_false()\n}\n\npub fn main() {\n    // TODO Tracked of int-literal is currently unsupported.\n    // Should support it, or rewrite this example\n    /*\n    let ato = AtomicU64::<(), u64, VEqualG>::new(Ghost(()), 10, Tracked(10));\n\n    // illustration of atomic_with_ghost!\n\n    atomic_with_ghost!(ato => fetch_or(19); ghost g => {\n        g = proof_int(g | 19);\n    });\n\n    atomic_with_ghost!(ato => fetch_or(23); update old_val -> new_val; ghost g => {\n        assert(new_val == old_val | 23);\n        assert(g == old_val);\n\n        g = proof_int(g | 23);\n\n        assert(g == new_val);\n    });\n\n    let res = atomic_with_ghost!(\n        ato => compare_exchange(20, 25);\n        update old_val -> new_val;\n        returning ret;\n        ghost g\n    => {\n        assert(imply(ret.is_Ok(), old_val == 20 && new_val == 25));\n        assert(imply(ret.is_Err(), old_val != 20 && new_val == old_val\n            && ret.get_Err_0() == old_val));\n\n        g = if g == 20 { proof_int(25) } else { g };\n    });\n\n    let res = atomic_with_ghost!( ato => load();\n        returning ret;\n        ghost g\n    => {\n        assert(ret == g);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n        assert(old_val == g);\n        assert(new_val == 36);\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n        assert(old_val == g);\n        assert(new_val == 36);\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        ghost g\n    => {\n        g = proof_int(36);\n    });\n    */\n}\n\n} // verus!\n", "target_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::prelude::*;\nuse vstd::{pervasive::*, *};\n\nverus! {\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        field: AtomicBool<_, Option<T>, _>,\n    }\n\n    spec fn well_formed(&self) -> bool {\n        invariant on field with () is (b: bool, t: Option<T>) {\n            b === t is Some\n        }\n    }\n}\n\nfn take<T>(lock: &Lock<T>) -> (t: Tracked<T>)\n    requires\n        lock.well_formed(),\n{\n    loop\n        invariant\n            lock.well_formed(),\n    {\n        let tracked ghost_value: Option<T>;\n        let result =\n            atomic_with_ghost!(\n            &lock.field => compare_exchange(true, false);\n            update prev -> next;\n            ghost g => {\n                if prev == true {\n                    ghost_value = g;\n                    g = Option::None;\n                } else {\n                    ghost_value = Option::None;\n                }\n            }\n        );\n        if let Result::Ok(_) = result {\n            return Tracked(\n                match ghost_value {\n                    Option::Some(s) => s,\n                    _ => { proof_from_false() },\n                },\n            );\n        }\n    }\n}\n\nstruct VEqualG {}\n\nimpl AtomicInvariantPredicate<(), u64, u64> for VEqualG {\n    closed spec fn atomic_inv(k: (), v: u64, g: u64) -> bool {\n        v == g\n    }\n}\n\nproof fn proof_int(x: u64) -> (tracked y: u64)\n    ensures\n        x == y,\n{\n    assume(false);\n    proof_from_false()\n}\n\npub fn main() {\n    // TODO Tracked of int-literal is currently unsupported.\n    // Should support it, or rewrite this example\n    /*\n    let ato = AtomicU64::<(), u64, VEqualG>::new(Ghost(()), 10, Tracked(10));\n\n    // illustration of atomic_with_ghost!\n\n    atomic_with_ghost!(ato => fetch_or(19); ghost g => {\n        g = proof_int(g | 19);\n    });\n\n    atomic_with_ghost!(ato => fetch_or(23); update old_val -> new_val; ghost g => {\n        assert(new_val == old_val | 23);\n        assert(g == old_val);\n\n        g = proof_int(g | 23);\n\n        assert(g == new_val);\n    });\n\n    let res = atomic_with_ghost!(\n        ato => compare_exchange(20, 25);\n        update old_val -> new_val;\n        returning ret;\n        ghost g\n    => {\n        assert(imply(ret.is_Ok(), old_val == 20 && new_val == 25));\n        assert(imply(ret.is_Err(), old_val != 20 && new_val == old_val\n            && ret.get_Err_0() == old_val));\n\n        g = if g == 20 { proof_int(25) } else { g };\n    });\n\n    let res = atomic_with_ghost!( ato => load();\n        returning ret;\n        ghost g\n    => {\n        assert(ret == g);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n        assert(old_val == g);\n        assert(new_val == 36);\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n        assert(old_val == g);\n        assert(new_val == 36);\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        ghost g\n    => {\n        g = proof_int(36);\n    });\n    */\n}\n\n} // verus!\n", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n#![allow(unused_imports)]\nuse verus_builtin::*;\nuse verus_builtin_macros::*;\nuse vstd::atomic_ghost::*;\nuse vstd::prelude::*;\nuse vstd::{pervasive::*, *};\n\nverus! {\n\nstruct_with_invariants!{\n    struct Lock<T> {\n        field: AtomicBool<_, Option<T>, _>,\n    }\n\n    spec fn well_formed(&self) -> bool {\n        invariant on field with () is (b: bool, t: Option<T>) {\n            b === t is Some\n        }\n    }\n}\n\nfn take<T>(lock: &Lock<T>) -> (t: Tracked<T>)\n    requires\n        lock.well_formed(),\n{\n    loop\n        invariant\n            lock.well_formed(),\n    {\n        let tracked ghost_value: Option<T>;\n        let result =\n            atomic_with_ghost!(\n            &lock.field => compare_exchange(true, false);\n            update prev -> next;\n            ghost g => {\n                if prev == true {\n                    ghost_value = g;\n                    g = Option::None;\n                } else {\n                    ghost_value = Option::None;\n                }\n            }\n        );\n        if let Result::Ok(_) = result {\n            return Tracked(\n                match ghost_value {\n                    Option::Some(s) => s,\n                    _ => { proof_from_false() },\n                },\n            );\n        }\n    }\n}\n\nstruct VEqualG {}\n\nimpl AtomicInvariantPredicate<(), u64, u64> for VEqualG {\n    closed spec fn atomic_inv(k: (), v: u64, g: u64) -> bool {\n        v == g\n    }\n}\n\nproof fn proof_int(x: u64) -> (tracked y: u64)\n    ensures\n        x == y,\n{\n    assume(false);\n    proof_from_false()\n}\n\npub fn main() {\n    // TODO Tracked of int-literal is currently unsupported.\n    // Should support it, or rewrite this example\n    /*\n    let ato = AtomicU64::<(), u64, VEqualG>::new(Ghost(()), 10, Tracked(10));\n\n    // illustration of atomic_with_ghost!\n\n    atomic_with_ghost!(ato => fetch_or(19); ghost g => {\n        g = proof_int(g | 19);\n    });\n\n    atomic_with_ghost!(ato => fetch_or(23); update old_val -> new_val; ghost g => {\n        assert(new_val == old_val | 23);\n        assert(g == old_val);\n\n        g = proof_int(g | 23);\n\n        assert(g == new_val);\n    });\n\n    let res = atomic_with_ghost!(\n        ato => compare_exchange(20, 25);\n        update old_val -> new_val;\n        returning ret;\n        ghost g\n    => {\n        assert(imply(ret.is_Ok(), old_val == 20 && new_val == 25));\n        assert(imply(ret.is_Err(), old_val != 20 && new_val == old_val\n            && ret.get_Err_0() == old_val));\n\n        g = if g == 20 { proof_int(25) } else { g };\n    });\n\n    let res = atomic_with_ghost!( ato => load();\n        returning ret;\n        ghost g\n    => {\n        assert(ret == g);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n        assert(old_val == g);\n        assert(new_val == 36);\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        update old_val -> new_val;\n        ghost g\n    => {\n        assert(old_val == g);\n        assert(new_val == 36);\n        g = proof_int(36);\n    });\n\n    atomic_with_ghost!( ato => store(36);\n        ghost g\n    => {\n        g = proof_int(36);\n    });\n    */\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/atomics.rs", "verified": true, "metadata": {"original_id": "verus_atomics_4df37194f547", "function_name": "", "bug_type": "missing_requires"}}
{"id": "task_c_missing_ensures_verus_doubly_linked_7b8ba918de95", "task": "task_c", "input_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n\nuse vstd::prelude::*;\n\nverus! {\n\nmod doubly_linked_list {\n    use vstd::prelude::*;\n    use vstd::simple_pptr::*;\n    use vstd::raw_ptr::MemContents;\n    use vstd::assert_by_contradiction;\n\n    // Single node in the list\n    struct Node<V> {\n        prev: Option<PPtr<Node<V>>>,\n        next: Option<PPtr<Node<V>>>,\n        payload: V,\n    }\n\n    // Doubly-linked list\n    // Contains head pointer, tail pointer\n    // and in ghost code, tracks all the pointers and all the PointsTo permissions\n    // to access the nodes\n    pub struct DoublyLinkedList<V> {\n        // physical data:\n        head: Option<PPtr<Node<V>>>,\n        tail: Option<PPtr<Node<V>>>,\n\n        // ghost and tracked data:\n        ghost_state: Tracked<GhostState<V>>,\n    }\n\n    pub tracked struct GhostState<V> {\n        ghost ptrs: Seq<PPtr<Node<V>>>,\n        tracked points_to_map: Map<nat, PointsTo<Node<V>>>,\n    }\n\n    impl<V> DoublyLinkedList<V> {\n        /// Pointer to the node of index (i-1), or None if i is 0.\n        spec fn prev_of(&self, i: nat) -> Option<PPtr<Node<V>>> {\n            if i == 0 {\n                None\n            } else {\n                Some(self.ghost_state@.ptrs[i as int - 1])\n            }\n        }\n\n        /// Pointer to the node of index (i+1), or None if i is the last index.\n        spec fn next_of(&self, i: nat) -> Option<PPtr<Node<V>>> {\n            if i + 1 == self.ghost_state@.ptrs.len() {\n                None\n            } else {\n                Some(self.ghost_state@.ptrs[i as int + 1])\n            }\n        }\n\n        /// Node at index `i` is well-formed\n        spec fn well_formed_node(&self, i: nat) -> bool {\n            &&& self.ghost_state@.points_to_map.dom().contains(i)\n            &&& self.ghost_state@.points_to_map[i].pptr() == self.ghost_state@.ptrs[i as int]\n            &&& self.ghost_state@.points_to_map[i].mem_contents() matches MemContents::Init(node)\n                  && node.prev == self.prev_of(i) && node.next == self.next_of(i)\n        }\n\n        /// Linked list is well-formed\n        pub closed spec fn well_formed(&self) -> bool {\n            // Every node from 0 .. len - 1 is well-formed\n            &&& forall|i: nat| 0 <= i && i < self.ghost_state@.ptrs.len() ==> self.well_formed_node(i)\n            &&& if self.ghost_state@.ptrs.len() == 0 {\n                // If the list is empty, then the `head` and `tail` pointers are both None\n                self.head.is_none() && self.tail.is_none()\n            } else {\n                // If the list is non-empty, then `head` and `tail` pointers point to the\n                // the first and last nodes.\n                &&& self.head == Some(self.ghost_state@.ptrs[0])\n                &&& self.tail == Some(self.ghost_state@.ptrs[self.ghost_state@.ptrs.len() as int - 1])\n            }\n        }\n\n        /// Representation of this list as a sequence\n        pub closed spec fn view(&self) -> Seq<V> {\n            Seq::<V>::new(\n                self.ghost_state@.ptrs.len(),\n                |i: int| { self.ghost_state@.points_to_map[i as nat].value().payload },\n            )\n        }\n\n        //// Interface of executable functions\n\n        /// Construct a new, empty, doubly-linked list.\n        pub fn new() -> (s: Self)\n\n        {\n            DoublyLinkedList {\n                ghost_state: Tracked(GhostState {\n                    ptrs: Seq::empty(),\n                    points_to_map: Map::tracked_empty(),\n                }),\n                head: None,\n                tail: None,\n            }\n        }\n\n        /// Insert one node, assuming the linked list is empty.\n        fn push_empty_case(&mut self, v: V)\n            requires\n                old(self).well_formed(),\n                old(self).ghost_state@.ptrs.len() == 0,\n\n        {\n            // Allocate a node to contain the payload\n            let (ptr, Tracked(points_to)) = PPtr::<Node<V>>::new(\n                Node::<V> { prev: None, next: None, payload: v },\n            );\n\n            // Update head and tail pointers\n            self.tail = Some(ptr);\n            self.head = Some(ptr);\n\n            // Update proof state\n            proof {\n                self.ghost_state.borrow_mut().ptrs = self.ghost_state@.ptrs.push(ptr);\n                self.ghost_state.borrow_mut().points_to_map.tracked_insert(\n                    (self.ghost_state@.ptrs.len() - 1) as nat,\n                    points_to,\n                );\n            }\n        }\n\n        /// Insert a value to the end of the list\n        pub fn push_back(&mut self, v: V)\n            requires\n                old(self).well_formed(),\n\n        {\n            match self.tail {\n                None => {\n                    // Special case: list is empty\n                    proof {\n                        // Show that the `self.tail == None` implies the list is empty\n                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 0,\n                        {\n                            assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat)); // trigger\n                        });\n                    }\n                    self.push_empty_case(v);\n                }\n                Some(old_tail_ptr) => {\n                    proof {\n                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat)); // trigger\n                    }\n\n                    // Allocate a new node to go on the end. It's 'prev' field points\n                    // to the old tail pointer.\n                    let (new_tail_ptr, Tracked(new_tail_pointsto)) = PPtr::<Node<V>>::new(\n                        Node::<V> { prev: Some(old_tail_ptr), next: None, payload: v },\n                    );\n\n                    // Update the 'next' pointer of the previous tail node\n                    // This is all equivalent to `(*old_tail_ptr).next = new_tail_ptr;`\n                    let tracked mut old_tail_pointsto: PointsTo<Node<V>> =\n                        self.ghost_state.borrow_mut().points_to_map.tracked_remove((self.ghost_state@.ptrs.len() - 1) as nat);\n                    let mut old_tail_node = old_tail_ptr.take(Tracked(&mut old_tail_pointsto));\n                    old_tail_node.next = Some(new_tail_ptr);\n                    old_tail_ptr.put(Tracked(&mut old_tail_pointsto), old_tail_node);\n                    proof {\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(\n                            (self.ghost_state@.ptrs.len() - 1) as nat,\n                            old_tail_pointsto,\n                        );\n                    }\n\n                    // Update `self.tail`\n                    self.tail = Some(new_tail_ptr);\n\n                    proof {\n                        // Put the new tail's PointsTo into the map\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(self.ghost_state@.ptrs.len(), new_tail_pointsto);\n                        self.ghost_state@.ptrs = self.ghost_state@.ptrs.push(new_tail_ptr);\n\n                        // Additional proof work to help the solver show that\n                        // `self.well_formed()` has been restored.\n                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 2) as nat));\n                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));\n                        assert(forall|i: nat| i < self.ghost_state@.ptrs.len() && old(self).well_formed_node(i)\n                            ==> self.well_formed_node(i));\n                        assert forall|i: int| 0 <= i && i < self.ghost_state@.ptrs.len() as int - 1\n                            implies old(self)@[i] == self@[i]\n                        by {\n                            assert(old(self).well_formed_node(i as nat));  // trigger\n                        }\n                        assert(self@ =~= old(self)@.push(v));\n\n                        assert(self.well_formed());\n                    }\n                }\n            }\n        }\n\n        /// Take a value from the end of the list. Requires the list to be non-empty.\n        pub fn pop_back(&mut self) -> (v: V)\n            requires\n                old(self).well_formed(),\n                old(self)@.len() > 0,\n\n        {\n            assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));\n\n            // Deallocate the last node in the list and get the payload.\n            // Note self.tail.unwrap() will always succeed because of the precondition `len > 0`\n            let last_ptr = self.tail.unwrap();\n            let tracked last_pointsto = self.ghost_state.borrow_mut().points_to_map.tracked_remove(\n                (self.ghost_state@.ptrs.len() - 1) as nat,\n            );\n            let last_node = last_ptr.into_inner(Tracked(last_pointsto));\n            let v = last_node.payload;\n\n            match last_node.prev {\n                None => {\n                    // If this was the *only* node in the list,\n                    // we set both `head` and `tail` to None\n                    self.tail = None;\n                    self.head = None;\n                    proof {\n                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 1,\n                        {\n                            assert(old(self).well_formed_node((self.ghost_state@.ptrs.len() - 2) as nat)); // trigger\n                        });\n                    }\n                },\n                Some(penultimate_ptr) => {\n                    assert(old(self)@.len() >= 2);\n                    assert(old(self).well_formed_node((self.ghost_state@.ptrs.len() - 2) as nat));\n\n                    // Otherwise, we need to set the 'tail' pointer to the (new) tail pointer,\n                    // i.e., the pointer that was previously the second-to-last pointer.\n                    self.tail = Some(penultimate_ptr);\n\n                    // And we need to set the 'next' pointer of the new tail node to None.\n                    let tracked mut penultimate_pointsto =\n                        self.ghost_state.borrow_mut().points_to_map.tracked_remove((self.ghost_state@.ptrs.len() - 2) as nat);\n                    let mut penultimate_node = penultimate_ptr.take(Tracked(&mut penultimate_pointsto));\n                    penultimate_node.next = None;\n                    penultimate_ptr.put(Tracked(&mut penultimate_pointsto), penultimate_node);\n                    proof {\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(\n                            (self.ghost_state@.ptrs.len() - 2) as nat,\n                            penultimate_pointsto,\n                        );\n                    }\n                },\n            }\n\n            // Additional proof work to help the solver show that\n            // `self.well_formed()` has been restored.\n            proof {\n                self.ghost_state@.ptrs = self.ghost_state@.ptrs.drop_last();\n                if self.ghost_state@.ptrs.len() > 0 {\n                    assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));\n                }\n                assert(forall|i: nat| i < self@.len() && old(self).well_formed_node(i) ==> self.well_formed_node(i));\n                assert forall|i: int| 0 <= i && i < self@.len() implies #[trigger] self@[i] == old(\n                    self,\n                )@.drop_last()[i] by {\n                    assert(old(self).well_formed_node(i as nat));  // trigger\n                }\n                assert(self@ =~= old(self)@.drop_last());\n\n                assert(self.well_formed());\n            }\n\n            return v;\n        }\n\n        /// Insert a value to the front of the list\n        pub fn push_front(&mut self, v: V)\n            requires\n                old(self).well_formed(),\n\n        {\n            match self.head {\n                None => {\n                    // Special case: list is empty\n                    proof {\n                        // Show that the `self.head == None` implies the list is empty\n                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 0, {\n                            assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));\n                        });\n                    }\n                    self.push_empty_case(v);\n                    assert(self@ =~= seq![v].add(old(self)@));\n                }\n                Some(old_head_ptr) => {\n                    proof {\n                        assert(self.ghost_state@.ptrs.len() > 0);\n                        assert(self.well_formed_node(0));\n                    }\n\n                    // Allocate a new node to go at the front. It's 'next' field points\n                    // to the old head pointer.\n                    let (new_head_ptr, Tracked(new_head_pointsto)) = PPtr::new(\n                        Node::<V> { prev: None, next: Some(old_head_ptr), payload: v },\n                    );\n\n                    // Update the 'tail' pointer of the previous head node\n                    // This is all equivalent to `(*old_head_ptr).next = new_head_ptr;`\n                    let tracked mut old_head_pointsto =\n                        self.ghost_state.borrow_mut().points_to_map.tracked_remove(0);\n                    let mut old_head_node = old_head_ptr.take(Tracked(&mut old_head_pointsto));\n                    old_head_node.prev = Some(new_head_ptr);\n                    old_head_ptr.put(Tracked(&mut old_head_pointsto), old_head_node);\n                    proof {\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(0, old_head_pointsto);\n                    }\n\n                    // Update `self.head`\n                    self.head = Some(new_head_ptr);\n\n                    proof {\n                        // Put the new head's PointsTo into the map.\n                        // This goes in at index 0, so we have to shift all the keys up by 1.\n                        assert forall|j: nat|\n                            0 <= j && j < old(self)@.len() implies self.ghost_state@.points_to_map.dom().contains(\n                            j,\n                        ) by {\n                            assert(old(self).well_formed_node(j));\n                        }\n                        self.ghost_state.borrow_mut().points_to_map.tracked_map_keys_in_place(\n                            Map::<nat, nat>::new(\n                                |j: nat| 1 <= j && j <= old(self).view().len(),\n                                |j: nat| (j - 1) as nat,\n                            ),\n                        );\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(0, new_head_pointsto);\n                        self.ghost_state@.ptrs = seq![new_head_ptr].add(self.ghost_state@.ptrs);\n\n                        // Additional proof work to help the solver show that\n                        // `self.well_formed()` has been restored.\n                        assert(self.well_formed_node(0));\n                        assert(self.well_formed_node(1));\n                        assert(forall|i: nat|\n                            1 <= i && i <= old(self).ghost_state@.ptrs.len() && old(self).well_formed_node((i - 1) as nat)\n                                ==> #[trigger] self.well_formed_node(i));\n                        assert forall|i: int| 1 <= i && i <= self.ghost_state@.ptrs.len() as int - 1\n                            implies old(self)@[i - 1] == self@[i]\n                        by {\n                            assert(old(self).well_formed_node((i - 1) as nat));  // trigger\n                        }\n                        assert(self@ =~= seq![v].add(old(self)@));\n\n                        assert(self.well_formed());\n                    }\n                }\n            }\n        }\n\n        /// Take a value from the front of the list. Requires the list to be non-empty.\n        pub fn pop_front(&mut self) -> (v: V)\n            requires\n                old(self).well_formed(),\n                old(self).view().len() > 0,\n\n        {\n            assert(self.well_formed_node(0));\n\n            // Deallocate the first node in the list and get the payload.\n            // Note self.head.unwrap() will always succeed because of the precondition `len > 0`\n            let first_ptr = self.head.unwrap();\n            let tracked first_pointsto = self.ghost_state.borrow_mut().points_to_map.tracked_remove(0);\n            let first_node = first_ptr.into_inner(Tracked(first_pointsto));\n            let v = first_node.payload;\n\n            match first_node.next {\n                None => {\n                    // If this was the *only* node in the list,\n                    // we set both `head` and `tail` to None\n                    self.tail = None;\n                    self.head = None;\n                    proof {\n                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 1,\n                        {\n                            assert(old(self).well_formed_node(1)); // trigger\n                        });\n                    }\n                }\n                Some(second_ptr) => {\n                    assert(old(self)@.len() >= 2);\n                    assert(old(self).well_formed_node(1));\n\n                    // Otherwise, we need to set the 'head' pointer to the (new) head pointer,\n                    // i.e., the pointer that was previously the second pointer.\n                    self.head = Some(second_ptr);\n\n                    // And we need to set the 'tail' pointer of the new head node to None\n                    let tracked mut second_pointsto = self.ghost_state.borrow_mut().points_to_map.tracked_remove(1);\n                    let mut second_node = second_ptr.take(Tracked(&mut second_pointsto));\n                    second_node.prev = None;\n                    second_ptr.put(Tracked(&mut second_pointsto), second_node);\n                    proof {\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(1, second_pointsto);\n\n                        // Since we removed index 0, we need to shift all the keys down,\n                        // 1 -> 0, 2 -> 1, etc.\n                        assert forall|j: nat|\n                            1 <= j && j < old(self)@.len() implies self.ghost_state@.points_to_map.dom().contains(\n                            j,\n                        ) by {\n                            assert(old(self).well_formed_node(j));\n                        };\n                        self.ghost_state.borrow_mut().points_to_map.tracked_map_keys_in_place(\n                            Map::<nat, nat>::new(\n                                |j: nat| 0 <= j && j < old(self).view().len() - 1,\n                                |j: nat| (j + 1) as nat,\n                            ),\n                        );\n                    }\n                }\n            }\n\n            // Additional proof work to help the solver show that\n            // `self.well_formed()` has been restored.\n            proof {\n                self.ghost_state@.ptrs = self.ghost_state@.ptrs.subrange(1, self.ghost_state@.ptrs.len() as int);\n                if self.ghost_state@.ptrs.len() > 0 {\n                    assert(self.well_formed_node(0));\n                }\n                assert(forall|i: nat|\n                    i < self.view().len() && old(self).well_formed_node(i + 1) ==> self.well_formed_node(i));\n                assert forall|i: int| 0 <= i && i < self@.len() implies #[trigger] self@[i] == old(\n                    self,\n                )@.subrange(1, old(self)@.len() as int)[i] by {\n                    assert(old(self).well_formed_node(i as nat + 1));  // trigger\n                }\n                assert(self@ =~= old(self)@.subrange(1, old(self)@.len() as int));\n\n                assert(self.well_formed());\n            }\n\n            return v;\n        }\n\n        /// Get a reference to the i^th value in the list\n        fn get<'a>(&'a self, i: usize) -> (v: &'a V)\n            requires\n                self.well_formed(),\n                0 <= i < self@.len(),\n\n        {\n            // Iterate the nodes from 0 to j, starting at the head node\n            let mut j = 0;\n            let mut ptr = self.head.unwrap();\n            while j < i\n                invariant\n                    self.well_formed(),\n                    0 <= j <= i < self@.len(),\n                    ptr == self.ghost_state@.ptrs[j as int],\n            {\n                proof {\n                    assert(self.well_formed_node(j as nat)); // trigger\n                }\n\n                // Get the next node from the 'next' field\n                let tracked pointsto_ref: &PointsTo<Node<V>> =\n                    self.ghost_state.borrow().points_to_map.tracked_borrow(j as nat);\n                let node_ref: &Node<V> = ptr.borrow(Tracked(pointsto_ref));\n                let next_ptr = node_ref.next.unwrap();\n\n                j += 1;\n                ptr = next_ptr;\n            }\n\n            proof {\n                assert(self.well_formed_node(j as nat)); // trigger\n            }\n\n            // Get a reference to this node's payload and return it\n            let tracked pointsto_ref: &PointsTo<Node<V>> =\n                self.ghost_state.borrow().points_to_map.tracked_borrow(j as nat);\n            let node_ref: &Node<V> = ptr.borrow(Tracked(pointsto_ref));\n            return &node_ref.payload;\n        }\n    }\n\n    pub struct Iterator<'a, V> {\n        l: &'a DoublyLinkedList<V>,\n        cur: Option<PPtr<Node<V>>>,\n        index: Ghost<nat>,\n    }\n\n    impl<'a, V> Iterator<'a, V> {\n        pub closed spec fn list(&self) -> &'a DoublyLinkedList<V> {\n            self.l\n        }\n\n        pub closed spec fn index(&self) -> nat {\n            self.index@\n        }\n\n        pub closed spec fn valid(&self) -> bool {\n            &&& self.list().well_formed()\n            &&& self.index@ < self.list()@.len()\n            &&& self.cur.is_some() && self.cur.unwrap() =~= self.l.ghost_state@.ptrs[self.index@ as int]\n        }\n\n        pub fn new(l: &'a DoublyLinkedList<V>) -> (it: Self)\n            requires\n                l.well_formed(),\n                l@.len() > 0,\n\n        {\n            Iterator { l, cur: l.head, index: Ghost(0) }\n        }\n\n        pub fn value(&self) -> (v: &V)\n            requires\n                self.valid(),\n\n        {\n            let cur = self.cur.unwrap();\n            assert(self.l.well_formed_node(self.index()));\n            let tracked pointsto = self.l.ghost_state.borrow().points_to_map.tracked_borrow(self.index());\n            let node = cur.borrow(Tracked(pointsto));\n            &node.payload\n        }\n\n        pub fn move_next(&mut self) -> (good: bool)\n            requires\n                old(self).valid(),\n\n        {\n            assert(self.l.well_formed_node(self.index()));\n            let cur = self.cur.unwrap();\n            let tracked pointsto = self.l.ghost_state.borrow().points_to_map.tracked_borrow(self.index());\n            let node = cur.borrow(Tracked(pointsto));\n            proof {\n                self.index@ = self.index@ + 1;\n            }\n            match node.next {\n                None => {\n                    self.cur = None;\n                    false\n                },\n                Some(next_ptr) => {\n                    self.cur = Some(next_ptr);\n                    true\n                },\n            }\n        }\n    }\n\n}\n\nmod main {\n    use super::doubly_linked_list::{DoublyLinkedList, Iterator};\n\n    pub fn run() {\n        let mut t = DoublyLinkedList::<u32>::new();\n        t.push_back(2);\n        t.push_back(3);\n        t.push_front(1);  // 1, 2, 3\n        let mut it = Iterator::new(&t);\n        let v1 = it.value();\n        assert(*v1 == 1);\n        let g = it.move_next();\n        let v2 = it.value();\n        assert(*v2 == 2);\n        let _ = it.move_next();\n        let v3 = it.value();\n        assert(*v3 == 3);\n        let g = it.move_next();\n        assert(!g);\n        let x = t.pop_back();  // 3\n        let y = t.pop_front();  // 1\n        let z = t.pop_front();  // 2\n        assert(x == 3);\n        assert(y == 1);\n        assert(z == 2);\n    }\n\n}\n\nfn main() {\n    main::run();\n}\n\n} // verus!\n", "target_text": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n\nuse vstd::prelude::*;\n\nverus! {\n\nmod doubly_linked_list {\n    use vstd::prelude::*;\n    use vstd::simple_pptr::*;\n    use vstd::raw_ptr::MemContents;\n    use vstd::assert_by_contradiction;\n\n    // Single node in the list\n    struct Node<V> {\n        prev: Option<PPtr<Node<V>>>,\n        next: Option<PPtr<Node<V>>>,\n        payload: V,\n    }\n\n    // Doubly-linked list\n    // Contains head pointer, tail pointer\n    // and in ghost code, tracks all the pointers and all the PointsTo permissions\n    // to access the nodes\n    pub struct DoublyLinkedList<V> {\n        // physical data:\n        head: Option<PPtr<Node<V>>>,\n        tail: Option<PPtr<Node<V>>>,\n\n        // ghost and tracked data:\n        ghost_state: Tracked<GhostState<V>>,\n    }\n\n    pub tracked struct GhostState<V> {\n        ghost ptrs: Seq<PPtr<Node<V>>>,\n        tracked points_to_map: Map<nat, PointsTo<Node<V>>>,\n    }\n\n    impl<V> DoublyLinkedList<V> {\n        /// Pointer to the node of index (i-1), or None if i is 0.\n        spec fn prev_of(&self, i: nat) -> Option<PPtr<Node<V>>> {\n            if i == 0 {\n                None\n            } else {\n                Some(self.ghost_state@.ptrs[i as int - 1])\n            }\n        }\n\n        /// Pointer to the node of index (i+1), or None if i is the last index.\n        spec fn next_of(&self, i: nat) -> Option<PPtr<Node<V>>> {\n            if i + 1 == self.ghost_state@.ptrs.len() {\n                None\n            } else {\n                Some(self.ghost_state@.ptrs[i as int + 1])\n            }\n        }\n\n        /// Node at index `i` is well-formed\n        spec fn well_formed_node(&self, i: nat) -> bool {\n            &&& self.ghost_state@.points_to_map.dom().contains(i)\n            &&& self.ghost_state@.points_to_map[i].pptr() == self.ghost_state@.ptrs[i as int]\n            &&& self.ghost_state@.points_to_map[i].mem_contents() matches MemContents::Init(node)\n                  && node.prev == self.prev_of(i) && node.next == self.next_of(i)\n        }\n\n        /// Linked list is well-formed\n        pub closed spec fn well_formed(&self) -> bool {\n            // Every node from 0 .. len - 1 is well-formed\n            &&& forall|i: nat| 0 <= i && i < self.ghost_state@.ptrs.len() ==> self.well_formed_node(i)\n            &&& if self.ghost_state@.ptrs.len() == 0 {\n                // If the list is empty, then the `head` and `tail` pointers are both None\n                self.head.is_none() && self.tail.is_none()\n            } else {\n                // If the list is non-empty, then `head` and `tail` pointers point to the\n                // the first and last nodes.\n                &&& self.head == Some(self.ghost_state@.ptrs[0])\n                &&& self.tail == Some(self.ghost_state@.ptrs[self.ghost_state@.ptrs.len() as int - 1])\n            }\n        }\n\n        /// Representation of this list as a sequence\n        pub closed spec fn view(&self) -> Seq<V> {\n            Seq::<V>::new(\n                self.ghost_state@.ptrs.len(),\n                |i: int| { self.ghost_state@.points_to_map[i as nat].value().payload },\n            )\n        }\n\n        //// Interface of executable functions\n\n        /// Construct a new, empty, doubly-linked list.\n        pub fn new() -> (s: Self)\n            ensures\n                s.well_formed(),\n                s@.len() == 0,\n        {\n            DoublyLinkedList {\n                ghost_state: Tracked(GhostState {\n                    ptrs: Seq::empty(),\n                    points_to_map: Map::tracked_empty(),\n                }),\n                head: None,\n                tail: None,\n            }\n        }\n\n        /// Insert one node, assuming the linked list is empty.\n        fn push_empty_case(&mut self, v: V)\n            requires\n                old(self).well_formed(),\n                old(self).ghost_state@.ptrs.len() == 0,\n            ensures\n                self.well_formed(),\n                self@ =~= old(self)@.push(v),\n        {\n            // Allocate a node to contain the payload\n            let (ptr, Tracked(points_to)) = PPtr::<Node<V>>::new(\n                Node::<V> { prev: None, next: None, payload: v },\n            );\n\n            // Update head and tail pointers\n            self.tail = Some(ptr);\n            self.head = Some(ptr);\n\n            // Update proof state\n            proof {\n                self.ghost_state.borrow_mut().ptrs = self.ghost_state@.ptrs.push(ptr);\n                self.ghost_state.borrow_mut().points_to_map.tracked_insert(\n                    (self.ghost_state@.ptrs.len() - 1) as nat,\n                    points_to,\n                );\n            }\n        }\n\n        /// Insert a value to the end of the list\n        pub fn push_back(&mut self, v: V)\n            requires\n                old(self).well_formed(),\n            ensures\n                self.well_formed(),\n                self@ == old(self)@.push(v),\n        {\n            match self.tail {\n                None => {\n                    // Special case: list is empty\n                    proof {\n                        // Show that the `self.tail == None` implies the list is empty\n                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 0,\n                        {\n                            assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat)); // trigger\n                        });\n                    }\n                    self.push_empty_case(v);\n                }\n                Some(old_tail_ptr) => {\n                    proof {\n                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat)); // trigger\n                    }\n\n                    // Allocate a new node to go on the end. It's 'prev' field points\n                    // to the old tail pointer.\n                    let (new_tail_ptr, Tracked(new_tail_pointsto)) = PPtr::<Node<V>>::new(\n                        Node::<V> { prev: Some(old_tail_ptr), next: None, payload: v },\n                    );\n\n                    // Update the 'next' pointer of the previous tail node\n                    // This is all equivalent to `(*old_tail_ptr).next = new_tail_ptr;`\n                    let tracked mut old_tail_pointsto: PointsTo<Node<V>> =\n                        self.ghost_state.borrow_mut().points_to_map.tracked_remove((self.ghost_state@.ptrs.len() - 1) as nat);\n                    let mut old_tail_node = old_tail_ptr.take(Tracked(&mut old_tail_pointsto));\n                    old_tail_node.next = Some(new_tail_ptr);\n                    old_tail_ptr.put(Tracked(&mut old_tail_pointsto), old_tail_node);\n                    proof {\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(\n                            (self.ghost_state@.ptrs.len() - 1) as nat,\n                            old_tail_pointsto,\n                        );\n                    }\n\n                    // Update `self.tail`\n                    self.tail = Some(new_tail_ptr);\n\n                    proof {\n                        // Put the new tail's PointsTo into the map\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(self.ghost_state@.ptrs.len(), new_tail_pointsto);\n                        self.ghost_state@.ptrs = self.ghost_state@.ptrs.push(new_tail_ptr);\n\n                        // Additional proof work to help the solver show that\n                        // `self.well_formed()` has been restored.\n                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 2) as nat));\n                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));\n                        assert(forall|i: nat| i < self.ghost_state@.ptrs.len() && old(self).well_formed_node(i)\n                            ==> self.well_formed_node(i));\n                        assert forall|i: int| 0 <= i && i < self.ghost_state@.ptrs.len() as int - 1\n                            implies old(self)@[i] == self@[i]\n                        by {\n                            assert(old(self).well_formed_node(i as nat));  // trigger\n                        }\n                        assert(self@ =~= old(self)@.push(v));\n\n                        assert(self.well_formed());\n                    }\n                }\n            }\n        }\n\n        /// Take a value from the end of the list. Requires the list to be non-empty.\n        pub fn pop_back(&mut self) -> (v: V)\n            requires\n                old(self).well_formed(),\n                old(self)@.len() > 0,\n            ensures\n                self.well_formed(),\n                self@ == old(self)@.drop_last(),\n                v == old(self)@[old(self)@.len() as int - 1],\n        {\n            assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));\n\n            // Deallocate the last node in the list and get the payload.\n            // Note self.tail.unwrap() will always succeed because of the precondition `len > 0`\n            let last_ptr = self.tail.unwrap();\n            let tracked last_pointsto = self.ghost_state.borrow_mut().points_to_map.tracked_remove(\n                (self.ghost_state@.ptrs.len() - 1) as nat,\n            );\n            let last_node = last_ptr.into_inner(Tracked(last_pointsto));\n            let v = last_node.payload;\n\n            match last_node.prev {\n                None => {\n                    // If this was the *only* node in the list,\n                    // we set both `head` and `tail` to None\n                    self.tail = None;\n                    self.head = None;\n                    proof {\n                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 1,\n                        {\n                            assert(old(self).well_formed_node((self.ghost_state@.ptrs.len() - 2) as nat)); // trigger\n                        });\n                    }\n                },\n                Some(penultimate_ptr) => {\n                    assert(old(self)@.len() >= 2);\n                    assert(old(self).well_formed_node((self.ghost_state@.ptrs.len() - 2) as nat));\n\n                    // Otherwise, we need to set the 'tail' pointer to the (new) tail pointer,\n                    // i.e., the pointer that was previously the second-to-last pointer.\n                    self.tail = Some(penultimate_ptr);\n\n                    // And we need to set the 'next' pointer of the new tail node to None.\n                    let tracked mut penultimate_pointsto =\n                        self.ghost_state.borrow_mut().points_to_map.tracked_remove((self.ghost_state@.ptrs.len() - 2) as nat);\n                    let mut penultimate_node = penultimate_ptr.take(Tracked(&mut penultimate_pointsto));\n                    penultimate_node.next = None;\n                    penultimate_ptr.put(Tracked(&mut penultimate_pointsto), penultimate_node);\n                    proof {\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(\n                            (self.ghost_state@.ptrs.len() - 2) as nat,\n                            penultimate_pointsto,\n                        );\n                    }\n                },\n            }\n\n            // Additional proof work to help the solver show that\n            // `self.well_formed()` has been restored.\n            proof {\n                self.ghost_state@.ptrs = self.ghost_state@.ptrs.drop_last();\n                if self.ghost_state@.ptrs.len() > 0 {\n                    assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));\n                }\n                assert(forall|i: nat| i < self@.len() && old(self).well_formed_node(i) ==> self.well_formed_node(i));\n                assert forall|i: int| 0 <= i && i < self@.len() implies #[trigger] self@[i] == old(\n                    self,\n                )@.drop_last()[i] by {\n                    assert(old(self).well_formed_node(i as nat));  // trigger\n                }\n                assert(self@ =~= old(self)@.drop_last());\n\n                assert(self.well_formed());\n            }\n\n            return v;\n        }\n\n        /// Insert a value to the front of the list\n        pub fn push_front(&mut self, v: V)\n            requires\n                old(self).well_formed(),\n            ensures\n                self.well_formed(),\n                self@ == seq![v].add(old(self)@),\n        {\n            match self.head {\n                None => {\n                    // Special case: list is empty\n                    proof {\n                        // Show that the `self.head == None` implies the list is empty\n                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 0, {\n                            assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));\n                        });\n                    }\n                    self.push_empty_case(v);\n                    assert(self@ =~= seq![v].add(old(self)@));\n                }\n                Some(old_head_ptr) => {\n                    proof {\n                        assert(self.ghost_state@.ptrs.len() > 0);\n                        assert(self.well_formed_node(0));\n                    }\n\n                    // Allocate a new node to go at the front. It's 'next' field points\n                    // to the old head pointer.\n                    let (new_head_ptr, Tracked(new_head_pointsto)) = PPtr::new(\n                        Node::<V> { prev: None, next: Some(old_head_ptr), payload: v },\n                    );\n\n                    // Update the 'tail' pointer of the previous head node\n                    // This is all equivalent to `(*old_head_ptr).next = new_head_ptr;`\n                    let tracked mut old_head_pointsto =\n                        self.ghost_state.borrow_mut().points_to_map.tracked_remove(0);\n                    let mut old_head_node = old_head_ptr.take(Tracked(&mut old_head_pointsto));\n                    old_head_node.prev = Some(new_head_ptr);\n                    old_head_ptr.put(Tracked(&mut old_head_pointsto), old_head_node);\n                    proof {\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(0, old_head_pointsto);\n                    }\n\n                    // Update `self.head`\n                    self.head = Some(new_head_ptr);\n\n                    proof {\n                        // Put the new head's PointsTo into the map.\n                        // This goes in at index 0, so we have to shift all the keys up by 1.\n                        assert forall|j: nat|\n                            0 <= j && j < old(self)@.len() implies self.ghost_state@.points_to_map.dom().contains(\n                            j,\n                        ) by {\n                            assert(old(self).well_formed_node(j));\n                        }\n                        self.ghost_state.borrow_mut().points_to_map.tracked_map_keys_in_place(\n                            Map::<nat, nat>::new(\n                                |j: nat| 1 <= j && j <= old(self).view().len(),\n                                |j: nat| (j - 1) as nat,\n                            ),\n                        );\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(0, new_head_pointsto);\n                        self.ghost_state@.ptrs = seq![new_head_ptr].add(self.ghost_state@.ptrs);\n\n                        // Additional proof work to help the solver show that\n                        // `self.well_formed()` has been restored.\n                        assert(self.well_formed_node(0));\n                        assert(self.well_formed_node(1));\n                        assert(forall|i: nat|\n                            1 <= i && i <= old(self).ghost_state@.ptrs.len() && old(self).well_formed_node((i - 1) as nat)\n                                ==> #[trigger] self.well_formed_node(i));\n                        assert forall|i: int| 1 <= i && i <= self.ghost_state@.ptrs.len() as int - 1\n                            implies old(self)@[i - 1] == self@[i]\n                        by {\n                            assert(old(self).well_formed_node((i - 1) as nat));  // trigger\n                        }\n                        assert(self@ =~= seq![v].add(old(self)@));\n\n                        assert(self.well_formed());\n                    }\n                }\n            }\n        }\n\n        /// Take a value from the front of the list. Requires the list to be non-empty.\n        pub fn pop_front(&mut self) -> (v: V)\n            requires\n                old(self).well_formed(),\n                old(self).view().len() > 0,\n            ensures\n                self.well_formed(),\n                self@ == old(self)@.subrange(1, old(self)@.len() as int),\n                v == old(self)@[0],\n        {\n            assert(self.well_formed_node(0));\n\n            // Deallocate the first node in the list and get the payload.\n            // Note self.head.unwrap() will always succeed because of the precondition `len > 0`\n            let first_ptr = self.head.unwrap();\n            let tracked first_pointsto = self.ghost_state.borrow_mut().points_to_map.tracked_remove(0);\n            let first_node = first_ptr.into_inner(Tracked(first_pointsto));\n            let v = first_node.payload;\n\n            match first_node.next {\n                None => {\n                    // If this was the *only* node in the list,\n                    // we set both `head` and `tail` to None\n                    self.tail = None;\n                    self.head = None;\n                    proof {\n                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 1,\n                        {\n                            assert(old(self).well_formed_node(1)); // trigger\n                        });\n                    }\n                }\n                Some(second_ptr) => {\n                    assert(old(self)@.len() >= 2);\n                    assert(old(self).well_formed_node(1));\n\n                    // Otherwise, we need to set the 'head' pointer to the (new) head pointer,\n                    // i.e., the pointer that was previously the second pointer.\n                    self.head = Some(second_ptr);\n\n                    // And we need to set the 'tail' pointer of the new head node to None\n                    let tracked mut second_pointsto = self.ghost_state.borrow_mut().points_to_map.tracked_remove(1);\n                    let mut second_node = second_ptr.take(Tracked(&mut second_pointsto));\n                    second_node.prev = None;\n                    second_ptr.put(Tracked(&mut second_pointsto), second_node);\n                    proof {\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(1, second_pointsto);\n\n                        // Since we removed index 0, we need to shift all the keys down,\n                        // 1 -> 0, 2 -> 1, etc.\n                        assert forall|j: nat|\n                            1 <= j && j < old(self)@.len() implies self.ghost_state@.points_to_map.dom().contains(\n                            j,\n                        ) by {\n                            assert(old(self).well_formed_node(j));\n                        };\n                        self.ghost_state.borrow_mut().points_to_map.tracked_map_keys_in_place(\n                            Map::<nat, nat>::new(\n                                |j: nat| 0 <= j && j < old(self).view().len() - 1,\n                                |j: nat| (j + 1) as nat,\n                            ),\n                        );\n                    }\n                }\n            }\n\n            // Additional proof work to help the solver show that\n            // `self.well_formed()` has been restored.\n            proof {\n                self.ghost_state@.ptrs = self.ghost_state@.ptrs.subrange(1, self.ghost_state@.ptrs.len() as int);\n                if self.ghost_state@.ptrs.len() > 0 {\n                    assert(self.well_formed_node(0));\n                }\n                assert(forall|i: nat|\n                    i < self.view().len() && old(self).well_formed_node(i + 1) ==> self.well_formed_node(i));\n                assert forall|i: int| 0 <= i && i < self@.len() implies #[trigger] self@[i] == old(\n                    self,\n                )@.subrange(1, old(self)@.len() as int)[i] by {\n                    assert(old(self).well_formed_node(i as nat + 1));  // trigger\n                }\n                assert(self@ =~= old(self)@.subrange(1, old(self)@.len() as int));\n\n                assert(self.well_formed());\n            }\n\n            return v;\n        }\n\n        /// Get a reference to the i^th value in the list\n        fn get<'a>(&'a self, i: usize) -> (v: &'a V)\n            requires\n                self.well_formed(),\n                0 <= i < self@.len(),\n            ensures\n                *v == self@[i as int]\n        {\n            // Iterate the nodes from 0 to j, starting at the head node\n            let mut j = 0;\n            let mut ptr = self.head.unwrap();\n            while j < i\n                invariant\n                    self.well_formed(),\n                    0 <= j <= i < self@.len(),\n                    ptr == self.ghost_state@.ptrs[j as int],\n            {\n                proof {\n                    assert(self.well_formed_node(j as nat)); // trigger\n                }\n\n                // Get the next node from the 'next' field\n                let tracked pointsto_ref: &PointsTo<Node<V>> =\n                    self.ghost_state.borrow().points_to_map.tracked_borrow(j as nat);\n                let node_ref: &Node<V> = ptr.borrow(Tracked(pointsto_ref));\n                let next_ptr = node_ref.next.unwrap();\n\n                j += 1;\n                ptr = next_ptr;\n            }\n\n            proof {\n                assert(self.well_formed_node(j as nat)); // trigger\n            }\n\n            // Get a reference to this node's payload and return it\n            let tracked pointsto_ref: &PointsTo<Node<V>> =\n                self.ghost_state.borrow().points_to_map.tracked_borrow(j as nat);\n            let node_ref: &Node<V> = ptr.borrow(Tracked(pointsto_ref));\n            return &node_ref.payload;\n        }\n    }\n\n    pub struct Iterator<'a, V> {\n        l: &'a DoublyLinkedList<V>,\n        cur: Option<PPtr<Node<V>>>,\n        index: Ghost<nat>,\n    }\n\n    impl<'a, V> Iterator<'a, V> {\n        pub closed spec fn list(&self) -> &'a DoublyLinkedList<V> {\n            self.l\n        }\n\n        pub closed spec fn index(&self) -> nat {\n            self.index@\n        }\n\n        pub closed spec fn valid(&self) -> bool {\n            &&& self.list().well_formed()\n            &&& self.index@ < self.list()@.len()\n            &&& self.cur.is_some() && self.cur.unwrap() =~= self.l.ghost_state@.ptrs[self.index@ as int]\n        }\n\n        pub fn new(l: &'a DoublyLinkedList<V>) -> (it: Self)\n            requires\n                l.well_formed(),\n                l@.len() > 0,\n            ensures\n                it.valid(),\n                it.index() == 0,\n                it.list() == l,\n        {\n            Iterator { l, cur: l.head, index: Ghost(0) }\n        }\n\n        pub fn value(&self) -> (v: &V)\n            requires\n                self.valid(),\n            ensures\n                v == self.list()@[self.index() as int],\n        {\n            let cur = self.cur.unwrap();\n            assert(self.l.well_formed_node(self.index()));\n            let tracked pointsto = self.l.ghost_state.borrow().points_to_map.tracked_borrow(self.index());\n            let node = cur.borrow(Tracked(pointsto));\n            &node.payload\n        }\n\n        pub fn move_next(&mut self) -> (good: bool)\n            requires\n                old(self).valid(),\n            ensures\n                old(self).list() == self.list(),\n                good == (old(self).index() < old(self).list()@.len() - 1),\n                good ==> (self.valid() && self.index() == old(self).index() + 1),\n        {\n            assert(self.l.well_formed_node(self.index()));\n            let cur = self.cur.unwrap();\n            let tracked pointsto = self.l.ghost_state.borrow().points_to_map.tracked_borrow(self.index());\n            let node = cur.borrow(Tracked(pointsto));\n            proof {\n                self.index@ = self.index@ + 1;\n            }\n            match node.next {\n                None => {\n                    self.cur = None;\n                    false\n                },\n                Some(next_ptr) => {\n                    self.cur = Some(next_ptr);\n                    true\n                },\n            }\n        }\n    }\n\n}\n\nmod main {\n    use super::doubly_linked_list::{DoublyLinkedList, Iterator};\n\n    pub fn run() {\n        let mut t = DoublyLinkedList::<u32>::new();\n        t.push_back(2);\n        t.push_back(3);\n        t.push_front(1);  // 1, 2, 3\n        let mut it = Iterator::new(&t);\n        let v1 = it.value();\n        assert(*v1 == 1);\n        let g = it.move_next();\n        let v2 = it.value();\n        assert(*v2 == 2);\n        let _ = it.move_next();\n        let v3 = it.value();\n        assert(*v3 == 3);\n        let g = it.move_next();\n        assert(!g);\n        let x = t.pop_back();  // 3\n        let y = t.pop_front();  // 1\n        let z = t.pop_front();  // 2\n        assert(x == 3);\n        assert(y == 1);\n        assert(z == 2);\n    }\n\n}\n\nfn main() {\n    main::run();\n}\n\n} // verus!\n", "full_verified_code": "#![cfg_attr(verus_keep_ghost, verifier::exec_allows_no_decreases_clause)]\n\nuse vstd::prelude::*;\n\nverus! {\n\nmod doubly_linked_list {\n    use vstd::prelude::*;\n    use vstd::simple_pptr::*;\n    use vstd::raw_ptr::MemContents;\n    use vstd::assert_by_contradiction;\n\n    // Single node in the list\n    struct Node<V> {\n        prev: Option<PPtr<Node<V>>>,\n        next: Option<PPtr<Node<V>>>,\n        payload: V,\n    }\n\n    // Doubly-linked list\n    // Contains head pointer, tail pointer\n    // and in ghost code, tracks all the pointers and all the PointsTo permissions\n    // to access the nodes\n    pub struct DoublyLinkedList<V> {\n        // physical data:\n        head: Option<PPtr<Node<V>>>,\n        tail: Option<PPtr<Node<V>>>,\n\n        // ghost and tracked data:\n        ghost_state: Tracked<GhostState<V>>,\n    }\n\n    pub tracked struct GhostState<V> {\n        ghost ptrs: Seq<PPtr<Node<V>>>,\n        tracked points_to_map: Map<nat, PointsTo<Node<V>>>,\n    }\n\n    impl<V> DoublyLinkedList<V> {\n        /// Pointer to the node of index (i-1), or None if i is 0.\n        spec fn prev_of(&self, i: nat) -> Option<PPtr<Node<V>>> {\n            if i == 0 {\n                None\n            } else {\n                Some(self.ghost_state@.ptrs[i as int - 1])\n            }\n        }\n\n        /// Pointer to the node of index (i+1), or None if i is the last index.\n        spec fn next_of(&self, i: nat) -> Option<PPtr<Node<V>>> {\n            if i + 1 == self.ghost_state@.ptrs.len() {\n                None\n            } else {\n                Some(self.ghost_state@.ptrs[i as int + 1])\n            }\n        }\n\n        /// Node at index `i` is well-formed\n        spec fn well_formed_node(&self, i: nat) -> bool {\n            &&& self.ghost_state@.points_to_map.dom().contains(i)\n            &&& self.ghost_state@.points_to_map[i].pptr() == self.ghost_state@.ptrs[i as int]\n            &&& self.ghost_state@.points_to_map[i].mem_contents() matches MemContents::Init(node)\n                  && node.prev == self.prev_of(i) && node.next == self.next_of(i)\n        }\n\n        /// Linked list is well-formed\n        pub closed spec fn well_formed(&self) -> bool {\n            // Every node from 0 .. len - 1 is well-formed\n            &&& forall|i: nat| 0 <= i && i < self.ghost_state@.ptrs.len() ==> self.well_formed_node(i)\n            &&& if self.ghost_state@.ptrs.len() == 0 {\n                // If the list is empty, then the `head` and `tail` pointers are both None\n                self.head.is_none() && self.tail.is_none()\n            } else {\n                // If the list is non-empty, then `head` and `tail` pointers point to the\n                // the first and last nodes.\n                &&& self.head == Some(self.ghost_state@.ptrs[0])\n                &&& self.tail == Some(self.ghost_state@.ptrs[self.ghost_state@.ptrs.len() as int - 1])\n            }\n        }\n\n        /// Representation of this list as a sequence\n        pub closed spec fn view(&self) -> Seq<V> {\n            Seq::<V>::new(\n                self.ghost_state@.ptrs.len(),\n                |i: int| { self.ghost_state@.points_to_map[i as nat].value().payload },\n            )\n        }\n\n        //// Interface of executable functions\n\n        /// Construct a new, empty, doubly-linked list.\n        pub fn new() -> (s: Self)\n            ensures\n                s.well_formed(),\n                s@.len() == 0,\n        {\n            DoublyLinkedList {\n                ghost_state: Tracked(GhostState {\n                    ptrs: Seq::empty(),\n                    points_to_map: Map::tracked_empty(),\n                }),\n                head: None,\n                tail: None,\n            }\n        }\n\n        /// Insert one node, assuming the linked list is empty.\n        fn push_empty_case(&mut self, v: V)\n            requires\n                old(self).well_formed(),\n                old(self).ghost_state@.ptrs.len() == 0,\n            ensures\n                self.well_formed(),\n                self@ =~= old(self)@.push(v),\n        {\n            // Allocate a node to contain the payload\n            let (ptr, Tracked(points_to)) = PPtr::<Node<V>>::new(\n                Node::<V> { prev: None, next: None, payload: v },\n            );\n\n            // Update head and tail pointers\n            self.tail = Some(ptr);\n            self.head = Some(ptr);\n\n            // Update proof state\n            proof {\n                self.ghost_state.borrow_mut().ptrs = self.ghost_state@.ptrs.push(ptr);\n                self.ghost_state.borrow_mut().points_to_map.tracked_insert(\n                    (self.ghost_state@.ptrs.len() - 1) as nat,\n                    points_to,\n                );\n            }\n        }\n\n        /// Insert a value to the end of the list\n        pub fn push_back(&mut self, v: V)\n            requires\n                old(self).well_formed(),\n            ensures\n                self.well_formed(),\n                self@ == old(self)@.push(v),\n        {\n            match self.tail {\n                None => {\n                    // Special case: list is empty\n                    proof {\n                        // Show that the `self.tail == None` implies the list is empty\n                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 0,\n                        {\n                            assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat)); // trigger\n                        });\n                    }\n                    self.push_empty_case(v);\n                }\n                Some(old_tail_ptr) => {\n                    proof {\n                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat)); // trigger\n                    }\n\n                    // Allocate a new node to go on the end. It's 'prev' field points\n                    // to the old tail pointer.\n                    let (new_tail_ptr, Tracked(new_tail_pointsto)) = PPtr::<Node<V>>::new(\n                        Node::<V> { prev: Some(old_tail_ptr), next: None, payload: v },\n                    );\n\n                    // Update the 'next' pointer of the previous tail node\n                    // This is all equivalent to `(*old_tail_ptr).next = new_tail_ptr;`\n                    let tracked mut old_tail_pointsto: PointsTo<Node<V>> =\n                        self.ghost_state.borrow_mut().points_to_map.tracked_remove((self.ghost_state@.ptrs.len() - 1) as nat);\n                    let mut old_tail_node = old_tail_ptr.take(Tracked(&mut old_tail_pointsto));\n                    old_tail_node.next = Some(new_tail_ptr);\n                    old_tail_ptr.put(Tracked(&mut old_tail_pointsto), old_tail_node);\n                    proof {\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(\n                            (self.ghost_state@.ptrs.len() - 1) as nat,\n                            old_tail_pointsto,\n                        );\n                    }\n\n                    // Update `self.tail`\n                    self.tail = Some(new_tail_ptr);\n\n                    proof {\n                        // Put the new tail's PointsTo into the map\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(self.ghost_state@.ptrs.len(), new_tail_pointsto);\n                        self.ghost_state@.ptrs = self.ghost_state@.ptrs.push(new_tail_ptr);\n\n                        // Additional proof work to help the solver show that\n                        // `self.well_formed()` has been restored.\n                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 2) as nat));\n                        assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));\n                        assert(forall|i: nat| i < self.ghost_state@.ptrs.len() && old(self).well_formed_node(i)\n                            ==> self.well_formed_node(i));\n                        assert forall|i: int| 0 <= i && i < self.ghost_state@.ptrs.len() as int - 1\n                            implies old(self)@[i] == self@[i]\n                        by {\n                            assert(old(self).well_formed_node(i as nat));  // trigger\n                        }\n                        assert(self@ =~= old(self)@.push(v));\n\n                        assert(self.well_formed());\n                    }\n                }\n            }\n        }\n\n        /// Take a value from the end of the list. Requires the list to be non-empty.\n        pub fn pop_back(&mut self) -> (v: V)\n            requires\n                old(self).well_formed(),\n                old(self)@.len() > 0,\n            ensures\n                self.well_formed(),\n                self@ == old(self)@.drop_last(),\n                v == old(self)@[old(self)@.len() as int - 1],\n        {\n            assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));\n\n            // Deallocate the last node in the list and get the payload.\n            // Note self.tail.unwrap() will always succeed because of the precondition `len > 0`\n            let last_ptr = self.tail.unwrap();\n            let tracked last_pointsto = self.ghost_state.borrow_mut().points_to_map.tracked_remove(\n                (self.ghost_state@.ptrs.len() - 1) as nat,\n            );\n            let last_node = last_ptr.into_inner(Tracked(last_pointsto));\n            let v = last_node.payload;\n\n            match last_node.prev {\n                None => {\n                    // If this was the *only* node in the list,\n                    // we set both `head` and `tail` to None\n                    self.tail = None;\n                    self.head = None;\n                    proof {\n                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 1,\n                        {\n                            assert(old(self).well_formed_node((self.ghost_state@.ptrs.len() - 2) as nat)); // trigger\n                        });\n                    }\n                },\n                Some(penultimate_ptr) => {\n                    assert(old(self)@.len() >= 2);\n                    assert(old(self).well_formed_node((self.ghost_state@.ptrs.len() - 2) as nat));\n\n                    // Otherwise, we need to set the 'tail' pointer to the (new) tail pointer,\n                    // i.e., the pointer that was previously the second-to-last pointer.\n                    self.tail = Some(penultimate_ptr);\n\n                    // And we need to set the 'next' pointer of the new tail node to None.\n                    let tracked mut penultimate_pointsto =\n                        self.ghost_state.borrow_mut().points_to_map.tracked_remove((self.ghost_state@.ptrs.len() - 2) as nat);\n                    let mut penultimate_node = penultimate_ptr.take(Tracked(&mut penultimate_pointsto));\n                    penultimate_node.next = None;\n                    penultimate_ptr.put(Tracked(&mut penultimate_pointsto), penultimate_node);\n                    proof {\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(\n                            (self.ghost_state@.ptrs.len() - 2) as nat,\n                            penultimate_pointsto,\n                        );\n                    }\n                },\n            }\n\n            // Additional proof work to help the solver show that\n            // `self.well_formed()` has been restored.\n            proof {\n                self.ghost_state@.ptrs = self.ghost_state@.ptrs.drop_last();\n                if self.ghost_state@.ptrs.len() > 0 {\n                    assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));\n                }\n                assert(forall|i: nat| i < self@.len() && old(self).well_formed_node(i) ==> self.well_formed_node(i));\n                assert forall|i: int| 0 <= i && i < self@.len() implies #[trigger] self@[i] == old(\n                    self,\n                )@.drop_last()[i] by {\n                    assert(old(self).well_formed_node(i as nat));  // trigger\n                }\n                assert(self@ =~= old(self)@.drop_last());\n\n                assert(self.well_formed());\n            }\n\n            return v;\n        }\n\n        /// Insert a value to the front of the list\n        pub fn push_front(&mut self, v: V)\n            requires\n                old(self).well_formed(),\n            ensures\n                self.well_formed(),\n                self@ == seq![v].add(old(self)@),\n        {\n            match self.head {\n                None => {\n                    // Special case: list is empty\n                    proof {\n                        // Show that the `self.head == None` implies the list is empty\n                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 0, {\n                            assert(self.well_formed_node((self.ghost_state@.ptrs.len() - 1) as nat));\n                        });\n                    }\n                    self.push_empty_case(v);\n                    assert(self@ =~= seq![v].add(old(self)@));\n                }\n                Some(old_head_ptr) => {\n                    proof {\n                        assert(self.ghost_state@.ptrs.len() > 0);\n                        assert(self.well_formed_node(0));\n                    }\n\n                    // Allocate a new node to go at the front. It's 'next' field points\n                    // to the old head pointer.\n                    let (new_head_ptr, Tracked(new_head_pointsto)) = PPtr::new(\n                        Node::<V> { prev: None, next: Some(old_head_ptr), payload: v },\n                    );\n\n                    // Update the 'tail' pointer of the previous head node\n                    // This is all equivalent to `(*old_head_ptr).next = new_head_ptr;`\n                    let tracked mut old_head_pointsto =\n                        self.ghost_state.borrow_mut().points_to_map.tracked_remove(0);\n                    let mut old_head_node = old_head_ptr.take(Tracked(&mut old_head_pointsto));\n                    old_head_node.prev = Some(new_head_ptr);\n                    old_head_ptr.put(Tracked(&mut old_head_pointsto), old_head_node);\n                    proof {\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(0, old_head_pointsto);\n                    }\n\n                    // Update `self.head`\n                    self.head = Some(new_head_ptr);\n\n                    proof {\n                        // Put the new head's PointsTo into the map.\n                        // This goes in at index 0, so we have to shift all the keys up by 1.\n                        assert forall|j: nat|\n                            0 <= j && j < old(self)@.len() implies self.ghost_state@.points_to_map.dom().contains(\n                            j,\n                        ) by {\n                            assert(old(self).well_formed_node(j));\n                        }\n                        self.ghost_state.borrow_mut().points_to_map.tracked_map_keys_in_place(\n                            Map::<nat, nat>::new(\n                                |j: nat| 1 <= j && j <= old(self).view().len(),\n                                |j: nat| (j - 1) as nat,\n                            ),\n                        );\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(0, new_head_pointsto);\n                        self.ghost_state@.ptrs = seq![new_head_ptr].add(self.ghost_state@.ptrs);\n\n                        // Additional proof work to help the solver show that\n                        // `self.well_formed()` has been restored.\n                        assert(self.well_formed_node(0));\n                        assert(self.well_formed_node(1));\n                        assert(forall|i: nat|\n                            1 <= i && i <= old(self).ghost_state@.ptrs.len() && old(self).well_formed_node((i - 1) as nat)\n                                ==> #[trigger] self.well_formed_node(i));\n                        assert forall|i: int| 1 <= i && i <= self.ghost_state@.ptrs.len() as int - 1\n                            implies old(self)@[i - 1] == self@[i]\n                        by {\n                            assert(old(self).well_formed_node((i - 1) as nat));  // trigger\n                        }\n                        assert(self@ =~= seq![v].add(old(self)@));\n\n                        assert(self.well_formed());\n                    }\n                }\n            }\n        }\n\n        /// Take a value from the front of the list. Requires the list to be non-empty.\n        pub fn pop_front(&mut self) -> (v: V)\n            requires\n                old(self).well_formed(),\n                old(self).view().len() > 0,\n            ensures\n                self.well_formed(),\n                self@ == old(self)@.subrange(1, old(self)@.len() as int),\n                v == old(self)@[0],\n        {\n            assert(self.well_formed_node(0));\n\n            // Deallocate the first node in the list and get the payload.\n            // Note self.head.unwrap() will always succeed because of the precondition `len > 0`\n            let first_ptr = self.head.unwrap();\n            let tracked first_pointsto = self.ghost_state.borrow_mut().points_to_map.tracked_remove(0);\n            let first_node = first_ptr.into_inner(Tracked(first_pointsto));\n            let v = first_node.payload;\n\n            match first_node.next {\n                None => {\n                    // If this was the *only* node in the list,\n                    // we set both `head` and `tail` to None\n                    self.tail = None;\n                    self.head = None;\n                    proof {\n                        assert_by_contradiction!(self.ghost_state@.ptrs.len() == 1,\n                        {\n                            assert(old(self).well_formed_node(1)); // trigger\n                        });\n                    }\n                }\n                Some(second_ptr) => {\n                    assert(old(self)@.len() >= 2);\n                    assert(old(self).well_formed_node(1));\n\n                    // Otherwise, we need to set the 'head' pointer to the (new) head pointer,\n                    // i.e., the pointer that was previously the second pointer.\n                    self.head = Some(second_ptr);\n\n                    // And we need to set the 'tail' pointer of the new head node to None\n                    let tracked mut second_pointsto = self.ghost_state.borrow_mut().points_to_map.tracked_remove(1);\n                    let mut second_node = second_ptr.take(Tracked(&mut second_pointsto));\n                    second_node.prev = None;\n                    second_ptr.put(Tracked(&mut second_pointsto), second_node);\n                    proof {\n                        self.ghost_state.borrow_mut().points_to_map.tracked_insert(1, second_pointsto);\n\n                        // Since we removed index 0, we need to shift all the keys down,\n                        // 1 -> 0, 2 -> 1, etc.\n                        assert forall|j: nat|\n                            1 <= j && j < old(self)@.len() implies self.ghost_state@.points_to_map.dom().contains(\n                            j,\n                        ) by {\n                            assert(old(self).well_formed_node(j));\n                        };\n                        self.ghost_state.borrow_mut().points_to_map.tracked_map_keys_in_place(\n                            Map::<nat, nat>::new(\n                                |j: nat| 0 <= j && j < old(self).view().len() - 1,\n                                |j: nat| (j + 1) as nat,\n                            ),\n                        );\n                    }\n                }\n            }\n\n            // Additional proof work to help the solver show that\n            // `self.well_formed()` has been restored.\n            proof {\n                self.ghost_state@.ptrs = self.ghost_state@.ptrs.subrange(1, self.ghost_state@.ptrs.len() as int);\n                if self.ghost_state@.ptrs.len() > 0 {\n                    assert(self.well_formed_node(0));\n                }\n                assert(forall|i: nat|\n                    i < self.view().len() && old(self).well_formed_node(i + 1) ==> self.well_formed_node(i));\n                assert forall|i: int| 0 <= i && i < self@.len() implies #[trigger] self@[i] == old(\n                    self,\n                )@.subrange(1, old(self)@.len() as int)[i] by {\n                    assert(old(self).well_formed_node(i as nat + 1));  // trigger\n                }\n                assert(self@ =~= old(self)@.subrange(1, old(self)@.len() as int));\n\n                assert(self.well_formed());\n            }\n\n            return v;\n        }\n\n        /// Get a reference to the i^th value in the list\n        fn get<'a>(&'a self, i: usize) -> (v: &'a V)\n            requires\n                self.well_formed(),\n                0 <= i < self@.len(),\n            ensures\n                *v == self@[i as int]\n        {\n            // Iterate the nodes from 0 to j, starting at the head node\n            let mut j = 0;\n            let mut ptr = self.head.unwrap();\n            while j < i\n                invariant\n                    self.well_formed(),\n                    0 <= j <= i < self@.len(),\n                    ptr == self.ghost_state@.ptrs[j as int],\n            {\n                proof {\n                    assert(self.well_formed_node(j as nat)); // trigger\n                }\n\n                // Get the next node from the 'next' field\n                let tracked pointsto_ref: &PointsTo<Node<V>> =\n                    self.ghost_state.borrow().points_to_map.tracked_borrow(j as nat);\n                let node_ref: &Node<V> = ptr.borrow(Tracked(pointsto_ref));\n                let next_ptr = node_ref.next.unwrap();\n\n                j += 1;\n                ptr = next_ptr;\n            }\n\n            proof {\n                assert(self.well_formed_node(j as nat)); // trigger\n            }\n\n            // Get a reference to this node's payload and return it\n            let tracked pointsto_ref: &PointsTo<Node<V>> =\n                self.ghost_state.borrow().points_to_map.tracked_borrow(j as nat);\n            let node_ref: &Node<V> = ptr.borrow(Tracked(pointsto_ref));\n            return &node_ref.payload;\n        }\n    }\n\n    pub struct Iterator<'a, V> {\n        l: &'a DoublyLinkedList<V>,\n        cur: Option<PPtr<Node<V>>>,\n        index: Ghost<nat>,\n    }\n\n    impl<'a, V> Iterator<'a, V> {\n        pub closed spec fn list(&self) -> &'a DoublyLinkedList<V> {\n            self.l\n        }\n\n        pub closed spec fn index(&self) -> nat {\n            self.index@\n        }\n\n        pub closed spec fn valid(&self) -> bool {\n            &&& self.list().well_formed()\n            &&& self.index@ < self.list()@.len()\n            &&& self.cur.is_some() && self.cur.unwrap() =~= self.l.ghost_state@.ptrs[self.index@ as int]\n        }\n\n        pub fn new(l: &'a DoublyLinkedList<V>) -> (it: Self)\n            requires\n                l.well_formed(),\n                l@.len() > 0,\n            ensures\n                it.valid(),\n                it.index() == 0,\n                it.list() == l,\n        {\n            Iterator { l, cur: l.head, index: Ghost(0) }\n        }\n\n        pub fn value(&self) -> (v: &V)\n            requires\n                self.valid(),\n            ensures\n                v == self.list()@[self.index() as int],\n        {\n            let cur = self.cur.unwrap();\n            assert(self.l.well_formed_node(self.index()));\n            let tracked pointsto = self.l.ghost_state.borrow().points_to_map.tracked_borrow(self.index());\n            let node = cur.borrow(Tracked(pointsto));\n            &node.payload\n        }\n\n        pub fn move_next(&mut self) -> (good: bool)\n            requires\n                old(self).valid(),\n            ensures\n                old(self).list() == self.list(),\n                good == (old(self).index() < old(self).list()@.len() - 1),\n                good ==> (self.valid() && self.index() == old(self).index() + 1),\n        {\n            assert(self.l.well_formed_node(self.index()));\n            let cur = self.cur.unwrap();\n            let tracked pointsto = self.l.ghost_state.borrow().points_to_map.tracked_borrow(self.index());\n            let node = cur.borrow(Tracked(pointsto));\n            proof {\n                self.index@ = self.index@ + 1;\n            }\n            match node.next {\n                None => {\n                    self.cur = None;\n                    false\n                },\n                Some(next_ptr) => {\n                    self.cur = Some(next_ptr);\n                    true\n                },\n            }\n        }\n    }\n\n}\n\nmod main {\n    use super::doubly_linked_list::{DoublyLinkedList, Iterator};\n\n    pub fn run() {\n        let mut t = DoublyLinkedList::<u32>::new();\n        t.push_back(2);\n        t.push_back(3);\n        t.push_front(1);  // 1, 2, 3\n        let mut it = Iterator::new(&t);\n        let v1 = it.value();\n        assert(*v1 == 1);\n        let g = it.move_next();\n        let v2 = it.value();\n        assert(*v2 == 2);\n        let _ = it.move_next();\n        let v3 = it.value();\n        assert(*v3 == 3);\n        let g = it.move_next();\n        assert(!g);\n        let x = t.pop_back();  // 3\n        let y = t.pop_front();  // 1\n        let z = t.pop_front();  // 2\n        assert(x == 3);\n        assert(y == 1);\n        assert(z == 2);\n    }\n\n}\n\nfn main() {\n    main::run();\n}\n\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/verus/examples/doubly_linked.rs", "verified": true, "metadata": {"original_id": "verus_doubly_linked_7b8ba918de95", "function_name": "", "bug_type": "missing_ensures"}}
{"id": "task_a_3406b6f065de", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool)   { let mut i : u32 = 2 ; while i < n  { if n % i == 0 { return true ; } i = i + 1 ; } return false ; }\n\n} // verus!", "target_text": "requires n >= 2 \nensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 \ndecreases n - i \ninvariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i , { if n % i == 0 { return true ; } i = i + 1 ; } return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/RustBench/invariants_removed/is_non_prime_impl.rs", "verified": true, "metadata": {"original_id": "3406b6f065de", "function_name": "is_non_prime", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_a_fa3fc34cebcd", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool)  { let mut index = 0 ; while index < arr . len ()  { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "target_text": "ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) \ndecreases arr . len () - index \ninvariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn is_greater (arr : & Vec < i32 > , number : i32) -> (result : bool) ensures result == (forall | i : int | 0 <= i < arr . len () ==> number > arr [i]) , { let mut index = 0 ; while index < arr . len () invariant 0 <= index <= arr . len () , forall | i : int | 0 <= i < index ==> number > arr [i] , decreases arr . len () - index , { if number <= arr [index] { return false ; } index += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/autoverus/MBPP/verified/task_id_433_iter_2_current.rs", "verified": true, "metadata": {"original_id": "fa3fc34cebcd", "function_name": "is_greater", "has_requires": false, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_c_missing_ensures_ddfeb024ca26", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn append_postcond (a : Seq < int > , b : int , result : Seq < int >) -> bool { (forall | i : int | 0 <= i < a . len () ==> result [i] == a [i]) && result [a . len () as int] == b && result . len () == a . len () + 1 }\npub open spec fn append_precond (a : Seq < int > , b : int) -> bool { true }\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] ,  { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\npub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >) requires append_precond (a @ , b) ,  { let mut result = Vec :: new () ; copy (a , 0 , & mut result) ; result . push (b) ; result }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn append_postcond (a : Seq < int > , b : int , result : Seq < int >) -> bool { (forall | i : int | 0 <= i < a . len () ==> result [i] == a [i]) && result [a . len () as int] == b && result . len () == a . len () + 1 }\npub open spec fn append_precond (a : Seq < int > , b : int) -> bool { true }\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\npub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >) requires append_precond (a @ , b) , ensures append_postcond (a @ , b , result @) , { let mut result = Vec :: new () ; copy (a , 0 , & mut result) ; result . push (b) ; result }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\npub open spec fn append_postcond (a : Seq < int > , b : int , result : Seq < int >) -> bool { (forall | i : int | 0 <= i < a . len () ==> result [i] == a [i]) && result [a . len () as int] == b && result . len () == a . len () + 1 }\npub open spec fn append_precond (a : Seq < int > , b : int) -> bool { true }\nfn copy (a : & Vec < int > , i : usize , acc : & mut Vec < int >) requires i <= a . len () , old (acc) . len () == i , forall | j : int | 0 <= j < i ==> old (acc) [j] == a [j] , ensures acc . len () == a . len () , forall | j : int | 0 <= j < a . len () ==> acc [j] == a [j] , decreases a . len () - i , { if i < a . len () { acc . push (a [i]) ; copy (a , i + 1 , acc) ; } }\npub fn append (a : & Vec < int > , b : int) -> (result : Vec < int >) requires append_precond (a @ , b) , ensures append_postcond (a @ , b , result @) , { let mut result = Vec :: new () ; copy (a , 0 , & mut result) ; result . push (b) ; result }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_basic_72/verina_basic_72_iter_1_generated.rs", "verified": true, "metadata": {"original_id": "ddfeb024ca26", "function_name": "append", "bug_type": "missing_ensures"}}
{"id": "task_c_missing_invariant_7de4d12e5805", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn selection_sort (a : & mut Vec < int >) ensures a . len () == old (a) . len () , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , { let len = a . len () ; let mut i : usize = 0 ; while i < len  { let mut min_idx : usize = i ; let mut j : usize = i + 1 ; while j < len  { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn selection_sort (a : & mut Vec < int >) ensures a . len () == old (a) . len () , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , { let len = a . len () ; let mut i : usize = 0 ; while i < len invariant i <= len , a . len () == len , forall | x : int , y : int | 0 <= x < y < i ==> a [x] <= a [y] , forall | x : int , y : int | 0 <= x < i && i <= y < len ==> a [x] <= a [y] , decreases len - i { let mut min_idx : usize = i ; let mut j : usize = i + 1 ; while j < len invariant i <= min_idx < len , i <= j <= len , a . len () == len , forall | k : int | i <= k < j ==> a [min_idx as int] <= a [k] , decreases len - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn selection_sort (a : & mut Vec < int >) ensures a . len () == old (a) . len () , forall | i : int , j : int | 0 <= i < j < a . len () ==> a [i] <= a [j] , { let len = a . len () ; let mut i : usize = 0 ; while i < len invariant i <= len , a . len () == len , forall | x : int , y : int | 0 <= x < y < i ==> a [x] <= a [y] , forall | x : int , y : int | 0 <= x < i && i <= y < len ==> a [x] <= a [y] , decreases len - i { let mut min_idx : usize = i ; let mut j : usize = i + 1 ; while j < len invariant i <= min_idx < len , i <= j <= len , a . len () == len , forall | k : int | i <= k < j ==> a [min_idx as int] <= a [k] , decreases len - j { if a [j] < a [min_idx] { min_idx = j ; } j += 1 ; } let temp = a [i] ; let min_val = a [min_idx] ; a . set (i , min_val) ; a . set (min_idx , temp) ; i += 1 ; } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/artifacts/dafnybench/Clover_selectionsort/verus_code_iter_4_current.rs", "verified": true, "metadata": {"original_id": "7de4d12e5805", "function_name": "selection_sort", "bug_type": "missing_invariant"}}
{"id": "task_c_missing_requires_9eafcf90cf77", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn loop_search (nums : & Vec < i32 > , start : usize , first : i32 , second : i32) -> (result : bool)  { return false ; }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn loop_search (nums : & Vec < i32 > , start : usize , first : i32 , second : i32) -> (result : bool) requires start <= nums . len () decreases nums . len () - start { return false ; }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn loop_search (nums : & Vec < i32 > , start : usize , first : i32 , second : i32) -> (result : bool) requires start <= nums . len () decreases nums . len () - start { return false ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_15/verina_advanced_15_iter_0_original.rs", "verified": true, "metadata": {"original_id": "9eafcf90cf77", "function_name": "loop_search", "bug_type": "missing_requires"}}
{"id": "task_c_missing_requires_555370735660", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize)  ensures result <= d , decreases a . len () + b . len () - m - n { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize) requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , ensures result <= d , decreases a . len () + b . len () - m - n { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn spec_nat_abs_diff (x : i32 , y : i32) -> nat { let diff = (x as int) - (y as int) ; if diff >= 0 { diff as nat } else { (- diff) as nat } }\nfn nat_abs_diff (x : i32 , y : i32) -> (result : usize) ensures result as nat == spec_nat_abs_diff (x , y) { let diff = x as i64 - y as i64 ; if diff >= 0 { diff as usize } else { (- diff) as usize } }\nfn canyon_search_aux (a : & Vec < i32 > , b : & Vec < i32 > , m : usize , n : usize , d : usize) -> (result : usize) requires a . len () > 0 , b . len () > 0 , m <= a . len () , n <= b . len () , ensures result <= d , decreases a . len () + b . len () - m - n { if m >= a . len () || n >= b . len () { return d ; } let current_diff = nat_abs_diff (a [m] , b [n]) ; let min_so_far = if current_diff < d { current_diff } else { d } ; if a [m] <= b [n] { canyon_search_aux (a , b , m + 1 , n , min_so_far) } else { canyon_search_aux (a , b , m , n + 1 , min_so_far) } }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_54/verina_basic_54_impl.rs", "verified": true, "metadata": {"original_id": "555370735660", "function_name": "canyon_search_aux", "bug_type": "missing_requires"}}
{"id": "task_c_missing_decreases_2a643fceefe9", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i , { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\n# [verifier :: loop_isolation (false)] fn is_non_prime (n : u32) -> (result : bool) requires n >= 2 , ensures result == exists | k : int | 2 <= k < n && # [trigger] (n as int % k) == 0 , { let mut i : u32 = 2 ; while i < n invariant 2 <= i <= n , forall | k : int | 2 <= k < i ==> # [trigger] (n as int % k) != 0 , decreases n - i , { if n % i == 0 { return true ; } i = i + 1 ; } false }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/RustBench/ground_truth/is_non_prime_iter_3_current.rs", "verified": true, "metadata": {"original_id": "2a643fceefe9", "function_name": "is_non_prime", "bug_type": "missing_decreases"}}
{"id": "task_a_6ece0c03585d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32)  { 0 }\n\n} // verus!", "target_text": "ensures r == F_spec () && r <= 0", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn F_spec () -> int { 0 }\nfn F () -> (r : i32) ensures r == F_spec () && r <= 0 { 0 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/artifacts/dafnybench/Dafny_tmp_tmp0wu8wmfr_tests_F1a/verus_code_impl.rs", "verified": true, "metadata": {"original_id": "6ece0c03585d", "function_name": "F", "has_requires": false, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_a_d13e9b30a13d", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_extend (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int)   { 1int } else { 0int }) , { let sub1 = s1 . subrange (0 , i + 1) ; let sub2 = s2 . subrange (0 , i + 1) ; let sub3 = s3 . subrange (0 , i + 1) ;        }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize)   { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len ()  {  if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count = count + 1 ; } i = i + 1 ; }     count }\n\n} // verus!", "target_text": "requires s1 . len () == s2 . len () == s3 . len () , 0 <= i < s1 . len () , arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () \nensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + (if s1 [i] == s2 [i] && s2 [i] == s3 [i], 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count \ndecreases s1 . len () , s2 . len () , s3 . len () , i , arr1 . len () - i \ninvariant 0 <= i <= arr1 . len () , 0 <= count <= i , arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn count_identical (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 >) -> (result : int) decreases s1 . len () , s2 . len () , s3 . len () , { if s1 . len () == 0 || s2 . len () == 0 || s3 . len () == 0 { 0 } else { count_identical (s1 . drop_last () , s2 . drop_last () , s3 . drop_last ()) + if (s1 . last () == s2 . last () && s2 . last () == s3 . last ()) { 1 as int } else { 0 as int } } }\nproof fn lemma_count_identical_extend (s1 : Seq < i32 > , s2 : Seq < i32 > , s3 : Seq < i32 > , i : int) requires s1 . len () == s2 . len () == s3 . len () , 0 <= i < s1 . len () , ensures count_identical (s1 . subrange (0 , i + 1) , s2 . subrange (0 , i + 1) , s3 . subrange (0 , i + 1)) == count_identical (s1 . subrange (0 , i) , s2 . subrange (0 , i) , s3 . subrange (0 , i)) + (if s1 [i] == s2 [i] && s2 [i] == s3 [i] { 1int } else { 0int }) , decreases i , { let sub1 = s1 . subrange (0 , i + 1) ; let sub2 = s2 . subrange (0 , i + 1) ; let sub3 = s3 . subrange (0 , i + 1) ; assert (sub1 . last () == s1 [i]) ; assert (sub2 . last () == s2 [i]) ; assert (sub3 . last () == s3 [i]) ; assert (sub1 . drop_last () == s1 . subrange (0 , i)) ; assert (sub2 . drop_last () == s2 . subrange (0 , i)) ; assert (sub3 . drop_last () == s3 . subrange (0 , i)) ; assert (count_identical (sub1 , sub2 , sub3) == count_identical (sub1 . drop_last () , sub2 . drop_last () , sub3 . drop_last ()) + (if sub1 . last () == sub2 . last () && sub2 . last () == sub3 . last () { 1int } else { 0int })) ; }\nfn count_identical_position (arr1 : & Vec < i32 > , arr2 : & Vec < i32 > , arr3 : & Vec < i32 >) -> (count : usize) requires arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , ensures 0 <= count <= arr1 . len () , count_identical (arr1 @ , arr2 @ , arr3 @) == count , { let mut count = 0 ; let mut i = 0 ; while i < arr1 . len () invariant 0 <= i <= arr1 . len () , 0 <= count <= i , arr1 . len () == arr2 . len () && arr2 . len () == arr3 . len () , count == count_identical (arr1 @ . subrange (0 , i as int) , arr2 @ . subrange (0 , i as int) , arr3 @ . subrange (0 , i as int)) , decreases arr1 . len () - i , { proof { lemma_count_identical_extend (arr1 @ , arr2 @ , arr3 @ , i as int) ; } if arr1 [i] == arr2 [i] && arr2 [i] == arr3 [i] { count = count + 1 ; } i = i + 1 ; } assert (i == arr1 . len ()) ; assert (arr1 @ . subrange (0 , i as int) == arr1 @) ; assert (arr2 @ . subrange (0 , i as int) == arr2 @) ; assert (arr3 @ . subrange (0 , i as int) == arr3 @) ; count }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_28-07_07h05/translations/specs_benches/VerusProofSynthesisBench/MBPP_no_bodies/task_id_142_impl.rs", "verified": true, "metadata": {"original_id": "d13e9b30a13d", "function_name": "count_identical_position", "has_requires": true, "has_ensures": true, "has_invariants": true, "has_decreases": true}}
{"id": "task_b_2f49a95aeca4", "task": "task_b", "input_text": "fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32)\nrequires minimum_right_shifts_precond (nums @ . map (| i , x | x as int))\nensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int)", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; for shifts in 0 .. n { if is_sorted_aux (& current) { return shifts as i32 ; } current = right_shift_once (& current) ; } - 1 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn minimum_right_shifts_precond (nums : Seq < int >) -> bool { forall | i : int , j : int | 0 <= i < j < nums . len () ==> # [trigger] nums [i] != # [trigger] nums [j] }\nspec fn minimum_right_shifts_postcond (nums : Seq < int > , result : int) -> bool { let n = nums . len () ; if n <= 1 { result == 0 } else if result >= 0 { result < n && is_sorted (right_shift (result as nat , nums)) && forall | j : nat | j < result ==> ! is_sorted (# [trigger] right_shift (j , nums)) } else { result == - 1 && forall | k : nat | k < n ==> ! is_sorted (# [trigger] right_shift (k , nums)) } }\nspec fn right_shift (k : nat , s : Seq < int >) -> Seq < int > decreases k { if k == 0 { s } else { right_shift ((k - 1) as nat , right_shift_one (s)) } }\nspec fn is_sorted (s : Seq < int >) -> bool { forall | i : int | 0 <= i < s . len () - 1 ==> # [trigger] s [i] <= s [i + 1] }\nspec fn right_shift_one (s : Seq < int >) -> Seq < int > { if s . len () == 0 { s } else { seq ! [s [s . len () - 1]] + s . subrange (0 , s . len () - 1) } }\n# [verifier :: external_body] fn right_shift_once (nums : & Vec < i32 >) -> (result : Vec < i32 >) { if nums . len () == 0 { return Vec :: new () ; } let mut result = Vec :: new () ; let last = nums [nums . len () - 1] ; result . push (last) ; for i in 0 .. nums . len () - 1 { result . push (nums [i]) ; } result }\n# [verifier :: external_body] fn is_sorted_aux (nums : & Vec < i32 >) -> (result : bool) { if nums . len () <= 1 { return true ; } for i in 0 .. nums . len () - 1 { if nums [i] > nums [i + 1] { return false ; } } true }\n# [verifier :: external_body] fn minimum_right_shifts (nums : Vec < i32 >) -> (result : i32) requires minimum_right_shifts_precond (nums @ . map (| i , x | x as int)) ensures minimum_right_shifts_postcond (nums @ . map (| i , x | x as int) , result as int) { let n = nums . len () ; if n <= 1 { return 0 ; } let mut current = nums ; for shifts in 0 .. n { if is_sorted_aux (& current) { return shifts as i32 ; } current = right_shift_once (& current) ; } - 1 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_53/verina_advanced_53_iter_1_current.rs", "verified": true, "metadata": {"original_id": "2f49a95aeca4", "function_name": "minimum_right_shifts", "has_invariants": false, "has_asserts": false}}
{"id": "task_c_missing_ensures_1d6324b3cfd8", "task": "task_c", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 ,  { let half = x / 2 ; let three_halves = half + half + half ; three_halves * 2 }\n\n} // verus!", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { let half = x / 2 ; let three_halves = half + half + half ; three_halves * 2 }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nfn triple_conditions (x : u32) -> (r : u32) requires x % 2 == 0 && x <= 0x55555555u32 , ensures r as int == 3 * (x as int) { let half = x / 2 ; let three_halves = half + half + half ; three_halves * 2 }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_06-08_14h50/verus/verus_specs/benches_no_bodies_20250806_143155/artifacts/dafnybench/Dafny_Verify_tmp_tmphq7j0row_Test_Cases_Triple/verus_code_iter_1_current.rs", "verified": true, "metadata": {"original_id": "1d6324b3cfd8", "function_name": "triple_conditions", "bug_type": "missing_ensures"}}
{"id": "task_b_58a0eaec350f", "task": "task_b", "input_text": "fn is_sorted (a : & [i32]) -> (result : bool)\nrequires is_sorted_precond (a @) \nensures is_sorted_postcond (a @ , result) ", "target_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted_postcond (a : Seq < i32 > , result : bool) -> bool { (forall | i : int | 0 <= i < a . len () - 1 ==> # [trigger] a [i] <= a [i + 1]) <==> result }\nspec fn is_sorted_precond (a : Seq < i32 >) -> bool { true }\nfn is_sorted (a : & [i32]) -> (result : bool) requires is_sorted_precond (a @) , ensures is_sorted_postcond (a @ , result) , { if a . len () <= 1 { return true ; } let mut i = 0 ; while i < a . len () - 1 invariant 0 <= i <= a . len () - 1 , forall | j : int | 0 <= j < i ==> # [trigger] a @ [j] <= a @ [j + 1] , decreases a . len () - i , { if a [i] > a [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn is_sorted_postcond (a : Seq < i32 > , result : bool) -> bool { (forall | i : int | 0 <= i < a . len () - 1 ==> # [trigger] a [i] <= a [i + 1]) <==> result }\nspec fn is_sorted_precond (a : Seq < i32 >) -> bool { true }\nfn is_sorted (a : & [i32]) -> (result : bool) requires is_sorted_precond (a @) , ensures is_sorted_postcond (a @ , result) , { if a . len () <= 1 { return true ; } let mut i = 0 ; while i < a . len () - 1 invariant 0 <= i <= a . len () - 1 , forall | j : int | 0 <= j < i ==> # [trigger] a @ [j] <= a @ [j + 1] , decreases a . len () - i , { if a [i] > a [i + 1] { return false ; } i += 1 ; } true }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_07-08_21h09/verus/verus_specs/verina_no_bodies_20250807_210557/verina_basic_19/verina_basic_19_iter_2_current.rs", "verified": true, "metadata": {"original_id": "58a0eaec350f", "function_name": "is_sorted", "has_invariants": true, "has_asserts": false}}
{"id": "task_a_4e2998c1460f", "task": "task_a", "input_text": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_consecutive_postcond (nums : & Vec < i32 > , result : nat) -> bool { (nums . len () == 0 ==> result == 0) && result <= nums . len () }\nspec fn longest_consecutive_precond (nums : & Vec < i32 >) -> bool { forall | i : int , j : int | 0 <= i < nums . len () && 0 <= j < nums . len () && i != j ==> nums [i] != nums [j] }\nfn longest_consecutive (nums : & Vec < i32 >) -> (result : usize)   { return 0 ; }\n\n} // verus!", "target_text": "requires longest_consecutive_precond (nums) \nensures longest_consecutive_postcond (nums , result as nat) ", "full_verified_code": "use vstd::prelude::*;\n\nverus! {\n\npub spec const MAX: int = i32::MAX as int;\npub spec const MIN: int = i32::MIN as int;\nspec fn longest_consecutive_postcond (nums : & Vec < i32 > , result : nat) -> bool { (nums . len () == 0 ==> result == 0) && result <= nums . len () }\nspec fn longest_consecutive_precond (nums : & Vec < i32 >) -> bool { forall | i : int , j : int | 0 <= i < nums . len () && 0 <= j < nums . len () && i != j ==> nums [i] != nums [j] }\nfn longest_consecutive (nums : & Vec < i32 >) -> (result : usize) requires longest_consecutive_precond (nums) , ensures longest_consecutive_postcond (nums , result as nat) , { return 0 ; }\n\n} // verus!", "source": "vericoding_ast", "source_file": "src/code_from_spec_on_09-08_09h27/verus/verus_specs/benches_no_bodies_20250809_091334/debug/verina/verina_advanced_28/verina_advanced_28_iter_0_original.rs", "verified": true, "metadata": {"original_id": "4e2998c1460f", "function_name": "longest_consecutive", "has_requires": true, "has_ensures": true, "has_invariants": false, "has_decreases": false}}
{"id": "task_b_vostd_cast_ptr_314976b92d91", "task": "task_b", "input_text": "fn to_repr(self) -> (res: R)\nrequires Self::wf(r), Self::wf(*r), Self::wf(r), old(perm).pptr() == self,\n            old(perm).is_init(),\n            old(perm).wf(), old(perm).pptr() == self,\n            old(perm).mem_contents() == MemContents::Uninit::<T>, perm.pptr() == self,\n            perm.is_init(),\n            perm.wf(), res == mem_contents_unwrap(arr),\n        is_mem_contents_all_init(arr), res == mem_contents_unwrap(arr),\n        is_mem_contents_all_uninit(arr), res == mem_contents_wrap(data), layout::size_of::<[V; N]>() > 0, old(perm).ptr() == ptr,\n        old(perm).is_uninit(index as int),\n        index < N, old(perm).ptr() == ptr,\n        old(perm).is_init(index as int),\n        index < N, old(perm).ptr() == ptr,\n        old(perm).is_init_all(), perm.ptr() == ptr,\n        perm.is_init(index as int), perm.ptr() == ptr,\n        perm.is_init_all(), self.wf(), old(self).wf(), layout::size_of::<[V; N]>() != 0,\n            layout::size_of::<[S; M]>() != 0, layout::size_of::<[V; N]>() > 0, layout::size_of::<[V; N]>() > 0, perm.wf(),\n            perm.pptr() == self,\n            perm.is_uninit_all(), old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_uninit(index as int),\n            index < N, old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init(index as int),\n            index < N, old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init_all(), perm.wf(),\n            perm.pptr() == self,\n            perm.is_init_all(), old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init(index as int),\n            index < N, perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            index < N, perm.wf(),\n            perm.pptr() == self,\n            perm.is_init_all(), old(perm).wf(),\n            old(perm).pptr() == self,\n            index < N, old(perm).wf(),\n            old(perm).pptr() == self,\n            index < N, perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            index < N\nensures u == self.addr, perm.pptr() == old(perm).pptr(),\n            perm.mem_contents() == MemContents::Uninit::<T>,\n            v == old(perm).value(), perm.pptr() == old(perm).pptr(),\n            perm.mem_contents() == MemContents::Init(v),\n            perm.wf(), *v === perm.value(), u == self.addr_spec(), self.addr() == self.pptr().addr(), res.is_init(),\n        forall|index: int| 0 <= index < N ==> #[trigger] res.value()[index] == arr[index].value(), res.is_uninit(), data.is_uninit() ==> is_mem_contents_all_uninit(res),\n        data.is_init() ==> is_mem_contents_all_init(res) && forall|index: int|\n            0 <= index < N ==> #[trigger] res[index].value() == data.value()[index], data.ptr == self.ptr,\n            data.opt_value == mem_contents_unwrap(self.value), res.ptr == data.ptr,\n            res.value == mem_contents_wrap(data.opt_value), self.ptr() == old(self).ptr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i], self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<[S; M]>() <= self.ptr() as int, self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<S>() <= self.ptr() as int, self@.ptr@.addr != 0, perm.ptr() == ptr,\n        perm.is_init(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind, perm.ptr() == ptr,\n        perm.is_uninit(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        res == old(perm).opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind, perm.ptr() == ptr,\n        perm.is_uninit_all(),\n        res@ == old(perm).value(),\n    opens_invariants none\n    no_unwind, res == perm.opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind, forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    opens_invariants none\n    no_unwind, res == self.addr, res.addr == addr, self.addr() != 0, self.wf(),\n            self.pptr() == old(self).pptr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i], self.addr() + layout::size_of::<[V; N]>() <= other.addr() || other.addr()\n                + layout::size_of::<[S; M]>() <= self.addr(), self.addr() != other.addr(), res.view().ptr == pt.view().ptr,\n            res.view().value == mem_contents_wrap(pt.view().opt_value), res.view().ptr == self.view().ptr,\n            res.view().opt_value == mem_contents_unwrap(self.view().value), res === *self, layout::valid_layout(\n            layout::size_of::<[V; N]>() as usize,\n            layout::align_of::<[V; N]>() as usize,\n        ),\n        layout::is_sized::<[V; N]>(),\n        layout::size_of::<[V; N]>() as usize as nat == layout::size_of::<[V; N]>(),\n        layout::align_of::<[V; N]>() as usize as nat == layout::align_of::<[V; N]>(),\n    opens_invariants none\n    no_unwind, res.1@.wf(),\n            res.1@.pptr() == res.0,\n            res.1@.is_uninit_all(), res.1@.wf(),\n            res.1@.pptr() == res.0,\n            forall|i: int|\n                0 <= i < N ==> #[trigger] res.1@.opt_value()[i] == raw_ptr::MemContents::Init(dft), perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value), perm.wf(),\n            perm.pptr() == self,\n            perm.is_uninit(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            res == old(perm).opt_value()[index as int].value(), perm.wf(),\n            perm.pptr() == self,\n            perm.is_uninit_all(),\n            res@ == old(perm).value(), res@ == perm.value(), perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n            res == old(perm).opt_value()[index as int].value(), res == perm.opt_value()[index as int].value(), forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(), perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value), perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value), res == perm.opt_value()[index as int].value(), res == self.to_repr_spec(),\n    ;\n\n    spec fn from_repr_spec(r: R) -> Self;\n\n    #[verifier::when_used_as_spec(from_repr_spec)]\n    fn from_repr(r: R) -> (res: Self)\n        requires\n            Self::wf(r),\n        ensures\n            res == Self::from_repr_spec(r),\n    ;\n\n    fn from_borrowed<'a>(r: &'a R) -> (res: &'a Self)\n        requires\n            Self::wf(*r),\n        ensures\n            *res == Self::from_repr_spec(*r),\n    ;\n\n    proof fn from_to_repr(self)\n        ensures\n            Self::from_repr(self.to_repr()) == self,\n    ;\n\n    proof fn to_from_repr(r: R)\n        requires\n            Self::wf(r),\n        ensures\n            Self::from_repr(r).to_repr() == r,\n    ;\n\n    proof fn to_repr_wf(self)\n        ensures\n            Self::wf(self.to_repr()),\n    ;\n}\n\n/// Concrete representation of a pointer to an array\n/// The length of the array is not stored in the pointer\npub struct ReprPtr<R, T: Repr<R>>, perm.ptr() == ptr,\n        perm.is_init_all(),\n        forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind, perm.wf(),\n            perm.pptr() == self,\n            perm.is_init_all(),\n            forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value)", "target_text": "use vstd::prelude::*;\n\nuse vstd::layout;\nuse vstd::raw_ptr::MemContents;\nuse vstd::set;\nuse vstd::set_lib;\nuse vstd::simple_pptr::{self, PPtr};\n\nuse core::marker::PhantomData;\n\nverus! {\n\npub trait Repr<R: Sized>: Sized {\n    spec fn wf(r: R) -> bool;\n\n    spec fn to_repr_spec(self) -> R;\n\n    #[verifier::when_used_as_spec(to_repr_spec)]\n    fn to_repr(self) -> (res: R)\n        ensures\n            res == self.to_repr_spec(),\n    ;\n\n    spec fn from_repr_spec(r: R) -> Self;\n\n    #[verifier::when_used_as_spec(from_repr_spec)]\n    fn from_repr(r: R) -> (res: Self)\n        requires\n            Self::wf(r),\n        ensures\n            res == Self::from_repr_spec(r),\n    ;\n\n    fn from_borrowed<'a>(r: &'a R) -> (res: &'a Self)\n        requires\n            Self::wf(*r),\n        ensures\n            *res == Self::from_repr_spec(*r),\n    ;\n\n    proof fn from_to_repr(self)\n        ensures\n            Self::from_repr(self.to_repr()) == self,\n    ;\n\n    proof fn to_from_repr(r: R)\n        requires\n            Self::wf(r),\n        ensures\n            Self::from_repr(r).to_repr() == r,\n    ;\n\n    proof fn to_repr_wf(self)\n        ensures\n            Self::wf(self.to_repr()),\n    ;\n}\n\n/// Concrete representation of a pointer to an array\n/// The length of the array is not stored in the pointer\npub struct ReprPtr<R, T: Repr<R>> {\n    pub addr: usize,\n    pub ptr: PPtr<R>,\n    pub _T: PhantomData<T>,\n}\n\nimpl<R, T: Repr<R>> Clone for ReprPtr<R, T> {\n    fn clone(&self) -> Self {\n        Self { addr: self.addr, ptr: self.ptr, _T: PhantomData }\n    }\n}\n\nimpl<R, T: Repr<R>> Copy for ReprPtr<R, T> {\n\n}\n\nimpl<R, T: Repr<R>> ReprPtr<R, T> {\n    pub open spec fn addr_spec(self) -> usize {\n        self.addr\n    }\n\n    #[verifier::when_used_as_spec(addr_spec)]\n    pub fn addr(self) -> (u: usize)\n        ensures\n            u == self.addr,\n    {\n        self.addr\n    }\n\n    pub exec fn take(self, Tracked(perm): Tracked<&mut PointsTo<R, T>>) -> (v: T)\n        requires\n            old(perm).pptr() == self,\n            old(perm).is_init(),\n            old(perm).wf(),\n        ensures\n            perm.pptr() == old(perm).pptr(),\n            perm.mem_contents() == MemContents::Uninit::<T>,\n            v == old(perm).value(),\n    {\n        proof {\n            T::from_to_repr(perm.value());\n        }\n        T::from_repr(self.ptr.take(Tracked(perm.points_to.borrow_mut())))\n    }\n\n    pub exec fn put(self, Tracked(perm): Tracked<&mut PointsTo<R, T>>, v: T)\n        requires\n            old(perm).pptr() == self,\n            old(perm).mem_contents() == MemContents::Uninit::<T>,\n        ensures\n            perm.pptr() == old(perm).pptr(),\n            perm.mem_contents() == MemContents::Init(v),\n            perm.wf(),\n    {\n        proof {\n            v.from_to_repr();\n            v.to_repr_wf();\n        }\n        self.ptr.put(Tracked(perm.points_to.borrow_mut()), v.to_repr())\n    }\n\n    pub exec fn borrow<'a>(self, Tracked(perm): Tracked<&'a PointsTo<R, T>>) -> (v: &'a T)\n        requires\n            perm.pptr() == self,\n            perm.is_init(),\n            perm.wf(),\n        ensures\n            *v === perm.value(),\n    {\n        T::from_borrowed(self.ptr.borrow(Tracked(perm.points_to.borrow())))\n    }\n}\n\n#[verifier::accept_recursive_types(T)]\npub tracked struct PointsTo<R, T: Repr<R>> {\n    pub addr: usize,\n    pub points_to: Tracked<simple_pptr::PointsTo<R>>,\n    pub _T: PhantomData<T>,\n}\n\nimpl<R, T: Repr<R>> PointsTo<R, T> {\n    pub fn new(addr: usize, points_to: Tracked<simple_pptr::PointsTo<R>>) -> Tracked<Self> {\n        Tracked(Self { addr: addr, points_to: points_to, _T: PhantomData })\n    }\n\n    pub closed spec fn wf(self) -> bool {\n        &&& T::wf(self.points_to@.value())\n    }\n\n    pub open spec fn addr_spec(self) -> usize {\n        self.addr\n    }\n\n    #[verifier::when_used_as_spec(addr_spec)]\n    pub fn addr(self) -> (u: usize)\n        ensures\n            u == self.addr_spec(),\n    {\n        self.addr\n    }\n\n    pub closed spec fn mem_contents(self) -> MemContents<T> {\n        match self.points_to@.mem_contents() {\n            MemContents::<R>::Uninit => MemContents::<T>::Uninit,\n            MemContents::<R>::Init(r) => MemContents::<T>::Init(T::from_repr(r)),\n        }\n    }\n\n    pub open spec fn is_init(self) -> bool {\n        self.mem_contents().is_init()\n    }\n\n    pub open spec fn is_uninit(self) -> bool {\n        self.mem_contents().is_uninit()\n    }\n\n    pub open spec fn value(self) -> T\n        recommends\n            self.is_init(),\n    {\n        self.mem_contents().value()\n    }\n\n    pub open spec fn pptr(self) -> ReprPtr<R, T> {\n        ReprPtr { addr: self.addr, ptr: self.points_to@.pptr(), _T: PhantomData }\n    }\n\n    pub broadcast proof fn pptr_implies_addr(&self)\n        ensures\n            self.addr() == self.pptr().addr(),\n    {\n    }\n}\n\n/*#[verifier::inline]\npub open spec fn is_mem_contents_all_init<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_init()\n}\n\n#[verifier::inline]\npub open spec fn is_mem_contents_all_uninit<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_uninit()\n}\n\npub open spec fn mem_contents_unwrap<V, const N: usize>(arr: [raw_ptr::MemContents<V>; N]) -> (res:\n    raw_ptr::MemContents<[V; N]>)\n    recommends\n        is_mem_contents_all_init(arr) || is_mem_contents_all_uninit(arr),\n;\n\npub open spec fn mem_contents_wrap<V, const N: usize>(data: raw_ptr::MemContents<[V; N]>) -> (res:\n    [raw_ptr::MemContents<V>; N]);\n\n#[verifier::external_body]\npub proof fn axiom_mem_contents_unwrap_init_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n    requires\n        res == mem_contents_unwrap(arr),\n        is_mem_contents_all_init(arr),\n    ensures\n        res.is_init(),\n        forall|index: int| 0 <= index < N ==> #[trigger] res.value()[index] == arr[index].value(),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn axiom_mem_contents_unwrap_uninit_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n    requires\n        res == mem_contents_unwrap(arr),\n        is_mem_contents_all_uninit(arr),\n    ensures\n        res.is_uninit(),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn axiom_mem_contents_wrap_correctness<V, const N: usize>(\n    data: raw_ptr::MemContents<[V; N]>,\n    res: [raw_ptr::MemContents<V>; N],\n)\n    requires\n        res == mem_contents_wrap(data),\n    ensures\n        data.is_uninit() ==> is_mem_contents_all_uninit(res),\n        data.is_init() ==> is_mem_contents_all_init(res) && forall|index: int|\n            0 <= index < N ==> #[trigger] res[index].value() == data.value()[index],\n{\n    unimplemented!();\n}\n\nimpl<V, const N: usize> PointsToArrayData<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked data: raw_ptr::PointsToData<[V; N]>)\n        ensures\n            data.ptr == self.ptr,\n            data.opt_value == mem_contents_unwrap(self.value),\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_array(tracked data: raw_ptr::PointsToData<[V; N]>) -> (tracked res:\n        PointsToArrayData<V, N>)\n        ensures\n            res.ptr == data.ptr,\n            res.value == mem_contents_wrap(data.opt_value),\n    {\n        unimplemented!();\n    }\n}\n\nimpl<T, const N: usize> View for PointsToArray<T, N> {\n    type V = PointsToArrayData<T, N>;\n\n    spec fn view(&self) -> Self::V;\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::inline]\n    pub open spec fn ptr(&self) -> *mut [V; N] {\n        self.view().ptr\n    }\n\n    #[verifier::inline]\n    pub open spec fn opt_value(&self) -> [raw_ptr::MemContents<V>; N] {\n        self.view().value\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(&self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_init()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(&self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_uninit()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(&self) -> bool {\n        is_mem_contents_all_init(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(&self) -> bool {\n        is_mem_contents_all_uninit(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn value(&self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        let opt_value = self.opt_value();\n        Seq::new(N as nat, |i: int| opt_value[i].value())\n    }\n\n    #[verifier::external_body]\n    pub proof fn leak_contents(tracked &mut self, index: int)\n        ensures\n            self.ptr() == old(self).ptr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i],\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsToArray<S, M>)\n        ensures\n            self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<[S; M]>() <= self.ptr() as int,\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint_ptr<S>(&self, other: &raw_ptr::PointsTo<S>)\n        ensures\n            self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<S>() <= self.ptr() as int,\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_nonnull(tracked &self)\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            self@.ptr@.addr != 0,\n    {\n        unimplemented!();\n    }\n}\n\n/// Reading and writing to an array of values\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_fill<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    value: V,\n) where V: Copy\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_uninit_all(),\n    ensures\n        perm.ptr() == ptr,\n        perm.is_init_all(),\n        forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind\n{\n    for i in 0..N {\n        unsafe {\n            core::ptr::write((ptr as *mut V).add(i), value);\n        }\n    }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_write_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n    value: V,\n)\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_uninit(index as int),\n        index < N,\n    ensures\n        perm.ptr() == ptr,\n        perm.is_init(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind\n{\n    unsafe {\n        core::ptr::write((ptr as *mut V).add(index), value);\n    }\n}\n\n/// Read only once and the value will be moved out side of the array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n) -> (res: V) where V: Copy\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_init(index as int),\n        index < N,\n    ensures\n        perm.ptr() == ptr,\n        perm.is_uninit(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        res == old(perm).opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { core::ptr::read((ptr as *const V).add(index)) }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_all<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n) -> (res: [V; N])\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_init_all(),\n    ensures\n        perm.ptr() == ptr,\n        perm.is_uninit_all(),\n        res@ == old(perm).value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { core::ptr::read(ptr) }\n}\n\n/// Get the immutable reference of the value at the index\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n    index: usize,\n) -> (res: &V)\n    requires\n        perm.ptr() == ptr,\n        perm.is_init(index as int),\n    ensures\n        res == perm.opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { &*((ptr as *const V).add(index)) }\n}\n\n/// Get the immutable reference of the entire array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n) -> (res: &[V; N])\n    requires\n        perm.ptr() == ptr,\n        perm.is_init_all(),\n    ensures\n        forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { &*ptr }\n}\n\n/// Permission to access an array of values\npub tracked struct PointsTo<V, const N: usize> {\n    points_to: PointsToArray<V, N>,\n    exposed: raw_ptr::IsExposed,\n    dealloc: Option<raw_ptr::Dealloc>,\n}\n\n#[verusfmt::skip]\nbroadcast use\n    raw_ptr::group_raw_ptr_axioms,\n//    set_lib::group_set_lib_axioms,\n    set::group_set_axioms;\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    /// Spec: cast the pointer to an integer\n    #[verifier::inline]\n    pub open spec fn addr_spec(&self) -> usize {\n        self.addr\n    }\n\n    /// Impl: cast the pointer to an integer\n    #[inline(always)]\n    #[verifier::when_used_as_spec(addr_spec)]\n    pub exec fn addr(&self) -> (res: usize)\n        ensures\n            res == self.addr,\n    {\n        self.addr\n    }\n\n    /// Impl: cast an integer to the pointer\n    #[inline(always)]\n    pub exec fn from_addr(addr: usize) -> (res: Self)\n        ensures\n            res.addr == addr,\n    {\n        Self { addr, _type: PhantomData }\n    }\n}\n\nimpl<V, const N: usize> PointsTo<V, N> {\n    /// Spec: cast the permission to an integer\n    pub closed spec fn addr(&self) -> usize {\n        self.points_to.ptr()@.addr\n    }\n\n    /// Spec: cast the permission to a pointer\n    pub open spec fn pptr(&self) -> ArrayPtr<V, N> {\n        ArrayPtr { addr: self.addr(), _type: PhantomData }\n    }\n\n    /// Spec: invariants for the ArrayPtr permissions\n    /// TODO: uncomment the below if \"external_type_specification: Const params not yet supported\" is fixed\n    /// #[verifier::type_invariant]\n    pub closed spec fn wf(&self) -> bool {\n        /// The pointer is not a slice, so it is still thin\n        &&& self.points_to.ptr()@.metadata == ()\n        &&& self.points_to.ptr()@.provenance == self.exposed.provenance()\n        &&& match self.dealloc {\n            Some(dealloc) => {\n                &&& dealloc.addr() == self.addr()\n                &&& dealloc.size() == layout::size_of::<[V; N]>()\n                &&& dealloc.align() == layout::align_of::<[V; N]>()\n                &&& dealloc.provenance() == self.exposed.provenance()\n                &&& layout::size_of::<[V; N]>() > 0\n            },\n            None => { layout::size_of::<[V; N]>() == 0 },\n        }\n        &&& self.addr() != 0\n    }\n\n    pub closed spec fn points_to(&self) -> PointsToArray<V, N> {\n        self.points_to\n    }\n\n    pub open spec fn opt_value(&self) -> [raw_ptr::MemContents<V>; N] {\n        self.points_to().opt_value()\n    }\n\n    pub open spec fn value(&self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        self.points_to().value()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(&self, index: int) -> bool {\n        self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(&self, index: int) -> bool {\n        !self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(&self) -> bool {\n        self.points_to().is_init_all()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(&self) -> bool {\n        self.points_to().is_uninit_all()\n    }\n\n    pub proof fn is_nonnull(tracked self)\n        requires\n            self.wf(),\n        ensures\n            self.addr() != 0,\n    {\n        self.wf();\n    }\n\n    pub proof fn leak_contents(tracked &mut self, index: int)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n            self.pptr() == old(self).pptr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i],\n    {\n        self.wf();\n        self.points_to.leak_contents(index);\n    }\n\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsTo<S, M>)\n        ensures\n            self.addr() + layout::size_of::<[V; N]>() <= other.addr() || other.addr()\n                + layout::size_of::<[S; M]>() <= self.addr(),\n    {\n        self.points_to.is_disjoint(&other.points_to)\n    }\n\n    pub proof fn is_distinct<S, const M: usize>(&self, other: &PointsTo<S, M>)\n        requires\n            layout::size_of::<[V; N]>() != 0,\n            layout::size_of::<[S; M]>() != 0,\n        ensures\n            self.addr() != other.addr(),\n    {\n        self.points_to.is_disjoint(&other.points_to);\n    }\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_array(tracked pt: raw_ptr::PointsTo<[V; N]>) -> (tracked res: PointsToArray<\n        V,\n        N,\n    >)\n        ensures\n            res.view().ptr == pt.view().ptr,\n            res.view().value == mem_contents_wrap(pt.view().opt_value),\n    {\n        Tracked::<PointsToArray<V, N>>::assume_new().get()\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked res: raw_ptr::PointsTo<[V; N]>)\n        ensures\n            res.view().ptr == self.view().ptr,\n            res.view().opt_value == mem_contents_unwrap(self.view().value),\n    {\n        Tracked::<raw_ptr::PointsTo<[V; N]>>::assume_new().get()\n    }\n}\n\nimpl<V, const N: usize> Clone for ArrayPtr<V, N> {\n    fn clone(&self) -> (res: Self)\n        ensures\n            res === *self,\n    {\n        Self { ..*self }\n    }\n}\n\nimpl<V, const N: usize> Copy for ArrayPtr<V, N> {\n\n}\n\n#[verifier::external_body]\n#[inline(always)]\npub exec fn layout_for_array_is_valid<V, const N: usize>()\n    ensures\n        layout::valid_layout(\n            layout::size_of::<[V; N]>() as usize,\n            layout::align_of::<[V; N]>() as usize,\n        ),\n        layout::is_sized::<[V; N]>(),\n        layout::size_of::<[V; N]>() as usize as nat == layout::size_of::<[V; N]>(),\n        layout::align_of::<[V; N]>() as usize as nat == layout::align_of::<[V; N]>(),\n    opens_invariants none\n    no_unwind\n{\n}\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    pub exec fn empty() -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>))\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            res.1@.wf(),\n            res.1@.pptr() == res.0,\n            res.1@.is_uninit_all(),\n    {\n        layout_for_array_is_valid::<V, N>();\n        let (p, Tracked(raw_perm), Tracked(dealloc)) = raw_ptr::allocate(\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n        );\n        let Tracked(exposed) = raw_ptr::expose_provenance(p);\n        let tracked ptr_perm = raw_perm.into_typed::<[V; N]>(p as usize);\n        proof {\n            ptr_perm.is_nonnull();\n            assert(ptr_perm.is_uninit());\n        }\n\n        let tracked arr_perm = PointsToArray::into_array(ptr_perm);\n        proof {\n            arr_perm.is_nonnull();\n            axiom_mem_contents_wrap_correctness(ptr_perm.opt_value(), arr_perm.view().value);\n            assert(arr_perm.is_uninit_all());\n        }\n        let tracked pt = PointsTo { points_to: arr_perm, exposed, dealloc: Some(dealloc) };\n        proof {\n            assert(pt.is_uninit_all());\n        }\n        let ptr = ArrayPtr { addr: p as usize, _type: PhantomData };\n        (ptr, Tracked(pt))\n    }\n\n    #[inline(always)]\n    pub exec fn make_as(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, value: V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_uninit_all(),\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init_all(),\n            forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit_all());\n        ptr_mut_fill(ptr, Tracked(&mut perm.points_to), value);\n    }\n\n    pub exec fn new(dft: V) -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>)) where V: Copy\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            res.1@.wf(),\n            res.1@.pptr() == res.0,\n            forall|i: int|\n                0 <= i < N ==> #[trigger] res.1@.opt_value()[i] == raw_ptr::MemContents::Init(dft),\n    {\n        let (p, Tracked(perm)) = ArrayPtr::empty();\n        proof {\n            assert(perm.wf());\n            assert(perm.pptr() == p);\n            assert(perm.is_uninit_all());\n        }\n        p.make_as(Tracked(&mut perm), dft);\n        (p, Tracked(perm))\n    }\n\n    pub exec fn free(self, Tracked(perm): Tracked<PointsTo<V, N>>)\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_uninit_all(),\n    {\n        if core::mem::size_of::<[V; N]>() == 0 {\n            return ;\n        }\n        assert(core::mem::size_of::<[V; N]>() > 0);\n        let ptr: *mut u8 = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n        let tracked PointsTo { points_to, dealloc: dea, exposed } = perm;\n\n        proof {\n            assert(perm.is_uninit_all());\n            assert(points_to.is_uninit_all());\n        }\n        let tracked perm_ptr: raw_ptr::PointsTo<[V; N]> = points_to.into_ptr();\n        proof {\n            axiom_mem_contents_unwrap_uninit_correctness(\n                points_to.view().value,\n                perm_ptr.opt_value(),\n            );\n            assert(perm_ptr.is_uninit());\n        }\n        let tracked perm_raw = perm_ptr.into_raw();\n\n        raw_ptr::deallocate(\n            ptr,\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n            Tracked(perm_raw),\n            Tracked(dea.tracked_unwrap()),\n        );\n    }\n\n    /// Insert `value` at `index`\n    /// The value is moved into the array.\n    /// Requires the slot at `index` to be uninitialized.\n    #[inline(always)]\n    pub exec fn insert(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, index: usize, value: V)\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_uninit(index as int),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit(index as int));\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n    }\n\n    /// Take the `value` at `index`\n    /// The value is moved out of the array.\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is uninitialized.\n    #[inline(always)]\n    pub exec fn take_at(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, index: usize) -> (res:\n        V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init(index as int),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_uninit(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            res == old(perm).opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), index)\n    }\n\n    /// Take all the values of the array\n    /// The values are moved out of the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn take_all(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>) -> (res: [V; N])\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init_all(),\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_uninit_all(),\n            res@ == old(perm).value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_mut_read_all(ptr, Tracked(&mut perm.points_to))\n    }\n\n    /// Free the memory of the entire array and return the value\n    /// that was previously stored in the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn into_inner(self, Tracked(perm): Tracked<PointsTo<V, N>>) -> (res: [V; N])\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init_all(),\n        ensures\n            res@ == perm.value(),\n    {\n        let tracked mut perm = perm;\n        let res = self.take_all(Tracked(&mut perm));\n        self.free(Tracked(perm));\n        res\n    }\n\n    /// Update the value at `index` with `value` and return the previous value\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is initialized with `value`.\n    /// Returns the previous value.\n    #[inline(always)]\n    pub exec fn update(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    ) -> (res: V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init(index as int),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n            res == old(perm).opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        let res = ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), index);\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n        res\n    }\n\n    /// Get the reference of the value at `index`\n    /// Borrow the immutable reference of the value at `index`\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    /// Returns the immutable reference of the value.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow_at<'a>(\n        &self,\n        Tracked(perm): Tracked<&'a PointsTo<V, N>>,\n        index: usize,\n    ) -> (res: &'a V)\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            index < N,\n        ensures\n            res == perm.opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        ptr_ref_at(ptr, Tracked(&perm.points_to), index)\n    }\n\n    /// Get the reference of the entire array\n    /// Borrow the immutable reference of the entire array\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are still initialized.\n    /// Returns the immutable reference of the entire array.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow<'a>(&self, Tracked(perm): Tracked<&'a PointsTo<V, N>>) -> (res: &'a [V; N])\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init_all(),\n        ensures\n            forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_ref(ptr, Tracked(&perm.points_to))\n    }\n\n    /// Overwrite the entry at `index` with `value`\n    /// The pervious value will be leaked if it was initialized.\n    #[inline(always)]\n    pub exec fn overwrite(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    )\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    {\n        proof {\n            perm.leak_contents(index as int);\n        }\n        assert(perm.is_uninit(index as int));\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n    }\n\n    #[verifier::external_body]\n    pub proof fn tracked_overwrite(\n        tracked &self,\n        tracked perm: &mut PointsTo<V, N>,\n        tracked index: usize,\n        tracked value: V,\n    )\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    {\n        self.overwrite(Tracked(perm), index, value);\n    }\n\n    /// Get the value at `index` and return it\n    /// The value is copied from the array\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    #[inline(always)]\n    pub exec fn get(&self, Tracked(perm): Tracked<&PointsTo<V, N>>, index: usize) -> (res: V) where\n        V: Copy,\n\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            index < N,\n        ensures\n            res == perm.opt_value()[index as int].value(),\n    {\n        *self.borrow_at(Tracked(perm), index)\n    }\n}\n*/\n} // verus!\n", "full_verified_code": "use vstd::prelude::*;\n\nuse vstd::layout;\nuse vstd::raw_ptr::MemContents;\nuse vstd::set;\nuse vstd::set_lib;\nuse vstd::simple_pptr::{self, PPtr};\n\nuse core::marker::PhantomData;\n\nverus! {\n\npub trait Repr<R: Sized>: Sized {\n    spec fn wf(r: R) -> bool;\n\n    spec fn to_repr_spec(self) -> R;\n\n    #[verifier::when_used_as_spec(to_repr_spec)]\n    fn to_repr(self) -> (res: R)\n        ensures\n            res == self.to_repr_spec(),\n    ;\n\n    spec fn from_repr_spec(r: R) -> Self;\n\n    #[verifier::when_used_as_spec(from_repr_spec)]\n    fn from_repr(r: R) -> (res: Self)\n        requires\n            Self::wf(r),\n        ensures\n            res == Self::from_repr_spec(r),\n    ;\n\n    fn from_borrowed<'a>(r: &'a R) -> (res: &'a Self)\n        requires\n            Self::wf(*r),\n        ensures\n            *res == Self::from_repr_spec(*r),\n    ;\n\n    proof fn from_to_repr(self)\n        ensures\n            Self::from_repr(self.to_repr()) == self,\n    ;\n\n    proof fn to_from_repr(r: R)\n        requires\n            Self::wf(r),\n        ensures\n            Self::from_repr(r).to_repr() == r,\n    ;\n\n    proof fn to_repr_wf(self)\n        ensures\n            Self::wf(self.to_repr()),\n    ;\n}\n\n/// Concrete representation of a pointer to an array\n/// The length of the array is not stored in the pointer\npub struct ReprPtr<R, T: Repr<R>> {\n    pub addr: usize,\n    pub ptr: PPtr<R>,\n    pub _T: PhantomData<T>,\n}\n\nimpl<R, T: Repr<R>> Clone for ReprPtr<R, T> {\n    fn clone(&self) -> Self {\n        Self { addr: self.addr, ptr: self.ptr, _T: PhantomData }\n    }\n}\n\nimpl<R, T: Repr<R>> Copy for ReprPtr<R, T> {\n\n}\n\nimpl<R, T: Repr<R>> ReprPtr<R, T> {\n    pub open spec fn addr_spec(self) -> usize {\n        self.addr\n    }\n\n    #[verifier::when_used_as_spec(addr_spec)]\n    pub fn addr(self) -> (u: usize)\n        ensures\n            u == self.addr,\n    {\n        self.addr\n    }\n\n    pub exec fn take(self, Tracked(perm): Tracked<&mut PointsTo<R, T>>) -> (v: T)\n        requires\n            old(perm).pptr() == self,\n            old(perm).is_init(),\n            old(perm).wf(),\n        ensures\n            perm.pptr() == old(perm).pptr(),\n            perm.mem_contents() == MemContents::Uninit::<T>,\n            v == old(perm).value(),\n    {\n        proof {\n            T::from_to_repr(perm.value());\n        }\n        T::from_repr(self.ptr.take(Tracked(perm.points_to.borrow_mut())))\n    }\n\n    pub exec fn put(self, Tracked(perm): Tracked<&mut PointsTo<R, T>>, v: T)\n        requires\n            old(perm).pptr() == self,\n            old(perm).mem_contents() == MemContents::Uninit::<T>,\n        ensures\n            perm.pptr() == old(perm).pptr(),\n            perm.mem_contents() == MemContents::Init(v),\n            perm.wf(),\n    {\n        proof {\n            v.from_to_repr();\n            v.to_repr_wf();\n        }\n        self.ptr.put(Tracked(perm.points_to.borrow_mut()), v.to_repr())\n    }\n\n    pub exec fn borrow<'a>(self, Tracked(perm): Tracked<&'a PointsTo<R, T>>) -> (v: &'a T)\n        requires\n            perm.pptr() == self,\n            perm.is_init(),\n            perm.wf(),\n        ensures\n            *v === perm.value(),\n    {\n        T::from_borrowed(self.ptr.borrow(Tracked(perm.points_to.borrow())))\n    }\n}\n\n#[verifier::accept_recursive_types(T)]\npub tracked struct PointsTo<R, T: Repr<R>> {\n    pub addr: usize,\n    pub points_to: Tracked<simple_pptr::PointsTo<R>>,\n    pub _T: PhantomData<T>,\n}\n\nimpl<R, T: Repr<R>> PointsTo<R, T> {\n    pub fn new(addr: usize, points_to: Tracked<simple_pptr::PointsTo<R>>) -> Tracked<Self> {\n        Tracked(Self { addr: addr, points_to: points_to, _T: PhantomData })\n    }\n\n    pub closed spec fn wf(self) -> bool {\n        &&& T::wf(self.points_to@.value())\n    }\n\n    pub open spec fn addr_spec(self) -> usize {\n        self.addr\n    }\n\n    #[verifier::when_used_as_spec(addr_spec)]\n    pub fn addr(self) -> (u: usize)\n        ensures\n            u == self.addr_spec(),\n    {\n        self.addr\n    }\n\n    pub closed spec fn mem_contents(self) -> MemContents<T> {\n        match self.points_to@.mem_contents() {\n            MemContents::<R>::Uninit => MemContents::<T>::Uninit,\n            MemContents::<R>::Init(r) => MemContents::<T>::Init(T::from_repr(r)),\n        }\n    }\n\n    pub open spec fn is_init(self) -> bool {\n        self.mem_contents().is_init()\n    }\n\n    pub open spec fn is_uninit(self) -> bool {\n        self.mem_contents().is_uninit()\n    }\n\n    pub open spec fn value(self) -> T\n        recommends\n            self.is_init(),\n    {\n        self.mem_contents().value()\n    }\n\n    pub open spec fn pptr(self) -> ReprPtr<R, T> {\n        ReprPtr { addr: self.addr, ptr: self.points_to@.pptr(), _T: PhantomData }\n    }\n\n    pub broadcast proof fn pptr_implies_addr(&self)\n        ensures\n            self.addr() == self.pptr().addr(),\n    {\n    }\n}\n\n/*#[verifier::inline]\npub open spec fn is_mem_contents_all_init<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_init()\n}\n\n#[verifier::inline]\npub open spec fn is_mem_contents_all_uninit<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n) -> bool {\n    forall|index: int| 0 <= index < N ==> #[trigger] arr[index].is_uninit()\n}\n\npub open spec fn mem_contents_unwrap<V, const N: usize>(arr: [raw_ptr::MemContents<V>; N]) -> (res:\n    raw_ptr::MemContents<[V; N]>)\n    recommends\n        is_mem_contents_all_init(arr) || is_mem_contents_all_uninit(arr),\n;\n\npub open spec fn mem_contents_wrap<V, const N: usize>(data: raw_ptr::MemContents<[V; N]>) -> (res:\n    [raw_ptr::MemContents<V>; N]);\n\n#[verifier::external_body]\npub proof fn axiom_mem_contents_unwrap_init_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n    requires\n        res == mem_contents_unwrap(arr),\n        is_mem_contents_all_init(arr),\n    ensures\n        res.is_init(),\n        forall|index: int| 0 <= index < N ==> #[trigger] res.value()[index] == arr[index].value(),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn axiom_mem_contents_unwrap_uninit_correctness<V, const N: usize>(\n    arr: [raw_ptr::MemContents<V>; N],\n    res: raw_ptr::MemContents<[V; N]>,\n)\n    requires\n        res == mem_contents_unwrap(arr),\n        is_mem_contents_all_uninit(arr),\n    ensures\n        res.is_uninit(),\n{\n    unimplemented!();\n}\n\n#[verifier::external_body]\npub proof fn axiom_mem_contents_wrap_correctness<V, const N: usize>(\n    data: raw_ptr::MemContents<[V; N]>,\n    res: [raw_ptr::MemContents<V>; N],\n)\n    requires\n        res == mem_contents_wrap(data),\n    ensures\n        data.is_uninit() ==> is_mem_contents_all_uninit(res),\n        data.is_init() ==> is_mem_contents_all_init(res) && forall|index: int|\n            0 <= index < N ==> #[trigger] res[index].value() == data.value()[index],\n{\n    unimplemented!();\n}\n\nimpl<V, const N: usize> PointsToArrayData<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked data: raw_ptr::PointsToData<[V; N]>)\n        ensures\n            data.ptr == self.ptr,\n            data.opt_value == mem_contents_unwrap(self.value),\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_array(tracked data: raw_ptr::PointsToData<[V; N]>) -> (tracked res:\n        PointsToArrayData<V, N>)\n        ensures\n            res.ptr == data.ptr,\n            res.value == mem_contents_wrap(data.opt_value),\n    {\n        unimplemented!();\n    }\n}\n\nimpl<T, const N: usize> View for PointsToArray<T, N> {\n    type V = PointsToArrayData<T, N>;\n\n    spec fn view(&self) -> Self::V;\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::inline]\n    pub open spec fn ptr(&self) -> *mut [V; N] {\n        self.view().ptr\n    }\n\n    #[verifier::inline]\n    pub open spec fn opt_value(&self) -> [raw_ptr::MemContents<V>; N] {\n        self.view().value\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(&self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_init()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(&self, index: int) -> bool {\n        0 <= index < N && self.opt_value()[index].is_uninit()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(&self) -> bool {\n        is_mem_contents_all_init(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(&self) -> bool {\n        is_mem_contents_all_uninit(self.opt_value())\n    }\n\n    #[verifier::inline]\n    pub open spec fn value(&self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        let opt_value = self.opt_value();\n        Seq::new(N as nat, |i: int| opt_value[i].value())\n    }\n\n    #[verifier::external_body]\n    pub proof fn leak_contents(tracked &mut self, index: int)\n        ensures\n            self.ptr() == old(self).ptr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i],\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsToArray<S, M>)\n        ensures\n            self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<[S; M]>() <= self.ptr() as int,\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_disjoint_ptr<S>(&self, other: &raw_ptr::PointsTo<S>)\n        ensures\n            self.ptr() as int + layout::size_of::<[V; N]>() <= other.ptr() as int\n                || other.ptr() as int + layout::size_of::<S>() <= self.ptr() as int,\n    {\n        unimplemented!();\n    }\n\n    #[verifier::external_body]\n    pub proof fn is_nonnull(tracked &self)\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            self@.ptr@.addr != 0,\n    {\n        unimplemented!();\n    }\n}\n\n/// Reading and writing to an array of values\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_fill<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    value: V,\n) where V: Copy\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_uninit_all(),\n    ensures\n        perm.ptr() == ptr,\n        perm.is_init_all(),\n        forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind\n{\n    for i in 0..N {\n        unsafe {\n            core::ptr::write((ptr as *mut V).add(i), value);\n        }\n    }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_write_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n    value: V,\n)\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_uninit(index as int),\n        index < N,\n    ensures\n        perm.ptr() == ptr,\n        perm.is_init(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    opens_invariants none\n    no_unwind\n{\n    unsafe {\n        core::ptr::write((ptr as *mut V).add(index), value);\n    }\n}\n\n/// Read only once and the value will be moved out side of the array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n    index: usize,\n) -> (res: V) where V: Copy\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_init(index as int),\n        index < N,\n    ensures\n        perm.ptr() == ptr,\n        perm.is_uninit(index as int),\n        forall|i: int| 0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n        res == old(perm).opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { core::ptr::read((ptr as *const V).add(index)) }\n}\n\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_mut_read_all<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&mut PointsToArray<V, N>>,\n) -> (res: [V; N])\n    requires\n        old(perm).ptr() == ptr,\n        old(perm).is_init_all(),\n    ensures\n        perm.ptr() == ptr,\n        perm.is_uninit_all(),\n        res@ == old(perm).value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { core::ptr::read(ptr) }\n}\n\n/// Get the immutable reference of the value at the index\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref_at<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n    index: usize,\n) -> (res: &V)\n    requires\n        perm.ptr() == ptr,\n        perm.is_init(index as int),\n    ensures\n        res == perm.opt_value()[index as int].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { &*((ptr as *const V).add(index)) }\n}\n\n/// Get the immutable reference of the entire array\n#[inline(always)]\n#[verifier::external_body]\npub exec fn ptr_ref<V, const N: usize>(\n    ptr: *mut [V; N],\n    Tracked(perm): Tracked<&PointsToArray<V, N>>,\n) -> (res: &[V; N])\n    requires\n        perm.ptr() == ptr,\n        perm.is_init_all(),\n    ensures\n        forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    opens_invariants none\n    no_unwind\n{\n    unsafe { &*ptr }\n}\n\n/// Permission to access an array of values\npub tracked struct PointsTo<V, const N: usize> {\n    points_to: PointsToArray<V, N>,\n    exposed: raw_ptr::IsExposed,\n    dealloc: Option<raw_ptr::Dealloc>,\n}\n\n#[verusfmt::skip]\nbroadcast use\n    raw_ptr::group_raw_ptr_axioms,\n//    set_lib::group_set_lib_axioms,\n    set::group_set_axioms;\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    /// Spec: cast the pointer to an integer\n    #[verifier::inline]\n    pub open spec fn addr_spec(&self) -> usize {\n        self.addr\n    }\n\n    /// Impl: cast the pointer to an integer\n    #[inline(always)]\n    #[verifier::when_used_as_spec(addr_spec)]\n    pub exec fn addr(&self) -> (res: usize)\n        ensures\n            res == self.addr,\n    {\n        self.addr\n    }\n\n    /// Impl: cast an integer to the pointer\n    #[inline(always)]\n    pub exec fn from_addr(addr: usize) -> (res: Self)\n        ensures\n            res.addr == addr,\n    {\n        Self { addr, _type: PhantomData }\n    }\n}\n\nimpl<V, const N: usize> PointsTo<V, N> {\n    /// Spec: cast the permission to an integer\n    pub closed spec fn addr(&self) -> usize {\n        self.points_to.ptr()@.addr\n    }\n\n    /// Spec: cast the permission to a pointer\n    pub open spec fn pptr(&self) -> ArrayPtr<V, N> {\n        ArrayPtr { addr: self.addr(), _type: PhantomData }\n    }\n\n    /// Spec: invariants for the ArrayPtr permissions\n    /// TODO: uncomment the below if \"external_type_specification: Const params not yet supported\" is fixed\n    /// #[verifier::type_invariant]\n    pub closed spec fn wf(&self) -> bool {\n        /// The pointer is not a slice, so it is still thin\n        &&& self.points_to.ptr()@.metadata == ()\n        &&& self.points_to.ptr()@.provenance == self.exposed.provenance()\n        &&& match self.dealloc {\n            Some(dealloc) => {\n                &&& dealloc.addr() == self.addr()\n                &&& dealloc.size() == layout::size_of::<[V; N]>()\n                &&& dealloc.align() == layout::align_of::<[V; N]>()\n                &&& dealloc.provenance() == self.exposed.provenance()\n                &&& layout::size_of::<[V; N]>() > 0\n            },\n            None => { layout::size_of::<[V; N]>() == 0 },\n        }\n        &&& self.addr() != 0\n    }\n\n    pub closed spec fn points_to(&self) -> PointsToArray<V, N> {\n        self.points_to\n    }\n\n    pub open spec fn opt_value(&self) -> [raw_ptr::MemContents<V>; N] {\n        self.points_to().opt_value()\n    }\n\n    pub open spec fn value(&self) -> Seq<V>\n        recommends\n            self.is_init_all(),\n    {\n        self.points_to().value()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init(&self, index: int) -> bool {\n        self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit(&self, index: int) -> bool {\n        !self.points_to().is_init(index)\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_init_all(&self) -> bool {\n        self.points_to().is_init_all()\n    }\n\n    #[verifier::inline]\n    pub open spec fn is_uninit_all(&self) -> bool {\n        self.points_to().is_uninit_all()\n    }\n\n    pub proof fn is_nonnull(tracked self)\n        requires\n            self.wf(),\n        ensures\n            self.addr() != 0,\n    {\n        self.wf();\n    }\n\n    pub proof fn leak_contents(tracked &mut self, index: int)\n        requires\n            old(self).wf(),\n        ensures\n            self.wf(),\n            self.pptr() == old(self).pptr(),\n            self.is_uninit(index),\n            forall|i: int|\n                0 <= i < N && i != index ==> self.opt_value()[i] == old(self).opt_value()[i],\n    {\n        self.wf();\n        self.points_to.leak_contents(index);\n    }\n\n    pub proof fn is_disjoint<S, const M: usize>(&self, other: &PointsTo<S, M>)\n        ensures\n            self.addr() + layout::size_of::<[V; N]>() <= other.addr() || other.addr()\n                + layout::size_of::<[S; M]>() <= self.addr(),\n    {\n        self.points_to.is_disjoint(&other.points_to)\n    }\n\n    pub proof fn is_distinct<S, const M: usize>(&self, other: &PointsTo<S, M>)\n        requires\n            layout::size_of::<[V; N]>() != 0,\n            layout::size_of::<[S; M]>() != 0,\n        ensures\n            self.addr() != other.addr(),\n    {\n        self.points_to.is_disjoint(&other.points_to);\n    }\n}\n\nimpl<V, const N: usize> PointsToArray<V, N> {\n    #[verifier::external_body]\n    pub proof fn into_array(tracked pt: raw_ptr::PointsTo<[V; N]>) -> (tracked res: PointsToArray<\n        V,\n        N,\n    >)\n        ensures\n            res.view().ptr == pt.view().ptr,\n            res.view().value == mem_contents_wrap(pt.view().opt_value),\n    {\n        Tracked::<PointsToArray<V, N>>::assume_new().get()\n    }\n\n    #[verifier::external_body]\n    pub proof fn into_ptr(tracked self) -> (tracked res: raw_ptr::PointsTo<[V; N]>)\n        ensures\n            res.view().ptr == self.view().ptr,\n            res.view().opt_value == mem_contents_unwrap(self.view().value),\n    {\n        Tracked::<raw_ptr::PointsTo<[V; N]>>::assume_new().get()\n    }\n}\n\nimpl<V, const N: usize> Clone for ArrayPtr<V, N> {\n    fn clone(&self) -> (res: Self)\n        ensures\n            res === *self,\n    {\n        Self { ..*self }\n    }\n}\n\nimpl<V, const N: usize> Copy for ArrayPtr<V, N> {\n\n}\n\n#[verifier::external_body]\n#[inline(always)]\npub exec fn layout_for_array_is_valid<V, const N: usize>()\n    ensures\n        layout::valid_layout(\n            layout::size_of::<[V; N]>() as usize,\n            layout::align_of::<[V; N]>() as usize,\n        ),\n        layout::is_sized::<[V; N]>(),\n        layout::size_of::<[V; N]>() as usize as nat == layout::size_of::<[V; N]>(),\n        layout::align_of::<[V; N]>() as usize as nat == layout::align_of::<[V; N]>(),\n    opens_invariants none\n    no_unwind\n{\n}\n\nimpl<V, const N: usize> ArrayPtr<V, N> {\n    pub exec fn empty() -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>))\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            res.1@.wf(),\n            res.1@.pptr() == res.0,\n            res.1@.is_uninit_all(),\n    {\n        layout_for_array_is_valid::<V, N>();\n        let (p, Tracked(raw_perm), Tracked(dealloc)) = raw_ptr::allocate(\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n        );\n        let Tracked(exposed) = raw_ptr::expose_provenance(p);\n        let tracked ptr_perm = raw_perm.into_typed::<[V; N]>(p as usize);\n        proof {\n            ptr_perm.is_nonnull();\n            assert(ptr_perm.is_uninit());\n        }\n\n        let tracked arr_perm = PointsToArray::into_array(ptr_perm);\n        proof {\n            arr_perm.is_nonnull();\n            axiom_mem_contents_wrap_correctness(ptr_perm.opt_value(), arr_perm.view().value);\n            assert(arr_perm.is_uninit_all());\n        }\n        let tracked pt = PointsTo { points_to: arr_perm, exposed, dealloc: Some(dealloc) };\n        proof {\n            assert(pt.is_uninit_all());\n        }\n        let ptr = ArrayPtr { addr: p as usize, _type: PhantomData };\n        (ptr, Tracked(pt))\n    }\n\n    #[inline(always)]\n    pub exec fn make_as(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, value: V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_uninit_all(),\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init_all(),\n            forall|i: int| 0 <= i < N ==> perm.opt_value()[i] == raw_ptr::MemContents::Init(value),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit_all());\n        ptr_mut_fill(ptr, Tracked(&mut perm.points_to), value);\n    }\n\n    pub exec fn new(dft: V) -> (res: (ArrayPtr<V, N>, Tracked<PointsTo<V, N>>)) where V: Copy\n        requires\n            layout::size_of::<[V; N]>() > 0,\n        ensures\n            res.1@.wf(),\n            res.1@.pptr() == res.0,\n            forall|i: int|\n                0 <= i < N ==> #[trigger] res.1@.opt_value()[i] == raw_ptr::MemContents::Init(dft),\n    {\n        let (p, Tracked(perm)) = ArrayPtr::empty();\n        proof {\n            assert(perm.wf());\n            assert(perm.pptr() == p);\n            assert(perm.is_uninit_all());\n        }\n        p.make_as(Tracked(&mut perm), dft);\n        (p, Tracked(perm))\n    }\n\n    pub exec fn free(self, Tracked(perm): Tracked<PointsTo<V, N>>)\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_uninit_all(),\n    {\n        if core::mem::size_of::<[V; N]>() == 0 {\n            return ;\n        }\n        assert(core::mem::size_of::<[V; N]>() > 0);\n        let ptr: *mut u8 = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n        let tracked PointsTo { points_to, dealloc: dea, exposed } = perm;\n\n        proof {\n            assert(perm.is_uninit_all());\n            assert(points_to.is_uninit_all());\n        }\n        let tracked perm_ptr: raw_ptr::PointsTo<[V; N]> = points_to.into_ptr();\n        proof {\n            axiom_mem_contents_unwrap_uninit_correctness(\n                points_to.view().value,\n                perm_ptr.opt_value(),\n            );\n            assert(perm_ptr.is_uninit());\n        }\n        let tracked perm_raw = perm_ptr.into_raw();\n\n        raw_ptr::deallocate(\n            ptr,\n            core::mem::size_of::<[V; N]>(),\n            core::mem::align_of::<[V; N]>(),\n            Tracked(perm_raw),\n            Tracked(dea.tracked_unwrap()),\n        );\n    }\n\n    /// Insert `value` at `index`\n    /// The value is moved into the array.\n    /// Requires the slot at `index` to be uninitialized.\n    #[inline(always)]\n    pub exec fn insert(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, index: usize, value: V)\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_uninit(index as int),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_uninit(index as int));\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n    }\n\n    /// Take the `value` at `index`\n    /// The value is moved out of the array.\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is uninitialized.\n    #[inline(always)]\n    pub exec fn take_at(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>, index: usize) -> (res:\n        V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init(index as int),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_uninit(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            res == old(perm).opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), index)\n    }\n\n    /// Take all the values of the array\n    /// The values are moved out of the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn take_all(&self, Tracked(perm): Tracked<&mut PointsTo<V, N>>) -> (res: [V; N])\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init_all(),\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_uninit_all(),\n            res@ == old(perm).value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_mut_read_all(ptr, Tracked(&mut perm.points_to))\n    }\n\n    /// Free the memory of the entire array and return the value\n    /// that was previously stored in the array.\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are uninitialized.\n    #[inline(always)]\n    pub exec fn into_inner(self, Tracked(perm): Tracked<PointsTo<V, N>>) -> (res: [V; N])\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init_all(),\n        ensures\n            res@ == perm.value(),\n    {\n        let tracked mut perm = perm;\n        let res = self.take_all(Tracked(&mut perm));\n        self.free(Tracked(perm));\n        res\n    }\n\n    /// Update the value at `index` with `value` and return the previous value\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is initialized with `value`.\n    /// Returns the previous value.\n    #[inline(always)]\n    pub exec fn update(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    ) -> (res: V) where V: Copy\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            old(perm).is_init(index as int),\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n            res == old(perm).opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        let res = ptr_mut_read_at(ptr, Tracked(&mut perm.points_to), index);\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n        res\n    }\n\n    /// Get the reference of the value at `index`\n    /// Borrow the immutable reference of the value at `index`\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    /// Returns the immutable reference of the value.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow_at<'a>(\n        &self,\n        Tracked(perm): Tracked<&'a PointsTo<V, N>>,\n        index: usize,\n    ) -> (res: &'a V)\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            index < N,\n        ensures\n            res == perm.opt_value()[index as int].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init(index as int));\n        ptr_ref_at(ptr, Tracked(&perm.points_to), index)\n    }\n\n    /// Get the reference of the entire array\n    /// Borrow the immutable reference of the entire array\n    /// Requires all slots to be initialized.\n    /// Afterwards, all slots are still initialized.\n    /// Returns the immutable reference of the entire array.\n    /// The reference is valid as long as the permission is alive.\n    /// The reference is not allowed to be stored.\n    #[inline(always)]\n    pub exec fn borrow<'a>(&self, Tracked(perm): Tracked<&'a PointsTo<V, N>>) -> (res: &'a [V; N])\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init_all(),\n        ensures\n            forall|i: int| 0 <= i < N ==> #[trigger] res[i] == perm.opt_value()[i].value(),\n    {\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        assert(perm.points_to().is_init_all());\n        ptr_ref(ptr, Tracked(&perm.points_to))\n    }\n\n    /// Overwrite the entry at `index` with `value`\n    /// The pervious value will be leaked if it was initialized.\n    #[inline(always)]\n    pub exec fn overwrite(\n        &self,\n        Tracked(perm): Tracked<&mut PointsTo<V, N>>,\n        index: usize,\n        value: V,\n    )\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    {\n        proof {\n            perm.leak_contents(index as int);\n        }\n        assert(perm.is_uninit(index as int));\n        let ptr: *mut [V; N] = raw_ptr::with_exposed_provenance(self.addr, Tracked(perm.exposed));\n\n        ptr_mut_write_at(ptr, Tracked(&mut perm.points_to), index, value);\n    }\n\n    #[verifier::external_body]\n    pub proof fn tracked_overwrite(\n        tracked &self,\n        tracked perm: &mut PointsTo<V, N>,\n        tracked index: usize,\n        tracked value: V,\n    )\n        requires\n            old(perm).wf(),\n            old(perm).pptr() == self,\n            index < N,\n        ensures\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            forall|i: int|\n                0 <= i < N && i != index ==> perm.opt_value()[i] == old(perm).opt_value()[i],\n            perm.opt_value()[index as int] == raw_ptr::MemContents::Init(value),\n    {\n        self.overwrite(Tracked(perm), index, value);\n    }\n\n    /// Get the value at `index` and return it\n    /// The value is copied from the array\n    /// Requires the slot at `index` to be initialized.\n    /// Afterwards, the slot is still initialized.\n    #[inline(always)]\n    pub exec fn get(&self, Tracked(perm): Tracked<&PointsTo<V, N>>, index: usize) -> (res: V) where\n        V: Copy,\n\n        requires\n            perm.wf(),\n            perm.pptr() == self,\n            perm.is_init(index as int),\n            index < N,\n        ensures\n            res == perm.opt_value()[index as int].value(),\n    {\n        *self.borrow_at(Tracked(perm), index)\n    }\n}\n*/\n} // verus!\n", "source": "complex_repos", "source_file": "workspace/complex_repos/vostd/vstd_extra/src/cast_ptr.rs", "verified": true, "metadata": {"original_id": "vostd_cast_ptr_314976b92d91", "function_name": "", "has_invariants": false, "has_asserts": true}}
