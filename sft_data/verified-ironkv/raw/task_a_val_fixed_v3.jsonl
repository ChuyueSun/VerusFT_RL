{"id": "task_a_host_impl_v_deliver_outbound_packets_86", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn deliver_outbound_packets(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n```\n\nWrite the specifications:", "target_text": "requires\n            old(netc).ok(),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),", "full_function": "    pub fn deliver_outbound_packets(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),\n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "deliver_outbound_packets", "function_mode": "exec", "line_start": 519, "line_end": 545, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 8, "is_method": true, "impl_type": "HostState"}}
{"id": "task_a_host_impl_v_receive_packet_next_87", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn receive_packet_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    {\n        let ghost old_self: HostState = *self;\n        let (rr, net_event) = receive_with_demarshal(netc, &self.constants.me);\n        match rr {\n            ReceiveResult::Fail{} => {\n                return (false, Ghost(EventResults{ recvs: seq![], clocks: seq![], sends: seq![], ios: seq![] }));\n            }\n            ReceiveResult::Timeout{} => {\n                let iop: NetEvent = LIoOp::TimeoutReceive{};\n                let ghost res = EventResults{ recvs: seq![], clocks: seq![ iop ], sends: seq![], ios: seq![ iop ] };\n                proof {\n                    old_self.delegation_map.valid_implies_complete();\n                    assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res.ios),\n                        Step::ReceivePacket));\n                    assert(res.event_seq() == res.ios);\n                }\n                return (true, Ghost(res));   // iop should also appear as a clock?\n            }\n            ReceiveResult::Packet{ cpacket } => {\n                match cpacket.msg {\n                    CSingleMessage::InvalidMessage { } => {\n                        let ghost res = EventResults{ recvs: seq![ net_event@ ], clocks: seq![], sends: seq![],\n                                                      ios: seq![ net_event@ ] };\n                        proof {\n                            old_self.delegation_map.valid_implies_complete();\n                            let ios = abstractify_raw_log_to_ios(res.ios);\n                            let r = ios[0]->r;\n                            let pkt = Packet{dst: r.dst, src: r.src, msg: r.msg};\n                            let sent_packets = extract_packets_from_abstract_ios(ios);\n                            lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty(\n                                ios, |io: LSHTIo| io is Send);\n                            assert(extract_sent_packets_from_ios(ios) =~= Seq::<LSHTPacket>::empty());\n                            assert(sent_packets =~= Set::<Packet>::empty());\n                            workaround_dermarshal_not_invertible();\n                            assert(host_protocol_t::receive_packet(old(self)@, self@, pkt, sent_packets, arbitrary()));\n                            assert(receive_packet_wrapper(old(self)@, self@, pkt, sent_packets));\n                            assert(receive_packet_without_reading_clock(old(self)@, self@,\n                                                                        abstractify_raw_log_to_ios(res.ios)));\n                            assert(host_protocol_t::next_step(old(self)@, self@, abstractify_raw_log_to_ios(res.ios),\n                                                              Step::ReceivePacket));\n                            assert(res.event_seq() == res.ios);\n                        }\n                        return (true, Ghost(res));\n                    }\n                    _ => {\n                        assert( *old(self) == *self );\n                        let ghost mid_netc = *netc;\n                        assert(netc.history() == old(netc).history().push(net_event@));\n                        let (ok, Ghost(event_results), Ghost(ios)) = self.host_next_receive_packet(netc, Ghost(old(netc).history()), cpacket, Ghost(net_event@));\n\n                        if !ok {\n                            return (ok, Ghost(event_results));\n                        }\n\n                        let rc = (ok, Ghost(event_results));\n                        assert(self.invariants(&netc.my_end_point()));\n                        proof {\n                            old(self).delegation_map.valid_implies_complete();\n                        }\n                        assert(host_protocol_t::next_step(old(self)@, self@, ios, Step::ReceivePacket));\n                        assert(Self::next(old(self)@, self@, event_results.ios));\n                        rc\n                    }\n                }\n            }\n        }\n    }\n```\n\nWrite the specifications:", "target_text": "requires Self::next_requires(*old(self), *old(netc)),\nensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),", "full_function": "    pub fn receive_packet_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        let ghost old_self: HostState = *self;\n        let (rr, net_event) = receive_with_demarshal(netc, &self.constants.me);\n        match rr {\n            ReceiveResult::Fail{} => {\n                return (false, Ghost(EventResults{ recvs: seq![], clocks: seq![], sends: seq![], ios: seq![] }));\n            }\n            ReceiveResult::Timeout{} => {\n                let iop: NetEvent = LIoOp::TimeoutReceive{};\n                let ghost res = EventResults{ recvs: seq![], clocks: seq![ iop ], sends: seq![], ios: seq![ iop ] };\n                proof {\n                    old_self.delegation_map.valid_implies_complete();\n                    assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res.ios),\n                        Step::ReceivePacket));\n                    assert(res.event_seq() == res.ios);\n                }\n                return (true, Ghost(res));   // iop should also appear as a clock?\n            }\n            ReceiveResult::Packet{ cpacket } => {\n                match cpacket.msg {\n                    CSingleMessage::InvalidMessage { } => {\n                        let ghost res = EventResults{ recvs: seq![ net_event@ ], clocks: seq![], sends: seq![],\n                                                      ios: seq![ net_event@ ] };\n                        proof {\n                            old_self.delegation_map.valid_implies_complete();\n                            let ios = abstractify_raw_log_to_ios(res.ios);\n                            let r = ios[0]->r;\n                            let pkt = Packet{dst: r.dst, src: r.src, msg: r.msg};\n                            let sent_packets = extract_packets_from_abstract_ios(ios);\n                            lemma_if_nothing_in_seq_satisfies_filter_then_filter_result_is_empty(\n                                ios, |io: LSHTIo| io is Send);\n                            assert(extract_sent_packets_from_ios(ios) =~= Seq::<LSHTPacket>::empty());\n                            assert(sent_packets =~= Set::<Packet>::empty());\n                            workaround_dermarshal_not_invertible();\n                            assert(host_protocol_t::receive_packet(old(self)@, self@, pkt, sent_packets, arbitrary()));\n                            assert(receive_packet_wrapper(old(self)@, self@, pkt, sent_packets));\n                            assert(receive_packet_without_reading_clock(old(self)@, self@,\n                                                                        abstractify_raw_log_to_ios(res.ios)));\n                            assert(host_protocol_t::next_step(old(self)@, self@, abstractify_raw_log_to_ios(res.ios),\n                                                              Step::ReceivePacket));\n                            assert(res.event_seq() == res.ios);\n                        }\n                        return (true, Ghost(res));\n                    }\n                    _ => {\n                        assert( *old(self) == *self );\n                        let ghost mid_netc = *netc;\n                        assert(netc.history() == old(netc).history().push(net_event@));\n                        let (ok, Ghost(event_results), Ghost(ios)) = self.host_next_receive_packet(netc, Ghost(old(netc).history()), cpacket, Ghost(net_event@));\n\n                        if !ok {\n                            return (ok, Ghost(event_results));\n                        }\n\n                        let rc = (ok, Ghost(event_results));\n                        assert(self.invariants(&netc.my_end_point()));\n                        proof {\n                            old(self).delegation_map.valid_implies_complete();\n                        }\n                        assert(host_protocol_t::next_step(old(self)@, self@, ios, Step::ReceivePacket));\n                        assert(Self::next(old(self)@, self@, event_results.ios));\n                        rc\n                    }\n                }\n            }\n        }\n    }", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "receive_packet_next", "function_mode": "exec", "line_start": 551, "line_end": 622, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 1, "num_ensures": 1, "complexity_score": 51, "is_method": true, "impl_type": "HostState"}}
{"id": "task_a_host_impl_t_next_impl_1", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    {\n        self.real_next_impl(netc)\n    }\n```\n\nWrite the specifications:", "target_text": "requires Self::next_requires(*old(self), *old(netc)),\nensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),", "full_function": "    pub fn next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n        requires\n            Self::next_requires(*old(self), *old(netc)),\n        ensures\n            Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        self.real_next_impl(netc)\n    }", "metadata": {"source_file": "../ironsht/src/host_impl_t.rs", "function_name": "next_impl", "function_mode": "exec", "line_start": 139, "line_end": 146, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "HostState"}}
{"id": "task_a_io_t_clone_up_to_view_56", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn clone_up_to_view(&self) -> (res: EndPoint)\n    {\n        EndPoint{id: clone_vec_u8(&self.id)}\n    }\n```\n\nWrite the specifications:", "target_text": "ensures res@ == self@,", "full_function": "    pub fn clone_up_to_view(&self) -> (res: EndPoint)\n        ensures res@ == self@\n    {\n        EndPoint{id: clone_vec_u8(&self.id)}\n    }", "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "clone_up_to_view", "function_mode": "exec", "line_start": 48, "line_end": 52, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "EndPoint"}}
{"id": "task_a_keys_t_cmp_107", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn cmp(&self, other: &Self) -> (o: Ordering)\n    {\n        if self.ukey < other.ukey {\n            Ordering::Less\n        } else if self.ukey == other.ukey {\n            Ordering::Equal\n        } else {\n            Ordering::Greater\n        }\n    }\n```\n\nWrite the specifications:", "target_text": "requires true,\nensures o == self.cmp_spec(*other),", "full_function": "\n    fn cmp(&self, other: &Self) -> (o: Ordering)\n//        requires true,\n//        ensures o == self.cmp_spec(*other)\n    {\n        if self.ukey < other.ukey {\n            Ordering::Less\n        } else if self.ukey == other.ukey {\n            Ordering::Equal\n        } else {\n            Ordering::Greater\n        }\n    }", "metadata": {"source_file": "../ironsht/src/keys_t.rs", "function_name": "cmp", "function_mode": "exec", "line_start": 224, "line_end": 236, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": false, "impl_type": null}}
{"id": "task_a_delegation_map_v_get_143", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn get(&self, k: &K) -> (id: ID)\n    {\n        let (id, glb_ret) = self.get_internal(k);\n        id\n    }\n```\n\nWrite the specifications:", "target_text": "requires self.valid(),\nensures id@ == self@[*k], id@.valid_physical_address(),", "full_function": "\n    pub fn get(&self, k: &K) -> (id: ID)\n        requires\n            self.valid(),\n        ensures\n            id@ == self@[*k],\n            id@.valid_physical_address(),\n    {\n        let (id, glb_ret) = self.get_internal(k);\n        id\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "get", "function_mode": "exec", "line_start": 1101, "line_end": 1111, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "DelegationMap<K>"}}
