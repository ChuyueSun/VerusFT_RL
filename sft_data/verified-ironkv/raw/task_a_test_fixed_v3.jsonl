{"id": "task_a_io_t_get_my_end_point_59", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn get_my_end_point(&self) -> (ep: EndPoint)\n    {\n        self.end_point.clone_up_to_view()\n    }\n```\n\nWrite the specifications:", "target_text": "ensures ep@ == self.my_end_point(),", "full_function": "\n    pub fn get_my_end_point(&self) -> (ep: EndPoint)\n        ensures\n            ep@ == self.my_end_point()\n    {\n        self.end_point.clone_up_to_view()\n    }", "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "get_my_end_point", "function_mode": "exec", "line_start": 267, "line_end": 273, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "NetClient"}}
{"id": "task_a_net_sht_v_send_packet_seq_55", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>))\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n```\n\nWrite the specifications:", "target_text": "requires\n    old(netc).ok(),\nensures\n    netc.my_end_point() == old(netc).my_end_point(),", "full_function": "pub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_seq_is_valid(cpackets@),\n    outbound_packet_seq_has_correct_srcs(cpackets@, old(netc).my_end_point()),\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_events)) = rc;\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n    }", "metadata": {"source_file": "../ironsht/src/net_sht_v.rs", "function_name": "send_packet_seq", "function_mode": "exec", "line_start": 353, "line_end": 369, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 6, "is_method": false, "impl_type": null}}
{"id": "task_a_delegation_map_v_is_eq_108", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn is_eq(self) -> (b:bool)\n    {\n        matches!(self, Ordering::Equal)\n    }\n```\n\nWrite the specifications:", "target_text": "ensures b == self.eq(),", "full_function": "\n    pub fn is_eq(self) -> (b:bool)\n        ensures b == self.eq(),\n    {\n        matches!(self, Ordering::Equal)\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "is_eq", "function_mode": "exec", "line_start": 42, "line_end": 47, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "Ordering"}}
{"id": "task_a_single_delivery_model_v_send_single_cmessage_22", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier::rlimit(15)]\n    pub fn send_single_cmessage(&mut self, m: &CMessage, dst: &EndPoint) -> (sm: Option<CSingleMessage>)\n    {\n        let (num_packets_acked, un_acked_len) = \n            match self.send_state.get(dst) {\n                Some(ref cack_state) => {\n                    proof {\n                        if cack_state.un_acked.len() > 0 {\n                            // This is necessary to show that appending our new seqno keeps the list sequential\n                            cack_state.lemma_seqno_in_un_acked_list(dst@, (cack_state.un_acked.len() - 1) as int);\n                        }\n                    }\n                    (cack_state.num_packets_acked, cack_state.un_acked.len() as u64)\n                }\n                None => { (0, 0) },\n                // In the None case, we have no ack state. To meet our AckState::receive_ack assum-ed\n                // protocol spec, we are forced to not update the send_state; stuffing an\n                // CAckState::new in there would make spec unmeetable.\n            };\n\n        if Parameters::static_params().max_seqno - num_packets_acked == un_acked_len {\n            // No more seqnos; must give up.\n            return None;\n        }\n\n        assert( num_packets_acked + un_acked_len <= AbstractParameters::static_params().max_seqno );\n        let new_seqno = num_packets_acked + un_acked_len + 1;\n        let sm_new = CSingleMessage::Message {\n            seqno: new_seqno,\n            dst: dst.clone_up_to_view(),\n            m: m.clone_up_to_view(),\n        };\n        assert(sm_new.abstractable());\n        assert(sm_new.is_marshalable()) by {\n            vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n            match sm_new {\n                CSingleMessage::Message { seqno, dst: dst_new, m: m_new } => {\n                    dst_new.lemma_same_views_serialize_the_same(&dst);\n                    m_new.lemma_same_views_serialize_the_same(&m);\n                    assert(sm_new.ghost_serialize().len() <= usize::MAX) by {\n                        // assert(seqno.ghost_serialize().len() == 8);\n                        // assert(dst_new.ghost_serialize().len() == dst.ghost_serialize().len());\n                        // assert(m_new.ghost_serialize().len() == m.ghost_serialize().len());\n                        // assert(dst_new.ghost_serialize().len() <= 0x100000 + 8);\n                        match m_new {\n                            CMessage::GetRequest { k } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::SetRequest { k, v } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::Reply { k, v } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::Redirect { k, id } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 16);\n                            },\n                            CMessage::Shard { kr, recipient } => {\n                                // assert(recipient.ghost_serialize().len() <= 0x100000 + 24);\n                                // assert(kr.ghost_serialize().len() <= 0x100000 + 24);\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 * 2);\n                            },\n                            CMessage::Delegate { range, h } => {\n                                // assert(range.ghost_serialize().len() <= 30);\n                                // assert(h.to_vec().len() <= 100);\n                                // assert(h.is_marshalable());\n                                // assert(h.ghost_serialize().len() <= crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size());\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            },\n                        };\n                    }\n                },\n                _ => {},\n            }\n        }\n        assert forall |sm_alt: CSingleMessage| sm_alt@ == sm_new@ implies sm_alt.is_marshalable() by {\n            sm_alt.lemma_same_views_serialize_the_same(&sm_new);\n        }\n\n        let mut local_state = CAckState::new();\n        let default = CAckState::new();\n\n        let ghost int_local_state = local_state;    // trigger fodder\n        self.send_state.cack_state_swap(&dst, &mut local_state, default);\n        local_state.un_acked.push(sm_new.clone_up_to_view());\n\n        let ghost old_ack_state = ack_state_lookup(dst@, old(self)@.send_state);\n        assert(local_state@.un_acked =~= old_ack_state.un_acked.push(sm_new@));\n        self.send_state.put(&dst, local_state);\n\n        assert forall |ep: EndPoint| #[trigger] self.send_state@.contains_key(ep@) implies\n                                ep.abstractable() && self.send_state.epmap[&ep].abstractable() by {\n            if ep@ != dst@ {\n                assert(old(self).send_state@.contains_key(ep@));\n            }\n        }\n\n        assert forall |ep: AbstractEndPoint| #[trigger] self.send_state@.contains_key(ep) implies self.send_state.epmap@[ep].valid(ep) by {\n            if ep != dst@ {\n                assert(old(self).send_state@.contains_key(ep));\n                assert(self.send_state.epmap@[ep].valid(ep));\n            }\n            else {\n                assert(self.send_state.epmap@[ep] == local_state);\n                assert(self.send_state.epmap@[ep].valid(ep));\n            }\n        }\n\n        assert(self@.send_state =~=\n               old(self)@.send_state.insert(dst@, AckState{ un_acked: old_ack_state.un_acked.push(sm_new@), .. old_ack_state }));\n        Some(sm_new)\n    }\n```\n\nWrite the specifications:", "target_text": "requires old(self).valid(), old(self).abstractable(), m.abstractable(), m.message_marshallable(), m.is_marshalable(), dst@.valid_physical_address(),\nensures self.valid(), match sm { Some(sm) => { &&& sm.abstractable() &&& sm is Message &&& sm.arrow_Message_dst()@ == dst@ &&& SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, Some(sm@), AbstractParameters::static_params()) &&& sm.is_marshalable() }, None => SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, None, AbstractParameters::static_params()), }, // TODO: capture the part of send_single_message when should_send == false,", "full_function": "    #[verifier::rlimit(15)]\n    pub fn send_single_cmessage(&mut self, m: &CMessage, dst: &EndPoint) -> (sm: Option<CSingleMessage>)\n        requires\n            old(self).valid(),\n            old(self).abstractable(),\n            m.abstractable(),\n            m.message_marshallable(),\n            m.is_marshalable(),\n            dst@.valid_physical_address(),\n        ensures\n            self.valid(),\n            match sm {\n                Some(sm) => {\n                    &&& sm.abstractable()\n                    &&& sm is Message\n                    &&& sm.arrow_Message_dst()@ == dst@\n                    &&& SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, Some(sm@), AbstractParameters::static_params())\n                    &&& sm.is_marshalable()\n                },\n                None =>\n                    SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, None, AbstractParameters::static_params()),\n            },\n            // TODO: capture the part of send_single_message when should_send == false\n    {\n        let (num_packets_acked, un_acked_len) = \n            match self.send_state.get(dst) {\n                Some(ref cack_state) => {\n                    proof {\n                        if cack_state.un_acked.len() > 0 {\n                            // This is necessary to show that appending our new seqno keeps the list sequential\n                            cack_state.lemma_seqno_in_un_acked_list(dst@, (cack_state.un_acked.len() - 1) as int);\n                        }\n                    }\n                    (cack_state.num_packets_acked, cack_state.un_acked.len() as u64)\n                }\n                None => { (0, 0) },\n                // In the None case, we have no ack state. To meet our AckState::receive_ack assum-ed\n                // protocol spec, we are forced to not update the send_state; stuffing an\n                // CAckState::new in there would make spec unmeetable.\n            };\n\n        if Parameters::static_params().max_seqno - num_packets_acked == un_acked_len {\n            // No more seqnos; must give up.\n            return None;\n        }\n\n        assert( num_packets_acked + un_acked_len <= AbstractParameters::static_params().max_seqno );\n        let new_seqno = num_packets_acked + un_acked_len + 1;\n        let sm_new = CSingleMessage::Message {\n            seqno: new_seqno,\n            dst: dst.clone_up_to_view(),\n            m: m.clone_up_to_view(),\n        };\n        assert(sm_new.abstractable());\n        assert(sm_new.is_marshalable()) by {\n            vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n            match sm_new {\n                CSingleMessage::Message { seqno, dst: dst_new, m: m_new } => {\n                    dst_new.lemma_same_views_serialize_the_same(&dst);\n                    m_new.lemma_same_views_serialize_the_same(&m);\n                    assert(sm_new.ghost_serialize().len() <= usize::MAX) by {\n                        // assert(seqno.ghost_serialize().len() == 8);\n                        // assert(dst_new.ghost_serialize().len() == dst.ghost_serialize().len());\n                        // assert(m_new.ghost_serialize().len() == m.ghost_serialize().len());\n                        // assert(dst_new.ghost_serialize().len() <= 0x100000 + 8);\n                        match m_new {\n                            CMessage::GetRequest { k } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::SetRequest { k, v } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::Reply { k, v } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::Redirect { k, id } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 16);\n                            },\n                            CMessage::Shard { kr, recipient } => {\n                                // assert(recipient.ghost_serialize().len() <= 0x100000 + 24);\n                                // assert(kr.ghost_serialize().len() <= 0x100000 + 24);\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 * 2);\n                            },\n                            CMessage::Delegate { range, h } => {\n                                // assert(range.ghost_serialize().len() <= 30);\n                                // assert(h.to_vec().len() <= 100);\n                                // assert(h.is_marshalable());\n                                // assert(h.ghost_serialize().len() <= crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size());\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            },\n                        };\n                    }\n                },\n                _ => {},\n            }\n        }\n        assert forall |sm_alt: CSingleMessage| sm_alt@ == sm_new@ implies sm_alt.is_marshalable() by {\n            sm_alt.lemma_same_views_serialize_the_same(&sm_new);\n        }\n\n        let mut local_state = CAckState::new();\n        let default = CAckState::new();\n\n        let ghost int_local_state = local_state;    // trigger fodder\n        self.send_state.cack_state_swap(&dst, &mut local_state, default);\n        local_state.un_acked.push(sm_new.clone_up_to_view());\n\n        let ghost old_ack_state = ack_state_lookup(dst@, old(self)@.send_state);\n        assert(local_state@.un_acked =~= old_ack_state.un_acked.push(sm_new@));\n        self.send_state.put(&dst, local_state);\n\n        assert forall |ep: EndPoint| #[trigger] self.send_state@.contains_key(ep@) implies\n                                ep.abstractable() && self.send_state.epmap[&ep].abstractable() by {\n            if ep@ != dst@ {\n                assert(old(self).send_state@.contains_key(ep@));\n            }\n        }\n\n        assert forall |ep: AbstractEndPoint| #[trigger] self.send_state@.contains_key(ep) implies self.send_state.epmap@[ep].valid(ep) by {\n            if ep != dst@ {\n                assert(old(self).send_state@.contains_key(ep));\n                assert(self.send_state.epmap@[ep].valid(ep));\n            }\n            else {\n                assert(self.send_state.epmap@[ep] == local_state);\n                assert(self.send_state.epmap@[ep].valid(ep));\n            }\n        }\n\n        assert(self@.send_state =~=\n               old(self)@.send_state.insert(dst@, AckState{ un_acked: old_ack_state.un_acked.push(sm_new@), .. old_ack_state }));\n        Some(sm_new)\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "send_single_cmessage", "function_mode": "exec", "line_start": 393, "line_end": 525, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 1, "num_ensures": 1, "complexity_score": 38, "is_method": true, "impl_type": "CSingleDelivery"}}
{"id": "task_a_io_t_valid_physical_address_57", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn valid_physical_address(&self) -> (out: bool)\n    {\n        self.id.len() < 0x100000\n    }\n```\n\nWrite the specifications:", "target_text": "ensures out == self@.valid_physical_address(),", "full_function": "    pub fn valid_physical_address(&self) -> (out: bool)\n    ensures\n        out == self@.valid_physical_address(),\n    {\n        self.id.len() < 0x100000\n    }", "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "valid_physical_address", "function_mode": "exec", "line_start": 70, "line_end": 75, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "EndPoint"}}
{"id": "task_a_seq_is_unique_v_clone_option_vec_u8_28", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn clone_option_vec_u8(ov: Option<&Vec<u8>>) -> (res: Option<Vec<u8>>)\n    {\n        match ov {\n            Some(e1) => Some(clone_vec_u8(e1)),\n            None => None,\n        }\n    }\n```\n\nWrite the specifications:", "target_text": "ensures match ov { Some(e1) => res.is_some() && e1@ == res->0@, None => res is None, },", "full_function": "\n    pub fn clone_option_vec_u8(ov: Option<&Vec<u8>>) -> (res: Option<Vec<u8>>)\n        ensures\n            match ov {\n                Some(e1) => res.is_some() && e1@ == res->0@,\n                None => res is None,\n            }\n    {\n        match ov {\n            Some(e1) => Some(clone_vec_u8(e1)),\n            None => None,\n        }\n    }", "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "clone_option_vec_u8", "function_mode": "exec", "line_start": 124, "line_end": 136, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": false, "impl_type": null}}
