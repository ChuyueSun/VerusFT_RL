{"id": "task_a_seq_is_unique_v_clone_option_end_point_30", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn clone_option_end_point(oep: &Option<EndPoint>) -> (cloned_oep: Option<EndPoint>)\n    {\n        match oep.as_ref() {\n            Some(ep) => Some(clone_end_point(ep)),\n            None => None\n        }\n    }\n```\n\nWrite the specifications:", "target_text": "ensures match oep { Some(ep) => cloned_oep.is_some() && ep@ == cloned_oep->0@, None => cloned_oep is None, },", "full_function": "\n    pub fn clone_option_end_point(oep: &Option<EndPoint>) -> (cloned_oep: Option<EndPoint>)\n        ensures\n            match oep {\n                Some(ep) => cloned_oep.is_some() && ep@ == cloned_oep->0@,\n                None => cloned_oep is None,\n            }\n    {\n        match oep.as_ref() {\n            Some(ep) => Some(clone_end_point(ep)),\n            None => None\n        }\n    }", "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "clone_option_end_point", "function_mode": "exec", "line_start": 144, "line_end": 156, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": false, "impl_type": null}}
{"id": "task_a_delegation_map_v_is_le_112", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub const fn is_le(self) -> (b:bool)\n    {\n        !matches!(self, Ordering::Greater)\n    }\n```\n\nWrite the specifications:", "target_text": "ensures b == self.le(),", "full_function": "\n    pub const fn is_le(self) -> (b:bool)\n        ensures b == self.le(),\n    {\n        !matches!(self, Ordering::Greater)\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "is_le", "function_mode": "exec", "line_start": 66, "line_end": 71, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "Ordering"}}
{"id": "task_a_net_sht_v_sht_demarshall_data_method_52", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn sht_demarshall_data_method(buffer: &Vec<u8>) -> (out: CSingleMessage)\n{\n    match CSingleMessage::deserialize(&buffer, 0) {\n        None => {\n            CSingleMessage::InvalidMessage\n        },\n        Some((cmessage, count)) => {\n            if count != buffer.len() { return CSingleMessage::InvalidMessage; }\n            match &cmessage {\n                CSingleMessage::Message{dst, m, ..} => {\n                    if !dst.valid_physical_address() { return CSingleMessage::InvalidMessage; }\n                    match m {\n                        CMessage::Redirect{id, ..} => {\n                            if !id.valid_physical_address() { return CSingleMessage::InvalidMessage; }\n                        },\n                        CMessage::Shard{recipient, ..} => {\n                            if !recipient.valid_physical_address() { return CSingleMessage::InvalidMessage; }\n                        },\n                        _ => {},\n                    }\n                },\n                _ => {},\n            }\n\n            proof {\n                assert( buffer@.subrange(0, count as int) =~= buffer@ );\n                sht_marshal_data_injective(&sht_demarshal_data(buffer@), &cmessage);\n            }\n            cmessage\n        }\n    }\n}\n```\n\nWrite the specifications:", "target_text": "ensures !(out is InvalidMessage) ==> { &&& out.is_marshalable() &&& out@ == sht_demarshal_data(buffer@)@ &&& out.abstractable() },", "full_function": "pub fn sht_demarshall_data_method(buffer: &Vec<u8>) -> (out: CSingleMessage)\nensures\n    !(out is InvalidMessage) ==> {\n        &&& out.is_marshalable()\n        &&& out@ == sht_demarshal_data(buffer@)@\n        &&& out.abstractable()\n    },\n{\n    match CSingleMessage::deserialize(&buffer, 0) {\n        None => {\n            CSingleMessage::InvalidMessage\n        },\n        Some((cmessage, count)) => {\n            if count != buffer.len() { return CSingleMessage::InvalidMessage; }\n            match &cmessage {\n                CSingleMessage::Message{dst, m, ..} => {\n                    if !dst.valid_physical_address() { return CSingleMessage::InvalidMessage; }\n                    match m {\n                        CMessage::Redirect{id, ..} => {\n                            if !id.valid_physical_address() { return CSingleMessage::InvalidMessage; }\n                        },\n                        CMessage::Shard{recipient, ..} => {\n                            if !recipient.valid_physical_address() { return CSingleMessage::InvalidMessage; }\n                        },\n                        _ => {},\n                    }\n                },\n                _ => {},\n            }\n\n            proof {\n                assert( buffer@.subrange(0, count as int) =~= buffer@ );\n                sht_marshal_data_injective(&sht_demarshal_data(buffer@), &cmessage);\n            }\n            cmessage\n        }\n    }\n}", "metadata": {"source_file": "../ironsht/src/net_sht_v.rs", "function_name": "sht_demarshall_data_method", "function_mode": "exec", "line_start": 129, "line_end": 166, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 0, "num_ensures": 1, "complexity_score": 8, "is_method": false, "impl_type": null}}
{"id": "task_a_io_t_send_64", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn send(&mut self, recipient: &EndPoint, message: &Vec<u8>) -> (result: Result<(), IronfleetIOError> )\n    {\n        let result: Result<(), IronfleetIOError> = self.send_internal_wrapper(recipient, message);\n        match result {\n            Ok(_) => {\n                self.state = Ghost(State::Sending{});\n                self.history = Ghost(self.history@ + seq![LIoOp::Send{s: LPacket{dst: recipient@, src: self.my_end_point(), msg: message@}}]);\n            }\n            Err(_) => {\n                self.state = Ghost(State::Error{});\n            }\n        };\n        result\n    }\n```\n\nWrite the specifications:", "target_text": "requires !(old(self).state() is Error),\nensures self.my_end_point() == old(self).my_end_point(), self.state() is Error <==> result is Err, result is Ok ==> self.state() is Sending, result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send{s: LPacket{dst: recipient@, src: self.my_end_point(), msg: message@}}],", "full_function": "\n    pub fn send(&mut self, recipient: &EndPoint, message: &Vec<u8>) -> (result: Result<(), IronfleetIOError> )\n        requires\n            !(old(self).state() is Error)\n        ensures\n            self.my_end_point() == old(self).my_end_point(),\n            self.state() is Error <==> result is Err,\n            result is Ok ==> self.state() is Sending,\n            result is Ok ==> self.history() == old(self).history() + seq![LIoOp::Send{s: LPacket{dst: recipient@, src: self.my_end_point(), msg: message@}}],\n    {\n        let result: Result<(), IronfleetIOError> = self.send_internal_wrapper(recipient, message);\n        match result {\n            Ok(_) => {\n                self.state = Ghost(State::Sending{});\n                self.history = Ghost(self.history@ + seq![LIoOp::Send{s: LPacket{dst: recipient@, src: self.my_end_point(), msg: message@}}]);\n            }\n            Err(_) => {\n                self.state = Ghost(State::Error{});\n            }\n        };\n        result\n    }", "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "send", "function_mode": "exec", "line_start": 399, "line_end": 420, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 10, "is_method": true, "impl_type": "NetClient"}}
{"id": "task_a_delegation_map_v_end_123", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(when_used_as_spec(end_spec))]\n    pub fn end() -> (s: Self)\n    {\n        KeyIterator { k: None }\n    }\n```\n\nWrite the specifications:", "target_text": "ensures s.k is None,", "full_function": "\n    #[verifier(when_used_as_spec(end_spec))]\n    pub fn end() -> (s: Self)\n        ensures s.k is None\n    {\n        KeyIterator { k: None }\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "end", "function_mode": "exec", "line_start": 342, "line_end": 348, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "KeyIterator<K>"}}
{"id": "task_a_delegation_map_v_new_140", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn new(k_zero: K, id_zero: ID) -> (s: Self)\n    {\n        let mut lows = StrictlyOrderedMap::new();\n        lows.set(k_zero, id_zero);\n        let m = Ghost(Map::total(|k| id_zero@));\n        let s = DelegationMap { lows, m };\n        s\n    }\n```\n\nWrite the specifications:", "target_text": "requires k_zero == K::zero_spec(), id_zero@.valid_physical_address(),\nensures s.valid(), s@ == Map::total(|k: K| id_zero@),", "full_function": "\n    pub fn new(k_zero: K, id_zero: ID) -> (s: Self)\n        requires\n            k_zero == K::zero_spec(),\n            id_zero@.valid_physical_address(),\n        ensures\n            s.valid(),\n            s@ == Map::total(|k: K| id_zero@),\n    {\n        let mut lows = StrictlyOrderedMap::new();\n        lows.set(k_zero, id_zero);\n        let m = Ghost(Map::total(|k| id_zero@));\n        let s = DelegationMap { lows, m };\n        s\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "new", "function_mode": "exec", "line_start": 1052, "line_end": 1066, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 6, "is_method": true, "impl_type": "DelegationMap<K>"}}
{"id": "task_a_delegation_map_v_get_135", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn get<'a>(&'a self, k: &K) -> (o: Option<&'a ID>)\n    {\n        match self.find_key(k) {\n            None => None,\n            Some(i) => Some(&self.vals[i]),\n        }\n    }\n```\n\nWrite the specifications:", "target_text": "requires self.valid(),\nensures match o { None => !self@.contains_key(*k), Some(v) => self@[*k] == v, },", "full_function": "\n\n    fn get<'a>(&'a self, k: &K) -> (o: Option<&'a ID>)\n        requires\n            self.valid(),\n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(v) => self@[*k] == v,\n            }\n    {\n        match self.find_key(k) {\n            None => None,\n            Some(i) => Some(&self.vals[i]),\n        }\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "get", "function_mode": "exec", "line_start": 673, "line_end": 688, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "StrictlyOrderedMap<K>"}}
{"id": "task_a_host_impl_v_make_empty_event_results_101", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn make_empty_event_results() -> (res: Ghost<EventResults>)\n{\n    let ghost res = EventResults {\n        recvs: Seq::<NetEvent>::empty(),\n        clocks: Seq::<NetEvent>::empty(),\n        sends: Seq::<NetEvent>::empty(),\n        ios: Seq::<NetEvent>::empty(),\n    };\n    proof {\n        assert_sets_equal!(extract_packets_from_abstract_ios(abstractify_raw_log_to_ios(res.ios)),\n                           Set::<Packet>::empty());\n    };\n    Ghost(res)\n}\n```\n\nWrite the specifications:", "target_text": "ensures res@.recvs == Seq::<NetEvent>::empty(), res@.clocks == Seq::<NetEvent>::empty(), res@.sends == Seq::<NetEvent>::empty(), res@.ios == Seq::<NetEvent>::empty(), extract_packets_from_abstract_ios(abstractify_raw_log_to_ios(res@.ios)) == Set::<Packet>::empty(),", "full_function": "\npub fn make_empty_event_results() -> (res: Ghost<EventResults>)\n    ensures\n        res@.recvs == Seq::<NetEvent>::empty(),\n        res@.clocks == Seq::<NetEvent>::empty(),\n        res@.sends == Seq::<NetEvent>::empty(),\n        res@.ios == Seq::<NetEvent>::empty(),\n        extract_packets_from_abstract_ios(abstractify_raw_log_to_ios(res@.ios)) == Set::<Packet>::empty(),\n{\n    let ghost res = EventResults {\n        recvs: Seq::<NetEvent>::empty(),\n        clocks: Seq::<NetEvent>::empty(),\n        sends: Seq::<NetEvent>::empty(),\n        ios: Seq::<NetEvent>::empty(),\n    };\n    proof {\n        assert_sets_equal!(extract_packets_from_abstract_ios(abstractify_raw_log_to_ios(res.ios)),\n                           Set::<Packet>::empty());\n    };\n    Ghost(res)\n}", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "make_empty_event_results", "function_mode": "exec", "line_start": 148, "line_end": 168, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 0, "num_ensures": 1, "complexity_score": 10, "is_method": false, "impl_type": null}}
{"id": "task_a_single_delivery_state_v_put_13", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn put(&mut self, src: &EndPoint, value: CAckState)\n    {\n        self.epmap.put(src, value)\n    }\n```\n\nWrite the specifications:", "target_text": "ensures HashMap::put_spec(old(self).epmap@, self.epmap@, src@, value),", "full_function": "\n    pub fn put(&mut self, src: &EndPoint, value: CAckState)\n    ensures\n        HashMap::put_spec(old(self).epmap@, self.epmap@, src@, value),\n    {\n        self.epmap.put(src, value)\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "put", "function_mode": "exec", "line_start": 292, "line_end": 298, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "CSendState"}}
{"id": "task_a_delegation_map_v_remove_119", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn remove(&mut self, i: usize) -> (k: K)\n    {\n        let k = self.v.remove(i);\n        proof {\n            let old_s = old(self)@.to_set().remove(k);\n            let new_s = self@.to_set();\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                assert(old(self)@.to_set().contains(e));\n                let n = choose |n: int| 0 <= n < old(self)@.len() && old(self)@[n] == e;\n                if n < i {\n                    assert(self@[n] == e);  // OBSERVE\n                } else {\n                    assert(self@[n-1] == e);  // OBSERVE\n                }\n            }\n            assert_sets_equal!(self@.to_set(), old(self)@.to_set().remove(k));\n        }\n        k\n    }\n```\n\nWrite the specifications:", "target_text": "requires old(self).valid(), i < old(self)@.len(),\nensures self.valid(), k == old(self)@.index(i as int), self@ == old(self)@.remove(i as int), self@.to_set() == old(self)@.to_set().remove(k),", "full_function": "\n    fn remove(&mut self, i: usize) -> (k: K)\n        requires\n            old(self).valid(),\n            i < old(self)@.len(),\n        ensures\n            self.valid(),\n            k == old(self)@.index(i as int),\n            self@ == old(self)@.remove(i as int),\n            self@.to_set() == old(self)@.to_set().remove(k),\n    {\n        let k = self.v.remove(i);\n        proof {\n            let old_s = old(self)@.to_set().remove(k);\n            let new_s = self@.to_set();\n            assert forall |e| old_s.contains(e) implies new_s.contains(e) by {\n                assert(old(self)@.to_set().contains(e));\n                let n = choose |n: int| 0 <= n < old(self)@.len() && old(self)@[n] == e;\n                if n < i {\n                    assert(self@[n] == e);  // OBSERVE\n                } else {\n                    assert(self@[n-1] == e);  // OBSERVE\n                }\n            }\n            assert_sets_equal!(self@.to_set(), old(self)@.to_set().remove(k));\n        }\n        k\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "remove", "function_mode": "exec", "line_start": 167, "line_end": 194, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 1, "num_ensures": 1, "complexity_score": 14, "is_method": true, "impl_type": "StrictlyOrderedVec<K>"}}
{"id": "task_a_cmessage_v_clone_optional_value_78", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn clone_optional_value(ov: &Option::<Vec::<u8>>) -> (res: Option::<Vec::<u8>>)\n{\n    match ov.as_ref() {\n        Some(v) => Some(clone_vec_u8(v)),\n        None => None,\n    }\n}\n```\n\nWrite the specifications:", "target_text": "ensures optional_value_view(*ov) == optional_value_view(res),", "full_function": "\npub fn clone_optional_value(ov: &Option::<Vec::<u8>>) -> (res: Option::<Vec::<u8>>)\n    ensures optional_value_view(*ov) == optional_value_view(res)\n{\n    match ov.as_ref() {\n        Some(v) => Some(clone_vec_u8(v)),\n        None => None,\n    }\n}", "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "clone_optional_value", "function_mode": "exec", "line_start": 41, "line_end": 49, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": false, "impl_type": null}}
{"id": "task_a_delegation_map_v_above_127", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(when_used_as_spec(above_spec))]\n    fn above(&self, k: K) -> (b: bool)\n    {\n        self.is_end() || k.cmp(&self.k.as_ref().unwrap().clone()).is_lt()\n    }\n```\n\nWrite the specifications:", "target_text": "ensures b == self.above_spec(k),", "full_function": "    #[verifier(when_used_as_spec(above_spec))]\n    fn above(&self, k: K) -> (b: bool)\n        ensures b == self.above_spec(k),\n    {\n        self.is_end() || k.cmp(&self.k.as_ref().unwrap().clone()).is_lt()\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "above", "function_mode": "exec", "line_start": 408, "line_end": 413, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "KeyIterator<K>"}}
{"id": "task_a_delegation_map_v_new_131", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn new() -> (s: Self)\n    {\n        let keys = StrictlyOrderedVec::new();\n        let m = Ghost(Map::empty());\n        proof {\n            assert_sets_equal!(m@.dom(), keys@.to_set());\n        }\n        StrictlyOrderedMap {\n            keys,\n            vals: Vec::new(),\n            m,\n        }\n    }\n```\n\nWrite the specifications:", "target_text": "ensures s.valid(), s@ == Map::<K,ID>::empty(),", "full_function": "\n\n    fn new() -> (s: Self)\n        ensures\n            s.valid(),\n            s@ == Map::<K,ID>::empty(),\n    {\n        let keys = StrictlyOrderedVec::new();\n        let m = Ghost(Map::empty());\n        proof {\n            assert_sets_equal!(m@.dom(), keys@.to_set());\n        }\n        StrictlyOrderedMap {\n            keys,\n            vals: Vec::new(),\n            m,\n        }\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "new", "function_mode": "exec", "line_start": 515, "line_end": 532, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 0, "num_ensures": 1, "complexity_score": 10, "is_method": true, "impl_type": "StrictlyOrderedMap<K>"}}
{"id": "task_a_cmessage_v_clone_up_to_view_76", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn clone_up_to_view(&self) -> (c: Self)\n  {\n      match self {\n          CSingleMessage::Message{seqno, dst, m} => {\n              CSingleMessage::Message{seqno: *seqno, dst: dst.clone_up_to_view(), m: m.clone_up_to_view() }\n          },\n          CSingleMessage::Ack{ack_seqno} => { CSingleMessage::Ack{ ack_seqno: *ack_seqno } },\n          CSingleMessage::InvalidMessage{} => { CSingleMessage::InvalidMessage{} }\n      }\n  }\n```\n\nWrite the specifications:", "target_text": "ensures c@ == self@,", "full_function": "\n  pub fn clone_up_to_view(&self) -> (c: Self)\n  ensures\n    c@ == self@\n  {\n      match self {\n          CSingleMessage::Message{seqno, dst, m} => {\n              CSingleMessage::Message{seqno: *seqno, dst: dst.clone_up_to_view(), m: m.clone_up_to_view() }\n          },\n          CSingleMessage::Ack{ack_seqno} => { CSingleMessage::Ack{ ack_seqno: *ack_seqno } },\n          CSingleMessage::InvalidMessage{} => { CSingleMessage::InvalidMessage{} }\n      }\n  }", "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "clone_up_to_view", "function_mode": "exec", "line_start": 246, "line_end": 258, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "CSingleMessage"}}
{"id": "task_a_delegation_map_v_len_116", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn len(&self) -> (len: usize )\n    {\n        self.v.len()\n    }\n```\n\nWrite the specifications:", "target_text": "ensures len == self@.len(),", "full_function": "\n    fn len(&self) -> (len: usize )\n        ensures len == self@.len()\n    {\n        self.v.len()\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "len", "function_mode": "exec", "line_start": 133, "line_end": 138, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "StrictlyOrderedVec<K>"}}
{"id": "task_a_net_sht_v_send_packet_54", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn send_packet(cpacket: &CPacket, netc: &mut NetClient) -> (rc: (bool, Ghost<Option<NetEvent>>))\n        {\n    &&& netc.ok() <==> ok\n    &&& ok ==> net_event is Some\n    &&& ok ==> netc.history() == old(netc).history() + seq![net_event.unwrap()]\n    &&& ok ==> rc.1@ is Some && send_log_entry_reflects_packet(net_event.unwrap(), &cpacket)\n                && is_marshalable_data(net_event.unwrap())\n        }\n```\n\nWrite the specifications:", "target_text": "requires\n    old(netc).ok(),\nensures\n    netc.my_end_point() == old(netc).my_end_point(),", "full_function": "\npub fn send_packet(cpacket: &CPacket, netc: &mut NetClient) -> (rc: (bool, Ghost<Option<NetEvent>>))\nrequires\n    old(netc).ok(),\n    outbound_packet_is_valid(cpacket),\n    cpacket.src@ == old(netc).my_end_point(), // OutboundPacketsSeqHasCorrectSrc\nensures\n    netc.my_end_point() == old(netc).my_end_point(),\n    ({\n        let (ok, Ghost(net_event)) = rc;\n        {\n    &&& netc.ok() <==> ok\n    &&& ok ==> net_event is Some\n    &&& ok ==> netc.history() == old(netc).history() + seq![net_event.unwrap()]\n    &&& ok ==> rc.1@ is Some && send_log_entry_reflects_packet(net_event.unwrap(), &cpacket)\n                && is_marshalable_data(net_event.unwrap())\n        }\n    }", "metadata": {"source_file": "../ironsht/src/net_sht_v.rs", "function_name": "send_packet", "function_mode": "exec", "line_start": 274, "line_end": 291, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 6, "is_method": false, "impl_type": null}}
{"id": "task_a_delegation_map_v_new_115", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn new() -> (v: Self)\n    {\n        StrictlyOrderedVec { v: Vec::new() }\n    }\n```\n\nWrite the specifications:", "target_text": "ensures v@ == Seq::<K>::empty(), v.valid(),", "full_function": "\n    fn new() -> (v: Self)\n        ensures v@ == Seq::<K>::empty(),\n                v.valid(),\n    {\n        StrictlyOrderedVec { v: Vec::new() }\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "new", "function_mode": "exec", "line_start": 126, "line_end": 132, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "StrictlyOrderedVec<K>"}}
{"id": "task_a_delegation_map_v_greatest_lower_bound_138", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn greatest_lower_bound(&self, iter: &KeyIterator<K>) -> (glb: KeyIterator<K>)\n    {\n        let index = self.greatest_lower_bound_index(iter);\n        let glb = KeyIterator::new(self.keys.index(index));\n        glb\n    }\n```\n\nWrite the specifications:", "target_text": "requires self.valid(), self@.contains_key(K::zero_spec()),\nensures self.greatest_lower_bound_spec(*iter, glb),", "full_function": "    fn greatest_lower_bound(&self, iter: &KeyIterator<K>) -> (glb: KeyIterator<K>)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            self.greatest_lower_bound_spec(*iter, glb),\n    {\n        let index = self.greatest_lower_bound_index(iter);\n        let glb = KeyIterator::new(self.keys.index(index));\n        glb\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "greatest_lower_bound", "function_mode": "exec", "line_start": 855, "line_end": 865, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "StrictlyOrderedMap<K>"}}
{"id": "task_a_single_delivery_state_v_empty_14", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn empty() -> (out:Self)\n    {\n        let result = CSingleDelivery {\n            receive_state: CTombstoneTable{epmap: HashMap::new()},\n            send_state: CSendState{epmap: HashMap::new()},\n        };\n        proof {\n            assert_maps_equal!(result.receive_state@, SingleDelivery::<Message>::init().receive_state);\n            assert_maps_equal!(result.send_state@, SingleDelivery::<Message>::init().send_state);\n        }\n        result\n    }\n```\n\nWrite the specifications:", "target_text": "ensures out@ == SingleDelivery::<Message>::init(),", "full_function": "\n    pub fn empty() -> (out:Self)\n    ensures out@ == SingleDelivery::<Message>::init()\n    {\n        let result = CSingleDelivery {\n            receive_state: CTombstoneTable{epmap: HashMap::new()},\n            send_state: CSendState{epmap: HashMap::new()},\n        };\n        proof {\n            assert_maps_equal!(result.receive_state@, SingleDelivery::<Message>::init().receive_state);\n            assert_maps_equal!(result.send_state@, SingleDelivery::<Message>::init().send_state);\n        }\n        result\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "empty", "function_mode": "exec", "line_start": 307, "line_end": 320, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 0, "num_ensures": 1, "complexity_score": 9, "is_method": true, "impl_type": "CSingleDelivery"}}
{"id": "task_a_delegation_map_v_set_136", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn set(&mut self, k: K, v: ID)\n    {\n        match self.find_key(&k) {\n            Some(i) => {\n                self.vals.set(i, v);\n                self.m = Ghost(self.m@.insert(k, v));\n                proof {\n                    assert_sets_equal!(self.m@.dom() == self.keys@.to_set());\n                }\n            },\n            None => {\n                let index = self.keys.insert(k.clone());\n                self.vals.insert(index, v);\n                self.m = Ghost(self.m@.insert(k, v));\n            }\n        }\n        assert forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)) by {\n            self.mind_the_gap();\n            old(self).mind_the_gap();\n            if old(self).gap(lo, hi) && !(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] self@.contains_key(*ki.get())) by {\n                    // TODO: This was the previous (flaky) proof:\n                    // K::cmp_properties();\n                    //\n                    assert_by_contradiction!(!old(self)@.contains_key(*ki.get()), {\n                        old(self).gap_means_empty(lo, hi, ki);\n                    });\n                };\n                assert(self.gap(lo, hi));\n            }\n\n            if self.gap(lo, hi) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] old(self)@.contains_key(*ki.get())) by {\n                    assert_by_contradiction!(!(old(self)@.contains_key(*ki.get())), {\n                        assert(self@.contains_key(*ki.get()));\n                        K::cmp_properties();\n                    });\n                };\n                assert(old(self).gap(lo, hi));\n                assert_by_contradiction!(!(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)), {\n                    assert(self@.contains_key(k));\n                    self.gap_means_empty(lo, hi, KeyIterator::new_spec(k));\n                });\n            }\n        };\n    }\n```\n\nWrite the specifications:", "target_text": "requires old(self).valid(),\nensures self.valid(), self@ == old(self)@.insert(k, v), forall |lo, hi| self.gap(lo, hi) <==> old(self).gap(lo, hi) && !(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)),", "full_function": "\n    fn set(&mut self, k: K, v: ID)\n        requires\n            old(self).valid(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.insert(k, v),\n            forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)),\n    {\n        match self.find_key(&k) {\n            Some(i) => {\n                self.vals.set(i, v);\n                self.m = Ghost(self.m@.insert(k, v));\n                proof {\n                    assert_sets_equal!(self.m@.dom() == self.keys@.to_set());\n                }\n            },\n            None => {\n                let index = self.keys.insert(k.clone());\n                self.vals.insert(index, v);\n                self.m = Ghost(self.m@.insert(k, v));\n            }\n        }\n        assert forall |lo, hi| self.gap(lo, hi) <==>\n                            old(self).gap(lo, hi)\n                        && !(lo.lt_spec(KeyIterator::new_spec(k))\n                          && KeyIterator::new_spec(k).lt_spec(hi)) by {\n            self.mind_the_gap();\n            old(self).mind_the_gap();\n            if old(self).gap(lo, hi) && !(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] self@.contains_key(*ki.get())) by {\n                    // TODO: This was the previous (flaky) proof:\n                    // K::cmp_properties();\n                    //\n                    assert_by_contradiction!(!old(self)@.contains_key(*ki.get()), {\n                        old(self).gap_means_empty(lo, hi, ki);\n                    });\n                };\n                assert(self.gap(lo, hi));\n            }\n\n            if self.gap(lo, hi) {\n                assert forall |ki| lo.lt_spec(ki) && ki.lt_spec(hi) implies !(#[trigger] old(self)@.contains_key(*ki.get())) by {\n                    assert_by_contradiction!(!(old(self)@.contains_key(*ki.get())), {\n                        assert(self@.contains_key(*ki.get()));\n                        K::cmp_properties();\n                    });\n                };\n                assert(old(self).gap(lo, hi));\n                assert_by_contradiction!(!(lo.lt_spec(KeyIterator::new_spec(k)) && KeyIterator::new_spec(k).lt_spec(hi)), {\n                    assert(self@.contains_key(k));\n                    self.gap_means_empty(lo, hi, KeyIterator::new_spec(k));\n                });\n            }\n        };\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "set", "function_mode": "exec", "line_start": 689, "line_end": 747, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 1, "num_ensures": 1, "complexity_score": 24, "is_method": true, "impl_type": "StrictlyOrderedMap<K>"}}
{"id": "task_a_seq_is_unique_v_do_end_points_match_25", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn do_end_points_match(e1: &EndPoint, e2: &EndPoint) -> (eq: bool)\n    {\n        do_vec_u8s_match(&e1.id, &e2.id)\n    }\n```\n\nWrite the specifications:", "target_text": "ensures eq == (e1@ == e2@),", "full_function": "\n    pub fn do_end_points_match(e1: &EndPoint, e2: &EndPoint) -> (eq: bool)\n        ensures\n            eq == (e1@ == e2@)\n    {\n        do_vec_u8s_match(&e1.id, &e2.id)\n    }", "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "do_end_points_match", "function_mode": "exec", "line_start": 49, "line_end": 55, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": false, "impl_type": null}}
{"id": "task_a_delegation_map_v_is_ne_109", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn is_ne(self) -> (b:bool)\n    {\n        !matches!(self, Ordering::Equal)\n    }\n```\n\nWrite the specifications:", "target_text": "ensures b == self.ne(),", "full_function": "\n    pub fn is_ne(self) -> (b:bool)\n        ensures b == self.ne(),\n    {\n        !matches!(self, Ordering::Equal)\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "is_ne", "function_mode": "exec", "line_start": 48, "line_end": 53, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "Ordering"}}
{"id": "task_a_io_t_get_time_internal_60", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(external)]\n    pub fn get_time_internal(&self) -> (time: u64)\n    {\n        (self.c_pointers.get_time_func)()\n    }\n```\n\nWrite the specifications:", "target_text": "requires from_trusted_code(),", "full_function": "\n    #[verifier(external)]\n    pub fn get_time_internal(&self) -> (time: u64)\n        requires\n            from_trusted_code()\n    {\n        (self.c_pointers.get_time_func)()\n    }", "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "get_time_internal", "function_mode": "exec", "line_start": 274, "line_end": 281, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 0, "complexity_score": 2, "is_method": true, "impl_type": "NetClient"}}
{"id": "task_a_cmessage_v_clone_value_72", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn clone_value(value: &Option<Vec<u8>>) -> (out: Option<Vec<u8>>)\n  {\n      match value {\n          Some(vec) => Some(clone_vec_u8(vec)),\n          None => None,\n      }\n  }\n```\n\nWrite the specifications:", "target_text": "ensures match value { Some(vec) => { &&& out is Some &&& out.unwrap()@ == vec@ } None => { &&& out is None } },", "full_function": "  pub fn clone_value(value: &Option<Vec<u8>>) -> (out: Option<Vec<u8>>)\n  ensures\n      match value {\n          Some(vec) => {\n              &&& out is Some\n              &&& out.unwrap()@ == vec@\n          }\n          None => {\n              &&& out is None\n          }\n      }\n  {\n      match value {\n          Some(vec) => Some(clone_vec_u8(vec)),\n          None => None,\n      }\n  }", "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "clone_value", "function_mode": "exec", "line_start": 107, "line_end": 123, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "CMessage"}}
{"id": "task_a_keys_t_contains_exec_104", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn contains_exec(&self, k: &K) -> (b: bool)\n    {\n        let ki = KeyIterator { k: Some(k.clone()) };\n        !ki.lt(&self.lo) && ki.lt(&self.hi)\n    }\n```\n\nWrite the specifications:", "target_text": "ensures b == self.contains(*k),", "full_function": "\n    pub fn contains_exec(&self, k: &K) -> (b: bool)\n    ensures\n        b == self.contains(*k),\n    {\n        let ki = KeyIterator { k: Some(k.clone()) };\n        !ki.lt(&self.lo) && ki.lt(&self.hi)\n    }", "metadata": {"source_file": "../ironsht/src/keys_t.rs", "function_name": "contains_exec", "function_mode": "exec", "line_start": 115, "line_end": 122, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "KeyRange<K>"}}
{"id": "task_a_host_impl_v_host_noreceive_noclock_next_99", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(spinoff_prover)]\n    pub fn host_noreceive_noclock_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    {\n        // HostModel.HostModelSpontaneouslyRetransmit\n        // SingleDeliveryModel.RetransmitUnAckedPackets\n        let sent_packets = self.sd.retransmit_un_acked_packets(&self.constants.me);\n\n        // SchedulerImpl.DeliverOutboundPackets (seems to be a no-op wrapper?)\n        // SchedulerImpl.DeliverPacketSeq\n        // NetSHT.SendPacketSeq\n        let (ok, Ghost(send_events)) = send_packet_seq(&sent_packets, netc);\n        if !ok {\n            let ghost event_results = Self::empty_event_results();\n            let rc = (false, Ghost(event_results));\n            assert( Self::next_ensures(*old(self), *old(netc), *self, *netc, rc) );\n            // this return path seems unstable\n            return rc;\n        }\n\n        let event_results = Ghost(EventResults {\n            recvs: seq![],\n            clocks: seq![],\n            sends: send_events,\n            ios: send_events,\n        });\n        proof {\n            let aios = abstractify_raw_log_to_ios(event_results@.ios);\n\n            assert forall |i| #![auto] 0 <= i < aios.len() && aios[i] is Send\n                implies !(aios[i].arrow_Send_s().msg is InvalidMessage) by {\n                assert( send_log_entry_reflects_packet(send_events[i], &sent_packets[i]) ); // trigger\n            }\n\n            self.delegation_map.valid_implies_complete();   // Needed to get old(self)@.wf()\n\n            // Have to do some =~= to the parts of these definitions before .to_set()\n            let view_seq = sent_packets@.map_values(|cp: CPacket| cp@);\n            let extract_seq = extract_sent_packets_from_ios(aios).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp));\n\n            // Skip through the filter in extract_sent_packets_from_ios, which is a no-op here\n            lemma_if_everything_in_seq_satisfies_filter_then_filter_is_identity(aios, |io: LSHTIo| io is Send);\n\n            // Reach into an inconvenient trigger\n            assert forall |i| 0<=i<extract_seq.len() implies extract_seq[i] == view_seq[i] by {\n                assert( send_log_entry_reflects_packet(event_results@.ios[i], &sent_packets@[i]) );\n            }\n            assert( view_seq =~= extract_seq ); // prompt ext equality\n\n            assert( next_step(old(self)@, self@, aios, Step::SpontaneouslyRetransmit) ); // witness\n\n            assert(ok ==> event_results@.event_seq() == event_results@.ios);\n        }\n        (ok, event_results)\n    }\n```\n\nWrite the specifications:", "target_text": "requires Self::next_requires(*old(self), *old(netc)),\nensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),", "full_function": "    #[verifier(spinoff_prover)]\n    pub fn host_noreceive_noclock_next(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        // HostModel.HostModelSpontaneouslyRetransmit\n        // SingleDeliveryModel.RetransmitUnAckedPackets\n        let sent_packets = self.sd.retransmit_un_acked_packets(&self.constants.me);\n\n        // SchedulerImpl.DeliverOutboundPackets (seems to be a no-op wrapper?)\n        // SchedulerImpl.DeliverPacketSeq\n        // NetSHT.SendPacketSeq\n        let (ok, Ghost(send_events)) = send_packet_seq(&sent_packets, netc);\n        if !ok {\n            let ghost event_results = Self::empty_event_results();\n            let rc = (false, Ghost(event_results));\n            assert( Self::next_ensures(*old(self), *old(netc), *self, *netc, rc) );\n            // this return path seems unstable\n            return rc;\n        }\n\n        let event_results = Ghost(EventResults {\n            recvs: seq![],\n            clocks: seq![],\n            sends: send_events,\n            ios: send_events,\n        });\n        proof {\n            let aios = abstractify_raw_log_to_ios(event_results@.ios);\n\n            assert forall |i| #![auto] 0 <= i < aios.len() && aios[i] is Send\n                implies !(aios[i].arrow_Send_s().msg is InvalidMessage) by {\n                assert( send_log_entry_reflects_packet(send_events[i], &sent_packets[i]) ); // trigger\n            }\n\n            self.delegation_map.valid_implies_complete();   // Needed to get old(self)@.wf()\n\n            // Have to do some =~= to the parts of these definitions before .to_set()\n            let view_seq = sent_packets@.map_values(|cp: CPacket| cp@);\n            let extract_seq = extract_sent_packets_from_ios(aios).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp));\n\n            // Skip through the filter in extract_sent_packets_from_ios, which is a no-op here\n            lemma_if_everything_in_seq_satisfies_filter_then_filter_is_identity(aios, |io: LSHTIo| io is Send);\n\n            // Reach into an inconvenient trigger\n            assert forall |i| 0<=i<extract_seq.len() implies extract_seq[i] == view_seq[i] by {\n                assert( send_log_entry_reflects_packet(event_results@.ios[i], &sent_packets@[i]) );\n            }\n            assert( view_seq =~= extract_seq ); // prompt ext equality\n\n            assert( next_step(old(self)@, self@, aios, Step::SpontaneouslyRetransmit) ); // witness\n\n            assert(ok ==> event_results@.event_seq() == event_results@.ios);\n        }\n        (ok, event_results)\n    }", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_noreceive_noclock_next", "function_mode": "exec", "line_start": 1720, "line_end": 1777, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 1, "num_ensures": 1, "complexity_score": 23, "is_method": true, "impl_type": "HostState"}}
{"id": "task_a_delegation_map_v_new_122", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn new(k: K) -> (s: Self)\n    {\n        KeyIterator { k: Some(k) }\n    }\n```\n\nWrite the specifications:", "target_text": "ensures s.k == Some(k),", "full_function": "    pub fn new(k: K) -> (s: Self)\n        ensures s.k == Some(k)\n    {\n        KeyIterator { k: Some(k) }\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "new", "function_mode": "exec", "line_start": 333, "line_end": 337, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "KeyIterator<K>"}}
{"id": "task_a_args_t_clone_arg_33", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn clone_arg(arg: &Arg) -> (out: Arg)\n{\n    clone_vec_u8(arg)\n}\n```\n\nWrite the specifications:", "target_text": "ensures out@ == arg@,", "full_function": "\n\npub fn clone_arg(arg: &Arg) -> (out: Arg)\nensures\n    out@ == arg@\n{\n    clone_vec_u8(arg)\n}", "metadata": {"source_file": "../ironsht/src/args_t.rs", "function_name": "clone_arg", "function_mode": "exec", "line_start": 44, "line_end": 51, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": false, "impl_type": null}}
{"id": "task_a_single_delivery_model_v_new_impl_18", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn new_impl(&self, pkt: &CPacket) -> (ok: bool)\n    {\n        match pkt.msg {\n            CSingleMessage::Message{seqno, ..} => {\n                seqno > 0 && seqno - 1 == self.receive_state.lookup(&pkt.src)\n            },\n            _ => false,\n        }\n    }\n```\n\nWrite the specifications:", "target_text": "requires self.valid(), self.abstractable(), pkt.abstractable(),\nensures ok == SingleDelivery::new_single_message(self@, pkt@),", "full_function": "    pub fn new_impl(&self, pkt: &CPacket) -> (ok: bool)\n    requires\n        self.valid(),\n        self.abstractable(),\n        pkt.abstractable(),\n    ensures\n        ok == SingleDelivery::new_single_message(self@, pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Message{seqno, ..} => {\n                seqno > 0 && seqno - 1 == self.receive_state.lookup(&pkt.src)\n            },\n            _ => false,\n        }\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "new_impl", "function_mode": "exec", "line_start": 182, "line_end": 196, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "CSingleDelivery"}}
{"id": "task_a_host_impl_v_extract_range_impl_103", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn extract_range_impl(h: &CKeyHashMap, kr: &KeyRange<CKey>) -> (ext: CKeyHashMap)\n{\n    let exec_lambda = |key| -> (b: bool) ensures b == kr.contains(key) { kr.contains_exec(&key)};\n\n    h.filter(exec_lambda, Ghost(|ak| kr.contains(ak)))\n}\n```\n\nWrite the specifications:", "target_text": "requires //h@.valid_key_range() // (See Distributed/Services/SHT/AppInterface.i.dfy: ValidKey() == true) forall |k| h@.contains_key(k) ==> /*#[trigger] valid_key(k) &&*/ #[trigger] valid_value(h@[k]),\nensures ext@ =~= extract_range(h@, *kr),", "full_function": "fn extract_range_impl(h: &CKeyHashMap, kr: &KeyRange<CKey>) -> (ext: CKeyHashMap)\nrequires\n    //h@.valid_key_range() // (See Distributed/Services/SHT/AppInterface.i.dfy: ValidKey() == true)\n    forall |k| h@.contains_key(k) ==> /*#[trigger] valid_key(k) &&*/ #[trigger] valid_value(h@[k]),\nensures\n    ext@ =~= extract_range(h@, *kr),\n{\n    let exec_lambda = |key| -> (b: bool) ensures b == kr.contains(key) { kr.contains_exec(&key)};\n\n    h.filter(exec_lambda, Ghost(|ak| kr.contains(ak)))\n}", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "extract_range_impl", "function_mode": "exec", "line_start": 212, "line_end": 222, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 6, "is_method": false, "impl_type": null}}
{"id": "task_a_delegation_map_v_get_125", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(when_used_as_spec(get_spec))]\n    pub fn get(&self) -> (k: &K)\n    {\n        self.k.as_ref().unwrap()\n    }\n```\n\nWrite the specifications:", "target_text": "requires !self.is_end(),\nensures k == self.get_spec(),", "full_function": "\n    #[verifier(when_used_as_spec(get_spec))]\n    pub fn get(&self) -> (k: &K)\n        requires !self.is_end(),\n        ensures k == self.get_spec(),\n    {\n        self.k.as_ref().unwrap()\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "get", "function_mode": "exec", "line_start": 366, "line_end": 373, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "KeyIterator<K>"}}
{"id": "task_a_cmessage_v_is_message_marshallable_74", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn is_message_marshallable(&self) -> (b: bool)\n  {\n      match self {\n          CMessage::GetRequest{ k } => is_key_valid(k),\n          CMessage::SetRequest{ k , v } =>\n              is_key_valid(k) &&\n              match v {\n                  Some(v) => is_value_valid(v),\n                  None => true,\n              },\n          CMessage::Reply{ k, v } =>\n              is_key_valid(k) &&\n              match v {\n                  Some(v) => is_value_valid(v),\n                  None => true,\n              },\n          CMessage::Redirect{ k, id } => is_key_valid(k) && id.valid_physical_address(),\n          CMessage::Shard{ kr, recipient } => recipient.valid_physical_address() && kr.lo.lt(&kr.hi),\n          CMessage::Delegate{ range, h } => range.lo.lt(&range.hi) && h.valid(),\n      }\n  }\n```\n\nWrite the specifications:", "target_text": "ensures b == self.message_marshallable(),", "full_function": "  pub fn is_message_marshallable(&self) -> (b: bool)\n      ensures  b == self.message_marshallable()\n  {\n      match self {\n          CMessage::GetRequest{ k } => is_key_valid(k),\n          CMessage::SetRequest{ k , v } =>\n              is_key_valid(k) &&\n              match v {\n                  Some(v) => is_value_valid(v),\n                  None => true,\n              },\n          CMessage::Reply{ k, v } =>\n              is_key_valid(k) &&\n              match v {\n                  Some(v) => is_value_valid(v),\n                  None => true,\n              },\n          CMessage::Redirect{ k, id } => is_key_valid(k) && id.valid_physical_address(),\n          CMessage::Shard{ kr, recipient } => recipient.valid_physical_address() && kr.lo.lt(&kr.hi),\n          CMessage::Delegate{ range, h } => range.lo.lt(&range.hi) && h.valid(),\n      }\n  }", "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "is_message_marshallable", "function_mode": "exec", "line_start": 153, "line_end": 174, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "CMessage"}}
{"id": "task_a_host_impl_v_host_model_next_set_request_92", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn host_model_next_set_request(&mut self) -> (sent_packets: Vec<CPacket>)\n    {\n        proof { self.delegation_map.valid_implies_complete(); }\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::SetRequest{k, v: ov} => {\n                        let owner: EndPoint = self.delegation_map.get(k);\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            let sent_packets = Vec::<CPacket>::new();\n                            let ghost sm = SingleMessage::Ack{ack_seqno: 0};\n                            proof {\n                                assert (!valid_key(*k) || !valid_optional_value(optional_value_view(*ov)));\n                                assert (sent_packets@ == Seq::<CPacket>::empty());\n                                assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                   Seq::<Packet>::empty());\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   extract_packets_from_lsht_packets(\n                                                       abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                                           sent_packets@)));\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   Set::<Packet>::empty());\n                                assert (next_set_request_complete(old(self)@, self@, pkt.src,\n                                                                  pkt.msg.arrow_Message_seqno(),\n                                                                  pkt.msg.arrow_Message_m(),\n                                                                  sm,\n                                                                  Message::Reply{key: *k,\n                                                                                 value: optional_value_view(*ov)},\n                                                                  Set::<Packet>::empty(), true));\n                                assert (next_set_request(old(self)@, self@, cpacket@,\n                                                         abstractify_seq_of_cpackets_to_set_of_sht_packets(\n                                                             sent_packets@)));\n                            };\n                            return sent_packets;\n                        }\n                        else {\n                            assert (valid_key(*k) && valid_optional_value(optional_value_view(*ov)));\n                            let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                            let mm: CMessage =\n                                if its_me {\n                                    CMessage::Reply{k: k.clone(), v: clone_optional_value(ov)}\n                                }\n                                else {\n                                    CMessage::Redirect{k: k.clone(), id: owner}\n                                };\n                            assert (mm.is_marshalable()) by {\n                                lemma_auto_spec_u64_to_from_le_bytes();\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&mm, &cpacket.src);\n                            let ghost received_request = AppRequest::AppSetRequest{seqno: seqno@ as nat, key: *k,\n                                                                                   ov: optional_value_view(*ov)};\n                            let mut sent_packets = Vec::<CPacket>::new();\n                            let ghost dst = cpacket.src@;\n                            match optional_sm {\n                                Some(sm) => {\n                                    let p = CPacket{dst: clone_end_point(&cpacket.src),\n                                                    src: clone_end_point(&self.constants.me),\n                                                    msg: sm};\n                                    assert (p@ == Packet{dst: cpacket.src@, src: self.constants.me@, msg: sm@});\n                                    sent_packets.push(p);\n                                    if its_me {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        self.received_requests = Ghost(self.received_requests@.push(received_request));\n                                        match ov {\n                                            Some(v) => self.h.insert(k.clone(), clone_vec_u8(v)),\n                                            None => self.h.remove(&k),\n                                        };\n                                        self.received_packet = None;\n                                    }\n                                    else {\n                                        self.received_packet = None;\n                                    }\n                                    proof {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                           seq![Packet{dst: cpacket.src@, src: self.constants.me@,\n                                                                       msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: cpacket.src@,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert_sets_equal!(\n                                            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                            set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (next_set_request_complete(\n                                                    old(self)@, self@, pkt.src,\n                                                    pkt.msg.arrow_Message_seqno(),\n                                                    m@, sm@, mm@,\n                                                    abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                    true));\n                                        assert (sm.is_marshalable()) by {\n                                            lemma_auto_spec_u64_to_from_le_bytes();\n                                        }\n                                        assert (outbound_packet_is_valid(&p));\n                                        assert (outbound_packet_seq_is_valid(sent_packets@));\n                                        assert (abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (sent_packets@.map_values(|packet: CPacket|\n                                                                  abstractify_cpacket_to_lsht_packet(packet))[0] ==\n                                                LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        singleton_seq_to_set_is_singleton_set(\n                                            LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        assert_seqs_equal!(\n                                            sent_packets@.map_values(|packet: CPacket|\n                                                              abstractify_cpacket_to_lsht_packet(packet)),\n                                            seq![LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)[0] ==\n                                                abstractify_cpacket_to_lsht_packet(p));\n                                        assert_seqs_equal!(\n                                            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                            seq![abstractify_cpacket_to_lsht_packet(p)]);\n                                        assert (extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@))\n                                                   == extract_packets_from_lsht_packets(\n                                                       seq![abstractify_cpacket_to_lsht_packet(p)]));\n                                        assert (seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))[0] ==\n                                                Packet {dst: pkt.src, src: self.constants.me@, msg: sm@} );\n                                        assert_seqs_equal!(\n                                            seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                            seq![Packet {dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: pkt.src,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert (extract_packets_from_lsht_packets(\n                                                    seq![abstractify_cpacket_to_lsht_packet(p)]) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (self.host_state_common_postconditions(\n                                            pre, pre.received_packet.unwrap(), sent_packets@));\n                                    }\n                                    return sent_packets;\n                                },\n                                None => {\n                                    self.received_packet = None;\n                                    proof {\n                                        let abs_sent_packets = abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@);\n                                        assert( abs_sent_packets =~= Set::<Packet>::empty() );\n                                        assert( abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@) =~= Seq::<LSHTPacket>::empty() );\n                                        assert( extract_packets_from_lsht_packets(Seq::<LSHTPacket>::empty()) =~= Set::<Packet>::empty() );\n\n                                        assert( next_set_request_complete(old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(), pkt.msg.arrow_Message_m(), arbitrary(), arbitrary(), abs_sent_packets, false) );   // exists witness\n                                    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        }\n    }\n```\n\nWrite the specifications:", "target_text": "requires old(self).next_set_request_preconditions(),\nensures self.next_set_request_postconditions(*old(self), sent_packets@),", "full_function": "    fn host_model_next_set_request(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires old(self).next_set_request_preconditions()\n        ensures  self.next_set_request_postconditions(*old(self), sent_packets@)\n    {\n        proof { self.delegation_map.valid_implies_complete(); }\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::SetRequest{k, v: ov} => {\n                        let owner: EndPoint = self.delegation_map.get(k);\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            let sent_packets = Vec::<CPacket>::new();\n                            let ghost sm = SingleMessage::Ack{ack_seqno: 0};\n                            proof {\n                                assert (!valid_key(*k) || !valid_optional_value(optional_value_view(*ov)));\n                                assert (sent_packets@ == Seq::<CPacket>::empty());\n                                assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                   Seq::<Packet>::empty());\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   extract_packets_from_lsht_packets(\n                                                       abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                                           sent_packets@)));\n                                assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                   Set::<Packet>::empty());\n                                assert (next_set_request_complete(old(self)@, self@, pkt.src,\n                                                                  pkt.msg.arrow_Message_seqno(),\n                                                                  pkt.msg.arrow_Message_m(),\n                                                                  sm,\n                                                                  Message::Reply{key: *k,\n                                                                                 value: optional_value_view(*ov)},\n                                                                  Set::<Packet>::empty(), true));\n                                assert (next_set_request(old(self)@, self@, cpacket@,\n                                                         abstractify_seq_of_cpackets_to_set_of_sht_packets(\n                                                             sent_packets@)));\n                            };\n                            return sent_packets;\n                        }\n                        else {\n                            assert (valid_key(*k) && valid_optional_value(optional_value_view(*ov)));\n                            let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                            let mm: CMessage =\n                                if its_me {\n                                    CMessage::Reply{k: k.clone(), v: clone_optional_value(ov)}\n                                }\n                                else {\n                                    CMessage::Redirect{k: k.clone(), id: owner}\n                                };\n                            assert (mm.is_marshalable()) by {\n                                lemma_auto_spec_u64_to_from_le_bytes();\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&mm, &cpacket.src);\n                            let ghost received_request = AppRequest::AppSetRequest{seqno: seqno@ as nat, key: *k,\n                                                                                   ov: optional_value_view(*ov)};\n                            let mut sent_packets = Vec::<CPacket>::new();\n                            let ghost dst = cpacket.src@;\n                            match optional_sm {\n                                Some(sm) => {\n                                    let p = CPacket{dst: clone_end_point(&cpacket.src),\n                                                    src: clone_end_point(&self.constants.me),\n                                                    msg: sm};\n                                    assert (p@ == Packet{dst: cpacket.src@, src: self.constants.me@, msg: sm@});\n                                    sent_packets.push(p);\n                                    if its_me {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        self.received_requests = Ghost(self.received_requests@.push(received_request));\n                                        match ov {\n                                            Some(v) => self.h.insert(k.clone(), clone_vec_u8(v)),\n                                            None => self.h.remove(&k),\n                                        };\n                                        self.received_packet = None;\n                                    }\n                                    else {\n                                        self.received_packet = None;\n                                    }\n                                    proof {\n                                        assert (SingleDelivery::send_single_message(old(self).sd@, self.sd@, mm@, dst, Some(sm@),\n                                                                                    AbstractParameters::static_params()));\n                                        assert_seqs_equal!(sent_packets@.map_values(|cp: CPacket| cp@),\n                                                           seq![Packet{dst: cpacket.src@, src: self.constants.me@,\n                                                                       msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: cpacket.src@,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert_sets_equal!(\n                                            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                            set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (next_set_request_complete(\n                                                    old(self)@, self@, pkt.src,\n                                                    pkt.msg.arrow_Message_seqno(),\n                                                    m@, sm@, mm@,\n                                                    abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                                    true));\n                                        assert (sm.is_marshalable()) by {\n                                            lemma_auto_spec_u64_to_from_le_bytes();\n                                        }\n                                        assert (outbound_packet_is_valid(&p));\n                                        assert (outbound_packet_seq_is_valid(sent_packets@));\n                                        assert (abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (sent_packets@.map_values(|packet: CPacket|\n                                                                  abstractify_cpacket_to_lsht_packet(packet))[0] ==\n                                                LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        singleton_seq_to_set_is_singleton_set(\n                                            LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@});\n                                        assert_seqs_equal!(\n                                            sent_packets@.map_values(|packet: CPacket|\n                                                              abstractify_cpacket_to_lsht_packet(packet)),\n                                            seq![LPacket{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)[0] ==\n                                                abstractify_cpacket_to_lsht_packet(p));\n                                        assert_seqs_equal!(\n                                            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                            seq![abstractify_cpacket_to_lsht_packet(p)]);\n                                        assert (extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@))\n                                                   == extract_packets_from_lsht_packets(\n                                                       seq![abstractify_cpacket_to_lsht_packet(p)]));\n                                        assert (seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))[0] ==\n                                                Packet {dst: pkt.src, src: self.constants.me@, msg: sm@} );\n                                        assert_seqs_equal!(\n                                            seq![abstractify_cpacket_to_lsht_packet(p)].\n                                                map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                            seq![Packet {dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        singleton_seq_to_set_is_singleton_set(Packet{dst: pkt.src,\n                                                                                     src: self.constants.me@,\n                                                                                     msg: sm@});\n                                        assert (extract_packets_from_lsht_packets(\n                                                    seq![abstractify_cpacket_to_lsht_packet(p)]) ==\n                                                set![Packet{dst: pkt.src, src: self.constants.me@, msg: sm@}]);\n                                        assert (self.host_state_common_postconditions(\n                                            pre, pre.received_packet.unwrap(), sent_packets@));\n                                    }\n                                    return sent_packets;\n                                },\n                                None => {\n                                    self.received_packet = None;\n                                    proof {\n                                        let abs_sent_packets = abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@);\n                                        assert( abs_sent_packets =~= Set::<Packet>::empty() );\n                                        assert( abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@) =~= Seq::<LSHTPacket>::empty() );\n                                        assert( extract_packets_from_lsht_packets(Seq::<LSHTPacket>::empty()) =~= Set::<Packet>::empty() );\n\n                                        assert( next_set_request_complete(old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(), pkt.msg.arrow_Message_m(), arbitrary(), arbitrary(), abs_sent_packets, false) );   // exists witness\n                                    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        }\n    }", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_model_next_set_request", "function_mode": "exec", "line_start": 1171, "line_end": 1332, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 1, "num_ensures": 1, "complexity_score": 60, "is_method": true, "impl_type": "HostState"}}
{"id": "task_a_single_delivery_state_v_new_4", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn new() -> (e: CAckState)\n    {\n         CAckState{ num_packets_acked: 0, un_acked: vec![] }\n//         let e = CAckState{ num_packets_acked: 0, un_acked: vec![] };\n//         assert( e@.num_packets_acked  == AckState::new().num_packets_acked );\n//         assert( e@.un_acked  =~= AckState::new().un_acked );\n//         e\n    }\n```\n\nWrite the specifications:", "target_text": "ensures e.num_packets_acked == 0, e.un_acked.len() == 0, e@ =~= AckState::new(),", "full_function": "\n    pub fn new() -> (e: CAckState)\n    ensures\n        e.num_packets_acked == 0,\n        e.un_acked.len() == 0,\n        e@ =~= AckState::new(),\n    {\n         CAckState{ num_packets_acked: 0, un_acked: vec![] }\n//         let e = CAckState{ num_packets_acked: 0, un_acked: vec![] };\n//         assert( e@.num_packets_acked  == AckState::new().num_packets_acked );\n//         assert( e@.un_acked  =~= AckState::new().un_acked );\n//         e\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "new", "function_mode": "exec", "line_start": 36, "line_end": 48, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "CAckState"}}
{"id": "task_a_host_impl_v_host_model_next_delegate_95", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn host_model_next_delegate(&mut self) -> (sent_packets: Vec<CPacket>)\n    {\n        let sent_packets = vec![];\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        proof {\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               Set::<Packet>::empty());\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               extract_packets_from_lsht_packets(\n                                   abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                       sent_packets@)));\n        };\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::Delegate{range, h} => {\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            assert (Self::host_ignoring_unparseable(\n                                pre@, self@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else if !endpoints_contain(&self.constants.host_ids, &cpacket.src) {\n                            self.received_packet = None;\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else {\n                            self.delegation_map.set(&range.lo, &range.hi, &self.constants.me);\n                            assert (valid_hashtable(h@));\n                            self.h.bulk_update(&range, &h);\n                            self.received_packet = None;\n                            self.num_delegations = self.num_delegations + 1;\n                            proof {\n                                Self::effect_of_delegation_map_set(pre.delegation_map, self.delegation_map,\n                                                                   &range.lo, &range.hi, &self.constants.me);\n                                Self::effect_of_hashmap_bulk_update(pre.h, self.h, &range, *h);\n                            }\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        };\n        assert(false); unreached()\n    }\n```\n\nWrite the specifications:", "target_text": "requires old(self).next_delegate_preconditions(),\nensures self.next_delegate_postconditions(*old(self), sent_packets@),", "full_function": "    fn host_model_next_delegate(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires\n            old(self).next_delegate_preconditions(),\n        ensures\n            self.next_delegate_postconditions(*old(self), sent_packets@),\n    {\n        let sent_packets = vec![];\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        proof {\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               Set::<Packet>::empty());\n            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                               extract_packets_from_lsht_packets(\n                                   abstractify_outbound_packets_to_seq_of_lsht_packets(\n                                       sent_packets@)));\n        };\n        match &cpacket.msg {\n            CSingleMessage::Message{m, seqno, ..} => {\n                match m {\n                    CMessage::Delegate{range, h} => {\n                        let marshalable: bool = m.is_message_marshallable();\n                        if (!marshalable) {\n                            self.received_packet = None;\n                            assert (Self::host_ignoring_unparseable(\n                                pre@, self@, abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else if !endpoints_contain(&self.constants.host_ids, &cpacket.src) {\n                            self.received_packet = None;\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                        else {\n                            self.delegation_map.set(&range.lo, &range.hi, &self.constants.me);\n                            assert (valid_hashtable(h@));\n                            self.h.bulk_update(&range, &h);\n                            self.received_packet = None;\n                            self.num_delegations = self.num_delegations + 1;\n                            proof {\n                                Self::effect_of_delegation_map_set(pre.delegation_map, self.delegation_map,\n                                                                   &range.lo, &range.hi, &self.constants.me);\n                                Self::effect_of_hashmap_bulk_update(pre.h, self.h, &range, *h);\n                            }\n                            assert (next_delegate(pre@, self@, pre.received_packet.unwrap()@,\n                                                  abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@)));\n                            return sent_packets;\n                        }\n                    },\n                    _ => { assert(false); unreached() },\n                }\n            },\n            _ => { assert(false); unreached() },\n        };\n        assert(false); unreached()\n    }", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_model_next_delegate", "function_mode": "exec", "line_start": 1377, "line_end": 1435, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 1, "num_ensures": 1, "complexity_score": 28, "is_method": true, "impl_type": "HostState"}}
{"id": "task_a_keys_t_clone_105", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn clone(&self) -> (out: SHTKey)\n    {\n        SHTKey{ ukey: self.ukey }\n    }\n```\n\nWrite the specifications:", "target_text": "ensures out == self,", "full_function": "\n    pub fn clone(&self) -> (out: SHTKey)\n    ensures out == self\n    {\n        SHTKey{ ukey: self.ukey }\n    }", "metadata": {"source_file": "../ironsht/src/keys_t.rs", "function_name": "clone", "function_mode": "exec", "line_start": 149, "line_end": 154, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "SHTKey"}}
{"id": "task_a_host_impl_v_real_next_impl_100", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn real_next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    {\n        proof { old(self).delegation_map.valid_implies_complete(); }\n        let cur_action_index = self.next_action_index;\n        let rc;\n        if cur_action_index == 0 {\n            rc = self.receive_packet_next(netc);\n        } else if cur_action_index == 1 {\n            let ghost old_self: HostState = *self;\n            let ghost old_netc: NetClient = *netc;\n            rc = self.process_received_packet_next_impl(netc);\n            proof {\n                let (ok, res) = rc; {\n                    if ok {\n                        if process_received_packet_next(old_self@, self@, abstractify_raw_log_to_ios(res@.ios)) {\n                            assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res@.ios),\n                                              Step::ProcessReceivedPacket{})); // establish exists |step| next_step...\n                        }\n                        else {\n                            assert (ignore_nonsensical_delegation_packet(old_self@, self@,\n                                                                         abstractify_raw_log_to_ios(res@.ios)));\n                            // establish exists |step| next_step...\n                            assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res@.ios),\n                                              Step::IgnoreNonsensicalDelegationPacket{}));\n                        }\n                        assert (host_protocol_t::next(old_self@, self@, abstractify_raw_log_to_ios(res@.ios)));\n                    }\n                }\n            }\n        } else if cur_action_index == 2 {\n            self.resend_count = (self.resend_count + 1) % 100000000;\n            if (self.resend_count == 0) {\n                rc = self.host_noreceive_noclock_next(netc);\n                assert( rc.0 ==> Self::next(old(self)@, self@, rc.1@.ios) );\n            } else {\n                rc = (true, make_empty_event_results());\n                assert( next_step(old(self)@, self@, abstractify_raw_log_to_ios(rc.1@.ios), Step::SpontaneouslyRetransmit{}));    // witness\n            }\n        } else {\n            assert (false);\n            rc = unreached()\n        }\n\n        if !rc.0 { return rc; }\n\n        assert(self.invariants(&netc.my_end_point()));\n        self.next_action_index = (self.next_action_index + 1) % 3;\n        proof {\n            let (ok, res) = rc;\n            assert(res@.event_seq() == res@.ios);\n            assert((ok || res@.sends.len()>0) ==> netc.history() == old(netc).history() + res@.event_seq());\n        }\n        rc\n    }\n```\n\nWrite the specifications:", "target_text": "requires Self::next_requires(*old(self), *old(netc)),\nensures Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),", "full_function": "\n    pub fn real_next_impl(&mut self, netc: &mut NetClient) -> (rc: (bool, Ghost<EventResults>))\n    requires\n        Self::next_requires(*old(self), *old(netc)),\n    ensures\n        Self::next_ensures(*old(self), *old(netc), *self, *netc, rc),\n    {\n        proof { old(self).delegation_map.valid_implies_complete(); }\n        let cur_action_index = self.next_action_index;\n        let rc;\n        if cur_action_index == 0 {\n            rc = self.receive_packet_next(netc);\n        } else if cur_action_index == 1 {\n            let ghost old_self: HostState = *self;\n            let ghost old_netc: NetClient = *netc;\n            rc = self.process_received_packet_next_impl(netc);\n            proof {\n                let (ok, res) = rc; {\n                    if ok {\n                        if process_received_packet_next(old_self@, self@, abstractify_raw_log_to_ios(res@.ios)) {\n                            assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res@.ios),\n                                              Step::ProcessReceivedPacket{})); // establish exists |step| next_step...\n                        }\n                        else {\n                            assert (ignore_nonsensical_delegation_packet(old_self@, self@,\n                                                                         abstractify_raw_log_to_ios(res@.ios)));\n                            // establish exists |step| next_step...\n                            assert (next_step(old_self@, self@, abstractify_raw_log_to_ios(res@.ios),\n                                              Step::IgnoreNonsensicalDelegationPacket{}));\n                        }\n                        assert (host_protocol_t::next(old_self@, self@, abstractify_raw_log_to_ios(res@.ios)));\n                    }\n                }\n            }\n        } else if cur_action_index == 2 {\n            self.resend_count = (self.resend_count + 1) % 100000000;\n            if (self.resend_count == 0) {\n                rc = self.host_noreceive_noclock_next(netc);\n                assert( rc.0 ==> Self::next(old(self)@, self@, rc.1@.ios) );\n            } else {\n                rc = (true, make_empty_event_results());\n                assert( next_step(old(self)@, self@, abstractify_raw_log_to_ios(rc.1@.ios), Step::SpontaneouslyRetransmit{}));    // witness\n            }\n        } else {\n            assert (false);\n            rc = unreached()\n        }\n\n        if !rc.0 { return rc; }\n\n        assert(self.invariants(&netc.my_end_point()));\n        self.next_action_index = (self.next_action_index + 1) % 3;\n        proof {\n            let (ok, res) = rc;\n            assert(res@.event_seq() == res@.ios);\n            assert((ok || res@.sends.len()>0) ==> netc.history() == old(netc).history() + res@.event_seq());\n        }\n        rc\n    }", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "real_next_impl", "function_mode": "exec", "line_start": 1778, "line_end": 1836, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 1, "num_ensures": 1, "complexity_score": 29, "is_method": true, "impl_type": "HostState"}}
{"id": "task_a_endpoint_hashmap_t_put_68", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn put(&mut self, key: &EndPoint, value: V)\n    {\n        self.insert(key, value);\n    }\n```\n\nWrite the specifications:", "target_text": "ensures Self::put_spec(old(self)@, self@, key@, value),", "full_function": "    pub fn put(&mut self, key: &EndPoint, value: V)\n    ensures\n        Self::put_spec(old(self)@, self@, key@, value),\n    {\n        self.insert(key, value);\n    }", "metadata": {"source_file": "../ironsht/src/endpoint_hashmap_t.rs", "function_name": "put", "function_mode": "exec", "line_start": 84, "line_end": 89, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "HashMap<V>"}}
{"id": "task_a_single_delivery_model_v_receive_impl_21", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn receive_impl(&mut self, pkt: &CPacket) -> (rr: ReceiveImplResult)\n    {\n        match pkt.msg {\n            CSingleMessage::Ack{..} => {\n                self.receive_ack_impl(pkt);\n                let rr = ReceiveImplResult::AckOrInvalid{};\n                rr\n            },\n            CSingleMessage::Message{..} => {\n                let packet_is_fresh = self.receive_real_packet_impl(pkt);\n                let opt_ack = self.maybe_ack_packet_impl(pkt);\n\n                match opt_ack {\n                    Some(ack) => {\n                        let rr =\n                            if packet_is_fresh {\n                                ReceiveImplResult::FreshPacket{ack}\n                            } else {\n                                ReceiveImplResult::DuplicatePacket{ack}\n                            };\n                        assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n                        rr\n                    }\n                    None => {\n                        assert( Self::option_cpacket_to_set_packet(opt_ack).is_empty() );   // this is an unfortunate trigger to need\n                        let rr = ReceiveImplResult::AckOrInvalid{};\n                        rr\n                    }\n                }\n            },\n            CSingleMessage::InvalidMessage{..} => {\n                let rr = ReceiveImplResult::AckOrInvalid{};\n//                 assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n//                 assert( self.valid() );\n                rr\n            },\n        }\n    }\n```\n\nWrite the specifications:", "target_text": "requires old(self).valid(), old(self).abstractable(), pkt.abstractable(),\nrequires old(self).valid(), old(self).abstractable(), m.abstractable(), m.message_marshallable(), m.is_marshalable(), dst@.valid_physical_address(),\nensures self.valid(), rr.valid_ack(*pkt), SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()), rr is FreshPacket ==> SingleDelivery::new_single_message(old(self)@, pkt@), rr is DuplicatePacket ==> !SingleDelivery::new_single_message(old(self)@, pkt@), { match pkt.msg { CSingleMessage::Ack{..} => { self.receive_ack_impl(pkt); let rr = ReceiveImplResult::AckOrInvalid{}; rr }, CSingleMessage::Message{..} => { let packet_is_fresh = self.receive_real_packet_impl(pkt); let opt_ack = self.maybe_ack_packet_impl(pkt); match opt_ack { Some(ack) => { let rr = if packet_is_fresh { ReceiveImplResult::FreshPacket{ack} } else { ReceiveImplResult::DuplicatePacket{ack} }; assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) ); rr } None => { assert( Self::option_cpacket_to_set_packet(opt_ack).is_empty() ); // this is an unfortunate trigger to need let rr = ReceiveImplResult::AckOrInvalid{}; rr } } }, CSingleMessage::InvalidMessage{..} => { let rr = ReceiveImplResult::AckOrInvalid{}; // assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) ); // assert( self.valid() ); rr }, } } /// Translates Impl/SHT/SingleDeliveryModel.i.dfy :: SendSingleCMessage #[verifier::rlimit(15)] pub fn send_single_cmessage(&mut self, m: &CMessage, dst: &EndPoint) -> (sm: Option<CSingleMessage>),\nensures self.valid(), match sm,", "full_function": "    pub fn receive_impl(&mut self, pkt: &CPacket) -> (rr: ReceiveImplResult)\n    requires\n        old(self).valid(),\n        old(self).abstractable(),\n        pkt.abstractable(),\n    ensures\n        self.valid(),\n        rr.valid_ack(*pkt),\n        SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()),\n        rr is FreshPacket ==> SingleDelivery::new_single_message(old(self)@, pkt@),\n        rr is DuplicatePacket ==> !SingleDelivery::new_single_message(old(self)@, pkt@),\n    {\n        match pkt.msg {\n            CSingleMessage::Ack{..} => {\n                self.receive_ack_impl(pkt);\n                let rr = ReceiveImplResult::AckOrInvalid{};\n                rr\n            },\n            CSingleMessage::Message{..} => {\n                let packet_is_fresh = self.receive_real_packet_impl(pkt);\n                let opt_ack = self.maybe_ack_packet_impl(pkt);\n\n                match opt_ack {\n                    Some(ack) => {\n                        let rr =\n                            if packet_is_fresh {\n                                ReceiveImplResult::FreshPacket{ack}\n                            } else {\n                                ReceiveImplResult::DuplicatePacket{ack}\n                            };\n                        assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n                        rr\n                    }\n                    None => {\n                        assert( Self::option_cpacket_to_set_packet(opt_ack).is_empty() );   // this is an unfortunate trigger to need\n                        let rr = ReceiveImplResult::AckOrInvalid{};\n                        rr\n                    }\n                }\n            },\n            CSingleMessage::InvalidMessage{..} => {\n                let rr = ReceiveImplResult::AckOrInvalid{};\n//                 assert( SingleDelivery::receive(old(self)@, self@, pkt@, rr.get_ack()@, rr.get_abstracted_ack_set()) );\n//                 assert( self.valid() );\n                rr\n            },\n        }\n    }\n\n    /// Translates Impl/SHT/SingleDeliveryModel.i.dfy :: SendSingleCMessage\n    #[verifier::rlimit(15)]\n    pub fn send_single_cmessage(&mut self, m: &CMessage, dst: &EndPoint) -> (sm: Option<CSingleMessage>)\n        requires\n            old(self).valid(),\n            old(self).abstractable(),\n            m.abstractable(),\n            m.message_marshallable(),\n            m.is_marshalable(),\n            dst@.valid_physical_address(),\n        ensures\n            self.valid(),\n            match sm {\n                Some(sm) => {\n                    &&& sm.abstractable()\n                    &&& sm is Message\n                    &&& sm.arrow_Message_dst()@ == dst@\n                    &&& SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, Some(sm@), AbstractParameters::static_params())\n                    &&& sm.is_marshalable()\n                },\n                None =>\n                    SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, None, AbstractParameters::static_params()),\n            }", "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "receive_impl", "function_mode": "exec", "line_start": 343, "line_end": 414, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 2, "num_ensures": 2, "complexity_score": 8, "is_method": true, "impl_type": "CSingleDelivery"}}
{"id": "task_a_host_impl_v_make_send_only_event_results_102", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn make_send_only_event_results(net_events: Ghost<Seq<NetEvent>>) -> (res: Ghost<EventResults>)\n{\n    let ghost res = EventResults {\n        recvs: Seq::<NetEvent>::empty(),\n        clocks: Seq::<NetEvent>::empty(),\n        sends: net_events@,\n        ios: net_events@,\n    };\n    assert (forall |i| 0 <= i < res.recvs.len() ==> res.recvs[i] is Receive);\n    assert (forall |i| 0 <= i < res.clocks.len() ==> res.clocks[i] is ReadClock || res.clocks[i] is TimeoutReceive);\n    assert (forall |i| 0 <= i < res.sends.len() ==> res.sends[i] is Send);\n    assert (res.clocks.len() <= 1);\n    assert (res.well_typed_events());\n    proof { assert_seqs_equal!(res.event_seq(), net_events@); };\n    Ghost(res)\n}\n```\n\nWrite the specifications:", "target_text": "requires forall |i: int| 0 <= i && i < net_events@.len() ==> net_events@[i] is Send,\nensures res@.recvs == Seq::<NetEvent>::empty(), res@.clocks == Seq::<NetEvent>::empty(), res@.sends == net_events@, res@.ios == net_events@, res@.event_seq() == net_events@, res@.well_typed_events(),", "full_function": "\npub fn make_send_only_event_results(net_events: Ghost<Seq<NetEvent>>) -> (res: Ghost<EventResults>)\n    requires\n        forall |i: int| 0 <= i && i < net_events@.len() ==> net_events@[i] is Send\n    ensures\n        res@.recvs == Seq::<NetEvent>::empty(),\n        res@.clocks == Seq::<NetEvent>::empty(),\n        res@.sends == net_events@,\n        res@.ios == net_events@,\n        res@.event_seq() == net_events@,\n        res@.well_typed_events(),\n{\n    let ghost res = EventResults {\n        recvs: Seq::<NetEvent>::empty(),\n        clocks: Seq::<NetEvent>::empty(),\n        sends: net_events@,\n        ios: net_events@,\n    };\n    assert (forall |i| 0 <= i < res.recvs.len() ==> res.recvs[i] is Receive);\n    assert (forall |i| 0 <= i < res.clocks.len() ==> res.clocks[i] is ReadClock || res.clocks[i] is TimeoutReceive);\n    assert (forall |i| 0 <= i < res.sends.len() ==> res.sends[i] is Send);\n    assert (res.clocks.len() <= 1);\n    assert (res.well_typed_events());\n    proof { assert_seqs_equal!(res.event_seq(), net_events@); };\n    Ghost(res)\n}", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "make_send_only_event_results", "function_mode": "exec", "line_start": 169, "line_end": 194, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 1, "num_ensures": 1, "complexity_score": 17, "is_method": false, "impl_type": null}}
{"id": "task_a_cmessage_v_is_marshallable_77", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn is_marshallable(&self) -> (b: bool)\n  {\n      match self {\n          CSingleMessage::Ack{ack_seqno} => true,\n          CSingleMessage::Message{seqno, dst, m} => dst.valid_physical_address() && m.is_message_marshallable(),\n          CSingleMessage::InvalidMessage{} => false,\n      }\n  }\n```\n\nWrite the specifications:", "target_text": "ensures b == self.marshallable(),", "full_function": "  pub fn is_marshallable(&self) -> (b: bool)\n      ensures b == self.marshallable()\n  {\n      match self {\n          CSingleMessage::Ack{ack_seqno} => true,\n          CSingleMessage::Message{seqno, dst, m} => dst.valid_physical_address() && m.is_message_marshallable(),\n          CSingleMessage::InvalidMessage{} => false,\n      }\n  }", "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "is_marshallable", "function_mode": "exec", "line_start": 271, "line_end": 279, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "CSingleMessage"}}
{"id": "task_a_single_delivery_state_v_lookup_9", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn lookup(&self, src: &EndPoint) -> (last_seqno: u64)\n    {\n        match self.epmap.get(src) {\n            Some(v) => *v,\n            _ => 0,\n        }\n    }\n```\n\nWrite the specifications:", "target_text": "ensures last_seqno as int == tombstone_table_lookup(src@, self@),", "full_function": "    pub fn lookup(&self, src: &EndPoint) -> (last_seqno: u64)\n    ensures\n        last_seqno as int == tombstone_table_lookup(src@, self@),\n    {\n        match self.epmap.get(src) {\n            Some(v) => *v,\n            _ => 0,\n        }\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "lookup", "function_mode": "exec", "line_start": 212, "line_end": 220, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "CTombstoneTable"}}
{"id": "task_a_host_impl_v_parse_end_point_82", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn parse_end_point(arg: &Arg) -> (out: EndPoint)\n    {\n        EndPoint{id: clone_arg(arg)}\n    }\n```\n\nWrite the specifications:", "target_text": "ensures out@ == host_protocol_t::parse_arg_as_end_point(arg@),", "full_function": "\n    fn parse_end_point(arg: &Arg) -> (out: EndPoint)\n    ensures\n        out@ == host_protocol_t::parse_arg_as_end_point(arg@),\n    {\n        EndPoint{id: clone_arg(arg)}\n    }", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "parse_end_point", "function_mode": "exec", "line_start": 279, "line_end": 285, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "HostState"}}
{"id": "task_a_host_impl_v_deliver_packet_seq_85", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn deliver_packet_seq(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n```\n\nWrite the specifications:", "target_text": "requires\n            old(netc).ok(),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),", "full_function": "    pub fn deliver_packet_seq(&self, netc: &mut NetClient, packets: &Vec<CPacket>) ->\n        (rc: (bool, Ghost<Seq<NetEvent>>, Ghost<Seq<LSHTIo>>))\n        requires\n            old(netc).ok(),\n            outbound_packet_seq_is_valid(packets@),\n            outbound_packet_seq_has_correct_srcs(packets@, old(netc).my_end_point()),\n        ensures\n            netc.my_end_point() == old(netc).my_end_point(),\n            ({\n                let (ok, Ghost(net_events), Ghost(ios)) = rc;\n                {\n                    &&& netc.ok() <==> ok\n                    &&& ok ==> {\n                        &&& all_ios_are_sends(ios)\n                        &&& (forall |i: int| 0 <= i && i < net_events.len() ==> net_events[i] is Send)\n                        &&& ios == map_sent_packet_seq_to_ios(packets@)\n                        &&& abstractify_outbound_packets_to_seq_of_lsht_packets(packets@) ==\n                                extract_sent_packets_from_ios(ios)\n                        &&& abstractify_seq_of_cpackets_to_set_of_sht_packets(packets@) ==\n                                extract_packets_from_abstract_ios(ios)\n                        &&& no_invalid_sends(ios)\n                        &&& raw_io_consistent_with_spec_io(net_events, ios)\n                        &&& only_sent_marshalable_data(net_events)\n                        &&& netc.history() == old(netc).history() + net_events\n                    }\n                }\n            }", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "deliver_packet_seq", "function_mode": "exec", "line_start": 433, "line_end": 459, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 8, "is_method": true, "impl_type": "HostState"}}
{"id": "task_a_single_delivery_model_v_receive_real_packet_impl_20", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn receive_real_packet_impl(&mut self, pkt: &CPacket) -> (packet_is_fresh: bool)\n    {\n        // We inlined NewSingleMessageImpl here.\n        let last_seqno = self.receive_state.lookup(&pkt.src);\n        match pkt.msg {\n            CSingleMessage::Message{seqno: pkt_seqno, ..} => {\n                let packet_is_fresh = pkt_seqno > 0 && pkt_seqno - 1 == last_seqno;\n                if packet_is_fresh {\n                    self.receive_state.insert(&pkt.src, last_seqno + 1);\n                }\n                packet_is_fresh \n            }\n            _ => { assert(false); unreached() }\n        }\n\n    }\n```\n\nWrite the specifications:", "target_text": "requires old(self).valid(), pkt.abstractable(), pkt.msg is Message,\nensures self.valid(), SingleDelivery::receive_real_packet(old(self)@, self@, pkt@), packet_is_fresh == SingleDelivery::new_single_message(old(self)@, pkt@),", "full_function": "    pub fn receive_real_packet_impl(&mut self, pkt: &CPacket) -> (packet_is_fresh: bool)\n    requires\n        old(self).valid(),\n        pkt.abstractable(),\n        pkt.msg is Message,\n    ensures\n        self.valid(),\n        SingleDelivery::receive_real_packet(old(self)@, self@, pkt@),\n        packet_is_fresh == SingleDelivery::new_single_message(old(self)@, pkt@),\n    {\n        // We inlined NewSingleMessageImpl here.\n        let last_seqno = self.receive_state.lookup(&pkt.src);\n        match pkt.msg {\n            CSingleMessage::Message{seqno: pkt_seqno, ..} => {\n                let packet_is_fresh = pkt_seqno > 0 && pkt_seqno - 1 == last_seqno;\n                if packet_is_fresh {\n                    self.receive_state.insert(&pkt.src, last_seqno + 1);\n                }\n                packet_is_fresh \n            }\n            _ => { assert(false); unreached() }\n        }\n\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_model_v.rs", "function_name": "receive_real_packet_impl", "function_mode": "exec", "line_start": 252, "line_end": 275, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 5, "is_method": true, "impl_type": "CSingleDelivery"}}
{"id": "task_a_delegation_map_v_set_118", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn set(&mut self, i: usize, k: K)\n    {\n        self.v.set(i, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n\n        assert forall |i, j| 0 <= i < self@.len() && 0 <= j < self@.len() && i != j implies self@[i] != self@[j] by {\n            K::cmp_properties();\n        }\n\n    }\n```\n\nWrite the specifications:", "target_text": "requires old(self).valid(), i < old(self)@.len(), i > 0 ==> old(self)@[i as int - 1].cmp_spec(k).lt(), i < old(self)@.len() - 1 ==> k.cmp_spec(old(self)@[i as int + 1]).lt(),\nensures self.valid(), self@ == old(self)@.update(i as int, k),", "full_function": "\n    fn set(&mut self, i: usize, k: K)\n        requires old(self).valid(),\n                 i < old(self)@.len(),\n                 i > 0 ==> old(self)@[i as int - 1].cmp_spec(k).lt(),\n                 i < old(self)@.len() - 1 ==> k.cmp_spec(old(self)@[i as int + 1]).lt(),\n        ensures\n            self.valid(),\n            self@ == old(self)@.update(i as int, k),\n    {\n        self.v.set(i, k);\n        assert forall |m, n| 0 <= m < n < self@.len() implies #[trigger](self@[m].cmp_spec(self@[n]).lt()) by {\n            K::cmp_properties();\n        }\n\n        assert forall |i, j| 0 <= i < self@.len() && 0 <= j < self@.len() && i != j implies self@[i] != self@[j] by {\n            K::cmp_properties();\n        }\n\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "set", "function_mode": "exec", "line_start": 147, "line_end": 166, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 6, "is_method": true, "impl_type": "StrictlyOrderedVec<K>"}}
{"id": "task_a_host_impl_v_static_params_81", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn static_params() -> (out: Parameters)\n    {\n        Parameters {\n            max_seqno: 0xffff_ffff_ffff_ffff,\n            max_delegations: 0x7FFF_FFFF_FFFF_FFFF,\n        }\n    }\n```\n\nWrite the specifications:", "target_text": "ensures out@ == AbstractParameters::static_params(),", "full_function": "    pub fn static_params() -> (out: Parameters)\n    ensures\n        out@ == AbstractParameters::static_params(),\n    {\n        Parameters {\n            max_seqno: 0xffff_ffff_ffff_ffff,\n            max_delegations: 0x7FFF_FFFF_FFFF_FFFF,\n        }\n    }", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "static_params", "function_mode": "exec", "line_start": 96, "line_end": 104, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "Parameters"}}
{"id": "task_a_io_t_reset_58", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn reset(&mut self)\n    {\n        self.state = Ghost(State::Receiving);\n    }\n```\n\nWrite the specifications:", "target_text": "requires from_trusted_code(),\nensures self.state() is Receiving, self.my_end_point() == old(self).my_end_point(),", "full_function": "    pub fn reset(&mut self)\n        requires\n            from_trusted_code()\n        ensures\n            self.state() is Receiving,\n            self.my_end_point() == old(self).my_end_point()\n    {\n        self.state = Ghost(State::Receiving);\n    }", "metadata": {"source_file": "../ironsht/src/io_t.rs", "function_name": "reset", "function_mode": "exec", "line_start": 224, "line_end": 232, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 6, "is_method": true, "impl_type": "NetClient"}}
{"id": "task_a_single_delivery_state_v_cack_state_swap_12", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn cack_state_swap(&mut self, src: &EndPoint, ack_state: &mut CAckState, default: CAckState)\n    {\n        self.epmap.swap(src, ack_state, default)\n    }\n```\n\nWrite the specifications:", "target_text": "requires old(self).valid(), src.abstractable(),\nensures HashMap::swap_spec(old(self).epmap@, self.epmap@, src@, *old(ack_state), *ack_state, default),", "full_function": "    pub fn cack_state_swap(&mut self, src: &EndPoint, ack_state: &mut CAckState, default: CAckState)\n    requires\n        old(self).valid(),\n        src.abstractable(),\n    ensures\n        HashMap::swap_spec(old(self).epmap@, self.epmap@, src@, *old(ack_state), *ack_state, default),\n    {\n        self.epmap.swap(src, ack_state, default)\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "cack_state_swap", "function_mode": "exec", "line_start": 283, "line_end": 291, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "CSendState"}}
{"id": "task_a_delegation_map_v_is_gt_111", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub const fn is_gt(self) -> (b:bool)\n    {\n        matches!(self, Ordering::Greater)\n    }\n```\n\nWrite the specifications:", "target_text": "ensures b == self.gt(),", "full_function": "\n    pub const fn is_gt(self) -> (b:bool)\n        ensures b == self.gt(),\n    {\n        matches!(self, Ordering::Greater)\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "is_gt", "function_mode": "exec", "line_start": 60, "line_end": 65, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "Ordering"}}
{"id": "task_a_delegation_map_v_lt_126", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn lt(&self, other: &Self) -> (b: bool)\n    {\n        (!self.is_end() && other.is_end())\n            || (!self.is_end() && !other.is_end() && self.k.as_ref().unwrap().cmp(&other.k.as_ref().unwrap()).is_lt())\n    }\n```\n\nWrite the specifications:", "target_text": "ensures b == self.lt_spec(*other),", "full_function": "    pub fn lt(&self, other: &Self) -> (b: bool)\n        ensures b == self.lt_spec(*other),\n    {\n        (!self.is_end() && other.is_end())\n            || (!self.is_end() && !other.is_end() && self.k.as_ref().unwrap().cmp(&other.k.as_ref().unwrap()).is_lt())\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "lt", "function_mode": "exec", "line_start": 387, "line_end": 392, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "KeyIterator<K>"}}
{"id": "task_a_delegation_map_v_is_end_124", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(when_used_as_spec(is_end_spec))]\n    pub fn is_end(&self) -> (b: bool)\n    {\n        matches!(self.k, None)\n    }\n```\n\nWrite the specifications:", "target_text": "ensures b == self.is_end_spec(),", "full_function": "\n    #[verifier(when_used_as_spec(is_end_spec))]\n    pub fn is_end(&self) -> (b: bool)\n        ensures b == self.is_end_spec()\n    {\n        matches!(self.k, None)\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "is_end", "function_mode": "exec", "line_start": 353, "line_end": 359, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "KeyIterator<K>"}}
{"id": "task_a_seq_is_unique_v_clone_end_point_29", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn clone_end_point(ep: &EndPoint) -> (cloned_ep: EndPoint)\n    {\n        EndPoint{id: clone_vec_u8(&ep.id)}\n    }\n```\n\nWrite the specifications:", "target_text": "ensures cloned_ep@ == ep@,", "full_function": "\n    pub fn clone_end_point(ep: &EndPoint) -> (cloned_ep: EndPoint)\n        ensures\n            cloned_ep@ == ep@\n    {\n        EndPoint{id: clone_vec_u8(&ep.id)}\n    }", "metadata": {"source_file": "../ironsht/src/seq_is_unique_v.rs", "function_name": "clone_end_point", "function_mode": "exec", "line_start": 137, "line_end": 143, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": false, "impl_type": null}}
{"id": "task_a_host_impl_v_should_process_received_message_impl_90", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn should_process_received_message_impl(&self) -> (b: bool)\n    {\n        match &self.received_packet {\n            Some(v) => {\n                match &v.msg {\n                    CSingleMessage::Message{seqno: _seqno, dst: _dst, m: cm} => {\n                        match cm {\n                            CMessage::Delegate{..} | CMessage::Shard{..} => {\n                                // We can't just compare self.num_delegations <\n                                // self.constants.params.max_delegations - 2 because the\n                                // latter quantity might underflow. So we do the following,\n                                // which is equivalent but can't overflow or underflow because\n                                // self.num_delegations < self.constants.params.max_delegations.\n                                self.num_delegations + 1 < self.constants.params.max_delegations - 1\n                            },\n                            _ => true,\n                        }\n                    },\n                    _ => false,\n                }\n            },\n            None => false,\n        }\n    }\n```\n\nWrite the specifications:", "target_text": "requires self.num_delegations < self.constants.params.max_delegations // part of,\nensures b == should_process_received_message(self@),", "full_function": "    fn should_process_received_message_impl(&self) -> (b: bool)\n        requires self.num_delegations < self.constants.params.max_delegations // part of invariants()\n        ensures  b == should_process_received_message(self@)\n    {\n        match &self.received_packet {\n            Some(v) => {\n                match &v.msg {\n                    CSingleMessage::Message{seqno: _seqno, dst: _dst, m: cm} => {\n                        match cm {\n                            CMessage::Delegate{..} | CMessage::Shard{..} => {\n                                // We can't just compare self.num_delegations <\n                                // self.constants.params.max_delegations - 2 because the\n                                // latter quantity might underflow. So we do the following,\n                                // which is equivalent but can't overflow or underflow because\n                                // self.num_delegations < self.constants.params.max_delegations.\n                                self.num_delegations + 1 < self.constants.params.max_delegations - 1\n                            },\n                            _ => true,\n                        }\n                    },\n                    _ => false,\n                }\n            },\n            None => false,\n        }\n    }", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "should_process_received_message_impl", "function_mode": "exec", "line_start": 833, "line_end": 858, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "HostState"}}
{"id": "task_a_delegation_map_v_keys_in_index_range_agree_134", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn keys_in_index_range_agree(&self, lo: usize, hi: usize, v: &ID) -> (ret:(bool, bool))\n    {\n        let (agree, almost) = self.values_agree(lo, hi, v);\n        proof {\n            if agree {\n            } else {\n                assert(!forall |i| #![auto] lo <= i <= hi ==> self.vals@[i]@ == v@);\n                let i = choose |i| #![auto] !(lo <= i <= hi ==> self.vals@.index(i)@ == v@);\n                assert(self.vals@.index(i)@ != v@);\n                assert(self@[self.keys@[i]]@ == self.vals@.index(i)@);\n                if almost {\n                } else {\n                    assert(!(self.vals@[hi as int]@ != v@ && forall |i| #![auto] lo <= i < hi ==> self.vals@[i]@ == v@));\n                    if self.vals@[hi as int]@ == v@ {\n                    } else {\n                        let j = choose |j| #![auto] lo <= j < hi && self.vals@[j]@ != v@;\n                        assert(self@[self.keys@[j]]@ != v@);\n                    }\n                }\n            }\n        }\n        (agree, almost)\n    }\n```\n\nWrite the specifications:", "target_text": "requires self.valid(), 0 <= lo <= hi < self.keys@.len(),\nrequires // self.valid(), // 0 <= lo_index <= hi_index < self.keys@.len(), // lo == self.keys@[lo_index as int], // hi == self.keys@[hi_index as int], //,\nensures ret.0 == forall |i| #![auto] lo <= i <= hi ==> self@[self.keys@[i]]@ == v@, !ret.0 ==> (ret.1 == (self@[self.keys@[hi as int]]@ != v@ && (forall |i| #![auto] lo <= i < hi ==> self@[self.keys@[i]]@ == v@))), { let (agree, almost) = self.values_agree(lo, hi, v); proof { if agree { } else { assert(!forall |i| #![auto] lo <= i <= hi ==> self.vals@[i]@ == v@); let i = choose |i| #![auto] !(lo <= i <= hi ==> self.vals@.index(i)@ == v@); assert(self.vals@.index(i)@ != v@); assert(self@[self.keys@[i]]@ == self.vals@.index(i)@); if almost { } else { assert(!(self.vals@[hi as int]@ != v@ && forall |i| #![auto] lo <= i < hi ==> self.vals@[i]@ == v@)); if self.vals@[hi as int]@ == v@ { } else { let j = choose |j| #![auto] lo <= j < hi && self.vals@[j]@ != v@; assert(self@[self.keys@[j]]@ != v@); } } } } (agree, almost) } // // All keys present in the range [lo .. hi] map `v` // fn keys_agree(&self, ghost(lo): Ghost<&K>, lo_index: usize, ghost(hi): Ghost<&K>, hi_index: usize, v: &ID) -> (b: bool) //,\nensures b == forall |k| #![auto] // lo.cmp_spec(k).le() // && k.cmp_spec(*hi).le() // && self@.contains_key(k) // ==> self@[k]@ == v@, //,", "full_function": "    fn keys_in_index_range_agree(&self, lo: usize, hi: usize, v: &ID) -> (ret:(bool, bool))\n        requires \n            self.valid(),\n            0 <= lo <= hi < self.keys@.len(),\n        ensures \n            ret.0 == forall |i| #![auto] lo <= i <= hi ==> self@[self.keys@[i]]@ == v@,\n            !ret.0 ==> (ret.1 == (self@[self.keys@[hi as int]]@ != v@ && (forall |i| #![auto] lo <= i < hi ==> self@[self.keys@[i]]@ == v@))),\n    {\n        let (agree, almost) = self.values_agree(lo, hi, v);\n        proof {\n            if agree {\n            } else {\n                assert(!forall |i| #![auto] lo <= i <= hi ==> self.vals@[i]@ == v@);\n                let i = choose |i| #![auto] !(lo <= i <= hi ==> self.vals@.index(i)@ == v@);\n                assert(self.vals@.index(i)@ != v@);\n                assert(self@[self.keys@[i]]@ == self.vals@.index(i)@);\n                if almost {\n                } else {\n                    assert(!(self.vals@[hi as int]@ != v@ && forall |i| #![auto] lo <= i < hi ==> self.vals@[i]@ == v@));\n                    if self.vals@[hi as int]@ == v@ {\n                    } else {\n                        let j = choose |j| #![auto] lo <= j < hi && self.vals@[j]@ != v@;\n                        assert(self@[self.keys@[j]]@ != v@);\n                    }\n                }\n            }\n        }\n        (agree, almost)\n    }\n\n//    // All keys present in the range [lo .. hi] map `v`\n//    fn keys_agree(&self, ghost(lo): Ghost<&K>, lo_index: usize, ghost(hi): Ghost<&K>, hi_index: usize, v: &ID) -> (b: bool)\n//        requires \n//            self.valid(),\n//            0 <= lo_index <= hi_index < self.keys@.len(),\n//            lo == self.keys@[lo_index as int],\n//            hi == self.keys@[hi_index as int],\n//        ensures b == forall |k| #![auto] \n//                        lo.cmp_spec(k).le() \n//                     && k.cmp_spec(*hi).le() \n//                     && self@.contains_key(k) \n//                     ==> self@[k]@ == v@,\n//    {\n//        let ret = self.keys_in_index_range_agree(lo_index, hi_index, v);\n//        proof {\n//            if ret {\n//                assert forall |k| #![auto] \n//                        lo.cmp_spec(k).le() \n//                     && k.cmp_spec(*hi).le() \n//                     && self@.contains_key(k) \n//                     implies self@[k]@ == v@ by {\n//                    assert(exists |i| 0 <= i < self.keys@.len() && self.keys@[i] == k);\n//                    let i = choose |i| 0 <= i < self.keys@.len() && self.keys@[i] == k;\n//                    assert(lo_index <= i <= hi_index) by {\n//                        K::cmp_properties();\n//                    }\n//                }\n//            } else {\n//                let i = choose |i| #![auto] !(lo_index <= i <= hi_index ==> self@[self.keys@[i]]@ == v@);\n//                let k = self.keys@[i];\n//                assert(lo.cmp_spec(k).le() && k.cmp_spec(*hi).le()) by {\n//                    K::cmp_properties();\n//                }\n//                assert(self@.contains_key(k));\n//                assert(self@[k]@ != v@);\n//            }\n//        }\n//        ret \n//    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "keys_in_index_range_agree", "function_mode": "exec", "line_start": 604, "line_end": 672, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 2, "num_ensures": 2, "complexity_score": 19, "is_method": true, "impl_type": "StrictlyOrderedMap<K>"}}
{"id": "task_a_cmessage_v_clone_up_to_view_73", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn clone_up_to_view(&self) -> (c: Self)\n  {\n      match self {\n          CMessage::GetRequest{ k } => { CMessage::GetRequest{ k: k.clone() } },\n          CMessage::SetRequest{ k , v } => { CMessage::SetRequest{ k: k.clone(), v: CMessage::clone_value(v) } },\n          CMessage::Reply{ k, v } => { CMessage::Reply{ k: k.clone(), v: CMessage::clone_value(v) } },\n          CMessage::Redirect{ k, id } => { CMessage::Redirect{ k: k.clone(), id: id.clone_up_to_view() } },\n          CMessage::Shard{ kr, recipient } => { CMessage::Shard{ kr: kr.clone(), recipient: recipient.clone_up_to_view() } },\n          CMessage::Delegate{ range, h } => { CMessage::Delegate{ range: range.clone(), h: h.clone_up_to_view() } },\n      }\n  }\n```\n\nWrite the specifications:", "target_text": "ensures c@ == self@,", "full_function": "\n  pub fn clone_up_to_view(&self) -> (c: Self)\n  ensures\n    c@ == self@\n  {\n      match self {\n          CMessage::GetRequest{ k } => { CMessage::GetRequest{ k: k.clone() } },\n          CMessage::SetRequest{ k , v } => { CMessage::SetRequest{ k: k.clone(), v: CMessage::clone_value(v) } },\n          CMessage::Reply{ k, v } => { CMessage::Reply{ k: k.clone(), v: CMessage::clone_value(v) } },\n          CMessage::Redirect{ k, id } => { CMessage::Redirect{ k: k.clone(), id: id.clone_up_to_view() } },\n          CMessage::Shard{ kr, recipient } => { CMessage::Shard{ kr: kr.clone(), recipient: recipient.clone_up_to_view() } },\n          CMessage::Delegate{ range, h } => { CMessage::Delegate{ range: range.clone(), h: h.clone_up_to_view() } },\n      }\n  }", "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "clone_up_to_view", "function_mode": "exec", "line_start": 124, "line_end": 137, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "CMessage"}}
{"id": "task_a_delegation_map_v_is_lt_110", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub const fn is_lt(self) -> (b:bool)\n    {\n        matches!(self, Ordering::Less)\n    }\n```\n\nWrite the specifications:", "target_text": "ensures b == self.lt(),", "full_function": "\n    pub const fn is_lt(self) -> (b:bool)\n        ensures b == self.lt(),\n    {\n        matches!(self, Ordering::Less)\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "is_lt", "function_mode": "exec", "line_start": 54, "line_end": 59, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "Ordering"}}
{"id": "task_a_delegation_map_v_is_ge_113", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub const fn is_ge(self) -> (b:bool)\n    {\n        !matches!(self, Ordering::Less)\n    }\n```\n\nWrite the specifications:", "target_text": "ensures b == self.ge(),", "full_function": "\n    pub const fn is_ge(self) -> (b:bool)\n        ensures b == self.ge(),\n    {\n        !matches!(self, Ordering::Less)\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "is_ge", "function_mode": "exec", "line_start": 72, "line_end": 77, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "Ordering"}}
{"id": "task_a_cmessage_v_is_key_valid_79", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn is_key_valid(key: &CKey) -> (b: bool)\n{\n    true\n}\n```\n\nWrite the specifications:", "target_text": "ensures b == valid_key(*key),", "full_function": "pub fn is_key_valid(key: &CKey) -> (b: bool)\n    ensures b == valid_key(*key)\n{\n    true\n}", "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "is_key_valid", "function_mode": "exec", "line_start": 52, "line_end": 56, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": false, "impl_type": null}}
{"id": "task_a_cmessage_v_is_value_valid_80", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn is_value_valid(val: &Vec<u8>) -> (b: bool)\n{\n    val.len() < 1024\n}\n```\n\nWrite the specifications:", "target_text": "ensures b == valid_value(val@),", "full_function": "pub fn is_value_valid(val: &Vec<u8>) -> (b: bool)\n    ensures b == valid_value(val@)\n{\n    val.len() < 1024\n}", "metadata": {"source_file": "../ironsht/src/cmessage_v.rs", "function_name": "is_value_valid", "function_mode": "exec", "line_start": 59, "line_end": 63, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": false, "impl_type": null}}
{"id": "task_a_single_delivery_state_v_insert_10", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn insert(&mut self, src: &EndPoint, last_seqno: u64)\n    {\n        self.epmap.insert(src, last_seqno);\n        assert( forall |k: AbstractEndPoint| #[trigger] self@.contains_key(k) ==> old(self)@.contains_key(k) || k == src@ );\n    }\n```\n\nWrite the specifications:", "target_text": "requires old(self).abstractable(), src@.valid_physical_address(),\nensures self@ =~= old(self)@.insert(src@, last_seqno as nat), self.abstractable(),", "full_function": "    pub fn insert(&mut self, src: &EndPoint, last_seqno: u64)\n    requires\n        old(self).abstractable(),\n        src@.valid_physical_address(),\n    ensures\n        self@ =~= old(self)@.insert(src@, last_seqno as nat),\n        self.abstractable(),\n    {\n        self.epmap.insert(src, last_seqno);\n        assert( forall |k: AbstractEndPoint| #[trigger] self@.contains_key(k) ==> old(self)@.contains_key(k) || k == src@ );\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "insert", "function_mode": "exec", "line_start": 223, "line_end": 233, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 5, "is_method": true, "impl_type": "CTombstoneTable"}}
{"id": "task_a_host_impl_v_host_model_next_shard_96", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn host_model_next_shard(&mut self) -> (sent_packets: Vec<CPacket>)\n    {\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{ m, .. } => {\n                let mut sent_packets: Vec<CPacket> = vec![];\n\n                // Learn this for early return cases.\n                assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n\n                reveal(abstractify_seq_of_cpackets_to_set_of_sht_packets);\n\n                let marshalable: bool = m.is_message_marshallable();\n\n                match m {\n                    CMessage::Shard{ ref kr, ref recipient } => {\n                        if {\n                               ||| !marshalable\n                               ||| do_end_points_match(&recipient, &self.constants.me)\n                               ||| !endpoints_contain(&self.constants.host_ids, &recipient)\n                           }\n                        {\n                            assert(recipient.abstractable());\n                            self.received_packet = None;\n                            return sent_packets;\n                        } else {\n                            let this_host_owns_range = self.delegation_map.delegate_for_key_range_is_host_impl(&kr.lo, &kr.hi, &self.constants.me);\n\n                            if !this_host_owns_range {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            let h = extract_range_impl(&self.h, kr);\n                            if h.len() >= 62 {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            // assert( !next_shard_wrapper_must_reject(old(self)@, m@) );\n\n                            // One thing that was surprising (and difficult to understand) in\n                            // the Dafny code was that it called ExtractRange twice. This port\n                            // eliminates that redundant call.\n                            let out_m = CMessage::Delegate{ range: kr.clone(), h };\n                            assert( out_m.is_marshalable() ) by {\n                                vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n                                crate::marshal_ironsht_specific_v::lemma_is_marshalable_CKeyHashMap(h);\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&out_m, &recipient);\n                            match optional_sm {\n                                None => {\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n                                    assert( next_shard(old(self)@, self@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        *kr, recipient@, arbitrary(), false) ); // exists witness\n                                    return sent_packets;\n                                },\n                                Some(sm) => {\n                                    self.delegation_map.set(&kr.lo, &kr.hi, recipient);\n                                    proof {\n                                        // When porting this, we couldn't figure out why this lemma\n                                        // proof consists entirely of a =~=, yet using that same\n                                        // twiddle here isn't sufficient.\n                                        DelegationMap::lemma_set_is_update(\n                                            old(self).delegation_map, self.delegation_map,\n                                            kr.lo, kr.hi, recipient)\n                                    };\n\n                                    self.h.bulk_remove(&kr);\n\n                                    // Borrowing rules (on kr) require us to copy-paste the\n                                    // packet. Perhaps there would be a better way to structure\n                                    // this code to follow a more borrow-friendly pattern.\n                                    let p = CPacket{\n                                        dst: clone_end_point(&recipient),\n                                        src: clone_end_point(&self.constants.me),\n                                        msg: sm\n                                    };\n                                    sent_packets.push(p);\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n\n    proof {\n        lemma_map_values_singleton_auto::<CPacket, Packet>();\n        lemma_to_set_singleton_auto::<Packet>();\n\n        assert(\n            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))\n            =~= seq![extract_packet_from_lsht_packet(abstractify_cpacket_to_lsht_packet(p))] ); // twiddle\n\n        assert( next_shard(old(self)@, self@,\n            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n            *kr, recipient@, sm@, true) ); // exists witness\n\n        assert( p.msg.is_marshalable() );\n    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => assert(false),\n                }\n            },\n            _ => assert(false)\n        }\n        unreached()\n    }\n```\n\nWrite the specifications:", "target_text": "requires old(self).next_shard_preconditions(),\nensures self.next_shard_postconditions(*old(self), sent_packets@),", "full_function": "    fn host_model_next_shard(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires\n            old(self).next_shard_preconditions(),\n        ensures\n            self.next_shard_postconditions(*old(self), sent_packets@),\n    {\n        proof { self.delegation_map.valid_implies_complete(); };\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        let ghost pre = *self;\n        match &cpacket.msg {\n            CSingleMessage::Message{ m, .. } => {\n                let mut sent_packets: Vec<CPacket> = vec![];\n\n                // Learn this for early return cases.\n                assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n\n                reveal(abstractify_seq_of_cpackets_to_set_of_sht_packets);\n\n                let marshalable: bool = m.is_message_marshallable();\n\n                match m {\n                    CMessage::Shard{ ref kr, ref recipient } => {\n                        if {\n                               ||| !marshalable\n                               ||| do_end_points_match(&recipient, &self.constants.me)\n                               ||| !endpoints_contain(&self.constants.host_ids, &recipient)\n                           }\n                        {\n                            assert(recipient.abstractable());\n                            self.received_packet = None;\n                            return sent_packets;\n                        } else {\n                            let this_host_owns_range = self.delegation_map.delegate_for_key_range_is_host_impl(&kr.lo, &kr.hi, &self.constants.me);\n\n                            if !this_host_owns_range {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            let h = extract_range_impl(&self.h, kr);\n                            if h.len() >= 62 {\n                                self.received_packet = None;\n                                return sent_packets;\n                            }\n\n                            // assert( !next_shard_wrapper_must_reject(old(self)@, m@) );\n\n                            // One thing that was surprising (and difficult to understand) in\n                            // the Dafny code was that it called ExtractRange twice. This port\n                            // eliminates that redundant call.\n                            let out_m = CMessage::Delegate{ range: kr.clone(), h };\n                            assert( out_m.is_marshalable() ) by {\n                                vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n                                crate::marshal_ironsht_specific_v::lemma_is_marshalable_CKeyHashMap(h);\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            }\n                            let optional_sm = self.sd.send_single_cmessage(&out_m, &recipient);\n                            match optional_sm {\n                                None => {\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n                                    assert( next_shard(old(self)@, self@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        *kr, recipient@, arbitrary(), false) ); // exists witness\n                                    return sent_packets;\n                                },\n                                Some(sm) => {\n                                    self.delegation_map.set(&kr.lo, &kr.hi, recipient);\n                                    proof {\n                                        // When porting this, we couldn't figure out why this lemma\n                                        // proof consists entirely of a =~=, yet using that same\n                                        // twiddle here isn't sufficient.\n                                        DelegationMap::lemma_set_is_update(\n                                            old(self).delegation_map, self.delegation_map,\n                                            kr.lo, kr.hi, recipient)\n                                    };\n\n                                    self.h.bulk_remove(&kr);\n\n                                    // Borrowing rules (on kr) require us to copy-paste the\n                                    // packet. Perhaps there would be a better way to structure\n                                    // this code to follow a more borrow-friendly pattern.\n                                    let p = CPacket{\n                                        dst: clone_end_point(&recipient),\n                                        src: clone_end_point(&self.constants.me),\n                                        msg: sm\n                                    };\n                                    sent_packets.push(p);\n                                    self.received_packet = None;\n                                    self.num_delegations = self.num_delegations + 1;\n\n    proof {\n        lemma_map_values_singleton_auto::<CPacket, Packet>();\n        lemma_to_set_singleton_auto::<Packet>();\n\n        assert(\n            abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@).map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp))\n            =~= seq![extract_packet_from_lsht_packet(abstractify_cpacket_to_lsht_packet(p))] ); // twiddle\n\n        assert( next_shard(old(self)@, self@,\n            abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n            *kr, recipient@, sm@, true) ); // exists witness\n\n        assert( p.msg.is_marshalable() );\n    }\n                                    return sent_packets;\n                                }\n                            }\n                        }\n                    },\n                    _ => assert(false),\n                }\n            },\n            _ => assert(false)\n        }\n        unreached()\n    }", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_model_next_shard", "function_mode": "exec", "line_start": 1438, "line_end": 1555, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 1, "num_ensures": 1, "complexity_score": 29, "is_method": true, "impl_type": "HostState"}}
{"id": "task_a_delegation_map_v_index_117", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn index(&self, i: usize) -> (k: K)\n    {\n        (self.v[i]).clone()\n    }\n```\n\nWrite the specifications:", "target_text": "requires i < self@.len(),\nensures k == self@[i as int],", "full_function": "    fn index(&self, i: usize) -> (k: K)\n        requires i < self@.len(),\n        ensures k == self@[i as int]\n    {\n        (self.v[i]).clone()\n    }", "metadata": {"source_file": "../ironsht/src/delegation_map_v.rs", "function_name": "index", "function_mode": "exec", "line_start": 141, "line_end": 146, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 1, "num_ensures": 1, "complexity_score": 4, "is_method": true, "impl_type": "StrictlyOrderedVec<K>"}}
{"id": "task_a_single_delivery_state_v_get_11", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn get(&self, src: &EndPoint) -> (value: Option<&CAckState>)\n    {\n        self.epmap.get(src)\n    }\n```\n\nWrite the specifications:", "target_text": "ensures value == match HashMap::get_spec(self.epmap@, src@) { Some(v) => Some(&v), None => None }, value is Some ==> self@.contains_key(src@), // helpfully trigger valid,", "full_function": "\n    pub fn get(&self, src: &EndPoint) -> (value: Option<&CAckState>)\n    ensures\n        value == match HashMap::get_spec(self.epmap@, src@) { Some(v) => Some(&v), None => None },\n        value is Some ==> self@.contains_key(src@), // helpfully trigger valid\n    {\n        self.epmap.get(src)\n    }", "metadata": {"source_file": "../ironsht/src/single_delivery_state_v.rs", "function_name": "get", "function_mode": "exec", "line_start": 272, "line_end": 279, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": false, "num_requires": 0, "num_ensures": 1, "complexity_score": 2, "is_method": true, "impl_type": "CSendState"}}
{"id": "task_a_host_impl_v_host_model_next_get_request_91", "task": "code_to_spec", "input_text": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn host_model_next_get_request(&mut self) -> (sent_packets: Vec<CPacket>)\n    {\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        match &cpacket.msg {\n            CSingleMessage::Message{m: CMessage::GetRequest{k}, seqno, ..} => {\n                let owner: EndPoint = self.delegation_map.get(k);\n                let ghost received_request: AppRequest = AppRequest::AppGetRequest{seqno: seqno@ as nat, key: *k};\n                let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                let m: CMessage =\n                    if its_me {\n                        let v = self.h.get(k);\n                        // OBSERVE: Need to say `valid_value` to trigger the quantifier saying all values are valid.\n                        assert (v.is_some() ==> valid_value(v.arrow_Some_0()@));\n                        CMessage::Reply{k: SHTKey{ukey: k.ukey}, v: clone_option_vec_u8(v)}\n                    }\n                    else {\n                        CMessage::Redirect{k: SHTKey{ukey: k.ukey}, id: clone_end_point(&owner)}\n                    };\n                let ghost new_received_requests: Seq<AppRequest> =\n                    if its_me {\n                        self.received_requests@.push(received_request)\n                    }\n                    else {\n                        self.received_requests@\n                    };\n                proof { lemma_auto_spec_u64_to_from_le_bytes(); }\n                assert (m.is_marshalable());\n                let optional_sm = self.sd.send_single_cmessage(&m, &cpacket.src);\n                let mut sent_packets = Vec::<CPacket>::new();\n                match optional_sm {\n                    Some(sm) => {\n                        let p = CPacket{\n                            dst: clone_end_point(&cpacket.src),\n                            src: clone_end_point(&self.constants.me),\n                            msg: sm\n                        };\n                        self.received_requests = Ghost(new_received_requests);\n                        self.received_packet = None;\n                        sent_packets.push(p);\n                        // TODO replace a bunch of the proof below with these lines:\n//                         proof {\n//                             lemma_map_values_singleton_auto::<CPacket, Packet>();\n//                             to_set_singleton_auto::<Packet>();\n//                         }\n                        proof {\n                            let ap = abstractify_cpacket_to_lsht_packet(p);\n                            let bp = Packet{dst: ap.dst, src: ap.src, msg: ap.msg};\n                            assert_seqs_equal!(Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@),\n                                               Seq::<Packet>::empty().push(p@));\n                            assert (Seq::<Packet>::empty().push(p@).index(0) == p@); // needed to show it contains p@\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@).to_set());\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Set::<Packet>::empty().insert(p@));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               set![ Packet{dst: pkt.src, src: self.constants.me@, msg: sm@} ]);\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                               Seq::<LSHTPacket>::empty().push(ap));\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)\n                                               .map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                               Seq::<Packet>::empty().push(bp));\n                            assert (Seq::<Packet>::empty().push(bp).index(0) == bp); // needed to show it contains bp\n                            assert_sets_equal!(Seq::<Packet>::empty().push(bp).to_set(),\n                                               Set::<Packet>::empty().insert(bp));\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        sm@, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        true));\n                        }\n                        return sent_packets;\n                    },\n                    None => {\n                        self.received_packet = None;\n                        proof {\n                            assert( sent_packets@ =~= Seq::<CPacket>::empty() );\n                            assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        SingleMessage::<Message>::InvalidMessage{}, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        false));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)));\n                        }\n                        return sent_packets;\n                    }\n                }\n            },\n            _ => {\n                assert(false);\n                unreached()\n            },\n        }\n    }\n```\n\nWrite the specifications:", "target_text": "requires old(self).next_get_request_preconditions(),\nensures self.next_get_request_postconditions(*old(self), sent_packets@),", "full_function": "    fn host_model_next_get_request(&mut self) -> (sent_packets: Vec<CPacket>)\n        requires old(self).next_get_request_preconditions()\n        ensures  self.next_get_request_postconditions(*old(self), sent_packets@)\n    {\n        let cpacket: &CPacket = &self.received_packet.as_ref().unwrap();\n        let ghost pkt: Packet = cpacket@;\n        match &cpacket.msg {\n            CSingleMessage::Message{m: CMessage::GetRequest{k}, seqno, ..} => {\n                let owner: EndPoint = self.delegation_map.get(k);\n                let ghost received_request: AppRequest = AppRequest::AppGetRequest{seqno: seqno@ as nat, key: *k};\n                let its_me: bool = do_end_points_match(&owner, &self.constants.me);\n                let m: CMessage =\n                    if its_me {\n                        let v = self.h.get(k);\n                        // OBSERVE: Need to say `valid_value` to trigger the quantifier saying all values are valid.\n                        assert (v.is_some() ==> valid_value(v.arrow_Some_0()@));\n                        CMessage::Reply{k: SHTKey{ukey: k.ukey}, v: clone_option_vec_u8(v)}\n                    }\n                    else {\n                        CMessage::Redirect{k: SHTKey{ukey: k.ukey}, id: clone_end_point(&owner)}\n                    };\n                let ghost new_received_requests: Seq<AppRequest> =\n                    if its_me {\n                        self.received_requests@.push(received_request)\n                    }\n                    else {\n                        self.received_requests@\n                    };\n                proof { lemma_auto_spec_u64_to_from_le_bytes(); }\n                assert (m.is_marshalable());\n                let optional_sm = self.sd.send_single_cmessage(&m, &cpacket.src);\n                let mut sent_packets = Vec::<CPacket>::new();\n                match optional_sm {\n                    Some(sm) => {\n                        let p = CPacket{\n                            dst: clone_end_point(&cpacket.src),\n                            src: clone_end_point(&self.constants.me),\n                            msg: sm\n                        };\n                        self.received_requests = Ghost(new_received_requests);\n                        self.received_packet = None;\n                        sent_packets.push(p);\n                        // TODO replace a bunch of the proof below with these lines:\n//                         proof {\n//                             lemma_map_values_singleton_auto::<CPacket, Packet>();\n//                             to_set_singleton_auto::<Packet>();\n//                         }\n                        proof {\n                            let ap = abstractify_cpacket_to_lsht_packet(p);\n                            let bp = Packet{dst: ap.dst, src: ap.src, msg: ap.msg};\n                            assert_seqs_equal!(Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@),\n                                               Seq::<Packet>::empty().push(p@));\n                            assert (Seq::<Packet>::empty().push(p@).index(0) == p@); // needed to show it contains p@\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Seq::<CPacket>::empty().push(p).map_values(|cp: CPacket| cp@).to_set());\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               Set::<Packet>::empty().insert(p@));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               set![ Packet{dst: pkt.src, src: self.constants.me@, msg: sm@} ]);\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@),\n                                               Seq::<LSHTPacket>::empty().push(ap));\n                            assert_seqs_equal!(abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)\n                                               .map_values(|lp: LSHTPacket| extract_packet_from_lsht_packet(lp)),\n                                               Seq::<Packet>::empty().push(bp));\n                            assert (Seq::<Packet>::empty().push(bp).index(0) == bp); // needed to show it contains bp\n                            assert_sets_equal!(Seq::<Packet>::empty().push(bp).to_set(),\n                                               Set::<Packet>::empty().insert(bp));\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        sm@, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        true));\n                        }\n                        return sent_packets;\n                    },\n                    None => {\n                        self.received_packet = None;\n                        proof {\n                            assert( sent_packets@ =~= Seq::<CPacket>::empty() );\n                            assert( abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@) =~= Set::<Packet>::empty() );\n                            assert (next_get_request_reply(\n                                        old(self)@, self@, pkt.src, pkt.msg.arrow_Message_seqno(),\n                                        pkt.msg.arrow_Message_m().arrow_GetRequest_key(),\n                                        SingleMessage::<Message>::InvalidMessage{}, m@,\n                                        abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                        false));\n                            assert_sets_equal!(abstractify_seq_of_cpackets_to_set_of_sht_packets(sent_packets@),\n                                               extract_packets_from_lsht_packets(\n                                                   abstractify_outbound_packets_to_seq_of_lsht_packets(sent_packets@)));\n                        }\n                        return sent_packets;\n                    }\n                }\n            },\n            _ => {\n                assert(false);\n                unreached()\n            },\n        }\n    }", "metadata": {"source_file": "../ironsht/src/host_impl_v.rs", "function_name": "host_model_next_get_request", "function_mode": "exec", "line_start": 1068, "line_end": 1168, "has_loop_invariant": false, "has_decreases": false, "has_proof_block": true, "num_requires": 1, "num_ensures": 1, "complexity_score": 43, "is_method": true, "impl_type": "HostState"}}
