{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nproof fn gap_means_empty(self, lo:KeyIterator<K>, hi:KeyIterator<K>, k:KeyIterator<K>)\n    {\n        self.mind_the_gap();\n    }\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires self.gap(lo, hi), lo.lt_spec(k) && k.lt_spec(hi), self@.contains_key(*k.get()),\nensures false,"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn get_my_end_point(&self) -> (ep: EndPoint)\n    {\n        self.end_point.clone_up_to_view()\n    }\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "ensures ep@ == self.my_end_point(),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn send_packet_seq(cpackets: &Vec<CPacket>, netc: &mut NetClient) -> (rc: (bool, Ghost<Seq<NetEvent>>))\n        {\n            &&& netc.ok() <==> ok\n            &&& ok ==> netc.history() == old(netc).history() + net_events\n            &&& ok ==> send_log_entries_reflect_packets(net_events, cpackets@)\n            &&& ok ==> only_sent_marshalable_data(net_events)\n            &&& forall |i| 0 <= i < net_events.len() ==> net_events[i] is Send\n        }\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires\n    old(netc).ok(),\nensures\n    netc.my_end_point() == old(netc).my_end_point(),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn same_view_same_marshalable(x: &CSingleMessage, y: &CSingleMessage)\n{\n    CSingleMessage::view_equal_spec();\n    assert(x.view_equal(y));\n    x.lemma_same_views_serialize_the_same(y);\n}\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires x@ == y@,\nensures x.is_marshalable() == y.is_marshalable(),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nproof fn abstractify_distributes_over_skip(cm: Seq<CSingleMessage>, i: int)\n    {\n        if 0 < i {\n            Self::abstractify_distributes_over_skip(cm.subrange(1, cm.len() as int), i-1);\n        }\n    }\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires 0 <= i <= cm.len(),\nensures abstractify_cmessage_seq(cm.skip(i)) =~= abstractify_cmessage_seq(cm).skip(i),\ndecreases i,"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn truncate(&mut self, seqno_acked: u64, Ghost(dst): Ghost<AbstractEndPoint>)\n    {\n        let mut i: usize = 0;\n        assert( self.un_acked@.skip(0 as int) =~= self.un_acked@ );\n\n        while (i < self.un_acked.len()\n            && match self.un_acked[i] {\n                CSingleMessage::Message{seqno, ..} => { seqno <= seqno_acked },\n                _ => {\n                    assert( Self::un_acked_valid(&self.un_acked[i as int]) );\n                    assert(false);\n                    true\n                },\n            })\n          invariant\n            self.valid(dst),\n            self == old(self),\n            i <= self.un_acked.len(),\n            i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1,\n            forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked,\n            Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst),\n            truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat)\n                == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat),\n            self.num_packets_acked + i <= seqno_acked,\n          decreases\n            self.un_acked.len() - i\n        {\n            assert( self.un_acked@.skip(i as int).skip(1) =~= self.un_acked@.skip((i + 1) as int) );\n            i = i + 1;\n\n            proof { Self::abstractify_distributes_over_skip(self.un_acked@.skip(i - 1 as int), 1); }\n        }\n\n        self.num_packets_acked = seqno_acked;\n        self.un_acked = self.un_acked.split_off(i); // snip!\n    }\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires old(self).valid(dst), old(self).num_packets_acked <= seqno_acked,\nensures self.valid(dst), abstractify_cmessage_seq(self.un_acked@) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat), self.un_acked@.len() > 0 ==> self.un_acked[0]@.arrow_Message_seqno() == seqno_acked + 1, self.num_packets_acked == seqno_acked,\ninvariant self.valid(dst), self == old(self), i <= self.un_acked.len(), i < self.un_acked.len() ==> self.un_acked[i as int].arrow_Message_seqno() <= seqno_acked + 1, forall |j: int| #![auto] 0 <= j < i ==> self.un_acked[j].arrow_Message_seqno() <= seqno_acked, Self::valid_list(self.un_acked@.skip(i as int), self.num_packets_acked + i, dst), truncate_un_ack_list(abstractify_cmessage_seq(self.un_acked@.skip(i as int)), seqno_acked as nat) == truncate_un_ack_list(abstractify_cmessage_seq(old(self).un_acked@), seqno_acked as nat), self.num_packets_acked + i <= seqno_acked,"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn is_eq(self) -> (b:bool)\n    {\n        matches!(self, Ordering::Equal)\n    }\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "ensures b == self.eq(),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_set_is_update(pre: Self, post: Self, lo: KeyIterator<CKey>, hi: KeyIterator<CKey>, dst: &ID)\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires pre.valid(), dst@.valid_physical_address(), // fn set postconditions post.valid(), forall |ki:KeyIterator<CKey>| #[trigger] KeyIterator::between(lo, ki, hi) ==> post@[*ki.get()] == dst@, forall |ki:KeyIterator<CKey>| !ki.is_end_spec() && !(#[trigger] KeyIterator::between(lo, ki, hi)) ==> post@[*ki.get()] == pre@[*ki.get()],\nensures AbstractDelegationMap(post@) =~= AbstractDelegationMap(pre@).update(KeyRange,"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier::rlimit(15)]\n    pub fn send_single_cmessage(&mut self, m: &CMessage, dst: &EndPoint) -> (sm: Option<CSingleMessage>)\n    {\n        let (num_packets_acked, un_acked_len) = \n            match self.send_state.get(dst) {\n                Some(ref cack_state) => {\n                    proof {\n                        if cack_state.un_acked.len() > 0 {\n                            // This is necessary to show that appending our new seqno keeps the list sequential\n                            cack_state.lemma_seqno_in_un_acked_list(dst@, (cack_state.un_acked.len() - 1) as int);\n                        }\n                    }\n                    (cack_state.num_packets_acked, cack_state.un_acked.len() as u64)\n                }\n                None => { (0, 0) },\n                // In the None case, we have no ack state. To meet our AckState::receive_ack assum-ed\n                // protocol spec, we are forced to not update the send_state; stuffing an\n                // CAckState::new in there would make spec unmeetable.\n            };\n\n        if Parameters::static_params().max_seqno - num_packets_acked == un_acked_len {\n            // No more seqnos; must give up.\n            return None;\n        }\n\n        assert( num_packets_acked + un_acked_len <= AbstractParameters::static_params().max_seqno );\n        let new_seqno = num_packets_acked + un_acked_len + 1;\n        let sm_new = CSingleMessage::Message {\n            seqno: new_seqno,\n            dst: dst.clone_up_to_view(),\n            m: m.clone_up_to_view(),\n        };\n        assert(sm_new.abstractable());\n        assert(sm_new.is_marshalable()) by {\n            vstd::bytes::lemma_auto_spec_u64_to_from_le_bytes();\n            match sm_new {\n                CSingleMessage::Message { seqno, dst: dst_new, m: m_new } => {\n                    dst_new.lemma_same_views_serialize_the_same(&dst);\n                    m_new.lemma_same_views_serialize_the_same(&m);\n                    assert(sm_new.ghost_serialize().len() <= usize::MAX) by {\n                        // assert(seqno.ghost_serialize().len() == 8);\n                        // assert(dst_new.ghost_serialize().len() == dst.ghost_serialize().len());\n                        // assert(m_new.ghost_serialize().len() == m.ghost_serialize().len());\n                        // assert(dst_new.ghost_serialize().len() <= 0x100000 + 8);\n                        match m_new {\n                            CMessage::GetRequest { k } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::SetRequest { k, v } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::Reply { k, v } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 8);\n                            },\n                            CMessage::Redirect { k, id } => {\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 + 16);\n                            },\n                            CMessage::Shard { kr, recipient } => {\n                                // assert(recipient.ghost_serialize().len() <= 0x100000 + 24);\n                                // assert(kr.ghost_serialize().len() <= 0x100000 + 24);\n                                // assert(m_new.ghost_serialize().len() <= 0x100000 * 2);\n                            },\n                            CMessage::Delegate { range, h } => {\n                                // assert(range.ghost_serialize().len() <= 30);\n                                // assert(h.to_vec().len() <= 100);\n                                // assert(h.is_marshalable());\n                                // assert(h.ghost_serialize().len() <= crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size());\n                                reveal(crate::marshal_ironsht_specific_v::ckeyhashmap_max_serialized_size);\n                            },\n                        };\n                    }\n                },\n                _ => {},\n            }\n        }\n        assert forall |sm_alt: CSingleMessage| sm_alt@ == sm_new@ implies sm_alt.is_marshalable() by {\n            sm_alt.lemma_same_views_serialize_the_same(&sm_new);\n        }\n\n        let mut local_state = CAckState::new();\n        let default = CAckState::new();\n\n        let ghost int_local_state = local_state;    // trigger fodder\n        self.send_state.cack_state_swap(&dst, &mut local_state, default);\n        local_state.un_acked.push(sm_new.clone_up_to_view());\n\n        let ghost old_ack_state = ack_state_lookup(dst@, old(self)@.send_state);\n        assert(local_state@.un_acked =~= old_ack_state.un_acked.push(sm_new@));\n        self.send_state.put(&dst, local_state);\n\n        assert forall |ep: EndPoint| #[trigger] self.send_state@.contains_key(ep@) implies\n                                ep.abstractable() && self.send_state.epmap[&ep].abstractable() by {\n            if ep@ != dst@ {\n                assert(old(self).send_state@.contains_key(ep@));\n            }\n        }\n\n        assert forall |ep: AbstractEndPoint| #[trigger] self.send_state@.contains_key(ep) implies self.send_state.epmap@[ep].valid(ep) by {\n            if ep != dst@ {\n                assert(old(self).send_state@.contains_key(ep));\n                assert(self.send_state.epmap@[ep].valid(ep));\n            }\n            else {\n                assert(self.send_state.epmap@[ep] == local_state);\n                assert(self.send_state.epmap@[ep].valid(ep));\n            }\n        }\n\n        assert(self@.send_state =~=\n               old(self)@.send_state.insert(dst@, AckState{ un_acked: old_ack_state.un_acked.push(sm_new@), .. old_ack_state }));\n        Some(sm_new)\n    }\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires old(self).valid(), old(self).abstractable(), m.abstractable(), m.message_marshallable(), m.is_marshalable(), dst@.valid_physical_address(),\nensures self.valid(), match sm { Some(sm) => { &&& sm.abstractable() &&& sm is Message &&& sm.arrow_Message_dst()@ == dst@ &&& SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, Some(sm@), AbstractParameters::static_params()) &&& sm.is_marshalable() }, None => SingleDelivery::send_single_message(old(self)@, self@, m@, dst@, None, AbstractParameters::static_params()), }, // TODO: capture the part of send_single_message when should_send == false,"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nfn erase(&mut self, lo: &KeyIterator<K>, hi: &KeyIterator<K>)\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires old(self).valid(),\nensures self.valid(), forall |k|,"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn test_unique(endpoints: &Vec<EndPoint>) -> (unique: bool)\n    {\n        let mut i: usize = 0;\n        while i < endpoints.len()\n            invariant\n                0 <= i,\n                i <= endpoints.len(),\n                forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                    0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n            decreases\n                endpoints.len() - i\n        {\n            let mut j: usize = 0;\n            while j < endpoints.len()\n                invariant\n                    0 <= i,\n                    i < endpoints.len(),\n                    forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@]\n                        0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\n                    0 <= j,\n                    j <= endpoints.len(),\n                    forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j && k != i ==> endpoints@[i as int]@ != endpoints@[k]@,\n                decreases\n                    endpoints.len() - j\n            {\n                if i != j && do_end_points_match(&endpoints[i], &endpoints[j]) {\n                    assert (!seq_is_unique(abstractify_end_points(*endpoints))) by {\n                        reveal(seq_is_unique::<AbstractEndPoint>);\n                        let aeps = abstractify_end_points(*endpoints);\n                        assert (aeps[i as int] == endpoints@[i as int]@);\n                        assert (aeps[j as int] == endpoints@[j as int]@);\n                        assert (endpoints@[i as int]@ == endpoints@[j as int]@ && i != j);\n                    }\n                    return false;\n                }\n                j = j + 1;\n            }\n            i = i + 1;\n        };\n        assert (seq_is_unique(abstractify_end_points(*endpoints))) by {\n            reveal(seq_is_unique::<AbstractEndPoint>);\n        }\n        return true;\n    }\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "ensures unique == seq_is_unique(abstractify_end_points(*endpoints)),\ninvariant 0 <= i, i <= endpoints.len(), forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@] 0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@,\ninvariant 0 <= i, i < endpoints.len(), forall |j: int, k: int| #![trigger endpoints@[j]@, endpoints@[k]@] 0 <= j && j < endpoints.len() && 0 <= k && k < i && j != k ==> endpoints@[j]@ != endpoints@[k]@, 0 <= j, j <= endpoints.len(), forall |k: int| #![trigger endpoints@[k]@] 0 <= k && k < j && k != i ==> endpoints@[i as int]@ != endpoints@[k]@,"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\nexec fn serialize(&self, data: &mut Vec<u8>)\n    // req, ens from trait\n  {\n    let self_len = self.len();\n    self_len.serialize(data);\n    let init: Ghost<int> = Ghost(self_len.ghost_serialize().len() as int);\n\n    let mut i: usize = 0;\n\n    proof {\n      assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, i + init@));\n    }\n\n    while i < self.len()\n      invariant\n        0 <= i <= self.len(),\n        self.is_marshalable(),\n        self.ghost_serialize().len() == init@ + self.len(),\n        0 <= i + init@ <= self.ghost_serialize().len(),\n        data@.subrange(0, old(data)@.len() as int) == old(data)@,\n        data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@),\n        data@.len() == old(data)@.len() + i + init@,\n      decreases\n        self.len() - i\n    {\n      assert(data@.subrange(old(data)@.len() as int, data@.len() as int) == data@.subrange(old(data)@.len() as int, old(data)@.len() + i + init@));\n\n      let x: u8 = self[i];\n      data.push(x);\n      i = i + 1;\n\n      proof {\n        assert(data@.subrange(0, old(data)@.len() as int) =~= old(data)@);\n        assert (data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@)) by {\n          assert(self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x) =~= self.ghost_serialize().subrange(0, i + init@));\n          assert(data@.subrange(old(data)@.len() as int, data@.len() as int) =~= self.ghost_serialize().subrange(0, (i + init@ - 1) as int).push(x));\n        }\n      }\n    }\n\n    proof {\n      assert(self.ghost_serialize().subrange(0, i + init@) =~= self.ghost_serialize());\n    }\n  }\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "invariant 0 <= i <= self.len(), self.is_marshalable(), self.ghost_serialize().len() == init@ + self.len(), 0 <= i + init@ <= self.ghost_serialize().len(), data@.subrange(0, old(data)@.len() as int) == old(data)@, data@.subrange(old(data)@.len() as int, data@.len() as int) == self.ghost_serialize().subrange(0, i + init@), data@.len() == old(data)@.len() + i + init@,"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn valid_physical_address(&self) -> (out: bool)\n    {\n        self.id.len() < 0x100000\n    }\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "ensures out == self@.valid_physical_address(),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n    {\n        let result: NetcReceiveResult = unsafe { self.receive_internal(time_limit_s) };\n        match result {\n            NetcReceiveResult::Received{ref sender, ref message} => {\n                self.history = Ghost(self.history@ + seq![LIoOp::Receive { r: LPacket::<AbstractEndPoint, Seq<u8>> { dst: self.my_end_point(), src: sender@, msg: message@ } } ]);\n            }\n            NetcReceiveResult::TimedOut{} => {\n                self.history = Ghost(self.history@ + seq![LIoOp::TimeoutReceive{}]);\n            }\n            NetcReceiveResult::Error{} => {\n                self.state = Ghost(State::Error{});\n            }\n        }\n        result\n    }\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires old(self).state() is Receiving,\nensures self.my_end_point() == old(self).my_end_point(), match result { NetcReceiveResult::Received{sender, message} => { &&& self.state() is Receiving &&& sender.abstractable() &&& self.history() == old(self).history() + seq![ LIoOp::Receive{ r: LPacket{ dst: self.my_end_point(), src: sender@, msg: message@} }] } NetcReceiveResult::TimedOut{} => { &&& self.state() is Sending &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}] } NetcReceiveResult::Error{} => { self.state() is Error } },"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\n#[verifier(external_body)]\n    pub fn keys(&self) -> (out: Vec<EndPoint>)\n    {\n      self.m.keys().map(|k| k.clone_up_to_view()).collect()\n    }\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "ensures out@.map_values(|e: EndPoint| e@).to_set() == self@.dom(),"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_seqno_in_un_acked_list(&self, dst: AbstractEndPoint, k: int)\n    {\n        if k > 0 {\n            self.lemma_seqno_in_un_acked_list(dst, k - 1);\n        }\n    }\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "requires self.valid(dst), 0 <= k < self.un_acked@.len(),\nensures self.un_acked@[k].arrow_Message_seqno() == self.num_packets_acked + k + 1,\ndecreases k,"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub fn clone_option_vec_u8(ov: Option<&Vec<u8>>) -> (res: Option<Vec<u8>>)\n    {\n        match ov {\n            Some(e1) => Some(clone_vec_u8(e1)),\n            None => None,\n        }\n    }\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "ensures match ov { Some(e1) => res.is_some() && e1@ == res->0@, None => res is None, },"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function implementation, infer the appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "Given the following Verus function implementation, infer the appropriate specifications (requires/ensures clauses).\n\nFunction:\n```rust\npub proof fn lemma_to_set_union_auto<A>()\n{\n    assert forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set() by {\n        lemma_to_set_distributes_over_addition(s, t);\n    }\n}\n```\n\nWrite the specifications:"}, {"role": "assistant", "content": "ensures forall |s: Seq<A>, t: Seq<A>| #[trigger] (s+t).to_set() == s.to_set() + t.to_set(),"}]}
