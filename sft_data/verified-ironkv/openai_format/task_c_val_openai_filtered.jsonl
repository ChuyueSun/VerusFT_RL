{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    #[verifier(external)]\n    pub fn get_time_internal(&self) -> (time: u64)\n        \n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "\n    #[verifier(external)]\n    pub fn get_time_internal(&self) -> (time: u64)\n        requires\n            from_trusted_code()\n    {\n        (self.c_pointers.get_time_func)()\n    }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n        \n          match result {\n            NetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n        }\n    {\n        let result: NetcReceiveResult = unsafe { self.receive_internal(time_limit_s) };\n        match result {\n            NetcReceiveResult::Received{ref sender, ref message} => {\n                self.history = Ghost(self.history@ + seq![LIoOp::Receive { r: LPacket::<AbstractEndPoint, Seq<u8>> { dst: self.my_end_point(), src: sender@, msg: message@ } } ]);\n            }\n            NetcReceiveResult::TimedOut{} => {\n                self.history = Ghost(self.history@ + seq![LIoOp::TimeoutReceive{}]);\n            }\n            NetcReceiveResult::Error{} => {\n                self.state = Ghost(State::Error{});\n            }\n        }\n        result\n    }\n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "\n    #[verifier(external_body)]\n    pub fn receive(&mut self, time_limit_s: i32) -> (result: NetcReceiveResult)\n        requires\n          old(self).state() is Receiving\n        ensures\n          self.my_end_point() == old(self).my_end_point(),\n          match result {\n            NetcReceiveResult::Received{sender, message} => {\n                &&& self.state() is Receiving\n                &&& sender.abstractable()\n                &&& self.history() == old(self).history() + seq![\n                    LIoOp::Receive{\n                        r: LPacket{\n                            dst: self.my_end_point(),\n                            src: sender@,\n                            msg: message@}\n                    }]\n            }\n            NetcReceiveResult::TimedOut{} => {\n                &&& self.state() is Sending\n                &&& self.history() == old(self).history() + seq![LIoOp/*TODO(verus) fix name when qpath fix*/::TimeoutReceive{}]\n            }\n            NetcReceiveResult::Error{} => {\n                self.state() is Error\n            }\n        }\n    {\n        let result: NetcReceiveResult = unsafe { self.receive_internal(time_limit_s) };\n        match result {\n            NetcReceiveResult::Received{ref sender, ref message} => {\n                self.history = Ghost(self.history@ + seq![LIoOp::Receive { r: LPacket::<AbstractEndPoint, Seq<u8>> { dst: self.my_end_point(), src: sender@, msg: message@ } } ]);\n            }\n            NetcReceiveResult::TimedOut{} => {\n                self.history = Ghost(self.history@ + seq![LIoOp::TimeoutReceive{}]);\n            }\n            NetcReceiveResult::Error{} => {\n                self.state = Ghost(State::Error{});\n            }\n        }\n        result\n    }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n    pub proof fn un_acked_messages_extend(&self, src: AbstractEndPoint, dst: AbstractEndPoint, i: nat)\n        \n            i < self@.send_state[dst].un_acked.len(),\n            self.send_state.valid()\n        ensures\n            self@.un_acked_messages_for_dest_up_to(src, dst, i+1) ==\n            self@.un_acked_messages_for_dest_up_to(src, dst, i).insert(\n                Packet {\n                    src,\n                    dst,\n                    msg: self@.send_state[dst].un_acked[i as int]\n                }\n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "    pub proof fn un_acked_messages_extend(&self, src: AbstractEndPoint, dst: AbstractEndPoint, i: nat)\n        requires\n            self@.send_state.contains_key(dst),\n            i < self@.send_state[dst].un_acked.len(),\n            self.send_state.valid()\n        ensures\n            self@.un_acked_messages_for_dest_up_to(src, dst, i+1) ==\n            self@.un_acked_messages_for_dest_up_to(src, dst, i).insert(\n                Packet {\n                    src,\n                    dst,\n                    msg: self@.send_state[dst].un_acked[i as int]\n                }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    #[verifier(external_body)]\n    pub fn insert(&mut self, key: &EndPoint, value: V)\n       value)\n    {\n      let key_clone: EndPoint = key.clone_up_to_view();\n      self.m.insert(key_clone, value);\n    }\n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "\n    #[verifier(external_body)]\n    pub fn insert(&mut self, key: &EndPoint, value: V)\n      ensures self@ == old(self)@.insert(key@, value)\n    {\n      let key_clone: EndPoint = key.clone_up_to_view();\n      self.m.insert(key_clone, value);\n    }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn seq_map_values_concat_auto<A, B>()\n f: spec_fn(A) -> B|\n    #[trigger] (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f)\n{\n    assert forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n        #[trigger] ((s1 + s2).map_values(f)) == s1.map_values(f) + s2.map_values(f) by {\n        seq_map_values_concat(s1, s2, f);\n    }\n}\n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "\npub proof fn seq_map_values_concat_auto<A, B>()\nensures forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n    #[trigger] (s1 + s2).map_values(f) == s1.map_values(f) + s2.map_values(f)\n{\n    assert forall |s1: Seq<A>, s2: Seq<A>, f: spec_fn(A) -> B|\n        #[trigger] ((s1 + s2).map_values(f)) == s1.map_values(f) + s2.map_values(f) by {\n        seq_map_values_concat(s1, s2, f);\n    }\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    pub proof fn lemma_un_acked_messages_for_dests_empty(&self, src: AbstractEndPoint, dests: Set<AbstractEndPoint>)\n         dests) == Set::<Packet>::empty()\n    {\n        assert_sets_equal!(dests.map(|dst: AbstractEndPoint| self.un_acked_messages_for_dest(src, dst)) == set![]);\n        assert_sets_equal!(self.un_acked_messages_for_dests(src, dests) == set![]);\n    }\n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "\n    pub proof fn lemma_un_acked_messages_for_dests_empty(&self, src: AbstractEndPoint, dests: Set<AbstractEndPoint>)\n        requires dests == Set::<AbstractEndPoint>::empty()\n        ensures self.un_acked_messages_for_dests(src, dests) == Set::<Packet>::empty()\n    {\n        assert_sets_equal!(dests.map(|dst: AbstractEndPoint| self.un_acked_messages_for_dest(src, dst)) == set![]);\n        assert_sets_equal!(self.un_acked_messages_for_dests(src, dests) == set![]);\n    }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn set_map_union_auto<A, B>()\n     f: spec_fn(A) -> B|\n        #[trigger] (s1 + s2).map(f) == s1.map(f) + s2.map(f)\n{\n    assert forall |s1: Set<A>, s2: Set<A>, f: spec_fn(A) -> B|\n        #[trigger] ((s1 + s2).map(f)) == s1.map(f) + s2.map(f) by {\n        set_map_union(s1, s2, f);\n    }\n}\n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "\npub proof fn set_map_union_auto<A, B>()\n    ensures forall |s1: Set<A>, s2: Set<A>, f: spec_fn(A) -> B|\n        #[trigger] (s1 + s2).map(f) == s1.map(f) + s2.map(f)\n{\n    assert forall |s1: Set<A>, s2: Set<A>, f: spec_fn(A) -> B|\n        #[trigger] ((s1 + s2).map(f)) == s1.map(f) + s2.map(f) by {\n        set_map_union(s1, s2, f);\n    }\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    pub fn get_my_end_point(&self) -> (ep: EndPoint)\n        \n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "\n    pub fn get_my_end_point(&self) -> (ep: EndPoint)\n        ensures\n            ep@ == self.my_end_point()\n    {\n        self.end_point.clone_up_to_view()\n    }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn lemma_to_set_distributes_over_addition<A>(s: Seq<A>, t: Seq<A>)\n right);\n}\n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "\npub proof fn lemma_to_set_distributes_over_addition<A>(s: Seq<A>, t: Seq<A>)\nensures (s+t).to_set() == s.to_set() + t.to_set()\n{\n    let left = (s+t).to_set();\n    let right = s.to_set() + t.to_set();\n    assert forall |x| right.contains(x) implies left.contains(x) by {\n        assert(s.to_set()+t.to_set() == s.to_set().union(t.to_set()));\n        if s.to_set().contains(x) {\n            let si = choose |si| 0<=si<s.len() && s[si] == x;\n            assert((s+t)[si] == x);\n        } else {\n            let ti = choose |ti| 0<=ti<t.len() && t[ti] == x;\n            assert((s+t)[s.len() + ti] == x);\n        }\n    }\n    assert_sets_equal!(left, right);\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    fn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n         KeyIterator::new_spec(self.keys@[index as int])),\n    {\n        let mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            invariant\n                1 <= i <= self.keys@.len(),\n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n            }\n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "    fn greatest_lower_bound_index(&self, iter: &KeyIterator<K>) -> (index: usize)\n        requires\n            self.valid(),\n            self@.contains_key(K::zero_spec()),\n        ensures\n            0 <= index < self.keys@.len(),\n            self.greatest_lower_bound_spec(*iter, KeyIterator::new_spec(self.keys@[index as int])),\n    {\n        let mut bound = 0;\n        let mut i = 1;\n\n        // Prove the initial starting condition\n        assert forall |j:nat| j < i implies iter.geq_K(#[trigger]self.keys@.index(j as int)) by {\n            let z = K::zero_spec();\n            assert(self.keys@.contains(z));\n            let n = choose |n: int| 0 <= n < self.keys@.len() && self.keys@[n] == z;\n            K::zero_properties();\n            assert_by_contradiction!(n == 0, {\n                assert(self.keys@[0].cmp_spec(self.keys@[n]).lt());\n                K::cmp_properties();\n            });\n            assert(self.keys@[0] == z);\n            K::cmp_properties();\n        }\n\n        // Find the glb's index (bound)\n        while i < self.keys.len()\n            invariant\n                1 <= i <= self.keys@.len(),\n                bound == i - 1,\n                forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)),\n            ensures\n                bound == i - 1,\n                (i == self.keys@.len() &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int)))\n             || (i < self.keys@.len() &&\n                 !iter.geq_K(self.keys@.index(i as int)) &&\n                 forall |j:nat| j < i ==> iter.geq_K(#[trigger]self.keys@.index(j as int))),\n            decreases\n                self.keys@.len() - i\n        {\n            if iter.lt(&KeyIterator::new(self.keys.index(i))) {\n                // Reached a key that's too large\n                break;\n            }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_requires\n```\n\nBroken code:\n```rust\n\n    fn find_key(&self, k: &K) -> (o: Option<usize>)\n        \n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(i) => 0 <= i < self.keys@.len() && self.keys@[i as int] == k,\n            },\n    {\n        let mut i = 0;\n        while i < self.keys.len()\n            invariant forall |j| 0 <= j < i ==> self.keys@[j] != k,\n            decreases self.keys@.len() - i\n        {\n            //println!(\"Loop {} of find_key\", i);\n            if self.keys.index(i).cmp(&k).is_eq() {\n                proof {\n                    K::cmp_properties();\n                }\n                return Some(i);\n            } else {\n                proof {\n                    K::cmp_properties();\n                }\n            }\n            i = i + 1;\n        }\n        return None;\n    }\n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "\n    fn find_key(&self, k: &K) -> (o: Option<usize>)\n        requires self.valid(),\n        ensures\n            match o {\n                None => !self@.contains_key(*k),\n                Some(i) => 0 <= i < self.keys@.len() && self.keys@[i as int] == k,\n            },\n    {\n        let mut i = 0;\n        while i < self.keys.len()\n            invariant forall |j| 0 <= j < i ==> self.keys@[j] != k,\n            decreases self.keys@.len() - i\n        {\n            //println!(\"Loop {} of find_key\", i);\n            if self.keys.index(i).cmp(&k).is_eq() {\n                proof {\n                    K::cmp_properties();\n                }\n                return Some(i);\n            } else {\n                proof {\n                    K::cmp_properties();\n                }\n            }\n            i = i + 1;\n        }\n        return None;\n    }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n    pub fn init_impl(netc: &NetClient, args: &Args) -> (rc: Option<Self>)\n    requires\n        netc.valid()\n        // IronFleet also gives us netc.IsOpen(), but it seems to be rotted, so we're ignoring it\n     rc),\n    {\n        Self::real_init_impl(netc, args)\n    }\n\n//    spec fn parse_command_line_configuration(args:Seq<Seq<u8>>) -> CC;\n\n//    spec fn concrete_config_init(cc: CC) -> bool;\n//    spec fn concrete_config_to_servers(cc: CC) -> Set<EndPoint>;\n\n    pub open spec fn next_requires(self, netc: NetClient) -> bool\n    {\n        &&& self.invariants(&netc.my_end_point())\n        &&& netc.state() is Receiving    // new wrt ironfleet because we're encoding reduction rules in NetClient interface instead of by reading the history.\n    }\n\n    pub open spec fn next_ensures(old_self: Self, old_netc: NetClient, new_self: Self, new_netc: NetClient, rc: (bool, Ghost<EventResults>)) -> bool\n    {\n        let (ok, res) = rc; {\n            &&& ok == new_netc.ok()\n            &&& ok ==> new_self.invariants(&new_netc.my_end_point())\n            &&& ok ==> Self::next(old_self.view(), new_self.view(), res@.ios)\n            &&& ok ==> res@.event_seq() == res@.ios\n            &&& (ok || res@.sends.len()>0) ==> new_netc.history() == old_netc.history() + res@.event_seq()\n            &&& res@.well_typed_events()\n        }\n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "    pub fn init_impl(netc: &NetClient, args: &Args) -> (rc: Option<Self>)\n    requires\n        netc.valid()\n        // IronFleet also gives us netc.IsOpen(), but it seems to be rotted, so we're ignoring it\n    ensures\n        Self::init_ensures(netc, *args, rc),\n    {\n        Self::real_init_impl(netc, args)\n    }\n\n//    spec fn parse_command_line_configuration(args:Seq<Seq<u8>>) -> CC;\n\n//    spec fn concrete_config_init(cc: CC) -> bool;\n//    spec fn concrete_config_to_servers(cc: CC) -> Set<EndPoint>;\n\n    pub open spec fn next_requires(self, netc: NetClient) -> bool\n    {\n        &&& self.invariants(&netc.my_end_point())\n        &&& netc.state() is Receiving    // new wrt ironfleet because we're encoding reduction rules in NetClient interface instead of by reading the history.\n    }\n\n    pub open spec fn next_ensures(old_self: Self, old_netc: NetClient, new_self: Self, new_netc: NetClient, rc: (bool, Ghost<EventResults>)) -> bool\n    {\n        let (ok, res) = rc; {\n            &&& ok == new_netc.ok()\n            &&& ok ==> new_self.invariants(&new_netc.my_end_point())\n            &&& ok ==> Self::next(old_self.view(), new_self.view(), res@.ios)\n            &&& ok ==> res@.event_seq() == res@.ios\n            &&& (ok || res@.sends.len()>0) ==> new_netc.history() == old_netc.history() + res@.event_seq()\n            &&& res@.well_typed_events()\n        }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n    proof fn extend_range_consistent(self, x: &KeyIterator<K>, y: &KeyIterator<K>, z: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            self.range_consistent(y, z, dst),\n        \n    {\n    }\n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "\n    proof fn extend_range_consistent(self, x: &KeyIterator<K>, y: &KeyIterator<K>, z: &KeyIterator<K>, dst: &ID) \n        requires \n            self.range_consistent(x, y, dst),\n            self.range_consistent(y, z, dst),\n        ensures\n            self.range_consistent(x, z, dst),\n    {\n    }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\nfn extract_range_impl(h: &CKeyHashMap, kr: &KeyRange<CKey>) -> (ext: CKeyHashMap)\nrequires\n    //h@.valid_key_range() // (See Distributed/Services/SHT/AppInterface.i.dfy: ValidKey() == true)\n    forall |k| h@.contains_key(k) ==> /*#[trigger] valid_key(k) &&*/ #[trigger] valid_value(h@[k]),\n\n{\n    let exec_lambda = |key| -> (b: bool) ensures b == kr.contains(key) { kr.contains_exec(&key)};\n\n    h.filter(exec_lambda, Ghost(|ak| kr.contains(ak)))\n}\n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "fn extract_range_impl(h: &CKeyHashMap, kr: &KeyRange<CKey>) -> (ext: CKeyHashMap)\nrequires\n    //h@.valid_key_range() // (See Distributed/Services/SHT/AppInterface.i.dfy: ValidKey() == true)\n    forall |k| h@.contains_key(k) ==> /*#[trigger] valid_key(k) &&*/ #[trigger] valid_value(h@[k]),\nensures\n    ext@ =~= extract_range(h@, *kr),\n{\n    let exec_lambda = |key| -> (b: bool) ensures b == kr.contains(key) { kr.contains_exec(&key)};\n\n    h.filter(exec_lambda, Ghost(|ak| kr.contains(ak)))\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n\npub proof fn lemma_subrange_subrange<A>(s: Seq<A>, start: int, midsize: int, endsize: int)\n  requires\n    0 <= start <= s.len(),\n    0 <= midsize <= endsize <= s.len() - start,\n   midsize) == s.subrange(start, start + midsize),\n{\n  assert(s.subrange(start, start + endsize).subrange(0, midsize) =~= s.subrange(start, start + midsize));\n}\n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "\n\npub proof fn lemma_subrange_subrange<A>(s: Seq<A>, start: int, midsize: int, endsize: int)\n  requires\n    0 <= start <= s.len(),\n    0 <= midsize <= endsize <= s.len() - start,\n  ensures\n    s.subrange(start, start + endsize).subrange(0, midsize) == s.subrange(start, start + midsize),\n{\n  assert(s.subrange(start, start + endsize).subrange(0, midsize) =~= s.subrange(start, start + midsize));\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n\npub fn clone_arg(arg: &Arg) -> (out: Arg)\n\n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "\n\npub fn clone_arg(arg: &Arg) -> (out: Arg)\nensures\n    out@ == arg@\n{\n    clone_vec_u8(arg)\n}"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\n  pub fn clone_up_to_view(&self) -> (c: Self)\n   dst, m} => {\n              CSingleMessage::Message{seqno: *seqno, dst: dst.clone_up_to_view(), m: m.clone_up_to_view() }\n          },\n          CSingleMessage::Ack{ack_seqno} => { CSingleMessage::Ack{ ack_seqno: *ack_seqno } },\n          CSingleMessage::InvalidMessage{} => { CSingleMessage::InvalidMessage{} }\n      }\n  }\n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "\n  pub fn clone_up_to_view(&self) -> (c: Self)\n  ensures\n    c@ == self@\n  {\n      match self {\n          CSingleMessage::Message{seqno, dst, m} => {\n              CSingleMessage::Message{seqno: *seqno, dst: dst.clone_up_to_view(), m: m.clone_up_to_view() }\n          },\n          CSingleMessage::Ack{ack_seqno} => { CSingleMessage::Ack{ ack_seqno: *ack_seqno } },\n          CSingleMessage::InvalidMessage{} => { CSingleMessage::InvalidMessage{} }\n      }\n  }"}]}
{"messages": [{"role": "system", "content": "You are an expert in Verus, a verification-oriented extension of Rust. Given a function, generate appropriate specifications including requires (preconditions), ensures (postconditions), invariants, and decreases clauses."}, {"role": "user", "content": "The following Verus code has a verification error. Fix the code to make it verify.\n\nError message:\n```\nVerification failed after remove_ensures\n```\n\nBroken code:\n```rust\n\npub proof fn lemma_to_set_singleton_auto<A>()\n\n{\n    assert forall |x: A| #[trigger] seq![x].to_set() =~= set![x] by {\n        assert(seq![x][0] == x);\n    }\n}\n```\n\nProvide the fixed code:"}, {"role": "assistant", "content": "\npub proof fn lemma_to_set_singleton_auto<A>()\nensures\n    forall |x: A| #[trigger] seq![x].to_set() == set![x],\n{\n    assert forall |x: A| #[trigger] seq![x].to_set() =~= set![x] by {\n        assert(seq![x][0] == x);\n    }\n}"}]}
